<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>translate.min.html</title>
</head>
<body>

<script>
/****************************************************************************
 This code is copyright (C) Raudas Hugbunadur ehf (Red Ace Software LLC)
 
 This code is NOT open source, and it is NOT permitted to use it on other
 sites, modify it, or otherwise use it for any other purpose than playing
 on one of our sites, (https://cardgames.io, https://iochess.com)
 
 I've had to deal with multiple people stealing my work and I'm sick of it.
 Don't be a thief, write your own game!
*****************************************************************************/(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var consoleLogger = {
  type: 'logger',
  log: function log(args) {
    this.output('log', args);
  },
  warn: function warn(args) {
    this.output('warn', args);
  },
  error: function error(args) {
    this.output('error', args);
  },
  output: function output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};

var Logger =
/*#__PURE__*/
function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.init(concreteLogger, options);
  }

  var _proto = Logger.prototype;

  _proto.init = function init(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.prefix = options.prefix || 'i18next:';
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  };

  _proto.log = function log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return this.forward(args, 'log', '', true);
  };

  _proto.warn = function warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return this.forward(args, 'warn', '', true);
  };

  _proto.error = function error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return this.forward(args, 'error', '');
  };

  _proto.deprecate = function deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
  };

  _proto.forward = function forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (typeof args[0] === 'string') args[0] = "" + prefix + this.prefix + " " + args[0];
    return this.logger[lvl](args);
  };

  _proto.create = function create(moduleName) {
    return new Logger(this.logger, _extends({}, {
      prefix: this.prefix + ":" + moduleName + ":"
    }, {}, this.options));
  };

  _proto.clone = function clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  };

  return Logger;
}();

var baseLogger = new Logger();

var EventEmitter =
/*#__PURE__*/
function () {
  function EventEmitter() {
    this.observers = {};
  }

  var _proto2 = EventEmitter.prototype;

  _proto2.on = function on(events, listener) {
    var _this4 = this;

    events.split(' ').forEach(function (event) {
      if (!_this4.observers[event]) _this4.observers[event] = new Map();
      var numListeners = _this4.observers[event].get(listener) || 0;

      _this4.observers[event].set(listener, numListeners + 1);
    });
    return this;
  };

  _proto2.off = function off(event, listener) {
    if (!this.observers[event]) return;

    if (!listener) {
      delete this.observers[event];
      return;
    }

    this.observers[event]["delete"](listener);
  };

  _proto2.emit = function emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (this.observers[event]) {
      var cloned = Array.from(this.observers[event].entries());
      cloned.forEach(function (_ref) {
        var observer = _ref[0],
            numTimesAdded = _ref[1];

        for (var i = 0; i < numTimesAdded; i++) {
          observer.apply(void 0, args);
        }
      });
    }

    if (this.observers['*']) {
      var _cloned = Array.from(this.observers['*'].entries());

      _cloned.forEach(function (_ref2) {
        var observer = _ref2[0],
            numTimesAdded = _ref2[1];

        for (var i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event].concat(args));
        }
      });
    }
  };

  return EventEmitter;
}();

function defer() {
  var res;
  var rej;
  var promise = new Promise(function (resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}

function makeString(object) {
  if (object == null) return '';
  return '' + object;
}

function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

var lastOfPathSeparatorRegExp = /###/g;

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(lastOfPathSeparatorRegExp, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? path : path.split('.');
  var stackIndex = 0;

  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();

    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }

    ++stackIndex;
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  if (obj !== undefined || path.length === 1) {
    obj[k] = newValue;
    return;
  }

  var e = path[path.length - 1];
  var p = path.slice(0, path.length - 1);
  var last = getLastOfPath(object, p, Object);

  while (last.obj === undefined && p.length) {
    e = p[p.length - 1] + "." + e;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);

    if (last && last.obj && typeof last.obj[last.k + "." + e] !== 'undefined') {
      last.obj = undefined;
    }
  }

  last.obj[last.k + "." + e] = newValue;
}

function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}

function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}

function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);

  if (value !== undefined) {
    return value;
  }

  return getPath(defaultData, key);
}

function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== '__proto__' && prop !== 'constructor') {
      if (prop in target) {
        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }

  return target;
}

function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}

var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};

function escape(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  }

  return data;
}

var RegExpCache =
/*#__PURE__*/
function () {
  function RegExpCache(capacity) {
    this.capacity = capacity;
    this.regExpMap = new Map();
    this.regExpQueue = [];
  }

  var _proto3 = RegExpCache.prototype;

  _proto3.getRegExp = function getRegExp(pattern) {
    var regExpFromCache = this.regExpMap.get(pattern);

    if (regExpFromCache !== undefined) {
      return regExpFromCache;
    }

    var regExpNew = new RegExp(pattern);

    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap["delete"](this.regExpQueue.shift());
    }

    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  };

  return RegExpCache;
}();

var chars = [' ', ',', '?', '!', ';'];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);

function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || '';
  keySeparator = keySeparator || '';
  var possibleChars = chars.filter(function (c) {
    return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
  });
  if (possibleChars.length === 0) return true;
  var r = looksLikeObjectPathRegExpCache.getRegExp("(" + possibleChars.map(function (c) {
    return c === '?' ? '\\?' : c;
  }).join('|') + ")");
  var matched = !r.test(key);

  if (!matched) {
    var ki = key.indexOf(keySeparator);

    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }

  return matched;
}

function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  if (!obj) return undefined;
  if (obj[path]) return obj[path];
  var tokens = path.split(keySeparator);
  var current = obj;

  for (var i = 0; i < tokens.length;) {
    if (!current || typeof current !== 'object') {
      return undefined;
    }

    var next = void 0;
    var nextPath = '';

    for (var j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }

      nextPath += tokens[j];
      next = current[nextPath];

      if (next !== undefined) {
        if (['string', 'number', 'boolean'].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }

        i += j - i + 1;
        break;
      }
    }

    current = next;
  }

  return current;
}

function getCleanedCode(code) {
  if (code && code.indexOf('_') > 0) return code.replace('_', '-');
  return code;
}

var ResourceStore =
/*#__PURE__*/
function (_EventEmitter) {
  _inheritsLoose(ResourceStore, _EventEmitter);

  function ResourceStore(data) {
    var _this5;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };
    _this5 = _EventEmitter.call(this) || this;
    _this5.data = data || {};
    _this5.options = options;

    if (_this5.options.keySeparator === undefined) {
      _this5.options.keySeparator = '.';
    }

    if (_this5.options.ignoreJSONStructure === undefined) {
      _this5.options.ignoreJSONStructure = true;
    }

    return _this5;
  }

  var _proto4 = ResourceStore.prototype;

  _proto4.addNamespaces = function addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  };

  _proto4.removeNamespaces = function removeNamespaces(ns) {
    var index = this.options.ns.indexOf(ns);

    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  };

  _proto4.getResource = function getResource(lng, ns, key) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    var path;

    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
    } else {
      path = [lng, ns];

      if (key) {
        if (Array.isArray(key)) {
          var _path;

          (_path = path).push.apply(_path, key);
        } else if (typeof key === 'string' && keySeparator) {
          var _path2;

          (_path2 = path).push.apply(_path2, key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }

    var result = getPath(this.data, path);

    if (!result && !ns && !key && lng.indexOf('.') > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join('.');
    }

    if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  };

  _proto4.addResource = function addResource(lng, ns, key, value) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      silent: false
    };
    var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    var path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      value = ns;
      ns = path[1];
    }

    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit('added', lng, ns, key, value);
  };

  _proto4.addResources = function addResources(lng, ns, resources) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      silent: false
    };

    for (var m in resources) {
      if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }

    if (!options.silent) this.emit('added', lng, ns, resources);
  };

  _proto4.addResourceBundle = function addResourceBundle(lng, ns, resources, deep, overwrite) {
    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
      silent: false
    };
    var path = [lng, ns];

    if (lng.indexOf('.') > -1) {
      path = lng.split('.');
      deep = resources;
      resources = ns;
      ns = path[1];
    }

    this.addNamespaces(ns);
    var pack = getPath(this.data, path) || {};

    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = _extends({}, pack, {}, resources);
    }

    setPath(this.data, path, pack);
    if (!options.silent) this.emit('added', lng, ns, resources);
  };

  _proto4.removeResourceBundle = function removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }

    this.removeNamespaces(ns);
    this.emit('removed', lng, ns);
  };

  _proto4.hasResourceBundle = function hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== undefined;
  };

  _proto4.getResourceBundle = function getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === 'v1') return _extends({}, {}, {}, this.getResource(lng, ns));
    return this.getResource(lng, ns);
  };

  _proto4.getDataByLanguage = function getDataByLanguage(lng) {
    return this.data[lng];
  };

  _proto4.hasLanguageSomeTranslations = function hasLanguageSomeTranslations(lng) {
    var data = this.getDataByLanguage(lng);
    var n = data && Object.keys(data) || [];
    return !!n.find(function (v) {
      return data[v] && Object.keys(data[v]).length > 0;
    });
  };

  _proto4.toJSON = function toJSON() {
    return this.data;
  };

  return ResourceStore;
}(EventEmitter);

var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this6 = this;

    processors.forEach(function (processor) {
      if (_this6.processors[processor]) value = _this6.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};

var Translator =
/*#__PURE__*/
function (_EventEmitter2) {
  _inheritsLoose(Translator, _EventEmitter2);

  function Translator(services) {
    var _this7;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _this7 = _EventEmitter2.call(this) || this;
    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized(_this7));
    _this7.options = options;

    if (_this7.options.keySeparator === undefined) {
      _this7.options.keySeparator = '.';
    }

    _this7.logger = baseLogger.create('translator');
    return _this7;
  }

  var _proto5 = Translator.prototype;

  _proto5.changeLanguage = function changeLanguage(lng) {
    if (lng) this.language = lng;
  };

  _proto5.exists = function exists(key) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      interpolation: {}
    };

    if (key === undefined || key === null) {
      return false;
    }

    var resolved = this.resolve(key, options);
    return resolved && resolved.res !== undefined;
  };

  _proto5.extractFromKey = function extractFromKey(key, options) {
    var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === undefined) nsSeparator = ':';
    var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
    var namespaces = options.ns || this.options.defaultNS || [];
    var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);

    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      var m = key.match(this.interpolator.nestingRegexp);

      if (m && m.length > 0) {
        return {
          key: key,
          namespaces: namespaces
        };
      }

      var parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }

    if (typeof namespaces === 'string') namespaces = [namespaces];
    return {
      key: key,
      namespaces: namespaces
    };
  };

  _proto5.translate = function translate(keys, options, lastKey) {
    var _this8 = this;

    if (typeof options !== 'object' && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }

    if (typeof options === 'object') options = _extends({}, options);
    if (!options) options = {};
    if (keys === undefined || keys === null) return '';
    if (!Array.isArray(keys)) keys = [String(keys)];
    var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
    var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;

    var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
        key = _this$extractFromKey.key,
        namespaces = _this$extractFromKey.namespaces;

    var namespace = namespaces[namespaces.length - 1];
    var lng = options.lng || this.language;
    var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

    if (lng && lng.toLowerCase() === 'cimode') {
      if (appendNamespaceToCIMode) {
        var nsSeparator = options.nsSeparator || this.options.nsSeparator;

        if (returnDetails) {
          return {
            res: "" + namespace + nsSeparator + key,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }

        return "" + namespace + nsSeparator + key;
      }

      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }

      return key;
    }

    var resolved = this.resolve(keys, options);
    var res = resolved && resolved.res;
    var resUsedKey = resolved && resolved.usedKey || key;
    var resExactUsedKey = resolved && resolved.exactUsedKey || key;
    var resType = Object.prototype.toString.apply(res);
    var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
    var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
    var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
        }

        var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _extends({}, options, {
          ns: namespaces
        })) : "key '" + key + " (" + this.language + ")' returned an object instead of string.";

        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }

        return r;
      }

      if (keySeparator) {
        var resTypeIsArray = resType === '[object Array]';

        var _copy = resTypeIsArray ? [] : {};

        var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

        for (var m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            var deepKey = "" + newKeyToUse + keySeparator + m;
            _copy[m] = this.translate(deepKey, _extends({}, options, {}, {
              joinArrays: false,
              ns: namespaces
            }));
            if (_copy[m] === deepKey) _copy[m] = res[m];
          }
        }

        res = _copy;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      var usedDefault = false;
      var usedKey = false;
      var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
      var hasDefaultValue = Translator.hasDefaultValue(options);
      var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
      var defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : '';
      var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      var defaultValue = needsZeroSuffixLookup && options["defaultValue" + this.options.pluralSeparator + "zero"] || options["defaultValue" + defaultValueSuffix] || options["defaultValue" + defaultValueSuffixOrdinalFallback] || options.defaultValue;

      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }

      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }

      var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
      var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;

      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);

        if (keySeparator) {
          var fk = this.resolve(key, _extends({}, options, {
            keySeparator: false
          }));
          if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
        }

        var lngs = [];
        var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

        if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
          for (var i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === 'all') {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }

        var send = function send(l, k, specificDefaultValue) {
          var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;

          if (_this8.options.missingKeyHandler) {
            _this8.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (_this8.backendConnector && _this8.backendConnector.saveMissing) {
            _this8.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }

          _this8.emit('missingKey', l, namespace, k, res);
        };

        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach(function (language) {
              var suffixes = _this8.pluralResolver.getSuffixes(language, options);

              if (needsZeroSuffixLookup && options["defaultValue" + _this8.options.pluralSeparator + "zero"] && suffixes.indexOf(_this8.options.pluralSeparator + "zero") < 0) {
                suffixes.push(_this8.options.pluralSeparator + "zero");
              }

              suffixes.forEach(function (suffix) {
                send([language], key + suffix, options["defaultValue" + suffix] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }

      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = namespace + ":" + key;

      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== 'v1') {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? namespace + ":" + key : key, usedDefault ? res : undefined);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }

    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }

    return res;
  };

  _proto5.extendTranslation = function extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;

    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, _extends({}, this.options.interpolation.defaultVariables, {}, options), options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved: resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init(_extends({}, options, {}, {
        interpolation: _extends({}, this.options.interpolation, {}, options.interpolation)
      }));
      var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      var nestBef;

      if (skipOnVariables) {
        var nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }

      var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = _extends({}, this.options.interpolation.defaultVariables, {}, data);
      res = this.interpolator.interpolate(res, data, options.lng || this.language, options);

      if (skipOnVariables) {
        var na = res.match(this.interpolator.nestingRegexp);
        var nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }

      if (!options.lng && this.options.compatibilityAPI !== 'v1' && resolved && resolved.res) options.lng = resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (lastKey && lastKey[0] === args[0] && !options.context) {
          _this.logger.warn("It seems you are nesting recursively key: " + args[0] + " in key: " + key[0]);

          return null;
        }

        return _this.translate.apply(_this, args.concat([key]));
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }

    var postProcess = options.postProcess || this.options.postProcess;
    var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

    if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _extends({
        i18nResolved: _extends({}, resolved, {
          usedParams: this.getUsedParamsDetails(options)
        })
      }, options) : options, this);
    }

    return res;
  };

  _proto5.resolve = function resolve(keys) {
    var _this9 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var found;
    var usedKey;
    var exactUsedKey;
    var usedLng;
    var usedNS;
    if (typeof keys === 'string') keys = [keys];
    keys.forEach(function (k) {
      if (_this9.isValidLookup(found)) return;

      var extracted = _this9.extractFromKey(k, options);

      var key = extracted.key;
      usedKey = key;
      var namespaces = extracted.namespaces;
      if (_this9.options.fallbackNS) namespaces = namespaces.concat(_this9.options.fallbackNS);
      var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

      var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this9.pluralResolver.shouldUseIntlApi();

      var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
      var codes = options.lngs ? options.lngs : _this9.languageUtils.toResolveHierarchy(options.lng || _this9.language, options.fallbackLng);
      namespaces.forEach(function (ns) {
        if (_this9.isValidLookup(found)) return;
        usedNS = ns;

        if (!checkedLoadedFor[codes[0] + "-" + ns] && _this9.utils && _this9.utils.hasLoadedNamespace && !_this9.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[codes[0] + "-" + ns] = true;

          _this9.logger.warn("key \"" + usedKey + "\" for languages \"" + codes.join(', ') + "\" won't get resolved as namespace \"" + usedNS + "\" was not yet loaded", 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        }

        codes.forEach(function (code) {
          if (_this9.isValidLookup(found)) return;
          usedLng = code;
          var finalKeys = [key];

          if (_this9.i18nFormat && _this9.i18nFormat.addLookupKeys) {
            _this9.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            var pluralSuffix;
            if (needsPluralHandling) pluralSuffix = _this9.pluralResolver.getSuffix(code, options.count, options);
            var zeroSuffix = _this9.options.pluralSeparator + "zero";
            var ordinalPrefix = _this9.options.pluralSeparator + "ordinal" + _this9.options.pluralSeparator;

            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);

              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, _this9.options.pluralSeparator));
              }

              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }

            if (needsContextHandling) {
              var contextKey = "" + key + _this9.options.contextSeparator + options.context;
              finalKeys.push(contextKey);

              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);

                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, _this9.options.pluralSeparator));
                }

                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }

          var possibleKey;

          while (possibleKey = finalKeys.pop()) {
            if (!_this9.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = _this9.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey: usedKey,
      exactUsedKey: exactUsedKey,
      usedLng: usedLng,
      usedNS: usedNS
    };
  };

  _proto5.isValidLookup = function isValidLookup(res) {
    return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
  };

  _proto5.getResource = function getResource(code, ns, key) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  };

  _proto5.getUsedParamsDetails = function getUsedParamsDetails() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var optionsKeys = ['defaultValue', 'ordinal', 'context', 'replace', 'lng', 'lngs', 'fallbackLng', 'ns', 'keySeparator', 'nsSeparator', 'returnObjects', 'returnDetails', 'joinArrays', 'postProcess', 'interpolation'];
    var useOptionsReplaceForData = options.replace && typeof options.replace !== 'string';
    var data = useOptionsReplaceForData ? options.replace : options;

    if (useOptionsReplaceForData && typeof options.count !== 'undefined') {
      data.count = options.count;
    }

    if (this.options.interpolation.defaultVariables) {
      data = _extends({}, this.options.interpolation.defaultVariables, {}, data);
    }

    if (!useOptionsReplaceForData) {
      data = _extends({}, data);

      for (var _iterator = optionsKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref3 = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref3 = _i.value;
        }

        var key = _ref3;
        delete data[key];
      }
    }

    return data;
  };

  Translator.hasDefaultValue = function hasDefaultValue(options) {
    var prefix = 'defaultValue';

    for (var option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
        return true;
      }
    }

    return false;
  };

  return Translator;
}(EventEmitter);

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var LanguageUtil =
/*#__PURE__*/
function () {
  function LanguageUtil(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create('languageUtils');
  }

  var _proto6 = LanguageUtil.prototype;

  _proto6.getScriptPartFromCode = function getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf('-') < 0) return null;
    var p = code.split('-');
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === 'x') return null;
    return this.formatLanguageCode(p.join('-'));
  };

  _proto6.getLanguagePartFromCode = function getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf('-') < 0) return code;
    var p = code.split('-');
    return this.formatLanguageCode(p[0]);
  };

  _proto6.formatLanguageCode = function formatLanguageCode(code) {
    if (typeof code === 'string' && code.indexOf('-') > -1) {
      var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
      var p = code.split('-');

      if (this.options.lowerCaseLng) {
        p = p.map(function (part) {
          return part.toLowerCase();
        });
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2) p[1] = p[1].toUpperCase();
        if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
      }

      return p.join('-');
    }

    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  };

  _proto6.isSupportedCode = function isSupportedCode(code) {
    if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }

    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  };

  _proto6.getBestMatchFromCodes = function getBestMatchFromCodes(codes) {
    var _this10 = this;

    if (!codes) return null;
    var found;
    codes.forEach(function (code) {
      if (found) return;

      var cleanedLng = _this10.formatLanguageCode(code);

      if (!_this10.options.supportedLngs || _this10.isSupportedCode(cleanedLng)) found = cleanedLng;
    });

    if (!found && this.options.supportedLngs) {
      codes.forEach(function (code) {
        if (found) return;

        var lngOnly = _this10.getLanguagePartFromCode(code);

        if (_this10.isSupportedCode(lngOnly)) return found = lngOnly;
        found = _this10.options.supportedLngs.find(function (supportedLng) {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf('-') < 0 && lngOnly.indexOf('-') < 0) return;
          if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
        });
      });
    }

    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  };

  _proto6.getFallbackCodes = function getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
    if (typeof fallbacks === 'string') fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
    if (!code) return fallbacks["default"] || [];
    var found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks["default"];
    return found || [];
  };

  _proto6.toResolveHierarchy = function toResolveHierarchy(code, fallbackCode) {
    var _this11 = this;

    var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    var codes = [];

    var addCode = function addCode(c) {
      if (!c) return;

      if (_this11.isSupportedCode(c)) {
        codes.push(c);
      } else {
        _this11.logger.warn("rejecting language code not found in supportedLngs: " + c);
      }
    };

    if (typeof code === 'string' && (code.indexOf('-') > -1 || code.indexOf('_') > -1)) {
      if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
      if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === 'string') {
      addCode(this.formatLanguageCode(code));
    }

    fallbackCodes.forEach(function (fc) {
      if (codes.indexOf(fc) < 0) addCode(_this11.formatLanguageCode(fc));
    });
    return codes;
  };

  return LanguageUtil;
}();

var sets = [{
  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
  nr: [1],
  fc: 3
}, {
  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ['ar'],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ['cs', 'sk'],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ['csb', 'pl'],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ['cy'],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ['fr'],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ['ga'],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ['gd'],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ['is'],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ['jv'],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ['kw'],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ['lt'],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ['lv'],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ['mk'],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ['mnk'],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ['mt'],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ['or'],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ['ro'],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ['sl'],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ['he', 'iw'],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var nonIntlVersions = ['v1', 'v2', 'v3'];
var intlVersions = ['v4'];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};

function createRules() {
  var rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var PluralResolver =
/*#__PURE__*/
function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');

    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
      this.options.compatibilityJSON = 'v3';
      this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
    }

    this.rules = createRules();
  }

  var _proto7 = PluralResolver.prototype;

  _proto7.addRule = function addRule(lng, obj) {
    this.rules[lng] = obj;
  };

  _proto7.getRule = function getRule(code) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (this.shouldUseIntlApi()) {
      try {
        return new Intl.PluralRules(getCleanedCode(code === 'dev' ? 'en' : code), {
          type: options.ordinal ? 'ordinal' : 'cardinal'
        });
      } catch (err) {
        return;
      }
    }

    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  };

  _proto7.needsPlural = function needsPlural(code) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var rule = this.getRule(code, options);

    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }

    return rule && rule.numbers.length > 1;
  };

  _proto7.getPluralFormsOfKey = function getPluralFormsOfKey(code, key) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this.getSuffixes(code, options).map(function (suffix) {
      return "" + key + suffix;
    });
  };

  _proto7.getSuffixes = function getSuffixes(code) {
    var _this12 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var rule = this.getRule(code, options);

    if (!rule) {
      return [];
    }

    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {
        return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
      }).map(function (pluralCategory) {
        return "" + _this12.options.prepend + (options.ordinal ? "ordinal" + _this12.options.prepend : '') + pluralCategory;
      });
    }

    return rule.numbers.map(function (number) {
      return _this12.getSuffix(code, number, options);
    });
  };

  _proto7.getSuffix = function getSuffix(code, count) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var rule = this.getRule(code, options);

    if (rule) {
      if (this.shouldUseIntlApi()) {
        return "" + this.options.prepend + (options.ordinal ? "ordinal" + this.options.prepend : '') + rule.select(count);
      }

      return this.getSuffixRetroCompatible(rule, count);
    }

    this.logger.warn("no plural rule found for: " + code);
    return '';
  };

  _proto7.getSuffixRetroCompatible = function getSuffixRetroCompatible(rule, count) {
    var _this13 = this;

    var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    var suffix = rule.numbers[idx];

    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = 'plural';
      } else if (suffix === 1) {
        suffix = '';
      }
    }

    var returnSuffix = function returnSuffix() {
      return _this13.options.prepend && suffix.toString() ? _this13.options.prepend + suffix.toString() : suffix.toString();
    };

    if (this.options.compatibilityJSON === 'v1') {
      if (suffix === 1) return '';
      if (typeof suffix === 'number') return "_plural_" + suffix.toString();
      return returnSuffix();
    } else if (this.options.compatibilityJSON === 'v2') {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }

    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  };

  _proto7.shouldUseIntlApi = function shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  };

  return PluralResolver;
}();

function deepFindWithDefaults(data, defaultData, key) {
  var keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
  var ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var path = getPathWithDefaults(data, defaultData, key);

  if (!path && ignoreJSONStructure && typeof key === 'string') {
    path = deepFind(data, key, keySeparator);
    if (path === undefined) path = deepFind(defaultData, key, keySeparator);
  }

  return path;
}

var Interpolator =
/*#__PURE__*/
function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.logger = baseLogger.create('interpolator');
    this.options = options;

    this.format = options.interpolation && options.interpolation.format || function (value) {
      return value;
    };

    this.init(options);
  }

  var _proto8 = Interpolator.prototype;

  _proto8.init = function init() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    var iOpts = options.interpolation;
    this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
    this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
    this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
    this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
    this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
    this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
    this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
    this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
    this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
    this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
    this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
    this.resetRegExp();
  };

  _proto8.reset = function reset() {
    if (this.options) this.init(this.options);
  };

  _proto8.resetRegExp = function resetRegExp() {
    var getOrResetRegExp = function getOrResetRegExp(existingRegExp, pattern) {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }

      return new RegExp(pattern, 'g');
    };

    this.regexp = getOrResetRegExp(this.regexp, this.prefix + "(.+?)" + this.suffix);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, "" + this.prefix + this.unescapePrefix + "(.+?)" + this.unescapeSuffix + this.suffix);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, this.nestingPrefix + "(.+?)" + this.nestingSuffix);
  };

  _proto8.interpolate = function interpolate(str, data, lng, options) {
    var _this14 = this;

    var match;
    var value;
    var replaces;
    var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

    function regexSafe(val) {
      return val.replace(/\$/g, '$$$$');
    }

    var handleFormat = function handleFormat(key) {
      if (key.indexOf(_this14.formatSeparator) < 0) {
        var path = deepFindWithDefaults(data, defaultData, key, _this14.options.keySeparator, _this14.options.ignoreJSONStructure);
        return _this14.alwaysFormat ? _this14.format(path, undefined, lng, _extends({}, options, {}, data, {
          interpolationkey: key
        })) : path;
      }

      var p = key.split(_this14.formatSeparator);
      var k = p.shift().trim();
      var f = p.join(_this14.formatSeparator).trim();
      return _this14.format(deepFindWithDefaults(data, defaultData, k, _this14.options.keySeparator, _this14.options.ignoreJSONStructure), f, lng, _extends({}, options, {}, data, {
        interpolationkey: k
      }));
    };

    this.resetRegExp();
    var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    var todos = [{
      regex: this.regexpUnescape,
      safeValue: function safeValue(val) {
        return regexSafe(val);
      }
    }, {
      regex: this.regexp,
      safeValue: function safeValue(val) {
        return _this14.escapeValue ? regexSafe(_this14.escape(val)) : regexSafe(val);
      }
    }];
    todos.forEach(function (todo) {
      replaces = 0;

      while (match = todo.regex.exec(str)) {
        var matchedVar = match[1].trim();
        value = handleFormat(matchedVar);

        if (value === undefined) {
          if (typeof missingInterpolationHandler === 'function') {
            var temp = missingInterpolationHandler(str, match, options);
            value = typeof temp === 'string' ? temp : '';
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = '';
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            _this14.logger.warn("missed to pass in variable " + matchedVar + " for interpolating " + str);

            value = '';
          }
        } else if (typeof value !== 'string' && !_this14.useRawValueToEscape) {
          value = makeString(value);
        }

        var safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);

        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }

        replaces++;

        if (replaces >= _this14.maxReplaces) {
          break;
        }
      }
    });
    return str;
  };

  _proto8.nest = function nest(str, fc) {
    var _this15 = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var match;
    var value;
    var clonedOptions;

    function handleHasOptions(key, inheritedOptions) {
      var sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      var c = key.split(new RegExp(sep + "[ ]*{"));
      var optionsString = "{" + c[1];
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      var matchedSingleQuotes = optionsString.match(/'/g);
      var matchedDoubleQuotes = optionsString.match(/"/g);

      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }

      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = _extends({}, inheritedOptions, {}, clonedOptions);
      } catch (e) {
        this.logger.warn("failed parsing options string in nesting for key " + key, e);
        return "" + key + sep + optionsString;
      }

      delete clonedOptions.defaultValue;
      return key;
    }

    while (match = this.nestingRegexp.exec(str)) {
      var formatters = [];
      clonedOptions = _extends({}, options);
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== 'string' ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      var doReduce = false;

      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        var r = match[1].split(this.formatSeparator).map(function (elem) {
          return elem.trim();
        });
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }

      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && typeof value !== 'string') return value;
      if (typeof value !== 'string') value = makeString(value);

      if (!value) {
        this.logger.warn("missed to resolve " + match[1] + " for nesting " + str);
        value = '';
      }

      if (doReduce) {
        value = formatters.reduce(function (v, f) {
          return _this15.format(v, f, options.lng, _extends({}, options, {
            interpolationkey: match[1].trim()
          }));
        }, value.trim());
      }

      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }

    return str;
  };

  return Interpolator;
}();

function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};

  if (formatStr.indexOf('(') > -1) {
    var p = formatStr.split('(');
    formatName = p[0].toLowerCase().trim();
    var optStr = p[1].substring(0, p[1].length - 1);

    if (formatName === 'currency' && optStr.indexOf(':') < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(';');
      opts.forEach(function (opt) {
        if (!opt) return;

        var _opt$split = opt.split(':'),
            key = _opt$split[0],
            rest = _opt$split.slice(1);

        var val = rest.join(':').trim().replace(/^'+|'+$/g, '');
        if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;
        if (val === 'false') formatOptions[key.trim()] = false;
        if (val === 'true') formatOptions[key.trim()] = true;
        if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }

  return {
    formatName: formatName,
    formatOptions: formatOptions
  };
}

function createCachedFormatter(fn) {
  var cache = {};
  return function invokeFormatter(val, lng, options) {
    var key = lng + JSON.stringify(options);
    var formatter = cache[key];

    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }

    return formatter(val);
  };
}

var Formatter =
/*#__PURE__*/
function () {
  function Formatter() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.logger = baseLogger.create('formatter');
    this.options = options;
    this.formats = {
      number: createCachedFormatter(function (lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _extends({}, opt));
        return function (val) {
          return formatter.format(val);
        };
      }),
      currency: createCachedFormatter(function (lng, opt) {
        var formatter = new Intl.NumberFormat(lng, _extends({}, opt, {
          style: 'currency'
        }));
        return function (val) {
          return formatter.format(val);
        };
      }),
      datetime: createCachedFormatter(function (lng, opt) {
        var formatter = new Intl.DateTimeFormat(lng, _extends({}, opt));
        return function (val) {
          return formatter.format(val);
        };
      }),
      relativetime: createCachedFormatter(function (lng, opt) {
        var formatter = new Intl.RelativeTimeFormat(lng, _extends({}, opt));
        return function (val) {
          return formatter.format(val, opt.range || 'day');
        };
      }),
      list: createCachedFormatter(function (lng, opt) {
        var formatter = new Intl.ListFormat(lng, _extends({}, opt));
        return function (val) {
          return formatter.format(val);
        };
      })
    };
    this.init(options);
  }

  var _proto9 = Formatter.prototype;

  _proto9.init = function init(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      interpolation: {}
    };
    var iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
  };

  _proto9.add = function add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  };

  _proto9.addCached = function addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  };

  _proto9.format = function format(value, _format, lng) {
    var _this16 = this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    var formats = _format.split(this.formatSeparator);

    var result = formats.reduce(function (mem, f) {
      var _parseFormatStr = parseFormatStr(f),
          formatName = _parseFormatStr.formatName,
          formatOptions = _parseFormatStr.formatOptions;

      if (_this16.formats[formatName]) {
        var formatted = mem;

        try {
          var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = _this16.formats[formatName](mem, l, _extends({}, formatOptions, {}, options, {}, valOptions));
        } catch (error) {
          _this16.logger.warn(error);
        }

        return formatted;
      } else {
        _this16.logger.warn("there was no format function for " + formatName);
      }

      return mem;
    }, value);
    return result;
  };

  return Formatter;
}();

function removePending(q, name) {
  if (q.pending[name] !== undefined) {
    delete q.pending[name];
    q.pendingCount--;
  }
}

var Connector =
/*#__PURE__*/
function (_EventEmitter3) {
  _inheritsLoose(Connector, _EventEmitter3);

  function Connector(backend, store, services) {
    var _this17;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _this17 = _EventEmitter3.call(this) || this;
    _this17.backend = backend;
    _this17.store = store;
    _this17.services = services;
    _this17.languageUtils = services.languageUtils;
    _this17.options = options;
    _this17.logger = baseLogger.create('backendConnector');
    _this17.waitingReads = [];
    _this17.maxParallelReads = options.maxParallelReads || 10;
    _this17.readingCalls = 0;
    _this17.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this17.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this17.state = {};
    _this17.queue = [];

    if (_this17.backend && _this17.backend.init) {
      _this17.backend.init(services, options.backend, options);
    }

    return _this17;
  }

  var _proto10 = Connector.prototype;

  _proto10.queueLoad = function queueLoad(languages, namespaces, options, callback) {
    var _this18 = this;

    var toLoad = {};
    var pending = {};
    var toLoadLanguages = {};
    var toLoadNamespaces = {};
    languages.forEach(function (lng) {
      var hasAllNamespaces = true;
      namespaces.forEach(function (ns) {
        var name = lng + "|" + ns;

        if (!options.reload && _this18.store.hasResourceBundle(lng, ns)) {
          _this18.state[name] = 2;
        } else if (_this18.state[name] < 0) ;else if (_this18.state[name] === 1) {
          if (pending[name] === undefined) pending[name] = true;
        } else {
          _this18.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === undefined) pending[name] = true;
          if (toLoad[name] === undefined) toLoad[name] = true;
          if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });

    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending: pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback: callback
      });
    }

    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  };

  _proto10.loaded = function loaded(name, err, data) {
    var s = name.split('|');
    var lng = s[0];
    var ns = s[1];
    if (err) this.emit('failedLoading', lng, ns, err);

    if (data) {
      this.store.addResourceBundle(lng, ns, data);
    }

    this.state[name] = err ? -1 : 2;
    var loaded = {};
    this.queue.forEach(function (q) {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);

      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach(function (l) {
          if (!loaded[l]) loaded[l] = {};
          var loadedKeys = q.loaded[l];

          if (loadedKeys.length) {
            loadedKeys.forEach(function (n) {
              if (loaded[l][n] === undefined) loaded[l][n] = true;
            });
          }
        });
        q.done = true;

        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit('loaded', loaded);
    this.queue = this.queue.filter(function (q) {
      return !q.done;
    });
  };

  _proto10.read = function read(lng, ns, fcName) {
    var _this19 = this;

    var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
    var callback = arguments.length > 5 ? arguments[5] : undefined;
    if (!lng.length) return callback(null, {});

    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: lng,
        ns: ns,
        fcName: fcName,
        tried: tried,
        wait: wait,
        callback: callback
      });
      return;
    }

    this.readingCalls++;

    var resolver = function resolver(err, data) {
      _this19.readingCalls--;

      if (_this19.waitingReads.length > 0) {
        var next = _this19.waitingReads.shift();

        _this19.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }

      if (err && data && tried < _this19.maxRetries) {
        setTimeout(function () {
          _this19.read.call(_this19, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }

      callback(err, data);
    };

    var fc = this.backend[fcName].bind(this.backend);

    if (fc.length === 2) {
      try {
        var r = fc(lng, ns);

        if (r && typeof r.then === 'function') {
          r.then(function (data) {
            return resolver(null, data);
          })["catch"](resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }

      return;
    }

    return fc(lng, ns, resolver);
  };

  _proto10.prepareLoading = function prepareLoading(languages, namespaces) {
    var _this20 = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var callback = arguments.length > 3 ? arguments[3] : undefined;

    if (!this.backend) {
      this.logger.warn('No backend was added via i18next.use. Will not load resources.');
      return callback && callback();
    }

    if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === 'string') namespaces = [namespaces];
    var toLoad = this.queueLoad(languages, namespaces, options, callback);

    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }

    toLoad.toLoad.forEach(function (name) {
      _this20.loadOne(name);
    });
  };

  _proto10.load = function load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  };

  _proto10.reload = function reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  };

  _proto10.loadOne = function loadOne(name) {
    var _this21 = this;

    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var s = name.split('|');
    var lng = s[0];
    var ns = s[1];
    this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
      if (err) _this21.logger.warn(prefix + "loading namespace " + ns + " for language " + lng + " failed", err);
      if (!err && data) _this21.logger.log(prefix + "loaded namespace " + ns + " for language " + lng, data);

      _this21.loaded(name, err, data);
    });
  };

  _proto10.saveMissing = function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
    var clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function () {};

    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn("did not save key \"" + key + "\" as the namespace \"" + namespace + "\" was not yet loaded", 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
      return;
    }

    if (key === undefined || key === null || key === '') return;

    if (this.backend && this.backend.create) {
      var opts = _extends({}, options, {
        isUpdate: isUpdate
      });

      var fc = this.backend.create.bind(this.backend);

      if (fc.length < 6) {
        try {
          var r;

          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }

          if (r && typeof r.then === 'function') {
            r.then(function (data) {
              return clb(null, data);
            })["catch"](clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }

    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  };

  return Connector;
}(EventEmitter);

function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: 'all',
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: 'fallback',
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (typeof args[1] === 'object') ret = args[1];
      if (typeof args[1] === 'string') ret.defaultValue = args[1];
      if (typeof args[2] === 'string') ret.tDescription = args[2];

      if (typeof args[2] === 'object' || typeof args[3] === 'object') {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function (key) {
          ret[key] = options[key];
        });
      }

      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      nestingOptionsSeparator: ',',
      maxReplaces: 1000,
      skipOnVariables: true
    }
  };
}

function transformOptions(options) {
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];

  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
    options.supportedLngs = options.supportedLngs.concat(['cimode']);
  }

  return options;
}

function noop() {}

function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function (mem) {
    if (typeof inst[mem] === 'function') {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}

var I18n =
/*#__PURE__*/
function (_EventEmitter4) {
  _inheritsLoose(I18n, _EventEmitter4);

  function I18n() {
    var _this22;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;
    _this22 = _EventEmitter4.call(this) || this;
    _this22.options = transformOptions(options);
    _this22.services = {};
    _this22.logger = baseLogger;
    _this22.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this22));

    if (callback && !_this22.isInitialized && !options.isClone) {
      if (!_this22.options.initImmediate) {
        _this22.init(options, callback);

        return _assertThisInitialized(_this22) || _assertThisInitialized(_this22);
      }

      setTimeout(function () {
        _this22.init(options, callback);
      }, 0);
    }

    return _this22;
  }

  var _proto11 = I18n.prototype;

  _proto11.init = function init() {
    var _this23 = this;

    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === 'string') {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf('translation') < 0) {
        options.defaultNS = options.ns[0];
      }
    }

    var defOpts = get();
    this.options = _extends({}, defOpts, {}, this.options, {}, transformOptions(options));

    if (this.options.compatibilityAPI !== 'v1') {
      this.options.interpolation = _extends({}, defOpts.interpolation, {}, this.options.interpolation);
    }

    if (options.keySeparator !== undefined) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }

    if (options.nsSeparator !== undefined) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }

    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === 'function') return new ClassOrObject();
      return ClassOrObject;
    }

    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }

      var formatter;

      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== 'undefined') {
        formatter = Formatter;
      }

      var lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      var s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });

      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }

      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on('*', function (event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this.emit.apply(_this, [event].concat(args));
      });

      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }

      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }

      this.translator = new Translator(this.services, this.options);
      this.translator.on('*', function (event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        _this.emit.apply(_this, [event].concat(args));
      });
      this.modules.external.forEach(function (m) {
        if (m.init) m.init(_this23);
      });
    }

    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;

    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
    }

    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn('init: no languageDetector is used and no lng is defined');
    }

    var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
    storeApi.forEach(function (fcName) {
      _this23[fcName] = function () {
        var _this$store;

        return (_this$store = _this.store)[fcName].apply(_this$store, arguments);
      };
    });
    var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
    storeApiChained.forEach(function (fcName) {
      _this23[fcName] = function () {
        var _this$store2;

        (_this$store2 = _this.store)[fcName].apply(_this$store2, arguments);

        return _this;
      };
    });
    var deferred = defer();

    var load = function load() {
      var finish = function finish(err, t) {
        if (_this23.isInitialized && !_this23.initializedStoreOnce) _this23.logger.warn('init: i18next is already initialized. You should call init just once!');
        _this23.isInitialized = true;
        if (!_this23.options.isClone) _this23.logger.log('initialized', _this23.options);

        _this23.emit('initialized', _this23.options);

        deferred.resolve(t);
        callback(err, t);
      };

      if (_this23.languages && _this23.options.compatibilityAPI !== 'v1' && !_this23.isInitialized) return finish(null, _this23.t.bind(_this23));

      _this23.changeLanguage(_this23.options.lng, finish);
    };

    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }

    return deferred;
  };

  _proto11.loadResources = function loadResources(language) {
    var _this24 = this;

    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    var usedCallback = callback;
    var usedLng = typeof language === 'string' ? language : this.language;
    if (typeof language === 'function') usedCallback = language;

    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === 'cimode' && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      var toLoad = [];

      var append = function append(lng) {
        if (!lng) return;
        if (lng === 'cimode') return;

        var lngs = _this24.services.languageUtils.toResolveHierarchy(lng);

        lngs.forEach(function (l) {
          if (l === 'cimode') return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };

      if (!usedLng) {
        var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach(function (l) {
          return append(l);
        });
      } else {
        append(usedLng);
      }

      if (this.options.preload) {
        this.options.preload.forEach(function (l) {
          return append(l);
        });
      }

      this.services.backendConnector.load(toLoad, this.options.ns, function (e) {
        if (!e && !_this24.resolvedLanguage && _this24.language) _this24.setResolvedLanguage(_this24.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  };

  _proto11.reloadResources = function reloadResources(lngs, ns, callback) {
    var deferred = defer();
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, function (err) {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  };

  _proto11.use = function use(module) {
    if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
    if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');

    if (module.type === 'backend') {
      this.modules.backend = module;
    }

    if (module.type === 'logger' || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }

    if (module.type === 'languageDetector') {
      this.modules.languageDetector = module;
    }

    if (module.type === 'i18nFormat') {
      this.modules.i18nFormat = module;
    }

    if (module.type === 'postProcessor') {
      postProcessor.addPostProcessor(module);
    }

    if (module.type === 'formatter') {
      this.modules.formatter = module;
    }

    if (module.type === '3rdParty') {
      this.modules.external.push(module);
    }

    return this;
  };

  _proto11.setResolvedLanguage = function setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (['cimode', 'dev'].indexOf(l) > -1) return;

    for (var li = 0; li < this.languages.length; li++) {
      var lngInLngs = this.languages[li];
      if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;

      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  };

  _proto11.changeLanguage = function changeLanguage(lng, callback) {
    var _this25 = this;

    var _this2 = this;

    this.isLanguageChangingTo = lng;
    var deferred = defer();
    this.emit('languageChanging', lng);

    var setLngProps = function setLngProps(l) {
      _this25.language = l;
      _this25.languages = _this25.services.languageUtils.toResolveHierarchy(l);
      _this25.resolvedLanguage = undefined;

      _this25.setResolvedLanguage(l);
    };

    var done = function done(err, l) {
      if (l) {
        setLngProps(l);

        _this25.translator.changeLanguage(l);

        _this25.isLanguageChangingTo = undefined;

        _this25.emit('languageChanged', l);

        _this25.logger.log('languageChanged', l);
      } else {
        _this25.isLanguageChangingTo = undefined;
      }

      deferred.resolve(function () {
        return _this2.t.apply(_this2, arguments);
      });
      if (callback) callback(err, function () {
        return _this2.t.apply(_this2, arguments);
      });
    };

    var setLng = function setLng(lngs) {
      if (!lng && !lngs && _this25.services.languageDetector) lngs = [];
      var l = typeof lngs === 'string' ? lngs : _this25.services.languageUtils.getBestMatchFromCodes(lngs);

      if (l) {
        if (!_this25.language) {
          setLngProps(l);
        }

        if (!_this25.translator.language) _this25.translator.changeLanguage(l);
        if (_this25.services.languageDetector && _this25.services.languageDetector.cacheUserLanguage) _this25.services.languageDetector.cacheUserLanguage(l);
      }

      _this25.loadResources(l, function (err) {
        done(err, l);
      });
    };

    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }

    return deferred;
  };

  _proto11.getFixedT = function getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;

    var fixedT = function fixedT(key, opts) {
      var options;

      if (typeof opts !== 'object') {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }

        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = _extends({}, opts);
      }

      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      var keySeparator = _this3.options.keySeparator || '.';
      var resultKey;

      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map(function (k) {
          return "" + options.keyPrefix + keySeparator + k;
        });
      } else {
        resultKey = options.keyPrefix ? "" + options.keyPrefix + keySeparator + key : key;
      }

      return _this3.t(resultKey, options);
    };

    if (typeof lng === 'string') {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }

    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  };

  _proto11.t = function t() {
    var _this$translator;

    return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
  };

  _proto11.exists = function exists() {
    var _this$translator2;

    return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
  };

  _proto11.setDefaultNamespace = function setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  };

  _proto11.hasLoadedNamespace = function hasLoadedNamespace(ns) {
    var _this26 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!this.isInitialized) {
      this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
      return false;
    }

    if (!this.languages || !this.languages.length) {
      this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
      return false;
    }

    var lng = options.lng || this.resolvedLanguage || this.languages[0];
    var fallbackLng = this.options ? this.options.fallbackLng : false;
    var lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === 'cimode') return true;

    var loadNotPending = function loadNotPending(l, n) {
      var loadState = _this26.services.backendConnector.state[l + "|" + n];
      return loadState === -1 || loadState === 2;
    };

    if (options.precheck) {
      var preResult = options.precheck(this, loadNotPending);
      if (preResult !== undefined) return preResult;
    }

    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  };

  _proto11.loadNamespaces = function loadNamespaces(ns, callback) {
    var _this27 = this;

    var deferred = defer();

    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }

    if (typeof ns === 'string') ns = [ns];
    ns.forEach(function (n) {
      if (_this27.options.ns.indexOf(n) < 0) _this27.options.ns.push(n);
    });
    this.loadResources(function (err) {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  };

  _proto11.loadLanguages = function loadLanguages(lngs, callback) {
    var deferred = defer();
    if (typeof lngs === 'string') lngs = [lngs];
    var preloaded = this.options.preload || [];
    var newLngs = lngs.filter(function (lng) {
      return preloaded.indexOf(lng) < 0;
    });

    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }

    this.options.preload = preloaded.concat(newLngs);
    this.loadResources(function (err) {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  };

  _proto11.dir = function dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng) return 'rtl';
    var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
    var languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
  };

  I18n.createInstance = function createInstance() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;
    return new I18n(options, callback);
  };

  _proto11.cloneInstance = function cloneInstance() {
    var _this28 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    var forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;

    var mergedOptions = _extends({}, this.options, {}, options, {}, {
      isClone: true
    });

    var clone = new I18n(mergedOptions);

    if (options.debug !== undefined || options.prefix !== undefined) {
      clone.logger = clone.logger.clone(options);
    }

    var membersToCopy = ['store', 'services', 'language'];
    membersToCopy.forEach(function (m) {
      clone[m] = _this28[m];
    });
    clone.services = _extends({}, this.services);
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };

    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }

    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on('*', function (event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      clone.emit.apply(clone, [event].concat(args));
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  };

  _proto11.toJSON = function toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  };

  return I18n;
}(EventEmitter);

var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
module.exports = instance;

},{}],2:[function(require,module,exports){
"use strict";

var registerFormatters = function registerFormatters(i18n) {
  i18n.services.formatter.add('uppercase', function (value) {
    return value.toUpperCase();
  });
  i18n.services.formatter.add('upper', function (value) {
    return value.toUpperCase();
  });
  i18n.services.formatter.add('lower', function (value) {
    return value.toLowerCase();
  });
  i18n.services.formatter.add('capitalize', function (value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  });
};

module.exports = registerFormatters;

},{}],3:[function(require,module,exports){
"use strict";

var Translate = require('./translate');

function initTranslation(namespace, lang) {
  var t = new Translate(namespace, lang);
  t.init();
}

window.initTranslation = initTranslation;
module.exports = {
  initTranslation: initTranslation
};

},{"./translate":4}],4:[function(require,module,exports){
"use strict";

var isLocal = function isLocal() {
  return window.location.href.includes('dev.cardgames.io') || window.location.href.includes('localhost') || window.location.href.includes('127.0.0.1');
};

var registerFormatters = require('./gulp/i18NextFormatters');

var i18next = require('i18next');

var Translate =
/*#__PURE__*/
function () {
  function Translate(namespace, lang) {
    this.hasInit = false;
    this.trans = null;
    this.namespace = namespace;
    this.lang = lang;
  }

  var _proto = Translate.prototype;

  _proto.init = function init() {
    var _this = this;

    var lang = window.location.pathname.split('/');

    if (lang[1].length == 2) {
      if (this.namespace == undefined || !this.namespace.length) {
        this.namespace = lang[2];
      }

      this.namespace = this.namespace || lang[2];
      this.lang = this.lang || lang[1];
    } else {
      this.lang = this.lang || 'en';
      this.namespace = this.namespace || lang[1];
    }

    if (isLocal()) {
      var i18n = i18next //.use(i18nextHttpBackend)
      .init({
        lng: this.lang,
        debug: false,
        fallbackLng: this.lang,
        //We wan't to see clearly when translation is missing
        ns: this.namespace,
        defaultNS: 'shared',
        fallbackNS: 'shared',
        resources: window.languages,
        saveMissing: true,
        saveMissingTo: 'all',
        keySeparator: '::',
        nsSeparator: ':ns:',
        interpolation: {
          prefix: '[[',
          suffix: ']]'
        },
        backend: {
          addPath: '/locales/add/[[lng]]/[[ns]]'
        }
      }).then(function (t) {
        _this.hasInit = true;
        _this.trans = t;

        window.t = function () {
          return _this.t.apply(_this, arguments);
        };
      });
      registerFormatters(i18next);
      return i18n;
    } else {
      var _i18n = i18next.init({
        lng: this.lang,
        debug: false,
        fallbackLng: 'en',
        ns: this.namespace,
        defaultNS: 'shared',
        fallbackNS: 'shared',
        resources: window.languages,
        saveMissing: false,
        saveMissingTo: 'all',
        keySeparator: '::',
        nsSeparator: ':ns:',
        interpolation: {
          prefix: '[[',
          suffix: ']]'
        }
      }).then(function (t) {
        _this.hasInit = true;
        _this.trans = t;

        window.t = function () {
          return _this.t.apply(_this, arguments);
        };
      });

      registerFormatters(i18next);
      return _i18n;
    }
  };

  _proto.t = function t(key, fallback, options) {
    var _this2 = this;

    if (key == undefined || key == null || key == "") {
      return key;
    }

    if (options === undefined && typeof fallback !== 'string') {
      options = fallback;
      fallback = undefined;
    }

    if (options == undefined) {
      options = {
        ns: this.namespace
      };
    } else if (!Object.prototype.hasOwnProperty.call(options, 'ns')) {
      options.ns = this.namespace;
    }

    options = Object.keys(options).reduce(function (newObj, key) {
      if (key.startsWith('trans_')) {
        // Extract the new key name without 'trans_'
        var newKey = key.substring(6); // Translate the value and add to new object

        newObj[newKey] = _this2.trans(options[key], {
          ns: _this2.namespace
        });
      } else {
        // Copy the key-value pair as is
        newObj[key] = options[key];
      }

      return newObj;
    }, {});

    if (this.hasInit) {
      return this.trans(key, fallback, options);
    } else {
      return this.init().then(function (t) {
        return t(key, fallback, options);
      });
    }
  };

  return Translate;
}();

module.exports = Translate;

},{"./gulp/i18NextFormatters":2,"i18next":1}]},{},[3]);

</script>

</body>
</html>
