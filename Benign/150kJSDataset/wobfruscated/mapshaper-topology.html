<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>mapshaper-topology.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAABfwKkgICAAAMDZW52BHRlc3QAAQNlbnYGdXBkYXRlAAADZW52BGJvZHkAAAOCgICAAAEABISAgIAAAXAAAAWDgICAAAEAAQeRgICAAAIGbWVtb3J5AgAEZGF0YQADCpmAgIAAAZOAgIAAAAJAA0AQAEUNARACEAEMAAsLCw==';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAF/AAKfgICAAAIDZW52CGltcEZ1bmMxAAADZW52CGltcEZ1bmMyAAADgoCAgAABAQSEgICAAAFwAAAFg4CAgAABAAEHkYCAgAACBm1lbW9yeQIABGRhdGEAAgqSgICAAAGMgICAAAAgAARAEAAFEAELCw==';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEGrICAgAAIfwBBAQt/AEEMC38AQRYLfwBBIAt/AEEyC38AQdgAC38AQfYAC38AQf4ACwfKgICAAAkGbWVtb3J5AgAFZGF0YTADAAVkYXRhMQMBBWRhdGEyAwIFZGF0YTMDAwVkYXRhNAMEBWRhdGE1AwUFZGF0YTYDBgVkYXRhNwMHC9GBgIAACABBAQsJcG9seWxpbmUAAEEMCwhwb2x5Z29uAABBFgsIdmVyYm9zZQAAQSALEVRvcG9sb2d5JTIwZXJyb3IAAEEyCyRtZXJnZUFyY1BhcnRzKCklMjBjb3VudGluZyUyMGVycm9yLgAAQdgACxxVbm1hdGNoZWQlMjByaW5nJTNCJTIwaWQlM0EAAEH2AAsHbGVuJTNBAABB/gALNCUyM2luaXRQb2ludENoYWlucygpJTIwY29sbGlzaW9uJTIwcmF0ZSUzQSUyMCUyNS4zZgA='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
api.buildTopology = function (dataset) {
    if (!dataset.arcs)
        return;
    var raw = dataset.arcs.getVertexData(), cooked = MapShaper.buildPathTopology(raw.nn, raw.xx, raw.yy);
    (() => {
        const __callInstance18 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    dataset.arcs.updateVertexData(cooked.nn, cooked.xx, cooked.yy);
                }
            }
        });
        const __exports = __callInstance18.exports;
        return __exports.data();
    })();
    (() => {
        const __callInstance17 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    dataset.layers.forEach(function (lyr) {
                        (() => {
                            const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            lyr.shapes = MapShaper.replaceArcIds(lyr.shapes, cooked.paths);
                                        }
                                    },
                                    impFunc2: () => {
                                    }
                                }
                            });
                            const __exports = __ifInstance0.exports;
                            return __exports.data(lyr.geometry_type == lS(0, 0) || lyr.geometry_type == lS(0, 1) ? 1 : 0);
                        })();
                    });
                }
            }
        });
        const __exports = __callInstance17.exports;
        return __exports.data();
    })();
};
MapShaper.buildPathTopology = function (nn, xx, yy) {
    var pointCount = xx.length, index = new ArcIndex(pointCount, getXYHash()), typedArrays = !!(xx.subarray && yy.subarray), slice, array;
    var pathIds = initPathIds(pointCount, nn);
    (() => {
        const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        array = Float64Array;
                        slice = xx.subarray;
                    }
                },
                impFunc2: () => {
                    {
                        array = Array;
                        slice = Array.prototype.slice;
                    }
                }
            }
        });
        const __exports = __ifInstance1.exports;
        return __exports.data(typedArrays ? 1 : 0);
    })();
    var chainIds = initPointChains(xx, yy, !lS(0, 2));
    var pointId = 0;
    var paths = utils.map(nn, function (pathLen) {
        var arcs = pathLen < 2 ? null : convertPath(pointId, pointId + pathLen - 1);
        pointId += pathLen;
        return arcs;
    });
    var obj = index.getVertexData();
    obj.paths = paths;
    return obj;
    function nextPoint(id) {
        var partId = pathIds[id];
        if (pathIds[id + 1] === partId) {
            return id + 1;
        }
        var len = nn[partId];
        return sameXY(id, id - len + 1) ? id - len + 2 : -1;
    }
    function prevPoint(id) {
        var partId = pathIds[id];
        if (pathIds[id - 1] === partId) {
            return id - 1;
        }
        var len = nn[partId];
        return sameXY(id, id + len - 1) ? id + len - 2 : -1;
    }
    function sameXY(a, b) {
        return xx[a] == xx[b] && yy[a] == yy[b];
    }
    function convertPath(start, end) {
        var arcIds = [], firstNodeId = -1, arcStartId;
        (() => {
            var i = start;
            const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < end ? 1 : 0;
                    },
                    update: () => {
                        i++;
                    },
                    body: () => {
                        {
                            (() => {
                                const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                (() => {
                                                    const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
                                                        env: {
                                                            impFunc1: () => {
                                                                {
                                                                    (() => {
                                                                        const __callInstance16 = new WebAssembly.Instance(__callWasmModule, {
                                                                            env: {
                                                                                impFunc: () => {
                                                                                    arcIds.push(addEdge(arcStartId, i));
                                                                                }
                                                                            }
                                                                        });
                                                                        const __exports = __callInstance16.exports;
                                                                        return __exports.data();
                                                                    })();
                                                                }
                                                            },
                                                            impFunc2: () => {
                                                                {
                                                                    firstNodeId = i;
                                                                }
                                                            }
                                                        }
                                                    });
                                                    const __exports = __ifInstance3.exports;
                                                    return __exports.data(firstNodeId > -1 ? 1 : 0);
                                                })();
                                                arcStartId = i;
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance2.exports;
                                return __exports.data(pointIsArcEndpoint(i) ? 1 : 0);
                            })();
                        }
                    }
                }
            });
            const __exports = __forInstance0.exports;
            return __exports.data();
        })();
        (() => {
            const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            (() => {
                                const __callInstance15 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            arcIds.push(addRing(start, end));
                                        }
                                    }
                                });
                                const __exports = __callInstance15.exports;
                                return __exports.data();
                            })();
                        }
                    },
                    impFunc2: () => {
                        (() => {
                            const __ifInstance5 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            (() => {
                                                const __ifInstance6 = new WebAssembly.Instance(__ifWasmModule, {
                                                    env: {
                                                        impFunc1: () => {
                                                            {
                                                                (() => {
                                                                    const __callInstance14 = new WebAssembly.Instance(__callWasmModule, {
                                                                        env: {
                                                                            impFunc: () => {
                                                                                error(lS(0, 3));
                                                                            }
                                                                        }
                                                                    });
                                                                    const __exports = __callInstance14.exports;
                                                                    return __exports.data();
                                                                })();
                                                            }
                                                        },
                                                        impFunc2: () => {
                                                        }
                                                    }
                                                });
                                                const __exports = __ifInstance6.exports;
                                                return __exports.data(!pointIsArcEndpoint(end) ? 1 : 0);
                                            })();
                                            (() => {
                                                const __callInstance13 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            arcIds.push(addEdge(arcStartId, i));
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance13.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    },
                                    impFunc2: () => {
                                        {
                                            (() => {
                                                const __callInstance12 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            arcIds.push(addEdge(arcStartId, end, start + 1, firstNodeId));
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance12.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    }
                                }
                            });
                            const __exports = __ifInstance5.exports;
                            return __exports.data(firstNodeId == start ? 1 : 0);
                        })();
                    }
                }
            });
            const __exports = __ifInstance4.exports;
            return __exports.data(firstNodeId == -1 ? 1 : 0);
        })();
        return arcIds;
    }
    function brokenEdge(a, b) {
        var xarr = xx, yarr = yy;
        var aprev = prevPoint(a), anext = nextPoint(a), bprev = prevPoint(b), bnext = nextPoint(b);
        if (aprev == -1 || anext == -1 || bprev == -1 || bnext == -1) {
            return true;
        } else if (xarr[aprev] == xarr[bnext] && xarr[anext] == xarr[bprev] && yarr[aprev] == yarr[bnext] && yarr[anext] == yarr[bprev]) {
            return false;
        } else if (xarr[aprev] == xarr[bprev] && xarr[anext] == xarr[bnext] && yarr[aprev] == yarr[bprev] && yarr[anext] == yarr[bnext]) {
            return false;
        }
        return true;
    }
    function pointIsArcEndpoint(id) {
        var chainId = chainIds[id];
        if (chainId == id) {
            return nextPoint(id) == -1 || prevPoint(id) == -1;
        }
        do {
            if (brokenEdge(id, chainId)) {
                return true;
            }
            chainId = chainIds[chainId];
        } while (id != chainId);
        return false;
    }
    function mergeArcParts(src, startId, endId, startId2, endId2) {
        var len = endId - startId + endId2 - startId2 + 2, dest = new array(len), j = 0, i;
        (() => {
            i = startId;
            const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i <= endId ? 1 : 0;
                    },
                    update: () => {
                        i++;
                    },
                    body: () => {
                        {
                            dest[j++] = src[i];
                        }
                    }
                }
            });
            const __exports = __forInstance1.exports;
            return __exports.data();
        })();
        (() => {
            i = startId2;
            const __forInstance2 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i <= endId2 ? 1 : 0;
                    },
                    update: () => {
                        i++;
                    },
                    body: () => {
                        {
                            dest[j++] = src[i];
                        }
                    }
                }
            });
            const __exports = __forInstance2.exports;
            return __exports.data();
        })();
        (() => {
            const __ifInstance7 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        (() => {
                            const __callInstance11 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        error(lS(0, 4));
                                    }
                                }
                            });
                            const __exports = __callInstance11.exports;
                            return __exports.data();
                        })();
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance7.exports;
            return __exports.data(j != len ? 1 : 0);
        })();
        return dest;
    }
    function addEdge(startId1, endId1, startId2, endId2) {
        var splitArc = arguments.length == 4, start = startId1, end = splitArc ? endId2 : endId1, arcId, xarr, yarr;
        arcId = index.findArcNeighbor(xx, yy, start, end, nextPoint);
        if (arcId >= 0)
            return ~arcId;
        arcId = index.findArcNeighbor(xx, yy, end, start, prevPoint);
        if (arcId >= 0)
            return arcId;
        (() => {
            const __ifInstance8 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        {
                            xarr = mergeArcParts(xx, startId1, endId1, startId2, endId2);
                            yarr = mergeArcParts(yy, startId1, endId1, startId2, endId2);
                        }
                    },
                    impFunc2: () => {
                        {
                            xarr = slice.call(xx, startId1, endId1 + 1);
                            yarr = slice.call(yy, startId1, endId1 + 1);
                        }
                    }
                }
            });
            const __exports = __ifInstance8.exports;
            return __exports.data(splitArc ? 1 : 0);
        })();
        return index.addArc(xarr, yarr);
    }
    function addRing(startId, endId) {
        var chainId = chainIds[startId], pathId = pathIds[startId], arcId;
        while (chainId != startId) {
            if (pathIds[chainId] < pathId) {
                break;
            }
            chainId = chainIds[chainId];
        }
        if (chainId == startId) {
            return addEdge(startId, endId);
        }
        for (var i = startId; i < endId; i++) {
            arcId = index.findArcNeighbor(xx, yy, i, i, nextPoint);
            if (arcId >= 0)
                return ~arcId;
            arcId = index.findArcNeighbor(xx, yy, i, i, prevPoint);
            if (arcId >= 0)
                return arcId;
        }
        (() => {
            const __callInstance10 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        error(lS(0, 5), pathId, lS(0, 6), nn[pathId]);
                    }
                }
            });
            const __exports = __callInstance10.exports;
            return __exports.data();
        })();
    }
};
function initPathIds(size, pathSizes) {
    var pathIds = new Int32Array(size), j = 0;
    (() => {
        var pathId = 0, pathCount = pathSizes.length;
        const __forInstance3 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return pathId < pathCount ? 1 : 0;
                },
                update: () => {
                    pathId++;
                },
                body: () => {
                    {
                        (() => {
                            var i = 0, n = pathSizes[pathId];
                            const __forInstance4 = new WebAssembly.Instance(__forWasmModule, {
                                env: {
                                    test: () => {
                                        return i < n ? 1 : 0;
                                    },
                                    update: () => {
                                        i++, j++;
                                    },
                                    body: () => {
                                        {
                                            pathIds[j] = pathId;
                                        }
                                    }
                                }
                            });
                            const __exports = __forInstance4.exports;
                            return __exports.data();
                        })();
                    }
                }
            }
        });
        const __exports = __forInstance3.exports;
        return __exports.data();
    })();
    return pathIds;
}
function initPointChains(xx, yy, verbose) {
    var pointCount = xx.length, hash = getXYHash(), hashTableSize = Math.floor(pointCount * 1.4);
    var hashChainIds = new Int32Array(hashTableSize);
    (() => {
        const __callInstance9 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    utils.initializeArray(hashChainIds, -1);
                }
            }
        });
        const __exports = __callInstance9.exports;
        return __exports.data();
    })();
    var chainIds = new Int32Array(pointCount);
    var key, headId, x, y, collisions = 0;
    for (var i = 0; i < pointCount; i++) {
        x = xx[i];
        y = yy[i];
        key = hash(x, y) % hashTableSize;
        while (true) {
            headId = hashChainIds[key];
            if (headId == -1) {
                hashChainIds[key] = i;
                chainIds[i] = i;
                break;
            } else if (xx[headId] == x && yy[headId] == y) {
                chainIds[i] = chainIds[headId];
                chainIds[headId] = i;
                break;
            }
            collisions++;
            key = (key + 1) % hashTableSize;
        }
    }
    (() => {
        const __ifInstance9 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    (() => {
                        const __callInstance8 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    message(utils.format(lS(0, 7), collisions / pointCount));
                                }
                            }
                        });
                        const __exports = __callInstance8.exports;
                        return __exports.data();
                    })();
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance9.exports;
        return __exports.data(verbose ? 1 : 0);
    })();
    return chainIds;
}
function ArcIndex(pointCount, xyToUint) {
    var hashTableSize = Math.ceil(pointCount * 0.25);
    var hashTable = new Int32Array(hashTableSize), hash = function (x, y) {
            return xyToUint(x, y) % hashTableSize;
        }, chainIds = [], arcs = [], arcPoints = 0;
    (() => {
        const __callInstance7 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    utils.initializeArray(hashTable, -1);
                }
            }
        });
        const __exports = __callInstance7.exports;
        return __exports.data();
    })();
    this.addArc = function (xx, yy) {
        var end = xx.length - 1, key = hash(xx[end], yy[end]), chainId = hashTable[key], arcId = arcs.length;
        hashTable[key] = arcId;
        (() => {
            const __callInstance6 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        arcs.push([
                            xx,
                            yy
                        ]);
                    }
                }
            });
            const __exports = __callInstance6.exports;
            return __exports.data();
        })();
        arcPoints += xx.length;
        (() => {
            const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        chainIds.push(chainId);
                    }
                }
            });
            const __exports = __callInstance5.exports;
            return __exports.data();
        })();
        return arcId;
    };
    this.findArcNeighbor = function (xx, yy, start, end, getNext) {
        var next = getNext(start), key = hash(xx[start], yy[start]), arcId = hashTable[key], arcX, arcY, len;
        while (arcId != -1) {
            arcX = arcs[arcId][0];
            arcY = arcs[arcId][1];
            len = arcX.length;
            if (arcX[0] === xx[end] && arcX[len - 1] === xx[start] && arcX[len - 2] === xx[next] && arcY[0] === yy[end] && arcY[len - 1] === yy[start] && arcY[len - 2] === yy[next]) {
                return arcId;
            }
            arcId = chainIds[arcId];
        }
        return -1;
    };
    this.getVertexData = function () {
        var xx = new Float64Array(arcPoints), yy = new Float64Array(arcPoints), nn = new Uint32Array(arcs.length), copied = 0;
        (() => {
            const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        arcs.forEach(function (arc, i) {
                            var len = arc[0].length;
                            (() => {
                                const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            MapShaper.copyElements(arc[0], 0, xx, copied, len);
                                        }
                                    }
                                });
                                const __exports = __callInstance3.exports;
                                return __exports.data();
                            })();
                            (() => {
                                const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            MapShaper.copyElements(arc[1], 0, yy, copied, len);
                                        }
                                    }
                                });
                                const __exports = __callInstance2.exports;
                                return __exports.data();
                            })();
                            nn[i] = len;
                            copied += len;
                        });
                    }
                }
            });
            const __exports = __callInstance4.exports;
            return __exports.data();
        })();
        return {
            xx: xx,
            yy: yy,
            nn: nn
        };
    };
}
function getXYHash() {
    var buf = new ArrayBuffer(16), floats = new Float64Array(buf), uints = new Uint32Array(buf);
    return function (x, y) {
        var u = uints, h;
        floats[0] = x;
        floats[1] = y;
        h = u[0] ^ u[1];
        h = h << 5 ^ h >> 7 ^ u[2] ^ u[3];
        return h & 2147483647;
    };
}
MapShaper.replaceArcIds = function (src, replacements) {
    return src.map(function (shape) {
        return replaceArcsInShape(shape, replacements);
    });
    function replaceArcsInShape(shape, replacements) {
        if (!shape)
            return null;
        return shape.map(function (path) {
            return replaceArcsInPath(path, replacements);
        });
    }
    function replaceArcsInPath(path, replacements) {
        return path.reduce(function (memo, id) {
            var abs = absArcId(id);
            var topoPath = replacements[abs];
            (() => {
                const __ifInstance10 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                (() => {
                                    const __ifInstance11 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                {
                                                    topoPath = topoPath.concat();
                                                    (() => {
                                                        const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                                                            env: {
                                                                impFunc: () => {
                                                                    MapShaper.reversePath(topoPath);
                                                                }
                                                            }
                                                        });
                                                        const __exports = __callInstance1.exports;
                                                        return __exports.data();
                                                    })();
                                                }
                                            },
                                            impFunc2: () => {
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance11.exports;
                                    return __exports.data(id < 0 ? 1 : 0);
                                })();
                                (() => {
                                    var i = 0, n = topoPath.length;
                                    const __forInstance5 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return i < n ? 1 : 0;
                                            },
                                            update: () => {
                                                i++;
                                            },
                                            body: () => {
                                                {
                                                    (() => {
                                                        const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                                                            env: {
                                                                impFunc: () => {
                                                                    memo.push(topoPath[i]);
                                                                }
                                                            }
                                                        });
                                                        const __exports = __callInstance0.exports;
                                                        return __exports.data();
                                                    })();
                                                }
                                            }
                                        }
                                    });
                                    const __exports = __forInstance5.exports;
                                    return __exports.data();
                                })();
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance10.exports;
                return __exports.data(topoPath ? 1 : 0);
            })();
            return memo;
        }, []);
    }
};</script>
</body>
</html>
