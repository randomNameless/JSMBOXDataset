<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>index.html</title>
</head>
<body>

<script>
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorMessages = exports.ErrorType = void 0;
    var ErrorType;
    (function(ErrorType2) {
      ErrorType2["MalformedUnicode"] = "MALFORMED_UNICODE";
      ErrorType2["MalformedHexadecimal"] = "MALFORMED_HEXADECIMAL";
      ErrorType2["CodePointLimit"] = "CODE_POINT_LIMIT";
      ErrorType2["OctalDeprecation"] = "OCTAL_DEPRECATION";
      ErrorType2["EndOfString"] = "END_OF_STRING";
    })(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
    exports.errorMessages = /* @__PURE__ */ new Map([
      [ErrorType.MalformedUnicode, "malformed Unicode character escape sequence"],
      [
        ErrorType.MalformedHexadecimal,
        "malformed hexadecimal character escape sequence"
      ],
      [
        ErrorType.CodePointLimit,
        "Unicode codepoint must not be greater than 0x10FFFF in escape sequence"
      ],
      [
        ErrorType.OctalDeprecation,
        '"0"-prefixed octal literals and octal escape sequences are deprecated; for octal literals use the "0o" prefix instead'
      ],
      [ErrorType.EndOfString, "malformed escape sequence at end of string"]
    ]);
  }
});

// node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/unraw@3.0.0/node_modules/unraw/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unraw = exports.errorMessages = exports.ErrorType = void 0;
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ErrorType", { enumerable: true, get: function() {
      return errors_1.ErrorType;
    } });
    Object.defineProperty(exports, "errorMessages", { enumerable: true, get: function() {
      return errors_1.errorMessages;
    } });
    function parseHexToInt(hex) {
      const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);
      return isOnlyHexChars ? parseInt(hex, 16) : NaN;
    }
    function validateAndParseHex(hex, errorName, enforcedLength) {
      const parsedHex = parseHexToInt(hex);
      if (Number.isNaN(parsedHex) || enforcedLength !== void 0 && enforcedLength !== hex.length) {
        throw new SyntaxError(errors_1.errorMessages.get(errorName));
      }
      return parsedHex;
    }
    function parseHexadecimalCode(code) {
      const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);
      return String.fromCharCode(parsedCode);
    }
    function parseUnicodeCode(code, surrogateCode) {
      const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);
      if (surrogateCode !== void 0) {
        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);
        return String.fromCharCode(parsedCode, parsedSurrogateCode);
      }
      return String.fromCharCode(parsedCode);
    }
    function isCurlyBraced(text) {
      return text.charAt(0) === "{" && text.charAt(text.length - 1) === "}";
    }
    function parseUnicodeCodePointCode(codePoint) {
      if (!isCurlyBraced(codePoint)) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));
      }
      const withoutBraces = codePoint.slice(1, -1);
      const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);
      try {
        return String.fromCodePoint(parsedCode);
      } catch (err) {
        throw err instanceof RangeError ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit)) : err;
      }
    }
    function parseOctalCode(code, error = false) {
      if (error) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));
      }
      const parsedCode = parseInt(code, 8);
      return String.fromCharCode(parsedCode);
    }
    var singleCharacterEscapes = /* @__PURE__ */ new Map([
      ["b", "\b"],
      ["f", "\f"],
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["v", "\v"],
      ["0", "\0"]
    ]);
    function parseSingleCharacterCode(code) {
      return singleCharacterEscapes.get(code) || code;
    }
    var escapeMatch = /\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;
    function unraw2(raw, allowOctals = false) {
      return raw.replace(escapeMatch, function(_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {
        if (backslash !== void 0) {
          return "\\";
        }
        if (hex !== void 0) {
          return parseHexadecimalCode(hex);
        }
        if (codePoint !== void 0) {
          return parseUnicodeCodePointCode(codePoint);
        }
        if (unicodeWithSurrogate !== void 0) {
          return parseUnicodeCode(unicodeWithSurrogate, surrogate);
        }
        if (unicode !== void 0) {
          return parseUnicodeCode(unicode);
        }
        if (octal === "0") {
          return "\0";
        }
        if (octal !== void 0) {
          return parseOctalCode(octal, !allowOctals);
        }
        if (singleCharacter !== void 0) {
          return parseSingleCharacterCode(singleCharacter);
        }
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));
      });
    }
    exports.unraw = unraw2;
    exports.default = unraw2;
  }
});

// node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js
var require_moo = __commonJS({
  "node_modules/.pnpm/moo@0.5.2/node_modules/moo/moo.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.moo = factory();
      }
    })(exports, function() {
      "use strict";
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var toString = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp(o) {
        return o && toString.call(o) === "[object RegExp]";
      }
      function isObject(o) {
        return o && typeof o === "object" && !isRegExp(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re = new RegExp("|" + s);
        return re.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length)
          return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp(obj)) {
          if (obj.ignoreCase)
            throw new Error("RegExp /i flag not allowed");
          if (obj.global)
            throw new Error("RegExp /g flag is implied");
          if (obj.sticky)
            throw new Error("RegExp /y flag is implied");
          if (obj.multiline)
            throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function pad(s, length) {
        if (s.length > length) {
          return s;
        }
        return Array(length - s.length + 1).join(" ") + s;
      }
      function lastNLines(string, numLines) {
        var position = string.length;
        var lineBreaks = 0;
        while (true) {
          var idx = string.lastIndexOf("\n", position - 1);
          if (idx === -1) {
            break;
          } else {
            lineBreaks++;
          }
          position = idx;
          if (lineBreaks === numLines) {
            break;
          }
          if (position === 0) {
            break;
          }
        }
        var startPosition = lineBreaks < numLines ? 0 : position + 1;
        return string.substring(startPosition).split("\n");
      }
      function objectToRules(object) {
        var keys = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var thing = object[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject(rule)) {
              if (match.length)
                result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length)
            result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
          var obj = array[i];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type, obj) {
        if (!isObject(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) {
            options[key] = obj[key];
          }
        }
        if (typeof options.type === "string" && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
        }
        var match = options.match;
        options.match = Array.isArray(match) ? match : match ? [match] : [];
        options.match.sort(function(a, b) {
          return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? 1 : b.length - a.length;
        });
        return options;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];
        for (var i = 0; i < rules.length; i++) {
          if (rules[i].fallback) {
            fastAllowed = false;
          }
        }
        for (var i = 0; i < rules.length; i++) {
          var options = rules[i];
          if (options.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options.error || options.fallback) {
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
              }
            }
            errorRule = options;
          }
          var match = options.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word = match.shift();
              fast[word.charCodeAt(0)] = options;
            }
          }
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options);
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
          }
          if (!options.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix2 = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true)
          flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix2, flags);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name, map) {
        var state = g && (g.push || g.next);
        if (state && !map[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
        }
      }
      function compileStates(states, start) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys = Object.getOwnPropertyNames(states);
        if (!start)
          start = keys[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include)
              continue;
            var splice = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1)
                  continue;
                splice.push(newRule);
              }
            }
            rules.splice.apply(rules, splice);
            j--;
          }
        }
        var map = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          map[key] = compileRules(ruleMap[key], true);
        }
        for (var i = 0; i < keys.length; i++) {
          var name = keys[i];
          var state = map[name];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name, map);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name, map);
          }
        }
        return new Lexer(map, start);
      }
      function keywordTransform(map) {
        var isMap = typeof Map !== "undefined";
        var reverseMap = isMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        var types = Object.getOwnPropertyNames(map);
        for (var i = 0; i < types.length; i++) {
          var tokenType = types[i];
          var item = map[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            if (isMap) {
              reverseMap.set(keyword, tokenType);
            } else {
              reverseMap[keyword] = tokenType;
            }
          });
        }
        return function(k) {
          return isMap ? reverseMap.get(k) : reverseMap[k];
        };
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedText = info ? info.queuedText : "";
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state)
          return;
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match = re.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i = 0; i < groupCount; i++) {
          if (match[i + 1] !== void 0) {
            return this.groups[i];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index);
        }
        var re = this.re;
        re.lastIndex = index;
        var match = eat(re, buffer);
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index, buffer.length), index);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error.fallback && match.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error, buffer.slice(index, match.index), index);
        }
        return this._token(group, text, index);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          var err = new Error(this.formatError(token, "invalid syntax"));
          throw err;
        }
        if (group.pop)
          this.popState();
        else if (group.push)
          this.pushState(group.push);
        else if (group.next)
          this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer) {
          this.lexer = lexer;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var numLinesAround = 2;
        var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
        var lastDisplayedLine = token.line + numLinesAround;
        var lastLineDigits = String(lastDisplayedLine).length;
        var displayedLines = lastNLines(
          this.buffer,
          this.line - token.line + numLinesAround + 1
        ).slice(0, 5);
        var errorLines = [];
        errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
        errorLines.push("");
        for (var i = 0; i < displayedLines.length; i++) {
          var line = displayedLines[i];
          var lineNo = firstDisplayedLine + i;
          errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
          if (lineNo === token.line) {
            errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
          }
        }
        return errorLines.join("\n");
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// node_modules/.pnpm/@messageformat+parser@5.1.0/node_modules/@messageformat/parser/lib/lexer.js
var require_lexer = __commonJS({
  "node_modules/.pnpm/@messageformat+parser@5.1.0/node_modules/@messageformat/parser/lib/lexer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lexer = exports.states = void 0;
    var moo_1 = __importDefault(require_moo());
    exports.states = {
      body: {
        doubleapos: { match: "''", value: () => "'" },
        quoted: {
          lineBreaks: true,
          match: /'[{}#](?:[^]*?[^'])?'(?!')/u,
          value: (src) => src.slice(1, -1).replace(/''/g, "'")
        },
        argument: {
          lineBreaks: true,
          match: /\{\s*[^\p{Pat_Syn}\p{Pat_WS}]+\s*/u,
          push: "arg",
          value: (src) => src.substring(1).trim()
        },
        octothorpe: "#",
        end: { match: "}", pop: 1 },
        content: { lineBreaks: true, match: /[^][^{}#']*/u }
      },
      arg: {
        select: {
          lineBreaks: true,
          match: /,\s*(?:plural|select|selectordinal)\s*,\s*/u,
          next: "select",
          value: (src) => src.split(",")[1].trim()
        },
        "func-args": {
          lineBreaks: true,
          match: /,\s*[^\p{Pat_Syn}\p{Pat_WS}]+\s*,/u,
          next: "body",
          value: (src) => src.split(",")[1].trim()
        },
        "func-simple": {
          lineBreaks: true,
          match: /,\s*[^\p{Pat_Syn}\p{Pat_WS}]+\s*/u,
          value: (src) => src.substring(1).trim()
        },
        end: { match: "}", pop: 1 }
      },
      select: {
        offset: {
          lineBreaks: true,
          match: /\s*offset\s*:\s*\d+\s*/u,
          value: (src) => src.split(":")[1].trim()
        },
        case: {
          lineBreaks: true,
          match: /\s*(?:=\d+|[^\p{Pat_Syn}\p{Pat_WS}]+)\s*\{/u,
          push: "body",
          value: (src) => src.substring(0, src.indexOf("{")).trim()
        },
        end: { match: /\s*\}/u, pop: 1 }
      }
    };
    exports.lexer = moo_1.default.states(exports.states);
  }
});

// node_modules/.pnpm/@messageformat+parser@5.1.0/node_modules/@messageformat/parser/lib/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/@messageformat+parser@5.1.0/node_modules/@messageformat/parser/lib/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.ParseError = void 0;
    var lexer_js_1 = require_lexer();
    var getContext = (lt) => ({
      offset: lt.offset,
      line: lt.line,
      col: lt.col,
      text: lt.text,
      lineBreaks: lt.lineBreaks
    });
    var isSelectType = (type) => type === "plural" || type === "select" || type === "selectordinal";
    function strictArgStyleParam(lt, param) {
      let value = "";
      let text = "";
      for (const p of param) {
        const pText = p.ctx.text;
        text += pText;
        switch (p.type) {
          case "content":
            value += p.value;
            break;
          case "argument":
          case "function":
          case "octothorpe":
            value += pText;
            break;
          default:
            throw new ParseError(lt, `Unsupported part in strict mode function arg style: ${pText}`);
        }
      }
      const c = {
        type: "content",
        value: value.trim(),
        ctx: Object.assign({}, param[0].ctx, { text })
      };
      return [c];
    }
    var strictArgTypes = [
      "number",
      "date",
      "time",
      "spellout",
      "ordinal",
      "duration"
    ];
    var defaultPluralKeys = ["zero", "one", "two", "few", "many", "other"];
    var ParseError = class extends Error {
      /** @internal */
      constructor(lt, msg) {
        super(lexer_js_1.lexer.formatError(lt, msg));
      }
    };
    exports.ParseError = ParseError;
    var Parser = class {
      constructor(src, opt) {
        var _a, _b, _c, _d;
        this.lexer = lexer_js_1.lexer.reset(src);
        this.cardinalKeys = (_a = opt === null || opt === void 0 ? void 0 : opt.cardinal) !== null && _a !== void 0 ? _a : defaultPluralKeys;
        this.ordinalKeys = (_b = opt === null || opt === void 0 ? void 0 : opt.ordinal) !== null && _b !== void 0 ? _b : defaultPluralKeys;
        this.strict = (_c = opt === null || opt === void 0 ? void 0 : opt.strict) !== null && _c !== void 0 ? _c : false;
        this.strictPluralKeys = (_d = opt === null || opt === void 0 ? void 0 : opt.strictPluralKeys) !== null && _d !== void 0 ? _d : true;
      }
      parse() {
        return this.parseBody(false, true);
      }
      checkSelectKey(lt, type, key) {
        if (key[0] === "=") {
          if (type === "select")
            throw new ParseError(lt, `The case ${key} is not valid with select`);
        } else if (type !== "select") {
          const keys = type === "plural" ? this.cardinalKeys : this.ordinalKeys;
          if (this.strictPluralKeys && keys.length > 0 && !keys.includes(key)) {
            const msg = `The ${type} case ${key} is not valid in this locale`;
            throw new ParseError(lt, msg);
          }
        }
      }
      parseSelect({ value: arg }, inPlural, ctx, type) {
        const sel = { type, arg, cases: [], ctx };
        if (type === "plural" || type === "selectordinal")
          inPlural = true;
        else if (this.strict)
          inPlural = false;
        for (const lt of this.lexer) {
          switch (lt.type) {
            case "offset":
              if (type === "select")
                throw new ParseError(lt, "Unexpected plural offset for select");
              if (sel.cases.length > 0)
                throw new ParseError(lt, "Plural offset must be set before cases");
              sel.pluralOffset = Number(lt.value);
              ctx.text += lt.text;
              ctx.lineBreaks += lt.lineBreaks;
              break;
            case "case": {
              this.checkSelectKey(lt, type, lt.value);
              sel.cases.push({
                key: lt.value,
                tokens: this.parseBody(inPlural),
                ctx: getContext(lt)
              });
              break;
            }
            case "end":
              return sel;
            default:
              throw new ParseError(lt, `Unexpected lexer token: ${lt.type}`);
          }
        }
        throw new ParseError(null, "Unexpected message end");
      }
      parseArgToken(lt, inPlural) {
        const ctx = getContext(lt);
        const argType = this.lexer.next();
        if (!argType)
          throw new ParseError(null, "Unexpected message end");
        ctx.text += argType.text;
        ctx.lineBreaks += argType.lineBreaks;
        if (this.strict && (argType.type === "func-simple" || argType.type === "func-args") && !strictArgTypes.includes(argType.value)) {
          const msg = `Invalid strict mode function arg type: ${argType.value}`;
          throw new ParseError(lt, msg);
        }
        switch (argType.type) {
          case "end":
            return { type: "argument", arg: lt.value, ctx };
          case "func-simple": {
            const end = this.lexer.next();
            if (!end)
              throw new ParseError(null, "Unexpected message end");
            if (end.type !== "end")
              throw new ParseError(end, `Unexpected lexer token: ${end.type}`);
            ctx.text += end.text;
            if (isSelectType(argType.value.toLowerCase()))
              throw new ParseError(argType, `Invalid type identifier: ${argType.value}`);
            return {
              type: "function",
              arg: lt.value,
              key: argType.value,
              ctx
            };
          }
          case "func-args": {
            if (isSelectType(argType.value.toLowerCase())) {
              const msg = `Invalid type identifier: ${argType.value}`;
              throw new ParseError(argType, msg);
            }
            let param = this.parseBody(this.strict ? false : inPlural);
            if (this.strict && param.length > 0)
              param = strictArgStyleParam(lt, param);
            return {
              type: "function",
              arg: lt.value,
              key: argType.value,
              param,
              ctx
            };
          }
          case "select":
            if (isSelectType(argType.value))
              return this.parseSelect(lt, inPlural, ctx, argType.value);
            else
              throw new ParseError(argType, `Unexpected select type ${argType.value}`);
          default:
            throw new ParseError(argType, `Unexpected lexer token: ${argType.type}`);
        }
      }
      parseBody(inPlural, atRoot) {
        const tokens = [];
        let content = null;
        for (const lt of this.lexer) {
          if (lt.type === "argument") {
            if (content)
              content = null;
            tokens.push(this.parseArgToken(lt, inPlural));
          } else if (lt.type === "octothorpe" && inPlural) {
            if (content)
              content = null;
            tokens.push({ type: "octothorpe", ctx: getContext(lt) });
          } else if (lt.type === "end" && !atRoot) {
            return tokens;
          } else {
            let value = lt.value;
            if (!inPlural && lt.type === "quoted" && value[0] === "#") {
              if (value.includes("{")) {
                const errMsg = `Unsupported escape pattern: ${value}`;
                throw new ParseError(lt, errMsg);
              }
              value = lt.text;
            }
            if (content) {
              content.value += value;
              content.ctx.text += lt.text;
              content.ctx.lineBreaks += lt.lineBreaks;
            } else {
              content = { type: "content", value, ctx: getContext(lt) };
              tokens.push(content);
            }
          }
        }
        if (atRoot)
          return tokens;
        throw new ParseError(null, "Unexpected message end");
      }
    };
    function parse2(src, options = {}) {
      const parser = new Parser(src, options);
      return parser.parse();
    }
    exports.parse = parse2;
  }
});

// packages/button/index.js
import { html } from "https://assets.finn.no/npm/lit-2/v2/lit.min.js";

// node_modules/.pnpm/@chbphone55+classnames@2.0.0/node_modules/@chbphone55/classnames/dist/index.m.js
var r = function() {
  for (var t = [], n = arguments.length; n--; )
    t[n] = arguments[n];
  return t.reduce(function(t2, n2) {
    return t2.concat("string" == typeof n2 ? n2 : Array.isArray(n2) ? r.apply(void 0, n2) : "object" == typeof n2 && n2 ? Object.keys(n2).map(function(r2) {
      return n2[r2] ? r2 : "";
    }) : "");
  }, []).join(" ");
};

// node_modules/.pnpm/@lingui+core@4.7.1/node_modules/@lingui/core/dist/index.mjs
var import_unraw = __toESM(require_dist(), 1);

// node_modules/.pnpm/@lingui+message-utils@4.7.1/node_modules/@lingui/message-utils/dist/compileMessage.mjs
var import_parser = __toESM(require_parser(), 1);
function processTokens(tokens, mapText) {
  if (!tokens.filter((token) => token.type !== "content").length) {
    return tokens.map((token) => mapText(token.value)).join("");
  }
  return tokens.map((token) => {
    var _a;
    if (token.type === "content") {
      return mapText(token.value);
    } else if (token.type === "octothorpe") {
      return "#";
    } else if (token.type === "argument") {
      return [token.arg];
    } else if (token.type === "function") {
      const _param = (_a = token == null ? void 0 : token.param) == null ? void 0 : _a[0];
      if (_param) {
        return [token.arg, token.key, _param.value.trim()];
      } else {
        return [token.arg, token.key];
      }
    }
    const offset = token.pluralOffset;
    const formatProps = {};
    token.cases.forEach((item) => {
      formatProps[item.key.replace(/^=(.)+/, "$1")] = processTokens(
        item.tokens,
        mapText
      );
    });
    return [
      token.arg,
      token.type,
      __spreadValues({
        offset
      }, formatProps)
    ];
  });
}
function compileMessage(message, mapText = (v) => v) {
  try {
    return processTokens((0, import_parser.parse)(message), mapText);
  } catch (e) {
    console.error(`${e.message} 

Message: ${message}`);
    return message;
  }
}

// node_modules/.pnpm/@lingui+core@4.7.1/node_modules/@lingui/core/dist/index.mjs
var isString = (s) => typeof s === "string";
var isFunction = (f) => typeof f === "function";
var cache = /* @__PURE__ */ new Map();
var defaultLocale = "en";
function normalizeLocales(locales) {
  const out = Array.isArray(locales) ? locales : [locales];
  return [...out, defaultLocale];
}
function date(locales, value, format) {
  const _locales = normalizeLocales(locales);
  const formatter = getMemoized(
    () => cacheKey("date", _locales, format),
    () => new Intl.DateTimeFormat(_locales, format)
  );
  return formatter.format(isString(value) ? new Date(value) : value);
}
function number(locales, value, format) {
  const _locales = normalizeLocales(locales);
  const formatter = getMemoized(
    () => cacheKey("number", _locales, format),
    () => new Intl.NumberFormat(_locales, format)
  );
  return formatter.format(value);
}
function plural(locales, ordinal, value, _a) {
  var _b = _a, { offset = 0 } = _b, rules = __objRest(_b, ["offset"]);
  var _a2, _b2;
  const _locales = normalizeLocales(locales);
  const plurals = ordinal ? getMemoized(
    () => cacheKey("plural-ordinal", _locales),
    () => new Intl.PluralRules(_locales, { type: "ordinal" })
  ) : getMemoized(
    () => cacheKey("plural-cardinal", _locales),
    () => new Intl.PluralRules(_locales, { type: "cardinal" })
  );
  return (_b2 = (_a2 = rules[value]) != null ? _a2 : rules[plurals.select(value - offset)]) != null ? _b2 : rules.other;
}
function getMemoized(getKey, construct) {
  const key = getKey();
  let formatter = cache.get(key);
  if (!formatter) {
    formatter = construct();
    cache.set(key, formatter);
  }
  return formatter;
}
function cacheKey(type, locales, options) {
  const localeKey = locales.join("-");
  return `${type}-${localeKey}-${JSON.stringify(options)}`;
}
var UNICODE_REGEX = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g;
var OCTOTHORPE_PH = "%__lingui_octothorpe__%";
var getDefaultFormats = (locale, passedLocales, formats = {}) => {
  const locales = passedLocales || locale;
  const style = (format) => {
    return typeof format === "object" ? format : formats[format] || { style: format };
  };
  const replaceOctothorpe = (value, message) => {
    const numberFormat = Object.keys(formats).length ? style("number") : void 0;
    const valueStr = number(locales, value, numberFormat);
    return message.replace(new RegExp(OCTOTHORPE_PH, "g"), valueStr);
  };
  return {
    plural: (value, cases) => {
      const { offset = 0 } = cases;
      const message = plural(locales, false, value, cases);
      return replaceOctothorpe(value - offset, message);
    },
    selectordinal: (value, cases) => {
      const { offset = 0 } = cases;
      const message = plural(locales, true, value, cases);
      return replaceOctothorpe(value - offset, message);
    },
    select: selectFormatter,
    number: (value, format) => number(locales, value, style(format)),
    date: (value, format) => date(locales, value, style(format))
  };
};
var selectFormatter = (value, rules) => {
  var _a;
  return (_a = rules[value]) != null ? _a : rules.other;
};
function interpolate(translation, locale, locales) {
  return (values = {}, formats) => {
    const formatters = getDefaultFormats(locale, locales, formats);
    const formatMessage = (tokens) => {
      if (!Array.isArray(tokens))
        return tokens;
      return tokens.reduce((message, token) => {
        if (token === "#") {
          return message + OCTOTHORPE_PH;
        }
        if (isString(token)) {
          return message + token;
        }
        const [name, type, format] = token;
        let interpolatedFormat = {};
        if (type === "plural" || type === "selectordinal" || type === "select") {
          Object.entries(format).forEach(
            ([key, value2]) => {
              interpolatedFormat[key] = formatMessage(value2);
            }
          );
        } else {
          interpolatedFormat = format;
        }
        let value;
        if (type) {
          const formatter = formatters[type];
          value = formatter(values[name], interpolatedFormat);
        } else {
          value = values[name];
        }
        if (value == null) {
          return message;
        }
        return message + value;
      }, "");
    };
    const result = formatMessage(translation);
    if (isString(result) && UNICODE_REGEX.test(result)) {
      return (0, import_unraw.unraw)(result.trim());
    }
    if (isString(result))
      return result.trim();
    return result ? String(result) : "";
  };
}
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var EventEmitter = class {
  constructor() {
    __publicField$1(this, "_events", {});
  }
  on(event, listener) {
    var _a2;
    var _a;
    (_a2 = (_a = this._events)[event]) != null ? _a2 : _a[event] = [];
    this._events[event].push(listener);
    return () => this.removeListener(event, listener);
  }
  removeListener(event, listener) {
    const maybeListeners = this._getListeners(event);
    if (!maybeListeners)
      return;
    const index = maybeListeners.indexOf(listener);
    if (~index)
      maybeListeners.splice(index, 1);
  }
  emit(event, ...args) {
    const maybeListeners = this._getListeners(event);
    if (!maybeListeners)
      return;
    maybeListeners.map((listener) => listener.apply(this, args));
  }
  _getListeners(event) {
    const maybeListeners = this._events[event];
    return Array.isArray(maybeListeners) ? maybeListeners : false;
  }
};
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var I18n = class extends EventEmitter {
  constructor(params) {
    var _a;
    super();
    __publicField2(this, "_locale", "");
    __publicField2(this, "_locales");
    __publicField2(this, "_localeData", {});
    __publicField2(this, "_messages", {});
    __publicField2(this, "_missing");
    __publicField2(this, "t", this._.bind(this));
    if (params.missing != null)
      this._missing = params.missing;
    if (params.messages != null)
      this.load(params.messages);
    if (params.localeData != null)
      this.loadLocaleData(params.localeData);
    if (typeof params.locale === "string" || params.locales) {
      this.activate((_a = params.locale) != null ? _a : defaultLocale, params.locales);
    }
  }
  get locale() {
    return this._locale;
  }
  get locales() {
    return this._locales;
  }
  get messages() {
    var _a;
    return (_a = this._messages[this._locale]) != null ? _a : {};
  }
  /**
   * @deprecated this has no effect. Please remove this from the code. Deprecated in v4
   */
  get localeData() {
    var _a;
    return (_a = this._localeData[this._locale]) != null ? _a : {};
  }
  _loadLocaleData(locale, localeData) {
    const maybeLocaleData = this._localeData[locale];
    if (!maybeLocaleData) {
      this._localeData[locale] = localeData;
    } else {
      Object.assign(maybeLocaleData, localeData);
    }
  }
  /**
   * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4
   */
  // @ts-ignore deprecated, so ignore the reported error
  loadLocaleData(localeOrAllData, localeData) {
    if (localeData != null) {
      this._loadLocaleData(localeOrAllData, localeData);
    } else {
      Object.keys(localeOrAllData).forEach(
        (locale) => this._loadLocaleData(locale, localeOrAllData[locale])
      );
    }
    this.emit("change");
  }
  _load(locale, messages4) {
    const maybeMessages = this._messages[locale];
    if (!maybeMessages) {
      this._messages[locale] = messages4;
    } else {
      Object.assign(maybeMessages, messages4);
    }
  }
  load(localeOrMessages, messages4) {
    if (typeof localeOrMessages == "string" && typeof messages4 === "object") {
      this._load(localeOrMessages, messages4);
    } else {
      Object.entries(localeOrMessages).forEach(
        ([locale, messages22]) => this._load(locale, messages22)
      );
    }
    this.emit("change");
  }
  /**
   * @param options {@link LoadAndActivateOptions}
   */
  loadAndActivate({ locale, locales, messages: messages4 }) {
    this._locale = locale;
    this._locales = locales || void 0;
    this._messages[this._locale] = messages4;
    this.emit("change");
  }
  activate(locale, locales) {
    if (true) {
      if (!this._messages[locale]) {
        console.warn(`Messages for locale "${locale}" not loaded.`);
      }
    }
    this._locale = locale;
    this._locales = locales;
    this.emit("change");
  }
  _(id, values, options) {
    let message = options == null ? void 0 : options.message;
    if (!isString(id)) {
      values = id.values || values;
      message = id.message;
      id = id.id;
    }
    const messageForId = this.messages[id];
    const messageMissing = messageForId === void 0;
    const missing = this._missing;
    if (missing && messageMissing) {
      return isFunction(missing) ? missing(this._locale, id) : missing;
    }
    if (messageMissing) {
      this.emit("missing", { id, locale: this._locale });
    }
    let translation = messageForId || message || id;
    if (true) {
      translation = isString(translation) ? compileMessage(translation) : translation;
    }
    if (isString(translation) && UNICODE_REGEX.test(translation))
      return JSON.parse(`"${translation}"`);
    if (isString(translation))
      return translation;
    return interpolate(
      translation,
      this._locale,
      this._locales
    )(values, options == null ? void 0 : options.formats);
  }
  date(value, format) {
    return date(this._locales || this._locale, value, format);
  }
  number(value, format) {
    return number(this._locales || this._locale, value, format);
  }
};
function setupI18n(params = {}) {
  return new I18n(params);
}
var i18n = setupI18n();

// node_modules/.pnpm/@warp-ds+css@1.10.1/node_modules/@warp-ds/css/component-classes/index.js
var box = {
  box: "group block relative break-words last-child:mb-0 p-16 rounded-8",
  // Relative here enables w-clickable
  bleed: "-mx-16 sm:mx-0 rounded-l-0 rounded-r-0 sm:rounded-8",
  // We target L and R to override the default rounded-8
  info: "s-bg-info-subtle",
  neutral: "s-surface-sunken",
  bordered: "border-2 s-border s-bg",
  infoClickable: "hover:s-bg-info-subtle-hover active:s-bg-info-subtle-active",
  // Deprecated - Remove in v2 (after removing Clickable prop in the Box components)
  neutralClickable: "hover:s-bg-hover active:s-bg-active",
  // Deprecated - Remove in v2 (after removing Clickable prop in the Box components)
  borderedClickable: "hover:s-bg-hover active:s-bg-active hover:s-border-hover active:s-border-active"
  // Deprecated - Remove in v2 (after removing Clickable prop in the Box components)
};
var buttonReset = "focus:outline-none appearance-none cursor-pointer bg-transparent border-0 m-0 p-0 inline-block";
var expandable = {
  expandable: "will-change-height",
  expandableTitle: "font-bold s-text",
  expandableBox: "s-surface-sunken hover:s-bg-hover active:s-bg-active py-0 px-0 " + box.box,
  expandableInfo: "s-bg-info-subtle! hover:s-bg-info-subtle-hover!",
  expandableBleed: box.bleed,
  chevron: "inline-block align-middle s-icon",
  chevronNonBox: "ml-8",
  chevronBox: "",
  chevronTransform: "transform transition-transform transform-gpu ease-in-out",
  chevronExpand: "-rotate-180",
  chevronCollapse: "rotate-180",
  elementsTransformChevronDownPart: "part-[w-icon-chevron-down-16-part]:transform part-[w-icon-chevron-down-16-part]:transition-transform part-[w-icon-chevron-down-16-part]:transform-gpu part-[w-icon-chevron-down-16-part]:ease-in-out",
  elementsChevronDownExpandPart: "part-[w-icon-chevron-down-16-part]:-rotate-180",
  elementsTransformChevronUpPart: "part-[w-icon-chevron-up-16-part]:transform part-[w-icon-chevron-up-16-part]:transition-transform part-[w-icon-chevron-up-16-part]:transform-gpu part-[w-icon-chevron-up-16-part]:ease-in-out",
  elementsChevronUpCollapsePart: "part-[w-icon-chevron-up-16-part]:rotate-180",
  expansion: "overflow-hidden",
  expansionNotExpanded: "h-0 invisible",
  button: buttonReset + " hover:underline focus-visible:underline",
  buttonBox: "w-full text-left relative inline-flex items-center justify-between " + box.box,
  paddingTop: "pt-0",
  title: "flex w-full justify-between items-center",
  titleType: "h4"
};
var buttonDefaultStyling = "font-bold focusable justify-center transition-colors ease-in-out";
var buttonColors = {
  primary: "s-text-inverted bg-[--w-color-button-primary-background] hover:bg-[--w-color-button-primary-background-hover] active:bg-[--w-color-button-primary-background-active]",
  secondary: "s-text-link s-border s-bg hover:s-bg-hover hover:s-border-hover active:s-bg-active",
  utility: "s-text s-bg hover:s-bg-hover active:s-bg-active s-border hover:s-border-hover active:s-border-active",
  destructive: "s-bg-negative s-text-inverted hover:s-bg-negative-hover active:s-bg-negative-active",
  pill: "s-icon hover:s-icon-hover active:s-icon-active bg-transparent hover:bg-[--w-color-button-pill-background-hover] active:bg-[--w-color-button-pill-background-active]",
  disabled: "s-text-inverted s-bg-disabled",
  quiet: "bg-transparent s-text-link hover:s-bg-hover active:s-bg-active",
  utilityQuiet: "s-text bg-transparent hover:s-bg-hover active:s-bg-active",
  negativeQuiet: "bg-transparent s-text-negative hover:s-bg-negative-subtle-hover active:s-bg-negative-subtle-active",
  loading: "s-text s-bg-subtle",
  link: "s-text-link"
};
var buttonTypes = {
  primary: `border-0 rounded-8 ${buttonDefaultStyling}`,
  secondary: `border-2 rounded-8 ${buttonDefaultStyling}`,
  utility: `border rounded-4 ${buttonDefaultStyling}`,
  negative: `border-0 rounded-8 ${buttonDefaultStyling}`,
  pill: `p-4 rounded-full border-0 inline-flex items-center justify-center hover:bg-clip-padding ${buttonDefaultStyling}`,
  link: `bg-transparent focusable ease-in-out inline active:underline hover:underline focus:underline ${buttonColors.link}`
};
var buttonSizes = {
  xsmall: "py-6 px-16",
  small: "py-8 px-16",
  medium: "py-10 px-14",
  large: "py-12 px-16",
  utility: "py-[11px] px-[15px]",
  smallUtility: "py-[7px] px-[15px]",
  pill: "min-h-[44px] min-w-[44px]",
  pillSmall: "min-h-32 min-w-32",
  link: "p-0"
};
var buttonTextSizes = {
  medium: "text-m leading-[24]",
  xsmall: "text-xs"
};
var buttonVariants = {
  inProgress: `border-transparent animate-inprogress pointer-events-none ${buttonColors.loading}`,
  // .button--in-progress, a.button--in-progress:visited
  quiet: `border-0 rounded-8 ${buttonDefaultStyling}`,
  utilityQuiet: `border-0 rounded-4 ${buttonDefaultStyling}`,
  negativeQuiet: `border-0 rounded-8 ${buttonDefaultStyling}`,
  isDisabled: `font-bold justify-center transition-colors ease-in-out cursor-default pointer-events-none ${buttonColors.disabled}`
  // .button:disabled, .button--is-disabled
};
var button = {
  // Buttontypes
  secondary: `${buttonSizes.medium} ${buttonTextSizes.medium} ${buttonTypes.secondary} ${buttonColors.secondary}`,
  // .button--secondary, .button--default, .button
  secondaryHref: `${buttonSizes.medium} ${buttonTextSizes.medium} ${buttonTypes.secondary} ${buttonColors.secondary}`,
  secondaryDisabled: `${buttonSizes.medium} ${buttonTextSizes.medium} ${buttonTypes.secondary} ${buttonVariants.isDisabled}`,
  secondarySmall: `${buttonTextSizes.xsmall} ${buttonSizes.xsmall} ${buttonTypes.secondary} ${buttonColors.secondary}`,
  secondarySmallDisabled: `${buttonTextSizes.xsmall} ${buttonSizes.xsmall} ${buttonTypes.secondary} ${buttonVariants.isDisabled}`,
  secondaryQuiet: `${buttonSizes.medium} ${buttonTextSizes.medium} ${buttonVariants.quiet} ${buttonColors.quiet}`,
  secondaryQuietDisabled: `${buttonSizes.medium} ${buttonTextSizes.medium} ${buttonVariants.quiet} ${buttonVariants.isDisabled}`,
  secondarySmallQuiet: `${buttonTextSizes.xsmall} ${buttonSizes.xsmall} ${buttonVariants.quiet} ${buttonColors.quiet}`,
  secondarySmallQuietDisabled: `${buttonTextSizes.xsmall} ${buttonSizes.xsmall} ${buttonVariants.quiet} ${buttonVariants.isDisabled}`,
  secondaryLoading: `${buttonSizes.medium} ${buttonTextSizes.medium} ${buttonTypes.secondary} ${buttonVariants.inProgress}`,
  secondarySmallLoading: `${buttonTextSizes.xsmall} ${buttonSizes.xsmall}  ${buttonTypes.secondary} ${buttonVariants.inProgress}`,
  secondarySmallQuietLoading: `${buttonTextSizes.xsmall} ${buttonSizes.xsmall} ${buttonVariants.quiet} ${buttonVariants.inProgress}`,
  secondaryQuietLoading: `${buttonSizes.medium} ${buttonTextSizes.medium} ${buttonVariants.quiet} ${buttonVariants.inProgress}`,
  primary: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonTypes.primary} ${buttonColors.primary}`,
  // .button--primary, .button--cta
  primaryDisabled: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.isDisabled} ${buttonTypes.primary}`,
  primarySmall: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonTypes.primary} ${buttonColors.primary}`,
  primarySmallDisabled: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.isDisabled} ${buttonTypes.primary} `,
  primaryQuiet: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.quiet} ${buttonColors.quiet}`,
  primaryQuietDisabled: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.quiet} ${buttonVariants.isDisabled}`,
  primarySmallQuiet: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.quiet} ${buttonColors.quiet}`,
  primarySmallQuietDisabled: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.quiet} ${buttonVariants.isDisabled}`,
  primaryLoading: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.inProgress} ${buttonTypes.primary}`,
  primarySmallLoading: `${buttonSizes.small} ${buttonTextSizes.xsmall}  ${buttonVariants.inProgress} ${buttonTypes.primary}`,
  primarySmallQuietLoading: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.quiet} ${buttonVariants.inProgress} ${buttonTypes.primary}`,
  primaryQuietLoading: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.quiet} ${buttonVariants.inProgress}`,
  utility: `${buttonSizes.utility} ${buttonTextSizes.medium} ${buttonTypes.utility} ${buttonColors.utility}`,
  // .button--utility
  utilityDisabled: `${buttonSizes.utility} ${buttonTextSizes.medium} ${buttonTypes.utility} ${buttonVariants.isDisabled}`,
  utilityQuiet: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.utilityQuiet} ${buttonColors.utilityQuiet}`,
  // .button--utility-flat
  utilityQuietDisabled: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.utilityQuiet} ${buttonVariants.isDisabled}`,
  utilitySmall: `${buttonSizes.smallUtility} ${buttonTextSizes.xsmall} ${buttonTypes.utility} ${buttonColors.utility}`,
  utilitySmallDisabled: `${buttonSizes.smallUtility} ${buttonTextSizes.xsmall} ${buttonTypes.utility} ${buttonVariants.isDisabled}`,
  utilitySmallQuiet: `${buttonSizes.smallUtility} ${buttonTextSizes.xsmall} ${buttonVariants.utilityQuiet} ${buttonColors.utilityQuiet}`,
  utilitySmallQuietDisabled: `${buttonSizes.smallUtility} ${buttonTextSizes.xsmall} ${buttonVariants.utilityQuiet} ${buttonVariants.isDisabled}`,
  utilityLoading: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonTypes.utility} ${buttonVariants.inProgress}`,
  utilitySmallLoading: `${buttonSizes.smallUtility} ${buttonTextSizes.xsmall} ${buttonTypes.utility} ${buttonVariants.inProgress}`,
  utilityQuietLoading: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.inProgress} ${buttonVariants.utilityQuiet}`,
  utilitySmallQuietLoading: `${buttonSizes.smallUtility} ${buttonTextSizes.xsmall} ${buttonVariants.inProgress} ${buttonVariants.utilityQuiet}`,
  negative: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonTypes.negative} ${buttonColors.destructive}`,
  // .button--destructive
  negativeDisabled: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonTypes.negative} ${buttonVariants.isDisabled}`,
  negativeQuiet: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.negativeQuiet} ${buttonColors.negativeQuiet}`,
  // .button--destructive-flat
  negativeQuietDisabled: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.negativeQuiet}${buttonVariants.isDisabled}`,
  negativeSmall: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonTypes.negative} ${buttonColors.destructive}`,
  negativeSmallDisabled: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonTypes.negative} ${buttonVariants.isDisabled}`,
  negativeSmallQuiet: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.negativeQuiet} ${buttonColors.negativeQuiet}`,
  negativeSmallQuietDisabled: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.negativeQuiet} ${buttonVariants.isDisabled}`,
  negativeLoading: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonTypes.negative} ${buttonVariants.inProgress}`,
  negativeSmallLoading: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.inProgress} ${buttonTypes.negative}`,
  negativeQuietLoading: `${buttonSizes.large} ${buttonTextSizes.medium} ${buttonVariants.negativeQuiet} ${buttonTypes.negative} ${buttonVariants.inProgress}`,
  negativeSmallQuietLoading: `${buttonSizes.small} ${buttonTextSizes.xsmall} ${buttonVariants.negativeQuiet} ${buttonVariants.inProgress}`,
  pill: `${buttonSizes.pill} ${buttonTextSizes.medium} ${buttonTypes.pill} ${buttonColors.pill}`,
  // .button--pill
  pillSmall: `${buttonSizes.pillSmall} ${buttonTextSizes.xsmall} ${buttonTypes.pill} ${buttonColors.pill}`,
  pillLoading: `${buttonSizes.pill} ${buttonTextSizes.medium} ${buttonTypes.pill} ${buttonVariants.inProgress}`,
  pillSmallLoading: `${buttonSizes.pillSmall} ${buttonTextSizes.xsmall} ${buttonTypes.pill} ${buttonVariants.inProgress}`,
  link: `${buttonSizes.link} ${buttonTextSizes.medium} ${buttonTypes.link}`,
  linkSmall: `${buttonSizes.link} ${buttonTextSizes.xsmall} ${buttonTypes.link}`,
  linkAsButton: "inline-block active:no-underline hover:no-underline focus:no-underline text-center",
  a11y: "sr-only",
  fullWidth: "w-full max-w-full",
  contentWidth: "max-w-max"
};
var modal = {
  transparentBg: "",
  //TODO: Remove in v2 - previously used for opacity before changing to a rgba background in backdrop
  backdrop: "fixed inset-0 flex sm:place-content-center sm:place-items-center items-end z-30 [--w-modal-max-height:80%] [--w-modal-width:640px] bg-[--w-black/25]",
  modal: "pb-safe-[32] shadow-m max-h-[--w-modal-max-height] min-h-[--w-modal-min-height] w-[--w-modal-width] h-[--w-modal-height] relative transition-300 ease-in-out backface-hidden will-change-height rounded-8 mx-0 sm:mx-16 bg-[--w-s-color-surface-elevated-100] flex flex-col overflow-hidden outline-none space-y-16 pt-8 sm:pt-32 sm:pb-32 rounded-b-0 sm:rounded-b-8",
  content: "block overflow-y-auto overflow-x-hidden last-child:mb-0 grow shrink px-16 sm:px-32 relative",
  footer: "flex justify-end shrink-0 px-16 sm:px-32",
  transitionTitle: "transition-all duration-300",
  transitionTitleCenter: "justify-self-center self-center",
  transitionTitleColSpan: "col-span-2",
  title: "py-8 sm:py-0 -mt-4 sm:-mt-8 min-h-40 sm:min-h-48 grid gap-8 sm:gap-16 grid-cols-[auto_1fr_auto] items-start px-16 sm:px-32 border-b sm:border-b-0 shrink-0",
  titleText: "mb-0 h4 sm:h3",
  titleButton: `${buttonTextSizes.medium} ${buttonTypes.pill} ${buttonColors.pill} sm:min-h-[44px] sm:min-w-[44px] min-h-[32px] min-w-[32px]`,
  titleButtonLeft: "-ml-8 sm:-ml-12 justify-self-start",
  titleButtonRight: "-mr-8 sm:-mr-12 justify-self-end",
  titleButtonIcon: "h-16 w-16 sm:h-24 sm:w-24",
  titleButtonIconRotated: "transform rotate-90"
};
var label = {
  label: "antialiased block relative text-s font-bold pb-4 cursor-pointer s-text",
  optional: "pl-8 font-normal text-s s-text-subtle",
  labelInvalid: "s-text-negative"
  // TODO: Remove in v2 - kept for backwards compatibility
};
var prefixSuffixWrapperBase = "absolute top-0 bottom-0 flex justify-center items-center focusable rounded-4 focus:[--w-outline-offset:-2px] bg-transparent ";
var suffix = {
  wrapper: prefixSuffixWrapperBase + "right-0",
  wrapperWithLabel: "w-max pr-12",
  wrapperWithIcon: "w-40",
  label: "antialiased block relative cursor-default pb-0 font-bold text-xs s-text"
};
var prefix = {
  wrapper: prefixSuffixWrapperBase + "left-0",
  wrapperWithLabel: "w-max pl-12",
  wrapperWithIcon: "w-40",
  label: "antialiased block relative cursor-default pb-0 font-bold text-xs s-text"
};
var toggle = {
  // wrapper classes
  field: "relative text-m",
  // true
  wrapper: "relative py-1",
  // true
  wrapperRadioButtons: "inline-flex font-bold rounded-8 focus-within:focusable",
  // isRadioButton && !isEqualWidth
  wrapperRadioButtonsJustified: "flex font-bold rounded-8 focus-within:focusable",
  // isRadioButton && isEqualWidth,
  // group classes
  radioButtonsGroup: "group",
  // isRadioButton
  radioButtonsGroupJustified: "grow-1 shrink-0 basis-auto",
  // isRadioButton && isEqualWidth
  // input classes
  input: "peer",
  a11y: "sr-only",
  // label classes
  label: "peer-focus:focusable cursor-pointer text-m s-text s-border py-2 pl-28 select-none relative block before:border before:absolute before:transition-all before:left-0 before:w-20 before:h-20 before:top-2",
  // !isRadioButton
  labelBefore: 'before:content-[""] before:block',
  // !isRadioButton && !isIndeterminate
  checkbox: "before:s-bg before:rounded-2 hover:before:s-border-primary hover:before:s-bg-hover peer-checked:before:bg-center peer-checked:before:bg-[url(var(--w-form-check-mark))] peer-checked:before:s-border-primary peer-checked:before:s-bg-primary peer-checked:peer-hover:before:s-border-primary-hover peer-checked:peer-hover:before:s-bg-primary-hover",
  // isCheckbox && !isIndeterminate && !isInvalid && !isDisabled
  checkboxInvalid: "before:s-bg before:s-border-negative before:rounded-2 hover:before:s-bg-negative-subtle-hover hover:before:s-border-negative-hover peer-checked:before:bg-center peer-checked:before:bg-[url(var(--w-form-check-mark))] peer-checked:before:s-bg-negative peer-checked:before:s-border-negative peer-checked:peer-hover:before:s-bg-negative-hover peer-checked:peer-hover:before:s-border-negative-hover",
  // isCheckbox && !isIndeterminate && isInvalid && !isDisabled
  checkboxDisabled: "before:s-bg-disabled-subtle before:s-border-disabled pointer-events-none before:rounded-2 peer-checked:before:bg-center peer-checked:before:bg-[url(var(--w-form-check-mark))] peer-checked:before:s-border-disabled peer-checked:before:s-bg-disabled",
  // isCheckbox && !isIndeterminate && !isInvalid && isDisabled
  indeterminate: 'before:content-["\u2013"] before:rounded-2 before:leading-xs before:text-center before:font-bold before:s-icon-inverted peer-indeterminate:before:s-border-primary peer-indeterminate:before:s-bg-primary peer-indeterminate:hover:before:s-border-primary-hover peer-indeterminate:hover:before:s-bg-primary-hover',
  // isCheckbox && isIndeterminate && !isInvalid && !isDisabled
  indeterminateInvalid: 'before:content-["\u2013"] before:rounded-2 before:leading-xs before:text-center before:font-bold before:s-icon-inverted peer-indeterminate:before:s-border-negative peer-indeterminate:before:s-bg-negative peer-indeterminate:hover:before:s-border-negative-hover peer-indeterminate:hover:before:s-bg-negative-hover',
  // isCheckbox && isIndeterminate && isInvalid && !isDisabled
  indeterminateDisabled: 'before:content-["\u2013"] before:rounded-2 before:leading-xs before:text-center before:font-bold pointer-events-none before:s-icon-inverted peer-indeterminate:before:s-border-disabled peer-indeterminate:before:s-bg-disabled',
  // isCheckbox && isIndeterminate && !isInvalid && isDisabled
  radio: "before:s-bg before:rounded-full peer-checked:before:border-[6] peer-checked:before:s-border-selected peer-checked:peer-hover:before:s-border-selected-hover peer-hover:before:s-border-primary peer-hover:before:s-bg-hover",
  // isRadio && !isDisabled && !isInvalid
  radioInvalid: "before:s-bg before:s-border-negative before:rounded-full peer-checked:before:border-[6] peer-hover:before:s-bg-negative-subtle peer-hover:before:s-border-negative-hover peer-checked:before:s-border-negative peer-checked:peer-hover:before:s-border-negative-hover",
  // isRadio && isInvalid && !isDisabled
  radioDisabled: "before:s-bg-disabled-subtle before:s-border-disabled pointer-events-none before:rounded-full peer-checked:before:border-[6]",
  // isRadio && !isInvalid && isDisabled
  radioButtonsLabel: "peer-hover:peer-not-checked:s-bg-hover peer-checked:s-text-inverted peer-checked:s-bg-primary peer-checked:s-border-primary block relative font-bold cursor-pointer s-text-link text-center s-bg border-2 s-border group-first-of-type:rounded-tl-8 group-first-of-type:rounded-bl-8 group-last-of-type:rounded-tr-8 group-last-of-type:rounded-br-8 group-not-last-of-type:border-r-0 peer-checked:z-10 group-not-first:-ml-2",
  // isRadioButtons
  radioButtonsRegular: "text-s py-8 pl-12 pr-14",
  // isRadioButtons && !isSmall
  radioButtonsSmall: "text-xs py-[5px] px-[8px]"
  // isRadioButtons && isSmall
};
var deadToggle = {
  wrapper: `${toggle.wrapper} h-20 w-20 pointer-events-none`,
  input: `${toggle.input} hidden`,
  inputVue: "hidden",
  labelRadio: `${toggle.label} ${toggle.labelBefore} ${toggle.radio}`,
  labelCheckbox: `${toggle.label} ${toggle.labelBefore} ${toggle.checkbox}`,
  labelVue: "-mt-2"
};
var clickable = {
  toggle: "absolute inset-0 h-full w-full appearance-none cursor-pointer focusable focusable-inset",
  label: `px-12 ${label.label} py-8! cursor-pointer focusable focusable-inset`,
  buttonOrLink: "bg-transparent focusable",
  buttonOrLinkStretch: "inset-0 absolute"
};
var attention = {
  base: "border-2 relative flex items-start",
  tooltip: "s-bg-inverted border-[--w-s-color-background-inverted] shadow-m s-text-inverted-static rounded-4 py-6 px-8",
  callout: "bg-[--w-color-callout-background] border-[--w-color-callout-border] s-text py-8 px-16 rounded-8",
  highlight: "bg-[--w-color-callout-background] border-[--w-color-callout-border] s-text py-8 px-16 rounded-8 drop-shadow-m translate-z-0",
  popover: "bg-[--w-s-color-surface-elevated-300] border-[--w-s-color-surface-elevated-300] s-text rounded-8 p-16 drop-shadow-m translate-z-0",
  arrowBase: "absolute h-[14px] w-[14px] border-2 border-b-0 border-r-0 rounded-tl-4 transform",
  arrowDirectionLeftStart: "-left-[8px]",
  arrowDirectionLeft: "-left-[8px]",
  arrowDirectionLeftEnd: "-left-[8px]",
  arrowDirectionRightStart: "-right-[8px]",
  arrowDirectionRight: "-right-[8px]",
  arrowDirectionRightEnd: "-right-[8px]",
  arrowDirectionBottomStart: "-bottom-[8px]",
  arrowDirectionBottom: "-bottom-[8px]",
  arrowDirectionBottomEnd: "-bottom-[8px]",
  arrowDirectionTopStart: "-top-[8px]",
  arrowDirectionTop: "-top-[8px]",
  arrowDirectionTopEnd: "-top-[8px]",
  arrowTooltip: "s-bg-inverted border-[--w-s-color-background-inverted]",
  arrowCallout: "bg-[--w-color-callout-background] border-[--w-color-callout-border]",
  arrowPopover: "bg-[--w-s-color-surface-elevated-300] border-[--w-s-color-surface-elevated-300]",
  arrowHighlight: "bg-[--w-color-callout-background] border-[--w-color-callout-border]",
  content: "last-child:mb-0",
  notCallout: "absolute z-50",
  closeBtn: `${buttonTextSizes.medium} ${buttonTypes.pill} ${buttonColors.pill} justify-self-end -mr-8 ml-8`
};

// packages/button/index.js
import WarpElement from "https://assets.finn.no/pkg/@warp-ds/elements-core/v0/element.js";

// packages/i18n.ts
var supportedLocales = ["en", "nb", "fi"];
var defaultLocale2 = "en";
var getSupportedLocale = (usedLocale) => {
  return supportedLocales.find(
    (locale) => usedLocale === locale || usedLocale.toLowerCase().includes(locale)
  ) || defaultLocale2;
};
function detectLocale() {
  if (typeof window === "undefined") {
    const serverLocale = process.env.NMP_LANGUAGE || Intl.DateTimeFormat().resolvedOptions().locale;
    return getSupportedLocale(serverLocale);
  }
  try {
    const htmlLocale = document.documentElement.lang;
    return getSupportedLocale(htmlLocale);
  } catch (e) {
    console.warn("could not detect locale, falling back to source locale", e);
    return defaultLocale2;
  }
}
var getMessages = (locale, enMsg, nbMsg, fiMsg) => {
  if (locale === "nb")
    return nbMsg;
  if (locale === "fi")
    return fiMsg;
  return enMsg;
};
var activateI18n = (enMessages, nbMessages, fiMessages) => {
  const locale = detectLocale();
  const messages4 = getMessages(locale, enMessages, nbMessages, fiMessages);
  i18n.load(locale, messages4);
  i18n.activate(locale);
};

// packages/utils/index.js
import { classMap } from "https://assets.finn.no/npm/lit-2/v2/lit.min.js";
var camelCaseToKebabCase = (str) => str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
function kebabCaseAttributes(constructor) {
  return class extends constructor {
    static createProperty(name, options) {
      let customOptions = options;
      if (typeof (options == null ? void 0 : options.attribute) === "undefined" || (options == null ? void 0 : options.attribute) === true) {
        customOptions = Object.assign({}, options, {
          attribute: camelCaseToKebabCase(name.toString())
        });
      }
      super.createProperty(name, customOptions);
    }
  };
}

// packages/button/locales/en/messages.mjs
var messages = JSON.parse('{"button.aria.loading":"Loading..."}');

// packages/button/locales/fi/messages.mjs
var messages2 = JSON.parse('{"button.aria.loading":"Ladataan..."}');

// packages/button/locales/nb/messages.mjs
var messages3 = JSON.parse('{"button.aria.loading":"Laster..."}');

// packages/button/index.js
var buttonTypes2 = ["primary", "secondary", "negative", "utility", "pill", "link"];
var WarpButton = class extends kebabCaseAttributes(WarpElement) {
  constructor() {
    super();
    activateI18n(messages, messages3, messages2);
    this.variant = "secondary";
    this.ariaValueTextLoading = i18n._({
      id: "button.aria.loading",
      message: "Loading...",
      comment: "Screenreader message for buttons that are loading"
    });
  }
  connectedCallback() {
    super.connectedCallback();
    if (!buttonTypes2.includes(this.variant)) {
      throw new Error(`Invalid "variant" attribute. Set its value to one of the following:
${buttonTypes2.join(", ")}.`);
    }
  }
  firstUpdated() {
    if (this.autofocus) {
      setTimeout(() => this.focus(), 0);
    }
  }
  get _classes() {
    const primary = this.variant === "primary";
    const secondary = this.variant === "secondary";
    const negative = this.variant === "negative";
    const utility = this.variant === "utility";
    const pill = this.variant === "pill";
    const link = this.variant === "link";
    return r(
      {
        [button.secondary]: secondary && !this.small && !this.quiet && !this.loading,
        [button.secondarySmall]: secondary && this.small && !this.quiet && !this.loading,
        [button.secondarySmallLoading]: secondary && this.small && !this.quiet && this.loading,
        [button.secondarySmallQuiet]: secondary && this.small && this.quiet && !this.loading,
        [button.secondarySmallQuietLoading]: secondary && this.small && this.quiet && this.loading,
        [button.secondaryQuiet]: secondary && !this.small && this.quiet && !this.loading,
        [button.secondaryQuietLoading]: secondary && !this.small && this.quiet && this.loading,
        [button.secondaryLoading]: secondary && !this.small && !this.quiet && this.loading,
        [button.primary]: primary && !this.small && !this.quiet && !this.loading,
        [button.primarySmall]: primary && this.small && !this.quiet && !this.loading,
        [button.primarySmallQuiet]: primary && this.small && this.quiet && !this.loading,
        [button.primarySmallLoading]: primary && this.small && !this.quiet && this.loading,
        [button.primarySmallQuietLoading]: primary && this.small && this.quiet && this.loading,
        [button.primaryQuiet]: primary && !this.small && this.quiet && !this.loading,
        [button.primaryQuietLoading]: primary && !this.small && this.quiet && this.loading,
        [button.primaryLoading]: primary && !this.small && !this.quiet && this.loading,
        [button.utility]: utility && !this.small && !this.quiet && !this.loading,
        [button.utilitySmall]: utility && this.small && !this.quiet && !this.loading,
        [button.utilitySmallQuiet]: utility && this.small && this.quiet && !this.loading,
        [button.utilitySmallLoading]: utility && this.small && !this.quiet && this.loading,
        [button.utilitySmallQuietLoading]: utility && this.small && this.quiet && this.loading,
        [button.utilityQuiet]: utility && !this.small && this.quiet && !this.loading,
        [button.utilityQuietLoading]: utility && !this.small && this.quiet && this.loading,
        [button.utilityLoading]: utility && !this.small && !this.quiet && this.loading,
        [button.negative]: negative && !this.small && !this.quiet && !this.loading,
        [button.negativeSmall]: negative && this.small && !this.quiet && !this.loading,
        [button.negativeSmallQuiet]: negative && this.small && this.quiet && !this.loading,
        [button.negativeSmallLoading]: negative && this.small && !this.quiet && this.loading,
        [button.negativeSmallQuietLoading]: negative && this.small && this.quiet && this.loading,
        [button.negativeQuiet]: negative && !this.small && this.quiet && !this.loading,
        [button.negativeQuietLoading]: negative && !this.small && this.quiet && this.loading,
        [button.negativeLoading]: negative && !this.small && !this.quiet && this.loading,
        [button.pill]: pill && !this.small && !this.loading,
        [button.pillSmall]: pill && this.small && !this.loading,
        [button.pillLoading]: pill && !this.small && this.loading,
        [button.pillSmallLoading]: pill && this.small && this.loading,
        [button.link]: link && !this.small,
        [button.linkSmall]: link && this.small,
        [button.linkAsButton]: !!this.href,
        [button.fullWidth]: this.fullWidth,
        [button.contentWidth]: !this.fullWidth
      },
      this.buttonClass
    );
  }
  render() {
    return html` ${this.href ? html`<a
          href=${this.href}
          target=${this.target}
          rel=${this.target === "_blank" ? this.rel || "noopener" : void 0}
          class=${this._classes}>
          <slot></slot>
        </a>` : html`<button type=${this.type || "button"} class=${this._classes}>
          <slot></slot>
        </button>`}
    ${this.loading ? html`<span class="sr-only" role="progressbar" aria-valuenow="{0}" aria-valuetext=${this.ariaValueTextLoading}></span>` : null}`;
  }
};
__publicField(WarpButton, "shadowRootOptions", __spreadProps(__spreadValues({}, WarpElement.shadowRootOptions), {
  delegatesFocus: true
}));
__publicField(WarpButton, "properties", {
  type: { type: "button" | "submit" | "reset", reflect: true },
  autofocus: { type: Boolean, reflect: true },
  variant: { type: String, reflect: true },
  quiet: { type: Boolean, reflect: true },
  small: { type: Boolean, reflect: true },
  loading: { type: Boolean, reflect: true },
  href: { type: String, reflect: true },
  target: { type: String, reflect: true },
  rel: { type: String, reflect: true },
  fullWidth: { type: Boolean, reflect: true },
  buttonClass: { type: String, reflect: true }
});
__publicField(WarpButton, "styles", [WarpElement.styles]);
if (!customElements.get("w-button")) {
  customElements.define("w-button", WarpButton);
}
export {
  WarpButton
};
//# sourceMappingURL=index.js.map

</script>

</body>
</html>
