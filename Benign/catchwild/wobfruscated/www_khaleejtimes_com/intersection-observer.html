<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>intersection-observer.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __aB = 'AGFzbQEAAAABiYCAgAACYAAAYAJ/fwADg4CAgAACAQAFg4CAgAABAAEGhoCAgAABfwFBAAsHkYCAgAACBm1lbW9yeQIABGFycjAAAQqogICAAAKPgICAAAAjACAAQQRsaiABNgIAC46AgIAAAQF/QRAkAEEAQQAQAAs=', __wAM = new WebAssembly.Instance(new WebAssembly.Module((() => {
        try {
            let binary_string = atob(__aB), len = binary_string.length, bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes;
        } catch (err) {
            return new Uint8Array(global.Buffer.from(__aB, 'base64'));
        }
    })()));
const ac = new Map();
const __lA = (pos, stIdx, eIdx) => {
    if (ac.has(pos)) {
        return ac.get(pos);
    } else {
        const sK = `arr${ pos }`;
        __wAM.exports[sK]();
        let mem = new Uint32Array(__wAM.exports.memory.buffer, stIdx, (eIdx - stIdx) / 4 + 1);
        const rA = Array.from(mem);
        ac.set(pos, rA);
        return rA;
    }
};
const __ifWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAF/AAKfgICAAAIDZW52CGltcEZ1bmMxAAADZW52CGltcEZ1bmMyAAADgoCAgAABAQSEgICAAAFwAAAFg4CAgAABAAEHkYCAgAACBm1lbW9yeQIABGRhdGEAAgqSgICAAAGMgICAAAAgAARAEAAFEAELCw==';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEGt4GAgAAffwBBAQt/AEEQC38AQRgLfwBBLgt/AEHKAAt/AEHeAAt/AEHuAAt/AEH+AAt/AEGiAQt/AEGqAQt/AEH0AQt/AEH6AQt/AEG8Agt/AEHEAgt/AEHMAgt/AEHeAgt/AEHmAgt/AEHuAgt/AEH0Agt/AEH6Agt/AEGEAwt/AEGIAwt/AEGSAwt/AEG4Awt/AEHaAwt/AEHgAwt/AEHqAwt/AEH0Awt/AEH4Awt/AEGCBAt/AEGMBAsHl4KAgAAgBm1lbW9yeQIABWRhdGEwAwAFZGF0YTEDAQVkYXRhMgMCBWRhdGEzAwMFZGF0YTQDBAVkYXRhNQMFBWRhdGE2AwYFZGF0YTcDBwVkYXRhOAMIBWRhdGE5AwkGZGF0YTEwAwoGZGF0YTExAwsGZGF0YTEyAwwGZGF0YTEzAw0GZGF0YTE0Aw4GZGF0YTE1Aw8GZGF0YTE2AxAGZGF0YTE3AxEGZGF0YTE4AxIGZGF0YTE5AxMGZGF0YTIwAxQGZGF0YTIxAxUGZGF0YTIyAxYGZGF0YTIzAxcGZGF0YTI0AxgGZGF0YTI1AxkGZGF0YTI2AxoGZGF0YTI3AxsGZGF0YTI4AxwGZGF0YTI5Ax0GZGF0YTMwAx4LnYWAgAAfAEEBCw11c2UlMjBzdHJpY3QAAEEQCwdvYmplY3QAAEEYCxVJbnRlcnNlY3Rpb25PYnNlcnZlcgAAQS4LGkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkAAEHKAAsSaW50ZXJzZWN0aW9uUmF0aW8AAEHeAAsPaXNJbnRlcnNlY3RpbmcAAEHuAAsPaXNJbnRlcnNlY3RpbmcAAEH+AAsidGFyZ2V0JTIwbXVzdCUyMGJlJTIwYW4lMjBFbGVtZW50AABBogELB251bWJlcgAAQaoBC0l0aHJlc2hvbGQlMjBtdXN0JTIwYmUlMjBhJTIwbnVtYmVyJTIwYmV0d2VlbiUyMDAlMjBhbmQlMjAxJTIwaW5jbHVzaXZlbHkAAEH0AQsEMHB4AABB+gELQHJvb3RNYXJnaW4lMjBtdXN0JTIwYmUlMjBzcGVjaWZpZWQlMjBpbiUyMHBpeGVscyUyMG9yJTIwcGVyY2VudAAAQbwCCwdyZXNpemUAAEHEAgsHc2Nyb2xsAABBzAILEU11dGF0aW9uT2JzZXJ2ZXIAAEHeAgsHcmVzaXplAABB5gILB3Njcm9sbAAAQe4CCwVub25lAABB9AILBW5vbmUAAEH6AgsIdmlzaWJsZQAAQYQDCwNweAAAQYgDCwlmdW5jdGlvbgAAQZIDCyRjYWxsYmFjayUyMG11c3QlMjBiZSUyMGElMjBmdW5jdGlvbgAAQbgDCyByb290JTIwbXVzdCUyMGJlJTIwYW4lMjBFbGVtZW50AABB2gMLBCUyMAAAQeADCwlmdW5jdGlvbgAAQeoDCwlmdW5jdGlvbgAAQfQDCwNvbgAAQfgDCwlmdW5jdGlvbgAAQYIECwlmdW5jdGlvbgAAQYwECwNvbgA='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
!function () {
    lS(0, 0);
    if (lS(0, 1) == typeof window)
        if (lS(0, 2) in window && lS(0, 3) in window && lS(0, 4) in window.IntersectionObserverEntry.prototype)
            lS(0, 5) in window.IntersectionObserverEntry.prototype || Object.defineProperty(window.IntersectionObserverEntry.prototype, lS(0, 6), {
                get: function () {
                    return this.intersectionRatio > 0;
                }
            });
        else {
            var t = window.document, e = [];
            o.prototype.THROTTLE_TIMEOUT = 100, o.prototype.POLL_INTERVAL = null, o.prototype.USE_MUTATION_OBSERVER = !0, o.prototype.observe = function (t) {
                if (!this._observationTargets.some(function (e) {
                        return e.element == t;
                    })) {
                    if (!t || 1 != t.nodeType)
                        throw new Error(lS(0, 7));
                    this._registerInstance(), this._observationTargets.push({
                        element: t,
                        entry: null
                    }), this._monitorIntersections(), this._checkForIntersections();
                }
            }, o.prototype.unobserve = function (t) {
                this._observationTargets = this._observationTargets.filter(function (e) {
                    return e.element != t;
                }), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance());
            }, o.prototype.disconnect = function () {
                this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance();
            }, o.prototype.takeRecords = function () {
                var t = this._queuedEntries.slice();
                return this._queuedEntries = [], t;
            }, o.prototype._initThresholds = function (t) {
                var e = t || __lA(0, 16, 20);
                return Array.isArray(e) || (e = [e]), e.sort().filter(function (t, e, n) {
                    if (lS(0, 8) != typeof t || isNaN(t) || t < 0 || t > 1)
                        throw new Error(lS(0, 9));
                    return t !== n[e - 1];
                });
            }, o.prototype._parseRootMargin = function (t) {
                var e = (t || lS(0, 10)).split(/\s+/).map(function (t) {
                    var e = /^(-?\d*\.?\d+)(px|%)$/.exec(t);
                    if (!e)
                        throw new Error(lS(0, 11));
                    return {
                        value: parseFloat(e[1]),
                        unit: e[2]
                    };
                });
                return e[1] = e[1] || e[0], e[2] = e[2] || e[0], e[3] = e[3] || e[1], e;
            }, o.prototype._monitorIntersections = function () {
                this._monitoringIntersections || (this._monitoringIntersections = !0, this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (i(window, lS(0, 12), this._checkForIntersections, !0), i(t, lS(0, 13), this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && lS(0, 14) in window && (this._domObserver = new MutationObserver(this._checkForIntersections), this._domObserver.observe(t, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                }))));
            }, o.prototype._unmonitorIntersections = function () {
                this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), this._monitoringInterval = null, r(window, lS(0, 15), this._checkForIntersections, !0), r(t, lS(0, 16), this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), this._domObserver = null));
            }, o.prototype._checkForIntersections = function () {
                var t = this._rootIsInDom(), e = t ? this._getRootRect() : {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0,
                        width: 0,
                        height: 0
                    };
                this._observationTargets.forEach(function (o) {
                    var i = o.element, r = s(i), h = this._rootContainsTarget(i), c = o.entry, a = t && h && this._computeTargetAndRootIntersection(i, e), u = o.entry = new n({
                            time: window.performance && performance.now && performance.now(),
                            target: i,
                            boundingClientRect: r,
                            rootBounds: e,
                            intersectionRect: a
                        });
                    c ? t && h ? this._hasCrossedThreshold(c, u) && this._queuedEntries.push(u) : c && c.isIntersecting && this._queuedEntries.push(u) : this._queuedEntries.push(u);
                }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this);
            }, o.prototype._computeTargetAndRootIntersection = function (e, n) {
                if (lS(0, 17) != window.getComputedStyle(e).display) {
                    for (var o, i, r, h, a, u, d, l, p = s(e), f = c(e), g = !1; !g;) {
                        var _ = null, v = 1 == f.nodeType ? window.getComputedStyle(f) : {};
                        if (lS(0, 18) == v.display)
                            return;
                        if (f == this.root || f == t ? (g = !0, _ = n) : f != t.body && f != t.documentElement && lS(0, 19) != v.overflow && (_ = s(f)), _ && (o = _, i = p, r = void 0, h = void 0, a = void 0, u = void 0, d = void 0, l = void 0, r = Math.max(o.top, i.top), h = Math.min(o.bottom, i.bottom), a = Math.max(o.left, i.left), u = Math.min(o.right, i.right), l = h - r, !(p = (d = u - a) >= 0 && l >= 0 && {
                                top: r,
                                bottom: h,
                                left: a,
                                right: u,
                                width: d,
                                height: l
                            })))
                            break;
                        f = c(f);
                    }
                    return p;
                }
            }, o.prototype._getRootRect = function () {
                var e;
                (() => {
                    const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                        env: {
                            impFunc1: () => {
                                e = s(this.root);
                            },
                            impFunc2: () => {
                                {
                                    var n = t.documentElement, o = t.body;
                                    e = {
                                        top: 0,
                                        left: 0,
                                        right: n.clientWidth || o.clientWidth,
                                        width: n.clientWidth || o.clientWidth,
                                        bottom: n.clientHeight || o.clientHeight,
                                        height: n.clientHeight || o.clientHeight
                                    };
                                }
                            }
                        }
                    });
                    const __exports = __ifInstance0.exports;
                    return __exports.data(this.root ? 1 : 0);
                })();
                return this._expandRectByRootMargin(e);
            }, o.prototype._expandRectByRootMargin = function (t) {
                var e = this._rootMarginValues.map(function (e, n) {
                        return lS(0, 20) == e.unit ? e.value : e.value * (n % 2 ? t.width : t.height) / 100;
                    }), n = {
                        top: t.top - e[0],
                        right: t.right + e[1],
                        bottom: t.bottom + e[2],
                        left: t.left - e[3]
                    };
                return n.width = n.right - n.left, n.height = n.bottom - n.top, n;
            }, o.prototype._hasCrossedThreshold = function (t, e) {
                var n = t && t.isIntersecting ? t.intersectionRatio || 0 : -1, o = e.isIntersecting ? e.intersectionRatio || 0 : -1;
                if (n !== o)
                    for (var i = 0; i < this.thresholds.length; i++) {
                        var r = this.thresholds[i];
                        if (r == n || r == o || r < n != r < o)
                            return !0;
                    }
            }, o.prototype._rootIsInDom = function () {
                return !this.root || h(t, this.root);
            }, o.prototype._rootContainsTarget = function (e) {
                return h(this.root || t, e);
            }, o.prototype._registerInstance = function () {
                e.indexOf(this) < 0 && e.push(this);
            }, o.prototype._unregisterInstance = function () {
                var t = e.indexOf(this);
                -1 != t && e.splice(t, 1);
            }, window.IntersectionObserver = o, window.IntersectionObserverEntry = n;
        }
    function n(t) {
        this.time = t.time, this.target = t.target, this.rootBounds = t.rootBounds, this.boundingClientRect = t.boundingClientRect, this.intersectionRect = t.intersectionRect || {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        }, this.isIntersecting = !!t.intersectionRect;
        var e = this.boundingClientRect, n = e.width * e.height, o = this.intersectionRect, i = o.width * o.height;
        this.intersectionRatio = n ? Number((i / n).toFixed(4)) : this.isIntersecting ? 1 : 0;
    }
    function o(t, e) {
        var n, o, i, r = e || {};
        if (lS(0, 21) != typeof t)
            throw new Error(lS(0, 22));
        if (r.root && 1 != r.root.nodeType)
            throw new Error(lS(0, 23));
        this._checkForIntersections = (n = this._checkForIntersections.bind(this), o = this.THROTTLE_TIMEOUT, i = null, function () {
            i || (i = setTimeout(function () {
                n(), i = null;
            }, o));
        }), this._callback = t, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(r.rootMargin), this.thresholds = this._initThresholds(r.threshold), this.root = r.root || null, this.rootMargin = this._rootMarginValues.map(function (t) {
            return t.value + t.unit;
        }).join(lS(0, 24));
    }
    function i(t, e, n, o) {
        lS(0, 25) == typeof t.addEventListener ? t.addEventListener(e, n, o || !1) : lS(0, 26) == typeof t.attachEvent && t.attachEvent(lS(0, 27) + e, n);
    }
    function r(t, e, n, o) {
        lS(0, 28) == typeof t.removeEventListener ? t.removeEventListener(e, n, o || !1) : lS(0, 29) == typeof t.detatchEvent && t.detatchEvent(lS(0, 30) + e, n);
    }
    function s(t) {
        var e;
        try {
            e = t.getBoundingClientRect();
        } catch (t) {
        }
        return e ? (e.width && e.height || (e = {
            top: e.top,
            right: e.right,
            bottom: e.bottom,
            left: e.left,
            width: e.right - e.left,
            height: e.bottom - e.top
        }), e) : {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        };
    }
    function h(t, e) {
        for (var n = e; n;) {
            if (n == t)
                return !0;
            n = c(n);
        }
        return !1;
    }
    function c(t) {
        var e = t.parentNode;
        return e && 11 == e.nodeType && e.host ? e.host : e && e.assignedSlot ? e.assignedSlot.parentNode : e;
    }
}();</script>
</body>
</html>
