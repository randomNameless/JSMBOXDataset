<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>main.html</title>
</head>
<body>

<script>
(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line es-x/no-global-this -- safe
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  // eslint-disable-next-line no-restricted-globals -- safe
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func -- fallback
	  (function () { return this; })() || Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Detect IE8's incomplete defineProperty implementation
	var descriptors = !fails(function () {
	  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var functionBindNative = !fails(function () {
	  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
	  var test = (function () { /* empty */ }).bind();
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return typeof test != 'function' || test.hasOwnProperty('prototype');
	});

	var call$2 = Function.prototype.call;

	var functionCall = functionBindNative ? call$2.bind(call$2) : function () {
	  return call$2.apply(call$2, arguments);
	};

	var $propertyIsEnumerable$2 = {}.propertyIsEnumerable;
	// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
	var getOwnPropertyDescriptor$9 = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor$9 && !$propertyIsEnumerable$2.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
	var f$8 = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$9(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable$2;

	var objectPropertyIsEnumerable = {
		f: f$8
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var FunctionPrototype$4 = Function.prototype;
	var bind$2 = FunctionPrototype$4.bind;
	var call$1 = FunctionPrototype$4.call;
	var uncurryThis = functionBindNative && bind$2.bind(call$1, call$1);

	var functionUncurryThis = functionBindNative ? function (fn) {
	  return fn && uncurryThis(fn);
	} : function (fn) {
	  return fn && function () {
	    return call$1.apply(fn, arguments);
	  };
	};

	var toString$3 = functionUncurryThis({}.toString);
	var stringSlice$h = functionUncurryThis(''.slice);

	var classofRaw = function (it) {
	  return stringSlice$h(toString$3(it), 8, -1);
	};

	var Object$8 = global_1.Object;
	var split$3 = functionUncurryThis(''.split);

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return !Object$8('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split$3(it, '') : Object$8(it);
	} : Object$8;

	var TypeError$I = global_1.TypeError;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError$I("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	// `IsCallable` abstract operation
	// https://tc39.es/ecma262/#sec-iscallable
	var isCallable = function (argument) {
	  return typeof argument == 'function';
	};

	var isObject$2 = function (it) {
	  return typeof it == 'object' ? it !== null : isCallable(it);
	};

	var aFunction = function (argument) {
	  return isCallable(argument) ? argument : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(global_1[namespace]) : global_1[namespace] && global_1[namespace][method];
	};

	var objectIsPrototypeOf = functionUncurryThis({}.isPrototypeOf);

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process$4 = global_1.process;
	var Deno$1 = global_1.Deno;
	var versions = process$4 && process$4.versions || Deno$1 && Deno$1.version;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
	  // but their correct versions are not interesting for us
	  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	}

	// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
	// so check `userAgent` even if `.v8` exists, but 0
	if (!version && engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = +match[1];
	  }
	}

	var engineV8Version = version;

	/* eslint-disable es-x/no-symbol -- required for testing */



	// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  var symbol = Symbol();
	  // Chrome 38 Symbol has incorrect toString conversion
	  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
	  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
	    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
	    !Symbol.sham && engineV8Version && engineV8Version < 41;
	});

	/* eslint-disable es-x/no-symbol -- required for testing */


	var useSymbolAsUid = nativeSymbol
	  && !Symbol.sham
	  && typeof Symbol.iterator == 'symbol';

	var Object$7 = global_1.Object;

	var isSymbol$1 = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  var $Symbol = getBuiltIn('Symbol');
	  return isCallable($Symbol) && objectIsPrototypeOf($Symbol.prototype, Object$7(it));
	};

	var String$7 = global_1.String;

	var tryToString = function (argument) {
	  try {
	    return String$7(argument);
	  } catch (error) {
	    return 'Object';
	  }
	};

	var TypeError$H = global_1.TypeError;

	// `Assert: IsCallable(argument) is true`
	var aCallable = function (argument) {
	  if (isCallable(argument)) return argument;
	  throw TypeError$H(tryToString(argument) + ' is not a function');
	};

	// `GetMethod` abstract operation
	// https://tc39.es/ecma262/#sec-getmethod
	var getMethod = function (V, P) {
	  var func = V[P];
	  return func == null ? undefined : aCallable(func);
	};

	var TypeError$G = global_1.TypeError;

	// `OrdinaryToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-ordinarytoprimitive
	var ordinaryToPrimitive = function (input, pref) {
	  var fn, val;
	  if (pref === 'string' && isCallable(fn = input.toString) && !isObject$2(val = functionCall(fn, input))) return val;
	  if (isCallable(fn = input.valueOf) && !isObject$2(val = functionCall(fn, input))) return val;
	  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject$2(val = functionCall(fn, input))) return val;
	  throw TypeError$G("Can't convert object to primitive value");
	};

	var isPure = false;

	// eslint-disable-next-line es-x/no-object-defineproperty -- safe
	var defineProperty$k = Object.defineProperty;

	var setGlobal = function (key, value) {
	  try {
	    defineProperty$k(global_1, key, { value: value, configurable: true, writable: true });
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store$3 = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store$3;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.22.0',
	  mode: 'global',
	  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',
	  license: 'https://github.com/zloirock/core-js/blob/v3.22.0/LICENSE',
	  source: 'https://github.com/zloirock/core-js'
	});
	});

	var Object$6 = global_1.Object;

	// `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object$6(requireObjectCoercible(argument));
	};

	var hasOwnProperty$9 = functionUncurryThis({}.hasOwnProperty);

	// `HasOwnProperty` abstract operation
	// https://tc39.es/ecma262/#sec-hasownproperty
	// eslint-disable-next-line es-x/no-object-hasown -- safe
	var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty$9(toObject(it), key);
	};

	var id$1 = 0;
	var postfix = Math.random();
	var toString$2 = functionUncurryThis(1.0.toString);

	var uid = function (key) {
	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$2(++id$1 + postfix, 36);
	};

	var WellKnownSymbolsStore$1 = shared('wks');
	var Symbol$3 = global_1.Symbol;
	var symbolFor = Symbol$3 && Symbol$3['for'];
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$3 : Symbol$3 && Symbol$3.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!hasOwnProperty_1(WellKnownSymbolsStore$1, name) || !(nativeSymbol || typeof WellKnownSymbolsStore$1[name] == 'string')) {
	    var description = 'Symbol.' + name;
	    if (nativeSymbol && hasOwnProperty_1(Symbol$3, name)) {
	      WellKnownSymbolsStore$1[name] = Symbol$3[name];
	    } else if (useSymbolAsUid && symbolFor) {
	      WellKnownSymbolsStore$1[name] = symbolFor(description);
	    } else {
	      WellKnownSymbolsStore$1[name] = createWellKnownSymbol(description);
	    }
	  } return WellKnownSymbolsStore$1[name];
	};

	var TypeError$F = global_1.TypeError;
	var TO_PRIMITIVE$1 = wellKnownSymbol('toPrimitive');

	// `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive
	var toPrimitive = function (input, pref) {
	  if (!isObject$2(input) || isSymbol$1(input)) return input;
	  var exoticToPrim = getMethod(input, TO_PRIMITIVE$1);
	  var result;
	  if (exoticToPrim) {
	    if (pref === undefined) pref = 'default';
	    result = functionCall(exoticToPrim, input, pref);
	    if (!isObject$2(result) || isSymbol$1(result)) return result;
	    throw TypeError$F("Can't convert object to primitive value");
	  }
	  if (pref === undefined) pref = 'number';
	  return ordinaryToPrimitive(input, pref);
	};

	// `ToPropertyKey` abstract operation
	// https://tc39.es/ecma262/#sec-topropertykey
	var toPropertyKey = function (argument) {
	  var key = toPrimitive(argument, 'string');
	  return isSymbol$1(key) ? key : key + '';
	};

	var document$3 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS$1 = isObject$2(document$3) && isObject$2(document$3.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS$1 ? document$3.createElement(it) : {};
	};

	// Thanks to IE8 for its funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	var f$7 = descriptors ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPropertyKey(P);
	  if (ie8DomDefine) try {
	    return $getOwnPropertyDescriptor$2(O, P);
	  } catch (error) { /* empty */ }
	  if (hasOwnProperty_1(O, P)) return createPropertyDescriptor(!functionCall(objectPropertyIsEnumerable.f, O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$7
	};

	// V8 ~ Chrome 36-
	// https://bugs.chromium.org/p/v8/issues/detail?id=3334
	var v8PrototypeDefineBug = descriptors && fails(function () {
	  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
	  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
	    value: 42,
	    writable: false
	  }).prototype != 42;
	});

	var String$6 = global_1.String;
	var TypeError$E = global_1.TypeError;

	// `Assert: Type(argument) is Object`
	var anObject = function (argument) {
	  if (isObject$2(argument)) return argument;
	  throw TypeError$E(String$6(argument) + ' is not an object');
	};

	var TypeError$D = global_1.TypeError;
	// eslint-disable-next-line es-x/no-object-defineproperty -- safe
	var $defineProperty$1 = Object.defineProperty;
	// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
	var ENUMERABLE = 'enumerable';
	var CONFIGURABLE$1 = 'configurable';
	var WRITABLE = 'writable';

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	var f$6 = descriptors ? v8PrototypeDefineBug ? function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPropertyKey(P);
	  anObject(Attributes);
	  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
	    var current = $getOwnPropertyDescriptor$1(O, P);
	    if (current && current[WRITABLE]) {
	      O[P] = Attributes.value;
	      Attributes = {
	        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
	        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
	        writable: false
	      };
	    }
	  } return $defineProperty$1(O, P, Attributes);
	} : $defineProperty$1 : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPropertyKey(P);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return $defineProperty$1(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError$D('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$6
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var functionToString$1 = functionUncurryThis(Function.toString);

	// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
	if (!isCallable(sharedStore.inspectSource)) {
	  sharedStore.inspectSource = function (it) {
	    return functionToString$1(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap$5 = global_1.WeakMap;

	var nativeWeakMap = isCallable(WeakMap$5) && /native code/.test(inspectSource(WeakMap$5));

	var keys$4 = shared('keys');

	var sharedKey = function (key) {
	  return keys$4[key] || (keys$4[key] = uid(key));
	};

	var hiddenKeys$1 = {};

	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError$C = global_1.TypeError;
	var WeakMap$4 = global_1.WeakMap;
	var set$4, get$3, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get$3(it) : set$4(it, {});
	};

	var getterFor$2 = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject$2(it) || (state = get$3(it)).type !== TYPE) {
	      throw TypeError$C('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap || sharedStore.state) {
	  var store$2 = sharedStore.state || (sharedStore.state = new WeakMap$4());
	  var wmget = functionUncurryThis(store$2.get);
	  var wmhas = functionUncurryThis(store$2.has);
	  var wmset = functionUncurryThis(store$2.set);
	  set$4 = function (it, metadata) {
	    if (wmhas(store$2, it)) throw new TypeError$C(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    wmset(store$2, it, metadata);
	    return metadata;
	  };
	  get$3 = function (it) {
	    return wmget(store$2, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas(store$2, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys$1[STATE] = true;
	  set$4 = function (it, metadata) {
	    if (hasOwnProperty_1(it, STATE)) throw new TypeError$C(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get$3 = function (it) {
	    return hasOwnProperty_1(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return hasOwnProperty_1(it, STATE);
	  };
	}

	var internalState = {
	  set: set$4,
	  get: get$3,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor$2
	};

	var FunctionPrototype$3 = Function.prototype;
	// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
	var getDescriptor = descriptors && Object.getOwnPropertyDescriptor;

	var EXISTS = hasOwnProperty_1(FunctionPrototype$3, 'name');
	// additional protection from minified / mangled / dropped function names
	var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
	var CONFIGURABLE = EXISTS && (!descriptors || (descriptors && getDescriptor(FunctionPrototype$3, 'name').configurable));

	var functionName = {
	  EXISTS: EXISTS,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};

	var redefine = createCommonjsModule(function (module) {
	var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;

	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');

	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  var name = options && options.name !== undefined ? options.name : key;
	  var state;
	  if (isCallable(value)) {
	    if (String(name).slice(0, 7) === 'Symbol(') {
	      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
	    }
	    if (!hasOwnProperty_1(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
	      createNonEnumerableProperty(value, 'name', name);
	    }
	    state = enforceInternalState(value);
	    if (!state.source) {
	      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
	    }
	  }
	  if (O === global_1) {
	    if (simple) O[key] = value;
	    else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) O[key] = value;
	  else createNonEnumerableProperty(O, key, value);
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return isCallable(this) && getInternalState(this).source || inspectSource(this);
	});
	});

	var ceil$2 = Math.ceil;
	var floor$b = Math.floor;

	// `ToIntegerOrInfinity` abstract operation
	// https://tc39.es/ecma262/#sec-tointegerorinfinity
	var toIntegerOrInfinity = function (argument) {
	  var number = +argument;
	  // eslint-disable-next-line no-self-compare -- safe
	  return number !== number || number === 0 ? 0 : (number > 0 ? floor$b : ceil$2)(number);
	};

	var max$8 = Math.max;
	var min$b = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toIntegerOrInfinity(index);
	  return integer < 0 ? max$8(integer + length, 0) : min$b(integer, length);
	};

	var min$a = Math.min;

	// `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min$a(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	// `LengthOfArrayLike` abstract operation
	// https://tc39.es/ecma262/#sec-lengthofarraylike
	var lengthOfArrayLike = function (obj) {
	  return toLength(obj.length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$8 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = lengthOfArrayLike(O);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare -- NaN check
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes$1 = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$8(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$8(false)
	};

	var indexOf$2 = arrayIncludes$1.indexOf;


	var push$m = functionUncurryThis([].push);

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !hasOwnProperty_1(hiddenKeys$1, key) && hasOwnProperty_1(O, key) && push$m(result, key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (hasOwnProperty_1(O, key = names[i++])) {
	    ~indexOf$2(result, key) || push$m(result, key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var hiddenKeys = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
	var f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys);
	};

	var objectGetOwnPropertyNames = {
		f: f$5
	};

	// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	var concat$4 = functionUncurryThis([].concat);

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? concat$4(keys, getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source, exceptions) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!hasOwnProperty_1(target, key) && !(exceptions && hasOwnProperty_1(exceptions, key))) {
	      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	    }
	  }
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : isCallable(detection) ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	  options.name        - the .name of the function if it does not match the key
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$8(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty == typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  }
	};

	var TO_STRING_TAG$9 = wellKnownSymbol('toStringTag');
	var test$3 = {};

	test$3[TO_STRING_TAG$9] = 'z';

	var toStringTagSupport = String(test$3) === '[object z]';

	var TO_STRING_TAG$8 = wellKnownSymbol('toStringTag');
	var Object$5 = global_1.Object;

	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object$5(it), TO_STRING_TAG$8)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
	};

	var String$5 = global_1.String;

	var toString_1$1 = function (argument) {
	  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
	  return String$5(argument);
	};

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	// eslint-disable-next-line es-x/no-object-keys -- safe
	var objectKeys$1 = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es-x/no-object-defineproperties -- safe
	var f$3 = descriptors && !v8PrototypeDefineBug ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var props = toIndexedObject(Properties);
	  var keys = objectKeys$1(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], props[key]);
	  return O;
	};

	var objectDefineProperties = {
		f: f$3
	};

	var html$1 = getBuiltIn('document', 'documentElement');

	/* global ActiveXObject -- old IE, WSH */








	var GT = '>';
	var LT = '<';
	var PROTOTYPE$2 = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html$1.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    activeXDocument = new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = typeof document != 'undefined'
	    ? document.domain && activeXDocument
	      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
	      : NullProtoObjectViaIFrame()
	    : NullProtoObjectViaActiveX(activeXDocument); // WSH
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE$2][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys$1[IE_PROTO$1] = true;

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	// eslint-disable-next-line es-x/no-object-create -- safe
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE$2] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE$2] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties.f(result, Properties);
	};

	var createProperty = function (object, key, value) {
	  var propertyKey = toPropertyKey(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	var Array$d = global_1.Array;
	var max$7 = Math.max;

	var arraySliceSimple = function (O, start, end) {
	  var length = lengthOfArrayLike(O);
	  var k = toAbsoluteIndex(start, length);
	  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	  var result = Array$d(max$7(fin - k, 0));
	  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
	  result.length = n;
	  return result;
	};

	/* eslint-disable es-x/no-object-getownpropertynames -- safe */


	var $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;


	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return $getOwnPropertyNames$1(it);
	  } catch (error) {
	    return arraySliceSimple(windowNames);
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$2 = function getOwnPropertyNames(it) {
	  return windowNames && classofRaw(it) == 'Window'
	    ? getWindowNames(it)
	    : $getOwnPropertyNames$1(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$2
	};

	var f$1 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$1
	};

	var path = global_1;

	var defineProperty$j = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!hasOwnProperty_1(Symbol, NAME)) defineProperty$j(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var symbolDefineToPrimitive = function () {
	  var Symbol = getBuiltIn('Symbol');
	  var SymbolPrototype = Symbol && Symbol.prototype;
	  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
	  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

	  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
	    // `Symbol.prototype[@@toPrimitive]` method
	    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
	    // eslint-disable-next-line no-unused-vars -- required for .length
	    redefine(SymbolPrototype, TO_PRIMITIVE, function (hint) {
	      return functionCall(valueOf, this);
	    });
	  }
	};

	var defineProperty$i = objectDefineProperty.f;



	var TO_STRING_TAG$7 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (target, TAG, STATIC) {
	  if (target && !STATIC) target = target.prototype;
	  if (target && !hasOwnProperty_1(target, TO_STRING_TAG$7)) {
	    defineProperty$i(target, TO_STRING_TAG$7, { configurable: true, value: TAG });
	  }
	};

	var bind$1 = functionUncurryThis(functionUncurryThis.bind);

	// optional / simple context binding
	var functionBindContext = function (fn, that) {
	  aCallable(fn);
	  return that === undefined ? fn : functionBindNative ? bind$1(fn, that) : function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	// eslint-disable-next-line es-x/no-array-isarray -- safe
	var isArray$2 = Array.isArray || function isArray(argument) {
	  return classofRaw(argument) == 'Array';
	};

	var noop$2 = function () { /* empty */ };
	var empty$1 = [];
	var construct$1 = getBuiltIn('Reflect', 'construct');
	var constructorRegExp = /^\s*(?:class|function)\b/;
	var exec$b = functionUncurryThis(constructorRegExp.exec);
	var INCORRECT_TO_STRING$2 = !constructorRegExp.exec(noop$2);

	var isConstructorModern = function isConstructor(argument) {
	  if (!isCallable(argument)) return false;
	  try {
	    construct$1(noop$2, empty$1, argument);
	    return true;
	  } catch (error) {
	    return false;
	  }
	};

	var isConstructorLegacy = function isConstructor(argument) {
	  if (!isCallable(argument)) return false;
	  switch (classof(argument)) {
	    case 'AsyncFunction':
	    case 'GeneratorFunction':
	    case 'AsyncGeneratorFunction': return false;
	  }
	  try {
	    // we can't check .prototype since constructors produced by .bind haven't it
	    // `Function#toString` throws on some built-it function in some legacy engines
	    // (for example, `DOMQuad` and similar in FF41-)
	    return INCORRECT_TO_STRING$2 || !!exec$b(constructorRegExp, inspectSource(argument));
	  } catch (error) {
	    return true;
	  }
	};

	isConstructorLegacy.sham = true;

	// `IsConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-isconstructor
	var isConstructor = !construct$1 || fails(function () {
	  var called;
	  return isConstructorModern(isConstructorModern.call)
	    || !isConstructorModern(Object)
	    || !isConstructorModern(function () { called = true; })
	    || called;
	}) ? isConstructorLegacy : isConstructorModern;

	var SPECIES$6 = wellKnownSymbol('species');
	var Array$c = global_1.Array;

	// a part of `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesConstructor = function (originalArray) {
	  var C;
	  if (isArray$2(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (isConstructor(C) && (C === Array$c || isArray$2(C.prototype))) C = undefined;
	    else if (isObject$2(C)) {
	      C = C[SPECIES$6];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array$c : C;
	};

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
	};

	var push$l = functionUncurryThis([].push);

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
	var createMethod$7 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var IS_FILTER_REJECT = TYPE == 7;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that);
	    var length = lengthOfArrayLike(self);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push$l(target, value);      // filter
	        } else switch (TYPE) {
	          case 4: return false;             // every
	          case 7: push$l(target, value);      // filterReject
	        }
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$7(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$7(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$7(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$7(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$7(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$7(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$7(6),
	  // `Array.prototype.filterReject` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterReject: createMethod$7(7)
	};

	var $forEach$3 = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';

	var setInternalState$i = internalState.set;
	var getInternalState$f = internalState.getterFor(SYMBOL);

	var ObjectPrototype$4 = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var SymbolPrototype$1 = $Symbol && $Symbol[PROTOTYPE$1];
	var TypeError$B = global_1.TypeError;
	var QObject = global_1.QObject;
	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyNames = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable = objectPropertyIsEnumerable.f;
	var push$k = functionUncurryThis([].push);

	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var WellKnownSymbolsStore = shared('wks');

	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty({}, 'a', {
	    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$4, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype$4[P];
	  nativeDefineProperty(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$4) {
	    nativeDefineProperty(ObjectPrototype$4, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty;

	var wrap$1 = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate(SymbolPrototype$1);
	  setInternalState$i(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype$4) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPropertyKey(P);
	  anObject(Attributes);
	  if (hasOwnProperty_1(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!hasOwnProperty_1(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (hasOwnProperty_1(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys$1(properties).concat($getOwnPropertySymbols(properties));
	  $forEach$3(keys, function (key) {
	    if (!descriptors || functionCall($propertyIsEnumerable$1, properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};

	var $propertyIsEnumerable$1 = function propertyIsEnumerable(V) {
	  var P = toPropertyKey(V);
	  var enumerable = functionCall(nativePropertyIsEnumerable, this, P);
	  if (this === ObjectPrototype$4 && hasOwnProperty_1(AllSymbols, P) && !hasOwnProperty_1(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !hasOwnProperty_1(this, P) || !hasOwnProperty_1(AllSymbols, P) || hasOwnProperty_1(this, HIDDEN) && this[HIDDEN][P]
	    ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPropertyKey(P);
	  if (it === ObjectPrototype$4 && hasOwnProperty_1(AllSymbols, key) && !hasOwnProperty_1(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
	  if (descriptor && hasOwnProperty_1(AllSymbols, key) && !(hasOwnProperty_1(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
	  var result = [];
	  $forEach$3(names, function (key) {
	    if (!hasOwnProperty_1(AllSymbols, key) && !hasOwnProperty_1(hiddenKeys$1, key)) push$k(result, key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function (O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$4;
	  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach$3(names, function (key) {
	    if (hasOwnProperty_1(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwnProperty_1(ObjectPrototype$4, key))) {
	      push$k(result, AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.es/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (objectIsPrototypeOf(SymbolPrototype$1, this)) throw TypeError$B('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : toString_1$1(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype$4) functionCall(setter, ObjectPrototypeSymbols, value);
	      if (hasOwnProperty_1(this, HIDDEN) && hasOwnProperty_1(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype$4, tag, { configurable: true, set: setter });
	    return wrap$1(tag, description);
	  };

	  SymbolPrototype$1 = $Symbol[PROTOTYPE$1];

	  redefine(SymbolPrototype$1, 'toString', function toString() {
	    return getInternalState$f(this).tag;
	  });

	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap$1(uid(description), description);
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable$1;
	  objectDefineProperty.f = $defineProperty;
	  objectDefineProperties.f = $defineProperties;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap$1(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty(SymbolPrototype$1, 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState$f(this).description;
	      }
	    });
	    {
	      redefine(ObjectPrototype$4, 'propertyIsEnumerable', $propertyIsEnumerable$1, { unsafe: true });
	    }
	  }
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach$3(objectKeys$1(WellKnownSymbolsStore), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.es/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.es/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.es/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames
	});

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
	symbolDefineToPrimitive();

	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys$1[HIDDEN] = true;

	/* eslint-disable es-x/no-symbol -- safe */
	var nativeSymbolRegistry = nativeSymbol && !!Symbol['for'] && !!Symbol.keyFor;

	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry$1 = shared('symbol-to-string-registry');

	// `Symbol.for` method
	// https://tc39.es/ecma262/#sec-symbol.for
	_export({ target: 'Symbol', stat: true, forced: !nativeSymbolRegistry }, {
	  'for': function (key) {
	    var string = toString_1$1(key);
	    if (hasOwnProperty_1(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = getBuiltIn('Symbol')(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry$1[symbol] = string;
	    return symbol;
	  }
	});

	var SymbolToStringRegistry = shared('symbol-to-string-registry');

	// `Symbol.keyFor` method
	// https://tc39.es/ecma262/#sec-symbol.keyfor
	_export({ target: 'Symbol', stat: true, forced: !nativeSymbolRegistry }, {
	  keyFor: function keyFor(sym) {
	    if (!isSymbol$1(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
	    if (hasOwnProperty_1(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  }
	});

	var FunctionPrototype$2 = Function.prototype;
	var apply$1 = FunctionPrototype$2.apply;
	var call = FunctionPrototype$2.call;

	// eslint-disable-next-line es-x/no-reflect -- safe
	var functionApply = typeof Reflect == 'object' && Reflect.apply || (functionBindNative ? call.bind(apply$1) : function () {
	  return call.apply(apply$1, arguments);
	});

	var arraySlice$1 = functionUncurryThis([].slice);

	var $stringify = getBuiltIn('JSON', 'stringify');
	var exec$a = functionUncurryThis(/./.exec);
	var charAt$h = functionUncurryThis(''.charAt);
	var charCodeAt$5 = functionUncurryThis(''.charCodeAt);
	var replace$b = functionUncurryThis(''.replace);
	var numberToString$3 = functionUncurryThis(1.0.toString);

	var tester = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var WRONG_SYMBOLS_CONVERSION = !nativeSymbol || fails(function () {
	  var symbol = getBuiltIn('Symbol')();
	  // MS Edge converts symbol values to JSON as {}
	  return $stringify([symbol]) != '[null]'
	    // WebKit converts symbol values to JSON as null
	    || $stringify({ a: symbol }) != '{}'
	    // V8 throws on boxed symbols
	    || $stringify(Object(symbol)) != '{}';
	});

	// https://github.com/tc39/proposal-well-formed-stringify
	var ILL_FORMED_UNICODE = fails(function () {
	  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
	    || $stringify('\uDEAD') !== '"\\udead"';
	});

	var stringifyWithSymbolsFix = function (it, replacer) {
	  var args = arraySlice$1(arguments);
	  var $replacer = replacer;
	  if (!isObject$2(replacer) && it === undefined || isSymbol$1(it)) return; // IE8 returns string on undefined
	  if (!isArray$2(replacer)) replacer = function (key, value) {
	    if (isCallable($replacer)) value = functionCall($replacer, this, key, value);
	    if (!isSymbol$1(value)) return value;
	  };
	  args[1] = replacer;
	  return functionApply($stringify, null, args);
	};

	var fixIllFormed = function (match, offset, string) {
	  var prev = charAt$h(string, offset - 1);
	  var next = charAt$h(string, offset + 1);
	  if ((exec$a(low, match) && !exec$a(hi, next)) || (exec$a(hi, match) && !exec$a(low, prev))) {
	    return '\\u' + numberToString$3(charCodeAt$5(match, 0), 16);
	  } return match;
	};

	if ($stringify) {
	  // `JSON.stringify` method
	  // https://tc39.es/ecma262/#sec-json.stringify
	  _export({ target: 'JSON', stat: true, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
	    // eslint-disable-next-line no-unused-vars -- required for `.length`
	    stringify: function stringify(it, replacer, space) {
	      var args = arraySlice$1(arguments);
	      var result = functionApply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
	      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace$b(result, tester, fixIllFormed) : result;
	    }
	  });
	}

	// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	var FORCED$n = !nativeSymbol || fails(function () { objectGetOwnPropertySymbols.f(1); });

	// `Object.getOwnPropertySymbols` method
	// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
	_export({ target: 'Object', stat: true, forced: FORCED$n }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    var $getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
	  }
	});

	var defineProperty$h = objectDefineProperty.f;


	var NativeSymbol = global_1.Symbol;
	var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

	if (descriptors && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
	  // Safari 12 bug
	  NativeSymbol().description !== undefined
	)) {
	  var EmptyStringDescriptionStore = {};
	  // wrap Symbol constructor for correct work with undefined description
	  var SymbolWrapper = function Symbol() {
	    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString_1$1(arguments[0]);
	    var result = objectIsPrototypeOf(SymbolPrototype, this)
	      ? new NativeSymbol(description)
	      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
	      : description === undefined ? NativeSymbol() : NativeSymbol(description);
	    if (description === '') EmptyStringDescriptionStore[result] = true;
	    return result;
	  };

	  copyConstructorProperties(SymbolWrapper, NativeSymbol);
	  SymbolWrapper.prototype = SymbolPrototype;
	  SymbolPrototype.constructor = SymbolWrapper;

	  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
	  var symbolToString$1 = functionUncurryThis(SymbolPrototype.toString);
	  var symbolValueOf$1 = functionUncurryThis(SymbolPrototype.valueOf);
	  var regexp = /^Symbol\((.*)\)[^)]+$/;
	  var replace$a = functionUncurryThis(''.replace);
	  var stringSlice$g = functionUncurryThis(''.slice);

	  defineProperty$h(SymbolPrototype, 'description', {
	    configurable: true,
	    get: function description() {
	      var symbol = symbolValueOf$1(this);
	      var string = symbolToString$1(symbol);
	      if (hasOwnProperty_1(EmptyStringDescriptionStore, symbol)) return '';
	      var desc = NATIVE_SYMBOL ? stringSlice$g(string, 7, -1) : replace$a(string, regexp, '$1');
	      return desc === '' ? undefined : desc;
	    }
	  });

	  _export({ global: true, forced: true }, {
	    Symbol: SymbolWrapper
	  });
	}

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.asynciterator
	defineWellKnownSymbol('asyncIterator');

	// `Symbol.hasInstance` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.hasinstance
	defineWellKnownSymbol('hasInstance');

	// `Symbol.isConcatSpreadable` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
	defineWellKnownSymbol('isConcatSpreadable');

	// `Symbol.iterator` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.iterator
	defineWellKnownSymbol('iterator');

	// `Symbol.match` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.match
	defineWellKnownSymbol('match');

	// `Symbol.matchAll` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.matchall
	defineWellKnownSymbol('matchAll');

	// `Symbol.replace` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.replace
	defineWellKnownSymbol('replace');

	// `Symbol.search` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.search
	defineWellKnownSymbol('search');

	// `Symbol.species` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.species
	defineWellKnownSymbol('species');

	// `Symbol.split` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.split
	defineWellKnownSymbol('split');

	// `Symbol.toPrimitive` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.toprimitive
	defineWellKnownSymbol('toPrimitive');

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
	symbolDefineToPrimitive();

	// `Symbol.toStringTag` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.tostringtag
	defineWellKnownSymbol('toStringTag');

	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag(getBuiltIn('Symbol'), 'Symbol');

	// `Symbol.unscopables` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.unscopables
	defineWellKnownSymbol('unscopables');

	var String$4 = global_1.String;
	var TypeError$A = global_1.TypeError;

	var aPossiblePrototype = function (argument) {
	  if (typeof argument == 'object' || isCallable(argument)) return argument;
	  throw TypeError$A("Can't set " + String$4(argument) + ' as a prototype');
	};

	/* eslint-disable no-proto -- safe */




	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	// eslint-disable-next-line es-x/no-object-setprototypeof -- safe
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
	    setter = functionUncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
	    setter(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var defineProperty$g = objectDefineProperty.f;

	var proxyAccessor = function (Target, Source, key) {
	  key in Target || defineProperty$g(Target, key, {
	    configurable: true,
	    get: function () { return Source[key]; },
	    set: function (it) { Source[key] = it; }
	  });
	};

	// makes subclassing work correct for wrapped built-ins
	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if (
	    // it can work only with native `setPrototypeOf`
	    objectSetPrototypeOf &&
	    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	    isCallable(NewTarget = dummy.constructor) &&
	    NewTarget !== Wrapper &&
	    isObject$2(NewTargetPrototype = NewTarget.prototype) &&
	    NewTargetPrototype !== Wrapper.prototype
	  ) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	var normalizeStringArgument = function (argument, $default) {
	  return argument === undefined ? arguments.length < 2 ? '' : $default : toString_1$1(argument);
	};

	// `InstallErrorCause` abstract operation
	// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
	var installErrorCause = function (O, options) {
	  if (isObject$2(options) && 'cause' in options) {
	    createNonEnumerableProperty(O, 'cause', options.cause);
	  }
	};

	var $Error = Error;
	var replace$9 = functionUncurryThis(''.replace);

	var TEST = (function (arg) { return String($Error(arg).stack); })('zxcasd');
	var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
	var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

	var clearErrorStack = function (stack, dropEntries) {
	  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
	    while (dropEntries--) stack = replace$9(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
	  } return stack;
	};

	var errorStackInstallable = !fails(function () {
	  var error = Error('a');
	  if (!('stack' in error)) return true;
	  // eslint-disable-next-line es-x/no-object-defineproperty -- safe
	  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
	  return error.stack !== 7;
	});

	var wrapErrorConstructorWithCause = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
	  var STACK_TRACE_LIMIT = 'stackTraceLimit';
	  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
	  var path = FULL_NAME.split('.');
	  var ERROR_NAME = path[path.length - 1];
	  var OriginalError = getBuiltIn.apply(null, path);

	  if (!OriginalError) return;

	  var OriginalErrorPrototype = OriginalError.prototype;

	  // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
	  if (hasOwnProperty_1(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;

	  if (!FORCED) return OriginalError;

	  var BaseError = getBuiltIn('Error');

	  var WrappedError = wrapper(function (a, b) {
	    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
	    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
	    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
	    if (errorStackInstallable) createNonEnumerableProperty(result, 'stack', clearErrorStack(result.stack, 2));
	    if (this && objectIsPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
	    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
	    return result;
	  });

	  WrappedError.prototype = OriginalErrorPrototype;

	  if (ERROR_NAME !== 'Error') {
	    if (objectSetPrototypeOf) objectSetPrototypeOf(WrappedError, BaseError);
	    else copyConstructorProperties(WrappedError, BaseError, { name: true });
	  } else if (descriptors && STACK_TRACE_LIMIT in OriginalError) {
	    proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
	    proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
	  }

	  copyConstructorProperties(WrappedError, OriginalError);

	  try {
	    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
	    if (OriginalErrorPrototype.name !== ERROR_NAME) {
	      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
	    }
	    OriginalErrorPrototype.constructor = WrappedError;
	  } catch (error) { /* empty */ }

	  return WrappedError;
	};

	/* eslint-disable no-unused-vars -- required for functions `.length` */





	var WEB_ASSEMBLY = 'WebAssembly';
	var WebAssembly$1 = global_1[WEB_ASSEMBLY];

	var FORCED$m = Error('e', { cause: 7 }).cause !== 7;

	var exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {
	  var O = {};
	  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED$m);
	  _export({ global: true, forced: FORCED$m }, O);
	};

	var exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {
	  if (WebAssembly$1 && WebAssembly$1[ERROR_NAME]) {
	    var O = {};
	    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED$m);
	    _export({ target: WEB_ASSEMBLY, stat: true, forced: FORCED$m }, O);
	  }
	};

	// https://github.com/tc39/proposal-error-cause
	exportGlobalErrorCauseWrapper('Error', function (init) {
	  return function Error(message) { return functionApply(init, this, arguments); };
	});
	exportGlobalErrorCauseWrapper('EvalError', function (init) {
	  return function EvalError(message) { return functionApply(init, this, arguments); };
	});
	exportGlobalErrorCauseWrapper('RangeError', function (init) {
	  return function RangeError(message) { return functionApply(init, this, arguments); };
	});
	exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
	  return function ReferenceError(message) { return functionApply(init, this, arguments); };
	});
	exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
	  return function SyntaxError(message) { return functionApply(init, this, arguments); };
	});
	exportGlobalErrorCauseWrapper('TypeError', function (init) {
	  return function TypeError(message) { return functionApply(init, this, arguments); };
	});
	exportGlobalErrorCauseWrapper('URIError', function (init) {
	  return function URIError(message) { return functionApply(init, this, arguments); };
	});
	exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
	  return function CompileError(message) { return functionApply(init, this, arguments); };
	});
	exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
	  return function LinkError(message) { return functionApply(init, this, arguments); };
	});
	exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
	  return function RuntimeError(message) { return functionApply(init, this, arguments); };
	});

	var nativeErrorToString = Error.prototype.toString;

	var INCORRECT_TO_STRING$1 = fails(function () {
	  if (descriptors) {
	    // Chrome 32- incorrectly call accessor
	    // eslint-disable-next-line es-x/no-object-defineproperty -- safe
	    var object = objectCreate(Object.defineProperty({}, 'name', { get: function () {
	      return this === object;
	    } }));
	    if (nativeErrorToString.call(object) !== 'true') return true;
	  }
	  // FF10- does not properly handle non-strings
	  return nativeErrorToString.call({ message: 1, name: 2 }) !== '2: 1'
	    // IE8 does not properly handle defaults
	    || nativeErrorToString.call({}) !== 'Error';
	});

	var errorToString = INCORRECT_TO_STRING$1 ? function toString() {
	  var O = anObject(this);
	  var name = normalizeStringArgument(O.name, 'Error');
	  var message = normalizeStringArgument(O.message);
	  return !name ? message : !message ? name : name + ': ' + message;
	} : nativeErrorToString;

	var ErrorPrototype$1 = Error.prototype;

	// `Error.prototype.toString` method fix
	// https://tc39.es/ecma262/#sec-error.prototype.tostring
	if (ErrorPrototype$1.toString !== errorToString) {
	  redefine(ErrorPrototype$1, 'toString', errorToString);
	}

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO = sharedKey('IE_PROTO');
	var Object$4 = global_1.Object;
	var ObjectPrototype$3 = Object$4.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object$4.getPrototypeOf : function (O) {
	  var object = toObject(O);
	  if (hasOwnProperty_1(object, IE_PROTO)) return object[IE_PROTO];
	  var constructor = object.constructor;
	  if (isCallable(constructor) && object instanceof constructor) {
	    return constructor.prototype;
	  } return object instanceof Object$4 ? ObjectPrototype$3 : null;
	};

	var iterators = {};

	var ITERATOR$a = wellKnownSymbol('iterator');
	var ArrayPrototype$2 = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype$2[ITERATOR$a] === it);
	};

	var ITERATOR$9 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return getMethod(it, ITERATOR$9)
	    || getMethod(it, '@@iterator')
	    || iterators[classof(it)];
	};

	var TypeError$z = global_1.TypeError;

	var getIterator = function (argument, usingIterator) {
	  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
	  if (aCallable(iteratorMethod)) return anObject(functionCall(iteratorMethod, argument));
	  throw TypeError$z(tryToString(argument) + ' is not iterable');
	};

	var iteratorClose = function (iterator, kind, value) {
	  var innerResult, innerError;
	  anObject(iterator);
	  try {
	    innerResult = getMethod(iterator, 'return');
	    if (!innerResult) {
	      if (kind === 'throw') throw value;
	      return value;
	    }
	    innerResult = functionCall(innerResult, iterator);
	  } catch (error) {
	    innerError = true;
	    innerResult = error;
	  }
	  if (kind === 'throw') throw value;
	  if (innerError) throw innerResult;
	  anObject(innerResult);
	  return value;
	};

	var TypeError$y = global_1.TypeError;

	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var ResultPrototype = Result.prototype;

	var iterate = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = functionBindContext(unboundFunction, that);
	  var iterator, iterFn, index, length, result, next, step;

	  var stop = function (condition) {
	    if (iterator) iteratorClose(iterator, 'normal', condition);
	    return new Result(true, condition);
	  };

	  var callFn = function (value) {
	    if (AS_ENTRIES) {
	      anObject(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    } return INTERRUPTED ? fn(value, stop) : fn(value);
	  };

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (!iterFn) throw TypeError$y(tryToString(iterable) + ' is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && objectIsPrototypeOf(ResultPrototype, result)) return result;
	      } return new Result(false);
	    }
	    iterator = getIterator(iterable, iterFn);
	  }

	  next = iterator.next;
	  while (!(step = functionCall(next, iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator, 'throw', error);
	    }
	    if (typeof result == 'object' && result && objectIsPrototypeOf(ResultPrototype, result)) return result;
	  } return new Result(false);
	};

	var TO_STRING_TAG$6 = wellKnownSymbol('toStringTag');
	var Error$5 = global_1.Error;
	var push$j = [].push;

	var $AggregateError$1 = function AggregateError(errors, message /* , options */) {
	  var options = arguments.length > 2 ? arguments[2] : undefined;
	  var isInstance = objectIsPrototypeOf(AggregateErrorPrototype, this);
	  var that;
	  if (objectSetPrototypeOf) {
	    that = objectSetPrototypeOf(new Error$5(), isInstance ? objectGetPrototypeOf(this) : AggregateErrorPrototype);
	  } else {
	    that = isInstance ? this : objectCreate(AggregateErrorPrototype);
	    createNonEnumerableProperty(that, TO_STRING_TAG$6, 'Error');
	  }
	  if (message !== undefined) createNonEnumerableProperty(that, 'message', normalizeStringArgument(message));
	  if (errorStackInstallable) createNonEnumerableProperty(that, 'stack', clearErrorStack(that.stack, 1));
	  installErrorCause(that, options);
	  var errorsArray = [];
	  iterate(errors, push$j, { that: errorsArray });
	  createNonEnumerableProperty(that, 'errors', errorsArray);
	  return that;
	};

	if (objectSetPrototypeOf) objectSetPrototypeOf($AggregateError$1, Error$5);
	else copyConstructorProperties($AggregateError$1, Error$5, { name: true });

	var AggregateErrorPrototype = $AggregateError$1.prototype = objectCreate(Error$5.prototype, {
	  constructor: createPropertyDescriptor(1, $AggregateError$1),
	  message: createPropertyDescriptor(1, ''),
	  name: createPropertyDescriptor(1, 'AggregateError')
	});

	// `AggregateError` constructor
	// https://tc39.es/ecma262/#sec-aggregate-error-constructor
	_export({ global: true }, {
	  AggregateError: $AggregateError$1
	});

	var AGGREGATE_ERROR = 'AggregateError';
	var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
	var FORCED$l = !fails(function () {
	  return $AggregateError([1]).errors[0] !== 1;
	}) && fails(function () {
	  return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
	});

	// https://github.com/tc39/proposal-error-cause
	_export({ global: true, forced: FORCED$l }, {
	  AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function (init) {
	    // eslint-disable-next-line no-unused-vars -- required for functions `.length`
	    return function AggregateError(errors, message) { return functionApply(init, this, arguments); };
	  }, FORCED$l, true)
	});

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype$1 = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	// `Array.prototype.at` method
	// https://github.com/tc39/proposal-relative-indexing-method
	_export({ target: 'Array', proto: true }, {
	  at: function at(index) {
	    var O = toObject(this);
	    var len = lengthOfArrayLike(O);
	    var relativeIndex = toIntegerOrInfinity(index);
	    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
	    return (k < 0 || k >= len) ? undefined : O[k];
	  }
	});

	addToUnscopables('at');

	var SPECIES$5 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$5] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER$5 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
	var TypeError$x = global_1.TypeError;

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject$2(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray$2(O);
	};

	var FORCED$k = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.es/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED$k }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  concat: function concat(arg) {
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = lengthOfArrayLike(E);
	        if (n + len > MAX_SAFE_INTEGER$5) throw TypeError$x(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER$5) throw TypeError$x(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var min$9 = Math.min;

	// `Array.prototype.copyWithin` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.copywithin
	// eslint-disable-next-line es-x/no-array-prototype-copywithin -- safe
	var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = lengthOfArrayLike(O);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = min$9((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};

	// `Array.prototype.copyWithin` method
	// https://tc39.es/ecma262/#sec-array.prototype.copywithin
	_export({ target: 'Array', proto: true }, {
	  copyWithin: arrayCopyWithin
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('copyWithin');

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call -- required for testing
	    method.call(null, argument || function () { return 1; }, 1);
	  });
	};

	var $every$2 = arrayIteration.every;


	var STRICT_METHOD$8 = arrayMethodIsStrict('every');

	// `Array.prototype.every` method
	// https://tc39.es/ecma262/#sec-array.prototype.every
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$8 }, {
	  every: function every(callbackfn /* , thisArg */) {
	    return $every$2(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.prototype.fill` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.fill
	var arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = lengthOfArrayLike(O);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	// `Array.prototype.fill` method
	// https://tc39.es/ecma262/#sec-array.prototype.fill
	_export({ target: 'Array', proto: true }, {
	  fill: arrayFill
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('fill');

	var $filter$1 = arrayIteration.filter;


	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('filter');

	// `Array.prototype.filter` method
	// https://tc39.es/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $find$2 = arrayIteration.find;


	var FIND = 'find';
	var SKIPS_HOLES$1 = true;

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES$1 = false; });

	// `Array.prototype.find` method
	// https://tc39.es/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find$2(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var $findIndex$1 = arrayIteration.findIndex;


	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES = true;

	// Shouldn't skip holes
	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

	// `Array.prototype.findIndex` method
	// https://tc39.es/ecma262/#sec-array.prototype.findindex
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND_INDEX);

	var TypeError$w = global_1.TypeError;

	// `FlattenIntoArray` abstract operation
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? functionBindContext(mapper, thisArg) : false;
	  var element, elementLen;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      if (depth > 0 && isArray$2(element)) {
	        elementLen = lengthOfArrayLike(element);
	        targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError$w('Exceed the acceptable array length');
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	};

	var flattenIntoArray_1 = flattenIntoArray;

	// `Array.prototype.flat` method
	// https://tc39.es/ecma262/#sec-array.prototype.flat
	_export({ target: 'Array', proto: true }, {
	  flat: function flat(/* depthArg = 1 */) {
	    var depthArg = arguments.length ? arguments[0] : undefined;
	    var O = toObject(this);
	    var sourceLen = lengthOfArrayLike(O);
	    var A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toIntegerOrInfinity(depthArg));
	    return A;
	  }
	});

	// `Array.prototype.flatMap` method
	// https://tc39.es/ecma262/#sec-array.prototype.flatmap
	_export({ target: 'Array', proto: true }, {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen = lengthOfArrayLike(O);
	    var A;
	    aCallable(callbackfn);
	    A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return A;
	  }
	});

	var $forEach$2 = arrayIteration.forEach;


	var STRICT_METHOD$7 = arrayMethodIsStrict('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.foreach
	var arrayForEach = !STRICT_METHOD$7 ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach$2(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	// eslint-disable-next-line es-x/no-array-prototype-foreach -- safe
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.es/ecma262/#sec-array.prototype.foreach
	// eslint-disable-next-line es-x/no-array-prototype-foreach -- safe
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  } catch (error) {
	    iteratorClose(iterator, 'throw', error);
	  }
	};

	var Array$b = global_1.Array;

	// `Array.from` method implementation
	// https://tc39.es/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var IS_CONSTRUCTOR = isConstructor(this);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod && !(this == Array$b && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = getIterator(O, iteratorMethod);
	    next = iterator.next;
	    result = IS_CONSTRUCTOR ? new this() : [];
	    for (;!(step = functionCall(next, iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = lengthOfArrayLike(O);
	    result = IS_CONSTRUCTOR ? new this(length) : Array$b(length);
	    for (;length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	var ITERATOR$8 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$8] = function () {
	    return this;
	  };
	  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$8] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
	  // eslint-disable-next-line es-x/no-array-from -- required for testing
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.es/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
	  from: arrayFrom
	});

	var $includes$1 = arrayIncludes$1.includes;


	// `Array.prototype.includes` method
	// https://tc39.es/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes$1(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	/* eslint-disable es-x/no-array-prototype-indexof -- required for testing */


	var $IndexOf = arrayIncludes$1.indexOf;


	var un$IndexOf = functionUncurryThis([].indexOf);

	var NEGATIVE_ZERO$1 = !!un$IndexOf && 1 / un$IndexOf([1], 1, -0) < 0;
	var STRICT_METHOD$6 = arrayMethodIsStrict('indexOf');

	// `Array.prototype.indexOf` method
	// https://tc39.es/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO$1 || !STRICT_METHOD$6 }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;
	    return NEGATIVE_ZERO$1
	      // convert -0 to +0
	      ? un$IndexOf(this, searchElement, fromIndex) || 0
	      : $IndexOf(this, searchElement, fromIndex);
	  }
	});

	// `Array.isArray` method
	// https://tc39.es/ecma262/#sec-array.isarray
	_export({ target: 'Array', stat: true }, {
	  isArray: isArray$2
	});

	var ITERATOR$7 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;

	// `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype$5, PrototypeOfArrayIteratorPrototype, arrayIterator$1;

	/* eslint-disable es-x/no-array-prototype-keys -- safe */
	if ([].keys) {
	  arrayIterator$1 = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator$1)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator$1));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$5 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$5 == undefined || fails(function () {
	  var test = {};
	  // FF44- legacy iterators case
	  return IteratorPrototype$5[ITERATOR$7].call(test) !== test;
	});

	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$5 = {};

	// `%IteratorPrototype%[@@iterator]()` method
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
	if (!isCallable(IteratorPrototype$5[ITERATOR$7])) {
	  redefine(IteratorPrototype$5, ITERATOR$7, function () {
	    return this;
	  });
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$5,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	var IteratorPrototype$4 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$4, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var PROPER_FUNCTION_NAME$3 = functionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
	var IteratorPrototype$3 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$6 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$6]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$3) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$3);
	        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR$6])) {
	          redefine(CurrentIteratorPrototype, ITERATOR$6, returnThis);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
	  if (PROPER_FUNCTION_NAME$3 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    if (CONFIGURABLE_FUNCTION_NAME$1) {
	      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
	    } else {
	      INCORRECT_VALUES_NAME = true;
	      defaultIterator = function values() { return functionCall(nativeIterator, this); };
	    }
	  }

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
	  }

	  // define iterator
	  if (IterablePrototype[ITERATOR$6] !== defaultIterator) {
	    redefine(IterablePrototype, ITERATOR$6, defaultIterator, { name: DEFAULT });
	  }
	  iterators[NAME] = defaultIterator;

	  return methods;
	};

	var defineProperty$f = objectDefineProperty.f;




	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$h = internalState.set;
	var getInternalState$e = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$h(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$e(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject
	var values$1 = iterators.Arguments = iterators.Array;

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	// V8 ~ Chrome 45- bug
	if (descriptors && values$1.name !== 'values') try {
	  defineProperty$f(values$1, 'name', { value: 'values' });
	} catch (error) { /* empty */ }

	var un$Join = functionUncurryThis([].join);

	var ES3_STRINGS = indexedObject != Object;
	var STRICT_METHOD$5 = arrayMethodIsStrict('join', ',');

	// `Array.prototype.join` method
	// https://tc39.es/ecma262/#sec-array.prototype.join
	_export({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD$5 }, {
	  join: function join(separator) {
	    return un$Join(toIndexedObject(this), separator === undefined ? ',' : separator);
	  }
	});

	/* eslint-disable es-x/no-array-prototype-lastindexof -- safe */






	var min$8 = Math.min;
	var $lastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$4 = arrayMethodIsStrict('lastIndexOf');
	var FORCED$j = NEGATIVE_ZERO || !STRICT_METHOD$4;

	// `Array.prototype.lastIndexOf` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
	var arrayLastIndexOf = FORCED$j ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO) return functionApply($lastIndexOf, this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = lengthOfArrayLike(O);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$8(index, toIntegerOrInfinity(arguments[1]));
	  if (index < 0) index = length + index;
	  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
	  return -1;
	} : $lastIndexOf;

	// `Array.prototype.lastIndexOf` method
	// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
	// eslint-disable-next-line es-x/no-array-prototype-lastindexof -- required for testing
	_export({ target: 'Array', proto: true, forced: arrayLastIndexOf !== [].lastIndexOf }, {
	  lastIndexOf: arrayLastIndexOf
	});

	var $map$1 = arrayIteration.map;


	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('map');

	// `Array.prototype.map` method
	// https://tc39.es/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var Array$a = global_1.Array;

	var ISNT_GENERIC = fails(function () {
	  function F() { /* empty */ }
	  return !(Array$a.of.call(F) instanceof F);
	});

	// `Array.of` method
	// https://tc39.es/ecma262/#sec-array.of
	// WebKit Array.of isn't generic
	_export({ target: 'Array', stat: true, forced: ISNT_GENERIC }, {
	  of: function of(/* ...args */) {
	    var index = 0;
	    var argumentsLength = arguments.length;
	    var result = new (isConstructor(this) ? this : Array$a)(argumentsLength);
	    while (argumentsLength > index) createProperty(result, index, arguments[index++]);
	    result.length = argumentsLength;
	    return result;
	  }
	});

	var TypeError$v = global_1.TypeError;

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$6 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aCallable(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = lengthOfArrayLike(O);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError$v('Reduce of empty array with no initial value');
	      }
	    }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.es/ecma262/#sec-array.prototype.reduce
	  left: createMethod$6(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$6(true)
	};

	var engineIsNode = classofRaw(global_1.process) == 'process';

	var $reduce$1 = arrayReduce.left;




	var STRICT_METHOD$3 = arrayMethodIsStrict('reduce');
	// Chrome 80-82 has a critical bug
	// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
	var CHROME_BUG$1 = !engineIsNode && engineV8Version > 79 && engineV8Version < 83;

	// `Array.prototype.reduce` method
	// https://tc39.es/ecma262/#sec-array.prototype.reduce
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 || CHROME_BUG$1 }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    var length = arguments.length;
	    return $reduce$1(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
	  }
	});

	var $reduceRight$1 = arrayReduce.right;




	var STRICT_METHOD$2 = arrayMethodIsStrict('reduceRight');
	// Chrome 80-82 has a critical bug
	// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
	var CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83;

	// `Array.prototype.reduceRight` method
	// https://tc39.es/ecma262/#sec-array.prototype.reduceright
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$2 || CHROME_BUG }, {
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduceRight$1(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var un$Reverse = functionUncurryThis([].reverse);
	var test$2 = [1, 2];

	// `Array.prototype.reverse` method
	// https://tc39.es/ecma262/#sec-array.prototype.reverse
	// fix for Safari 12.0 bug
	// https://bugs.webkit.org/show_bug.cgi?id=188794
	_export({ target: 'Array', proto: true, forced: String(test$2) === String(test$2.reverse()) }, {
	  reverse: function reverse() {
	    // eslint-disable-next-line no-self-assign -- dirty hack
	    if (isArray$2(this)) this.length = this.length;
	    return un$Reverse(this);
	  }
	});

	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('slice');

	var SPECIES$4 = wellKnownSymbol('species');
	var Array$9 = global_1.Array;
	var max$6 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.es/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = lengthOfArrayLike(O);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray$2(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (isConstructor(Constructor) && (Constructor === Array$9 || isArray$2(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject$2(Constructor)) {
	        Constructor = Constructor[SPECIES$4];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array$9 || Constructor === undefined) {
	        return arraySlice$1(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array$9 : Constructor)(max$6(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var $some$2 = arrayIteration.some;


	var STRICT_METHOD$1 = arrayMethodIsStrict('some');

	// `Array.prototype.some` method
	// https://tc39.es/ecma262/#sec-array.prototype.some
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$1 }, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some$2(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var floor$a = Math.floor;

	var mergeSort = function (array, comparefn) {
	  var length = array.length;
	  var middle = floor$a(length / 2);
	  return length < 8 ? insertionSort(array, comparefn) : merge$1(
	    array,
	    mergeSort(arraySliceSimple(array, 0, middle), comparefn),
	    mergeSort(arraySliceSimple(array, middle), comparefn),
	    comparefn
	  );
	};

	var insertionSort = function (array, comparefn) {
	  var length = array.length;
	  var i = 1;
	  var element, j;

	  while (i < length) {
	    j = i;
	    element = array[i];
	    while (j && comparefn(array[j - 1], element) > 0) {
	      array[j] = array[--j];
	    }
	    if (j !== i++) array[j] = element;
	  } return array;
	};

	var merge$1 = function (array, left, right, comparefn) {
	  var llength = left.length;
	  var rlength = right.length;
	  var lindex = 0;
	  var rindex = 0;

	  while (lindex < llength || rindex < rlength) {
	    array[lindex + rindex] = (lindex < llength && rindex < rlength)
	      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
	      : lindex < llength ? left[lindex++] : right[rindex++];
	  } return array;
	};

	var arraySort = mergeSort;

	var firefox = engineUserAgent.match(/firefox\/(\d+)/i);

	var engineFfVersion = !!firefox && +firefox[1];

	var engineIsIeOrEdge = /MSIE|Trident/.test(engineUserAgent);

	var webkit = engineUserAgent.match(/AppleWebKit\/(\d+)\./);

	var engineWebkitVersion = !!webkit && +webkit[1];

	var test$1 = [];
	var un$Sort$1 = functionUncurryThis(test$1.sort);
	var push$i = functionUncurryThis(test$1.push);

	// IE8-
	var FAILS_ON_UNDEFINED = fails(function () {
	  test$1.sort(undefined);
	});
	// V8 bug
	var FAILS_ON_NULL = fails(function () {
	  test$1.sort(null);
	});
	// Old WebKit
	var STRICT_METHOD = arrayMethodIsStrict('sort');

	var STABLE_SORT$1 = !fails(function () {
	  // feature detection can be too slow, so check engines versions
	  if (engineV8Version) return engineV8Version < 70;
	  if (engineFfVersion && engineFfVersion > 3) return;
	  if (engineIsIeOrEdge) return true;
	  if (engineWebkitVersion) return engineWebkitVersion < 603;

	  var result = '';
	  var code, chr, value, index;

	  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
	  for (code = 65; code < 76; code++) {
	    chr = String.fromCharCode(code);

	    switch (code) {
	      case 66: case 69: case 70: case 72: value = 3; break;
	      case 68: case 71: value = 4; break;
	      default: value = 2;
	    }

	    for (index = 0; index < 47; index++) {
	      test$1.push({ k: chr + index, v: value });
	    }
	  }

	  test$1.sort(function (a, b) { return b.v - a.v; });

	  for (index = 0; index < test$1.length; index++) {
	    chr = test$1[index].k.charAt(0);
	    if (result.charAt(result.length - 1) !== chr) result += chr;
	  }

	  return result !== 'DGBEFHACIJK';
	});

	var FORCED$i = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT$1;

	var getSortCompare$1 = function (comparefn) {
	  return function (x, y) {
	    if (y === undefined) return -1;
	    if (x === undefined) return 1;
	    if (comparefn !== undefined) return +comparefn(x, y) || 0;
	    return toString_1$1(x) > toString_1$1(y) ? 1 : -1;
	  };
	};

	// `Array.prototype.sort` method
	// https://tc39.es/ecma262/#sec-array.prototype.sort
	_export({ target: 'Array', proto: true, forced: FORCED$i }, {
	  sort: function sort(comparefn) {
	    if (comparefn !== undefined) aCallable(comparefn);

	    var array = toObject(this);

	    if (STABLE_SORT$1) return comparefn === undefined ? un$Sort$1(array) : un$Sort$1(array, comparefn);

	    var items = [];
	    var arrayLength = lengthOfArrayLike(array);
	    var itemsLength, index;

	    for (index = 0; index < arrayLength; index++) {
	      if (index in array) push$i(items, array[index]);
	    }

	    arraySort(items, getSortCompare$1(comparefn));

	    itemsLength = items.length;
	    index = 0;

	    while (index < itemsLength) array[index] = items[index++];
	    while (index < arrayLength) delete array[index++];

	    return array;
	  }
	});

	var SPECIES$3 = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
	    defineProperty(Constructor, SPECIES$3, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	// `Array[@@species]` getter
	// https://tc39.es/ecma262/#sec-get-array-@@species
	setSpecies('Array');

	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

	var TypeError$u = global_1.TypeError;
	var max$5 = Math.max;
	var min$7 = Math.min;
	var MAX_SAFE_INTEGER$4 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.es/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = lengthOfArrayLike(O);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$7(max$5(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$4) {
	      throw TypeError$u(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module


	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('flat');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module


	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('flatMap');

	// eslint-disable-next-line es-x/no-typed-arrays -- safe
	var arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);
	  return target;
	};

	var TypeError$t = global_1.TypeError;

	var anInstance = function (it, Prototype) {
	  if (objectIsPrototypeOf(Prototype, it)) return it;
	  throw TypeError$t('Incorrect invocation');
	};

	var RangeError$e = global_1.RangeError;

	// `ToIndex` abstract operation
	// https://tc39.es/ecma262/#sec-toindex
	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toIntegerOrInfinity(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError$e('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754


	var Array$8 = global_1.Array;
	var abs$8 = Math.abs;
	var pow$5 = Math.pow;
	var floor$9 = Math.floor;
	var log$8 = Math.log;
	var LN2$2 = Math.LN2;

	var pack = function (number, mantissaLength, bytes) {
	  var buffer = Array$8(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow$5(2, -24) - pow$5(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs$8(number);
	  // eslint-disable-next-line no-self-compare -- NaN check
	  if (number != number || number === Infinity) {
	    // eslint-disable-next-line no-self-compare -- NaN check
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$9(log$8(number) / LN2$2);
	    c = pow$5(2, -exponent);
	    if (number * c < 1) {
	      exponent--;
	      c *= 2;
	    }
	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow$5(2, 1 - eBias);
	    }
	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }
	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow$5(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow$5(2, eBias - 1) * pow$5(2, mantissaLength);
	      exponent = 0;
	    }
	  }
	  while (mantissaLength >= 8) {
	    buffer[index++] = mantissa & 255;
	    mantissa /= 256;
	    mantissaLength -= 8;
	  }
	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;
	  while (exponentLength > 0) {
	    buffer[index++] = exponent & 255;
	    exponent /= 256;
	    exponentLength -= 8;
	  }
	  buffer[--index] |= sign * 128;
	  return buffer;
	};

	var unpack = function (buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;
	  while (nBits > 0) {
	    exponent = exponent * 256 + buffer[index--];
	    nBits -= 8;
	  }
	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;
	  while (nBits > 0) {
	    mantissa = mantissa * 256 + buffer[index--];
	    nBits -= 8;
	  }
	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity : Infinity;
	  } else {
	    mantissa = mantissa + pow$5(2, mantissaLength);
	    exponent = exponent - eBias;
	  } return (sign ? -1 : 1) * mantissa * pow$5(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	var getOwnPropertyNames$3 = objectGetOwnPropertyNames.f;
	var defineProperty$e = objectDefineProperty.f;





	var PROPER_FUNCTION_NAME$2 = functionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
	var getInternalState$d = internalState.get;
	var setInternalState$g = internalState.set;
	var ARRAY_BUFFER$1 = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];
	var $ArrayBuffer = NativeArrayBuffer$1;
	var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
	var $DataView = global_1[DATA_VIEW];
	var DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE];
	var ObjectPrototype$2 = Object.prototype;
	var Array$7 = global_1.Array;
	var RangeError$d = global_1.RangeError;
	var fill = functionUncurryThis(arrayFill);
	var reverse = functionUncurryThis([].reverse);

	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;

	var packInt8 = function (number) {
	  return [number & 0xFF];
	};

	var packInt16 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function (buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function (number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function (number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter = function (Constructor, key) {
	  defineProperty$e(Constructor[PROTOTYPE], key, { get: function () { return getInternalState$d(this)[key]; } });
	};

	var get$2 = function (view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$d(view);
	  if (intIndex + count > store.byteLength) throw RangeError$d(WRONG_INDEX);
	  var bytes = getInternalState$d(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = arraySliceSimple(bytes, start, start + count);
	  return isLittleEndian ? pack : reverse(pack);
	};

	var set$3 = function (view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$d(view);
	  if (intIndex + count > store.byteLength) throw RangeError$d(WRONG_INDEX);
	  var bytes = getInternalState$d(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);
	  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	};

	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, ArrayBufferPrototype);
	    var byteLength = toIndex(length);
	    setInternalState$g(this, {
	      bytes: fill(Array$7(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };

	  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, DataViewPrototype$1);
	    anInstance(buffer, ArrayBufferPrototype);
	    var bufferLength = getInternalState$d(buffer).byteLength;
	    var offset = toIntegerOrInfinity(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$d('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$d(WRONG_LENGTH);
	    setInternalState$g(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });
	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  DataViewPrototype$1 = $DataView[PROTOTYPE];

	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }

	  redefineAll(DataViewPrototype$1, {
	    getInt8: function getInt8(byteOffset) {
	      return get$2(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$2(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get$2(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get$2(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$2(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$2(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$2(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$2(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$3(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$3(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set$3(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set$3(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set$3(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set$3(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set$3(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set$3(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME$2 && NativeArrayBuffer$1.name !== ARRAY_BUFFER$1;
	  /* eslint-disable no-new -- required for testing */
	  if (!fails(function () {
	    NativeArrayBuffer$1(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer$1(-1);
	  }) || fails(function () {
	    new NativeArrayBuffer$1();
	    new NativeArrayBuffer$1(1.5);
	    new NativeArrayBuffer$1(NaN);
	    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
	  })) {
	  /* eslint-enable no-new -- required for testing */
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, ArrayBufferPrototype);
	      return new NativeArrayBuffer$1(toIndex(length));
	    };

	    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;

	    for (var keys$3 = getOwnPropertyNames$3(NativeArrayBuffer$1), j$1 = 0, key$3; keys$3.length > j$1;) {
	      if (!((key$3 = keys$3[j$1++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key$3, NativeArrayBuffer$1[key$3]);
	      }
	    }

	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
	    createNonEnumerableProperty(NativeArrayBuffer$1, 'name', ARRAY_BUFFER$1);
	  }

	  // WebKit bug - the same parent prototype for typed arrays and data view
	  if (objectSetPrototypeOf && objectGetPrototypeOf(DataViewPrototype$1) !== ObjectPrototype$2) {
	    objectSetPrototypeOf(DataViewPrototype$1, ObjectPrototype$2);
	  }

	  // iOS Safari 7.x bug
	  var testView = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = functionUncurryThis(DataViewPrototype$1.setInt8);
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll(DataViewPrototype$1, {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    }
	  }, { unsafe: true });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER$1);
	setToStringTag($DataView, DATA_VIEW);

	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var ARRAY_BUFFER = 'ArrayBuffer';
	var ArrayBuffer$3 = arrayBuffer[ARRAY_BUFFER];
	var NativeArrayBuffer = global_1[ARRAY_BUFFER];

	// `ArrayBuffer` constructor
	// https://tc39.es/ecma262/#sec-arraybuffer-constructor
	_export({ global: true, forced: NativeArrayBuffer !== ArrayBuffer$3 }, {
	  ArrayBuffer: ArrayBuffer$3
	});

	setSpecies(ARRAY_BUFFER);

	var defineProperty$d = objectDefineProperty.f;






	var Int8Array$4 = global_1.Int8Array;
	var Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;
	var Uint8ClampedArray$1 = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
	var TypedArray = Int8Array$4 && objectGetPrototypeOf(Int8Array$4);
	var TypedArrayPrototype$1 = Int8ArrayPrototype$1 && objectGetPrototypeOf(Int8ArrayPrototype$1);
	var ObjectPrototype$1 = Object.prototype;
	var TypeError$s = global_1.TypeError;

	var TO_STRING_TAG$5 = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
	var TYPED_ARRAY_CONSTRUCTOR$5 = uid('TYPED_ARRAY_CONSTRUCTOR');
	// Fixing native typed arrays in Opera Presto crashes the browser, see #595
	var NATIVE_ARRAY_BUFFER_VIEWS$2 = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQUIRED = false;
	var NAME$1, Constructor, Prototype;

	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};

	var BigIntArrayConstructorsList = {
	  BigInt64Array: 8,
	  BigUint64Array: 8
	};

	var isView = function isView(it) {
	  if (!isObject$2(it)) return false;
	  var klass = classof(it);
	  return klass === 'DataView'
	    || hasOwnProperty_1(TypedArrayConstructorsList, klass)
	    || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
	};

	var isTypedArray$1 = function (it) {
	  if (!isObject$2(it)) return false;
	  var klass = classof(it);
	  return hasOwnProperty_1(TypedArrayConstructorsList, klass)
	    || hasOwnProperty_1(BigIntArrayConstructorsList, klass);
	};

	var aTypedArray$x = function (it) {
	  if (isTypedArray$1(it)) return it;
	  throw TypeError$s('Target is not a typed array');
	};

	var aTypedArrayConstructor$4 = function (C) {
	  if (isCallable(C) && (!objectSetPrototypeOf || objectIsPrototypeOf(TypedArray, C))) return C;
	  throw TypeError$s(tryToString(C) + ' is not a typed array constructor');
	};

	var exportTypedArrayMethod$y = function (KEY, property, forced, options) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor.prototype, KEY)) try {
	      delete TypedArrayConstructor.prototype[KEY];
	    } catch (error) {
	      // old WebKit bug - some methods are non-configurable
	      try {
	        TypedArrayConstructor.prototype[KEY] = property;
	      } catch (error2) { /* empty */ }
	    }
	  }
	  if (!TypedArrayPrototype$1[KEY] || forced) {
	    redefine(TypedArrayPrototype$1, KEY, forced ? property
	      : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);
	  }
	};

	var exportTypedArrayStaticMethod$3 = function (KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;
	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];
	      if (TypedArrayConstructor && hasOwnProperty_1(TypedArrayConstructor, KEY)) try {
	        delete TypedArrayConstructor[KEY];
	      } catch (error) { /* empty */ }
	    }
	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray[KEY] || property);
	      } catch (error) { /* empty */ }
	    } else return;
	  }
	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME$1 in TypedArrayConstructorsList) {
	  Constructor = global_1[NAME$1];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR$5, Constructor);
	  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
	}

	for (NAME$1 in BigIntArrayConstructorsList) {
	  Constructor = global_1[NAME$1];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR$5, Constructor);
	}

	// WebKit bug - typed arrays constructors prototype is Object.prototype
	if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable(TypedArray) || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow -- safe
	  TypedArray = function TypedArray() {
	    throw TypeError$s('Incorrect invocation');
	  };
	  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME$1 in TypedArrayConstructorsList) {
	    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1], TypedArray);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {
	  TypedArrayPrototype$1 = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME$1 in TypedArrayConstructorsList) {
	    if (global_1[NAME$1]) objectSetPrototypeOf(global_1[NAME$1].prototype, TypedArrayPrototype$1);
	  }
	}

	// WebKit bug - one more object in Uint8ClampedArray prototype chain
	if (NATIVE_ARRAY_BUFFER_VIEWS$2 && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);
	}

	if (descriptors && !hasOwnProperty_1(TypedArrayPrototype$1, TO_STRING_TAG$5)) {
	  TYPED_ARRAY_TAG_REQUIRED = true;
	  defineProperty$d(TypedArrayPrototype$1, TO_STRING_TAG$5, { get: function () {
	    return isObject$2(this) ? this[TYPED_ARRAY_TAG] : undefined;
	  } });
	  for (NAME$1 in TypedArrayConstructorsList) if (global_1[NAME$1]) {
	    createNonEnumerableProperty(global_1[NAME$1], TYPED_ARRAY_TAG, NAME$1);
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
	  TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR$5,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray$x,
	  aTypedArrayConstructor: aTypedArrayConstructor$4,
	  exportTypedArrayMethod: exportTypedArrayMethod$y,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$3,
	  isView: isView,
	  isTypedArray: isTypedArray$1,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype$1
	};

	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	// `ArrayBuffer.isView` method
	// https://tc39.es/ecma262/#sec-arraybuffer.isview
	_export({ target: 'ArrayBuffer', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS$1 }, {
	  isView: arrayBufferViewCore.isView
	});

	var TypeError$r = global_1.TypeError;

	// `Assert: IsConstructor(argument) is true`
	var aConstructor = function (argument) {
	  if (isConstructor(argument)) return argument;
	  throw TypeError$r(tryToString(argument) + ' is not a constructor');
	};

	var SPECIES$2 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$2]) == undefined ? defaultConstructor : aConstructor(S);
	};

	var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
	var DataView$2 = arrayBuffer.DataView;
	var DataViewPrototype = DataView$2.prototype;
	var un$ArrayBufferSlice = functionUncurryThis(ArrayBuffer$2.prototype.slice);
	var getUint8 = functionUncurryThis(DataViewPrototype.getUint8);
	var setUint8 = functionUncurryThis(DataViewPrototype.setUint8);

	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
	});

	// `ArrayBuffer.prototype.slice` method
	// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
	_export({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
	  slice: function slice(start, end) {
	    if (un$ArrayBufferSlice && end === undefined) {
	      return un$ArrayBufferSlice(anObject(this), start); // FF fix
	    }
	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
	    var viewSource = new DataView$2(this);
	    var viewTarget = new DataView$2(result);
	    var index = 0;
	    while (first < fin) {
	      setUint8(viewTarget, index++, getUint8(viewSource, first++));
	    } return result;
	  }
	});

	// `DataView` constructor
	// https://tc39.es/ecma262/#sec-dataview-constructor
	_export({ global: true, forced: !arrayBufferNative }, {
	  DataView: arrayBuffer.DataView
	});

	var FORCED$h = fails(function () {
	  return new Date(16e11).getYear() !== 120;
	});

	var getFullYear = functionUncurryThis(Date.prototype.getFullYear);

	// `Date.prototype.getYear` method
	// https://tc39.es/ecma262/#sec-date.prototype.getyear
	_export({ target: 'Date', proto: true, forced: FORCED$h }, {
	  getYear: function getYear() {
	    return getFullYear(this) - 1900;
	  }
	});

	// TODO: Remove from `core-js@4`




	var Date$2 = global_1.Date;
	var getTime$4 = functionUncurryThis(Date$2.prototype.getTime);

	// `Date.now` method
	// https://tc39.es/ecma262/#sec-date.now
	_export({ target: 'Date', stat: true }, {
	  now: function now() {
	    return getTime$4(new Date$2());
	  }
	});

	var DatePrototype$3 = Date.prototype;
	var getTime$3 = functionUncurryThis(DatePrototype$3.getTime);
	var setFullYear = functionUncurryThis(DatePrototype$3.setFullYear);

	// `Date.prototype.setYear` method
	// https://tc39.es/ecma262/#sec-date.prototype.setyear
	_export({ target: 'Date', proto: true }, {
	  setYear: function setYear(year) {
	    // validate
	    getTime$3(this);
	    var yi = toIntegerOrInfinity(year);
	    var yyyy = 0 <= yi && yi <= 99 ? yi + 1900 : yi;
	    return setFullYear(this, yyyy);
	  }
	});

	// `Date.prototype.toGMTString` method
	// https://tc39.es/ecma262/#sec-date.prototype.togmtstring
	_export({ target: 'Date', proto: true }, {
	  toGMTString: Date.prototype.toUTCString
	});

	var RangeError$c = global_1.RangeError;

	// `String.prototype.repeat` method implementation
	// https://tc39.es/ecma262/#sec-string.prototype.repeat
	var stringRepeat = function repeat(count) {
	  var str = toString_1$1(requireObjectCoercible(this));
	  var result = '';
	  var n = toIntegerOrInfinity(count);
	  if (n < 0 || n == Infinity) throw RangeError$c('Wrong number of repetitions');
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
	  return result;
	};

	// https://github.com/tc39/proposal-string-pad-start-end






	var repeat$2 = functionUncurryThis(stringRepeat);
	var stringSlice$f = functionUncurryThis(''.slice);
	var ceil$1 = Math.ceil;

	// `String.prototype.{ padStart, padEnd }` methods implementation
	var createMethod$5 = function (IS_END) {
	  return function ($this, maxLength, fillString) {
	    var S = toString_1$1(requireObjectCoercible($this));
	    var intMaxLength = toLength(maxLength);
	    var stringLength = S.length;
	    var fillStr = fillString === undefined ? ' ' : toString_1$1(fillString);
	    var fillLen, stringFiller;
	    if (intMaxLength <= stringLength || fillStr == '') return S;
	    fillLen = intMaxLength - stringLength;
	    stringFiller = repeat$2(fillStr, ceil$1(fillLen / fillStr.length));
	    if (stringFiller.length > fillLen) stringFiller = stringSlice$f(stringFiller, 0, fillLen);
	    return IS_END ? S + stringFiller : stringFiller + S;
	  };
	};

	var stringPad = {
	  // `String.prototype.padStart` method
	  // https://tc39.es/ecma262/#sec-string.prototype.padstart
	  start: createMethod$5(false),
	  // `String.prototype.padEnd` method
	  // https://tc39.es/ecma262/#sec-string.prototype.padend
	  end: createMethod$5(true)
	};

	var padStart = stringPad.start;

	var RangeError$b = global_1.RangeError;
	var abs$7 = Math.abs;
	var DatePrototype$2 = Date.prototype;
	var n$DateToISOString = DatePrototype$2.toISOString;
	var getTime$2 = functionUncurryThis(DatePrototype$2.getTime);
	var getUTCDate = functionUncurryThis(DatePrototype$2.getUTCDate);
	var getUTCFullYear = functionUncurryThis(DatePrototype$2.getUTCFullYear);
	var getUTCHours = functionUncurryThis(DatePrototype$2.getUTCHours);
	var getUTCMilliseconds = functionUncurryThis(DatePrototype$2.getUTCMilliseconds);
	var getUTCMinutes = functionUncurryThis(DatePrototype$2.getUTCMinutes);
	var getUTCMonth = functionUncurryThis(DatePrototype$2.getUTCMonth);
	var getUTCSeconds = functionUncurryThis(DatePrototype$2.getUTCSeconds);

	// `Date.prototype.toISOString` method implementation
	// https://tc39.es/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit fails here:
	var dateToIsoString = (fails(function () {
	  return n$DateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  n$DateToISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime$2(this))) throw RangeError$b('Invalid time value');
	  var date = this;
	  var year = getUTCFullYear(date);
	  var milliseconds = getUTCMilliseconds(date);
	  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
	  return sign + padStart(abs$7(year), sign ? 6 : 4, 0) +
	    '-' + padStart(getUTCMonth(date) + 1, 2, 0) +
	    '-' + padStart(getUTCDate(date), 2, 0) +
	    'T' + padStart(getUTCHours(date), 2, 0) +
	    ':' + padStart(getUTCMinutes(date), 2, 0) +
	    ':' + padStart(getUTCSeconds(date), 2, 0) +
	    '.' + padStart(milliseconds, 3, 0) +
	    'Z';
	} : n$DateToISOString;

	// `Date.prototype.toISOString` method
	// https://tc39.es/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit has a broken implementations
	_export({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== dateToIsoString }, {
	  toISOString: dateToIsoString
	});

	var FORCED$g = fails(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	});

	// `Date.prototype.toJSON` method
	// https://tc39.es/ecma262/#sec-date.prototype.tojson
	_export({ target: 'Date', proto: true, forced: FORCED$g }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O, 'number');
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	var TypeError$q = global_1.TypeError;

	// `Date.prototype[@@toPrimitive](hint)` method implementation
	// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
	var dateToPrimitive = function (hint) {
	  anObject(this);
	  if (hint === 'string' || hint === 'default') hint = 'string';
	  else if (hint !== 'number') throw TypeError$q('Incorrect hint');
	  return ordinaryToPrimitive(this, hint);
	};

	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var DatePrototype$1 = Date.prototype;

	// `Date.prototype[@@toPrimitive]` method
	// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
	if (!hasOwnProperty_1(DatePrototype$1, TO_PRIMITIVE)) {
	  redefine(DatePrototype$1, TO_PRIMITIVE, dateToPrimitive);
	}

	// TODO: Remove from `core-js@4`



	var DatePrototype = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING$1 = 'toString';
	var un$DateToString = functionUncurryThis(DatePrototype[TO_STRING$1]);
	var getTime$1 = functionUncurryThis(DatePrototype.getTime);

	// `Date.prototype.toString` method
	// https://tc39.es/ecma262/#sec-date.prototype.tostring
	if (String(new Date(NaN)) != INVALID_DATE) {
	  redefine(DatePrototype, TO_STRING$1, function toString() {
	    var value = getTime$1(this);
	    // eslint-disable-next-line no-self-compare -- NaN check
	    return value === value ? un$DateToString(this) : INVALID_DATE;
	  });
	}

	var charAt$g = functionUncurryThis(''.charAt);
	var charCodeAt$4 = functionUncurryThis(''.charCodeAt);
	var exec$9 = functionUncurryThis(/./.exec);
	var numberToString$2 = functionUncurryThis(1.0.toString);
	var toUpperCase = functionUncurryThis(''.toUpperCase);

	var raw = /[\w*+\-./@]/;

	var hex$1 = function (code, length) {
	  var result = numberToString$2(code, 16);
	  while (result.length < length) result = '0' + result;
	  return result;
	};

	// `escape` method
	// https://tc39.es/ecma262/#sec-escape-string
	_export({ global: true }, {
	  escape: function escape(string) {
	    var str = toString_1$1(string);
	    var result = '';
	    var length = str.length;
	    var index = 0;
	    var chr, code;
	    while (index < length) {
	      chr = charAt$g(str, index++);
	      if (exec$9(raw, chr)) {
	        result += chr;
	      } else {
	        code = charCodeAt$4(chr, 0);
	        if (code < 256) {
	          result += '%' + hex$1(code, 2);
	        } else {
	          result += '%u' + toUpperCase(hex$1(code, 4));
	        }
	      }
	    } return result;
	  }
	});

	var Function$3 = global_1.Function;
	var concat$3 = functionUncurryThis([].concat);
	var join$7 = functionUncurryThis([].join);
	var factories = {};

	var construct = function (C, argsLength, args) {
	  if (!hasOwnProperty_1(factories, argsLength)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
	    factories[argsLength] = Function$3('C,a', 'return new C(' + join$7(list, ',') + ')');
	  } return factories[argsLength](C, args);
	};

	// `Function.prototype.bind` method implementation
	// https://tc39.es/ecma262/#sec-function.prototype.bind
	var functionBind = functionBindNative ? Function$3.bind : function bind(that /* , ...args */) {
	  var F = aCallable(this);
	  var Prototype = F.prototype;
	  var partArgs = arraySlice$1(arguments, 1);
	  var boundFunction = function bound(/* args... */) {
	    var args = concat$3(partArgs, arraySlice$1(arguments));
	    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
	  };
	  if (isObject$2(Prototype)) boundFunction.prototype = Prototype;
	  return boundFunction;
	};

	// TODO: Remove from `core-js@4`



	// `Function.prototype.bind` method
	// https://tc39.es/ecma262/#sec-function.prototype.bind
	_export({ target: 'Function', proto: true, forced: Function.bind !== functionBind }, {
	  bind: functionBind
	});

	var HAS_INSTANCE = wellKnownSymbol('hasInstance');
	var FunctionPrototype$1 = Function.prototype;

	// `Function.prototype[@@hasInstance]` method
	// https://tc39.es/ecma262/#sec-function.prototype-@@hasinstance
	if (!(HAS_INSTANCE in FunctionPrototype$1)) {
	  objectDefineProperty.f(FunctionPrototype$1, HAS_INSTANCE, { value: function (O) {
	    if (!isCallable(this) || !isObject$2(O)) return false;
	    var P = this.prototype;
	    if (!isObject$2(P)) return O instanceof this;
	    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	    while (O = objectGetPrototypeOf(O)) if (P === O) return true;
	    return false;
	  } });
	}

	var FUNCTION_NAME_EXISTS = functionName.EXISTS;

	var defineProperty$c = objectDefineProperty.f;

	var FunctionPrototype = Function.prototype;
	var functionToString = functionUncurryThis(FunctionPrototype.toString);
	var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
	var regExpExec = functionUncurryThis(nameRE.exec);
	var NAME = 'name';

	// Function instances `.name` property
	// https://tc39.es/ecma262/#sec-function-instances-name
	if (descriptors && !FUNCTION_NAME_EXISTS) {
	  defineProperty$c(FunctionPrototype, NAME, {
	    configurable: true,
	    get: function () {
	      try {
	        return regExpExec(nameRE, functionToString(this))[1];
	      } catch (error) {
	        return '';
	      }
	    }
	  });
	}

	// `globalThis` object
	// https://tc39.es/ecma262/#sec-globalthis
	_export({ global: true }, {
	  globalThis: global_1
	});

	// JSON[@@toStringTag] property
	// https://tc39.es/ecma262/#sec-json-@@tostringtag
	setToStringTag(global_1.JSON, 'JSON', true);

	// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it


	var arrayBufferNonExtensible = fails(function () {
	  if (typeof ArrayBuffer == 'function') {
	    var buffer = new ArrayBuffer(8);
	    // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-defineproperty -- safe
	    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
	  }
	});

	// eslint-disable-next-line es-x/no-object-isextensible -- safe
	var $isExtensible = Object.isExtensible;
	var FAILS_ON_PRIMITIVES$9 = fails(function () { $isExtensible(1); });

	// `Object.isExtensible` method
	// https://tc39.es/ecma262/#sec-object.isextensible
	var objectIsExtensible = (FAILS_ON_PRIMITIVES$9 || arrayBufferNonExtensible) ? function isExtensible(it) {
	  if (!isObject$2(it)) return false;
	  if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return false;
	  return $isExtensible ? $isExtensible(it) : true;
	} : $isExtensible;

	var freezing = !fails(function () {
	  // eslint-disable-next-line es-x/no-object-isextensible, es-x/no-object-preventextensions -- required for testing
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = objectDefineProperty.f;






	var REQUIRED = false;
	var METADATA = uid('meta');
	var id = 0;

	var setMetadata = function (it) {
	  defineProperty(it, METADATA, { value: {
	    objectID: 'O' + id++, // object ID
	    weakData: {}          // weak collections IDs
	  } });
	};

	var fastKey = function (it, create) {
	  // return a primitive with prefix
	  if (!isObject$2(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!hasOwnProperty_1(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!objectIsExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMetadata(it);
	  // return object ID
	  } return it[METADATA].objectID;
	};

	var getWeakData = function (it, create) {
	  if (!hasOwnProperty_1(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!objectIsExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMetadata(it);
	  // return the store of weak collections IDs
	  } return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (freezing && REQUIRED && objectIsExtensible(it) && !hasOwnProperty_1(it, METADATA)) setMetadata(it);
	  return it;
	};

	var enable = function () {
	  meta.enable = function () { /* empty */ };
	  REQUIRED = true;
	  var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	  var splice = functionUncurryThis([].splice);
	  var test = {};
	  test[METADATA] = 1;

	  // prevent exposing of metadata key
	  if (getOwnPropertyNames(test).length) {
	    objectGetOwnPropertyNames.f = function (it) {
	      var result = getOwnPropertyNames(it);
	      for (var i = 0, length = result.length; i < length; i++) {
	        if (result[i] === METADATA) {
	          splice(result, i, 1);
	          break;
	        }
	      } return result;
	    };

	    _export({ target: 'Object', stat: true, forced: true }, {
	      getOwnPropertyNames: objectGetOwnPropertyNamesExternal.f
	    });
	  }
	};

	var meta = module.exports = {
	  enable: enable,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys$1[METADATA] = true;
	});
	internalMetadata.enable;
	internalMetadata.fastKey;
	internalMetadata.getWeakData;
	internalMetadata.onFreeze;

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var Constructor = NativeConstructor;
	  var exported = {};

	  var fixMethod = function (KEY) {
	    var uncurriedNativeMethod = functionUncurryThis(NativePrototype[KEY]);
	    redefine(NativePrototype, KEY,
	      KEY == 'add' ? function add(value) {
	        uncurriedNativeMethod(this, value === 0 ? 0 : value);
	        return this;
	      } : KEY == 'delete' ? function (key) {
	        return IS_WEAK && !isObject$2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
	      } : KEY == 'get' ? function get(key) {
	        return IS_WEAK && !isObject$2(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
	      } : KEY == 'has' ? function has(key) {
	        return IS_WEAK && !isObject$2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
	      } : function set(key, value) {
	        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
	        return this;
	      }
	    );
	  };

	  var REPLACE = isForced_1(
	    CONSTRUCTOR_NAME,
	    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
	      new NativeConstructor().entries().next();
	    }))
	  );

	  if (REPLACE) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.enable();
	  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
	    var instance = new Constructor();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    // eslint-disable-next-line no-new -- required for testing
	    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new NativeConstructor();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });

	    if (!ACCEPT_ITERABLES) {
	      Constructor = wrapper(function (dummy, iterable) {
	        anInstance(dummy, NativePrototype);
	        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
	        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
	        return that;
	      });
	      Constructor.prototype = NativePrototype;
	      NativePrototype.constructor = Constructor;
	    }

	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }

	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

	    // weak collections should not contains .clear method
	    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
	  }

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({ global: true, forced: Constructor != NativeConstructor }, exported);

	  setToStringTag(Constructor, CONSTRUCTOR_NAME);

	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

	  return Constructor;
	};

	var defineProperty$b = objectDefineProperty.f;








	var fastKey = internalMetadata.fastKey;


	var setInternalState$f = internalState.set;
	var internalStateGetterFor$1 = internalState.getterFor;

	var collectionStrong = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var Constructor = wrapper(function (that, iterable) {
	      anInstance(that, Prototype);
	      setInternalState$f(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
	    });

	    var Prototype = Constructor.prototype;

	    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index;
	      // change existing entry
	      if (entry) {
	        entry.value = value;
	      // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;
	        else that.size++;
	        // add to index
	        if (index !== 'F') state.index[index] = entry;
	      } return that;
	    };

	    var getEntry = function (that, key) {
	      var state = getInternalState(that);
	      // fast case
	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index];
	      // frozen object case
	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };

	    redefineAll(Prototype, {
	      // `{ Map, Set }.prototype.clear()` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.clear
	      // https://tc39.es/ecma262/#sec-set.prototype.clear
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;
	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }
	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;
	        else that.size = 0;
	      },
	      // `{ Map, Set }.prototype.delete(key)` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.delete
	      // https://tc39.es/ecma262/#sec-set.prototype.delete
	      'delete': function (key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;
	          else that.size--;
	        } return !!entry;
	      },
	      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.foreach
	      // https://tc39.es/ecma262/#sec-set.prototype.foreach
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        var state = getInternalState(this);
	        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	        var entry;
	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this);
	          // revert to the last existing entry
	          while (entry && entry.removed) entry = entry.previous;
	        }
	      },
	      // `{ Map, Set}.prototype.has(key)` methods
	      // https://tc39.es/ecma262/#sec-map.prototype.has
	      // https://tc39.es/ecma262/#sec-set.prototype.has
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });

	    redefineAll(Prototype, IS_MAP ? {
	      // `Map.prototype.get(key)` method
	      // https://tc39.es/ecma262/#sec-map.prototype.get
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // `Map.prototype.set(key, value)` method
	      // https://tc39.es/ecma262/#sec-map.prototype.set
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // `Set.prototype.add(value)` method
	      // https://tc39.es/ecma262/#sec-set.prototype.add
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$b(Prototype, 'size', {
	      get: function () {
	        return getInternalState(this).size;
	      }
	    });
	    return Constructor;
	  },
	  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);
	    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
	    // https://tc39.es/ecma262/#sec-map.prototype.entries
	    // https://tc39.es/ecma262/#sec-map.prototype.keys
	    // https://tc39.es/ecma262/#sec-map.prototype.values
	    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
	    // https://tc39.es/ecma262/#sec-set.prototype.entries
	    // https://tc39.es/ecma262/#sec-set.prototype.keys
	    // https://tc39.es/ecma262/#sec-set.prototype.values
	    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
	    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$f(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last;
	      // revert to the last existing entry
	      while (entry && entry.removed) entry = entry.previous;
	      // get next entry
	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return { value: undefined, done: true };
	      }
	      // return step by kind
	      if (kind == 'keys') return { value: entry.key, done: false };
	      if (kind == 'values') return { value: entry.value, done: false };
	      return { value: [entry.key, entry.value], done: false };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // `{ Map, Set }.prototype[@@species]` accessors
	    // https://tc39.es/ecma262/#sec-get-map-@@species
	    // https://tc39.es/ecma262/#sec-get-set-@@species
	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};
	collectionStrong.getConstructor;
	collectionStrong.setStrong;

	// `Map` constructor
	// https://tc39.es/ecma262/#sec-map-objects
	collection('Map', function (init) {
	  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	var log$7 = Math.log;

	// `Math.log1p` method implementation
	// https://tc39.es/ecma262/#sec-math.log1p
	// eslint-disable-next-line es-x/no-math-log1p -- safe
	var mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$7(1 + x);
	};

	// eslint-disable-next-line es-x/no-math-acosh -- required for testing
	var $acosh = Math.acosh;
	var log$6 = Math.log;
	var sqrt$2 = Math.sqrt;
	var LN2$1 = Math.LN2;

	var FORCED$f = !$acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  || Math.floor($acosh(Number.MAX_VALUE)) != 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  || $acosh(Infinity) != Infinity;

	// `Math.acosh` method
	// https://tc39.es/ecma262/#sec-math.acosh
	_export({ target: 'Math', stat: true, forced: FORCED$f }, {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? log$6(x) + LN2$1
	      : mathLog1p(x - 1 + sqrt$2(x - 1) * sqrt$2(x + 1));
	  }
	});

	// eslint-disable-next-line es-x/no-math-asinh -- required for testing
	var $asinh = Math.asinh;
	var log$5 = Math.log;
	var sqrt$1 = Math.sqrt;

	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log$5(x + sqrt$1(x * x + 1));
	}

	// `Math.asinh` method
	// https://tc39.es/ecma262/#sec-math.asinh
	// Tor Browser bug: Math.asinh(0) -> -0
	_export({ target: 'Math', stat: true, forced: !($asinh && 1 / $asinh(0) > 0) }, {
	  asinh: asinh
	});

	// eslint-disable-next-line es-x/no-math-atanh -- required for testing
	var $atanh = Math.atanh;
	var log$4 = Math.log;

	// `Math.atanh` method
	// https://tc39.es/ecma262/#sec-math.atanh
	// Tor Browser bug: Math.atanh(-0) -> 0
	_export({ target: 'Math', stat: true, forced: !($atanh && 1 / $atanh(-0) < 0) }, {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : log$4((1 + x) / (1 - x)) / 2;
	  }
	});

	// `Math.sign` method implementation
	// https://tc39.es/ecma262/#sec-math.sign
	// eslint-disable-next-line es-x/no-math-sign -- safe
	var mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var abs$6 = Math.abs;
	var pow$4 = Math.pow;

	// `Math.cbrt` method
	// https://tc39.es/ecma262/#sec-math.cbrt
	_export({ target: 'Math', stat: true }, {
	  cbrt: function cbrt(x) {
	    return mathSign(x = +x) * pow$4(abs$6(x), 1 / 3);
	  }
	});

	var floor$8 = Math.floor;
	var log$3 = Math.log;
	var LOG2E = Math.LOG2E;

	// `Math.clz32` method
	// https://tc39.es/ecma262/#sec-math.clz32
	_export({ target: 'Math', stat: true }, {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - floor$8(log$3(x + 0.5) * LOG2E) : 32;
	  }
	});

	// eslint-disable-next-line es-x/no-math-expm1 -- safe
	var $expm1 = Math.expm1;
	var exp$2 = Math.exp;

	// `Math.expm1` method implementation
	// https://tc39.es/ecma262/#sec-math.expm1
	var mathExpm1 = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp$2(x) - 1;
	} : $expm1;

	// eslint-disable-next-line es-x/no-math-cosh -- required for testing
	var $cosh = Math.cosh;
	var abs$5 = Math.abs;
	var E$1 = Math.E;

	// `Math.cosh` method
	// https://tc39.es/ecma262/#sec-math.cosh
	_export({ target: 'Math', stat: true, forced: !$cosh || $cosh(710) === Infinity }, {
	  cosh: function cosh(x) {
	    var t = mathExpm1(abs$5(x) - 1) + 1;
	    return (t + 1 / (t * E$1 * E$1)) * (E$1 / 2);
	  }
	});

	// `Math.expm1` method
	// https://tc39.es/ecma262/#sec-math.expm1
	// eslint-disable-next-line es-x/no-math-expm1 -- required for testing
	_export({ target: 'Math', stat: true, forced: mathExpm1 != Math.expm1 }, { expm1: mathExpm1 });

	var abs$4 = Math.abs;
	var pow$3 = Math.pow;
	var EPSILON = pow$3(2, -52);
	var EPSILON32 = pow$3(2, -23);
	var MAX32 = pow$3(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$3(2, -126);

	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	// `Math.fround` method implementation
	// https://tc39.es/ecma262/#sec-math.fround
	// eslint-disable-next-line es-x/no-math-fround -- safe
	var mathFround = Math.fround || function fround(x) {
	  var $abs = abs$4(x);
	  var $sign = mathSign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare -- NaN check
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	// `Math.fround` method
	// https://tc39.es/ecma262/#sec-math.fround
	_export({ target: 'Math', stat: true }, { fround: mathFround });

	// eslint-disable-next-line es-x/no-math-hypot -- required for testing
	var $hypot = Math.hypot;
	var abs$3 = Math.abs;
	var sqrt = Math.sqrt;

	// Chrome 77 bug
	// https://bugs.chromium.org/p/v8/issues/detail?id=9546
	var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;

	// `Math.hypot` method
	// https://tc39.es/ecma262/#sec-math.hypot
	_export({ target: 'Math', stat: true, forced: BUGGY }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  hypot: function hypot(value1, value2) {
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$3(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * sqrt(sum);
	  }
	});

	// eslint-disable-next-line es-x/no-math-imul -- required for testing
	var $imul = Math.imul;

	var FORCED$e = fails(function () {
	  return $imul(0xFFFFFFFF, 5) != -5 || $imul.length != 2;
	});

	// `Math.imul` method
	// https://tc39.es/ecma262/#sec-math.imul
	// some WebKit versions fails with big numbers, some has wrong arity
	_export({ target: 'Math', stat: true, forced: FORCED$e }, {
	  imul: function imul(x, y) {
	    var UINT16 = 0xFFFF;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	var log$2 = Math.log;
	var LOG10E = Math.LOG10E;

	// eslint-disable-next-line es-x/no-math-log10 -- safe
	var mathLog10 = Math.log10 || function log10(x) {
	  return log$2(x) * LOG10E;
	};

	// `Math.log10` method
	// https://tc39.es/ecma262/#sec-math.log10
	_export({ target: 'Math', stat: true }, {
	  log10: mathLog10
	});

	// `Math.log1p` method
	// https://tc39.es/ecma262/#sec-math.log1p
	_export({ target: 'Math', stat: true }, { log1p: mathLog1p });

	var log$1 = Math.log;
	var LN2 = Math.LN2;

	// `Math.log2` method
	// https://tc39.es/ecma262/#sec-math.log2
	_export({ target: 'Math', stat: true }, {
	  log2: function log2(x) {
	    return log$1(x) / LN2;
	  }
	});

	// `Math.sign` method
	// https://tc39.es/ecma262/#sec-math.sign
	_export({ target: 'Math', stat: true }, {
	  sign: mathSign
	});

	var abs$2 = Math.abs;
	var exp$1 = Math.exp;
	var E = Math.E;

	var FORCED$d = fails(function () {
	  // eslint-disable-next-line es-x/no-math-sinh -- required for testing
	  return Math.sinh(-2e-17) != -2e-17;
	});

	// `Math.sinh` method
	// https://tc39.es/ecma262/#sec-math.sinh
	// V8 near Chromium 38 has a problem with very small numbers
	_export({ target: 'Math', stat: true, forced: FORCED$d }, {
	  sinh: function sinh(x) {
	    return abs$2(x = +x) < 1 ? (mathExpm1(x) - mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (E / 2);
	  }
	});

	var exp = Math.exp;

	// `Math.tanh` method
	// https://tc39.es/ecma262/#sec-math.tanh
	_export({ target: 'Math', stat: true }, {
	  tanh: function tanh(x) {
	    var a = mathExpm1(x = +x);
	    var b = mathExpm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

	// Math[@@toStringTag] property
	// https://tc39.es/ecma262/#sec-math-@@tostringtag
	setToStringTag(Math, 'Math', true);

	var ceil = Math.ceil;
	var floor$7 = Math.floor;

	// `Math.trunc` method
	// https://tc39.es/ecma262/#sec-math.trunc
	_export({ target: 'Math', stat: true }, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$7 : ceil)(it);
	  }
	});

	// `thisNumberValue` abstract operation
	// https://tc39.es/ecma262/#sec-thisnumbervalue
	var thisNumberValue = functionUncurryThis(1.0.valueOf);

	// a string of all valid unicode whitespaces
	var whitespaces$1 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
	  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var replace$8 = functionUncurryThis(''.replace);
	var whitespace = '[' + whitespaces$1 + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$4 = function (TYPE) {
	  return function ($this) {
	    var string = toString_1$1(requireObjectCoercible($this));
	    if (TYPE & 1) string = replace$8(string, ltrim, '');
	    if (TYPE & 2) string = replace$8(string, rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$4(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimend
	  end: createMethod$4(2),
	  // `String.prototype.trim` method
	  // https://tc39.es/ecma262/#sec-string.prototype.trim
	  trim: createMethod$4(3)
	};

	var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$a = objectDefineProperty.f;

	var trim$2 = stringTrim.trim;

	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype;
	var TypeError$p = global_1.TypeError;
	var arraySlice = functionUncurryThis(''.slice);
	var charCodeAt$3 = functionUncurryThis(''.charCodeAt);

	// `ToNumeric` abstract operation
	// https://tc39.es/ecma262/#sec-tonumeric
	var toNumeric = function (value) {
	  var primValue = toPrimitive(value, 'number');
	  return typeof primValue == 'bigint' ? primValue : toNumber$1(primValue);
	};

	// `ToNumber` abstract operation
	// https://tc39.es/ecma262/#sec-tonumber
	var toNumber$1 = function (argument) {
	  var it = toPrimitive(argument, 'number');
	  var first, third, radix, maxCode, digits, length, index, code;
	  if (isSymbol$1(it)) throw TypeError$p('Cannot convert a Symbol value to a number');
	  if (typeof it == 'string' && it.length > 2) {
	    it = trim$2(it);
	    first = charCodeAt$3(it, 0);
	    if (first === 43 || first === 45) {
	      third = charCodeAt$3(it, 2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (charCodeAt$3(it, 1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
	        default: return +it;
	      }
	      digits = arraySlice(it, 2);
	      length = digits.length;
	      for (index = 0; index < length; index++) {
	        code = charCodeAt$3(digits, index);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};

	// `Number` constructor
	// https://tc39.es/ecma262/#sec-number-constructor
	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
	    var dummy = this;
	    // check on 1..constructor(foo) case
	    return objectIsPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); })
	      ? inheritIfRequired(Object(n), dummy, NumberWrapper) : n;
	  };
	  for (var keys$2 = descriptors ? getOwnPropertyNames$2(NativeNumber) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES2015 (in case, if modules with ES2015 Number statics required before):
	    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
	    // ESNext
	    'fromString,range'
	  ).split(','), j = 0, key$2; keys$2.length > j; j++) {
	    if (hasOwnProperty_1(NativeNumber, key$2 = keys$2[j]) && !hasOwnProperty_1(NumberWrapper, key$2)) {
	      defineProperty$a(NumberWrapper, key$2, getOwnPropertyDescriptor$7(NativeNumber, key$2));
	    }
	  }
	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	// `Number.EPSILON` constant
	// https://tc39.es/ecma262/#sec-number.epsilon
	_export({ target: 'Number', stat: true }, {
	  EPSILON: Math.pow(2, -52)
	});

	var globalIsFinite = global_1.isFinite;

	// `Number.isFinite` method
	// https://tc39.es/ecma262/#sec-number.isfinite
	// eslint-disable-next-line es-x/no-number-isfinite -- safe
	var numberIsFinite = Number.isFinite || function isFinite(it) {
	  return typeof it == 'number' && globalIsFinite(it);
	};

	// `Number.isFinite` method
	// https://tc39.es/ecma262/#sec-number.isfinite
	_export({ target: 'Number', stat: true }, { isFinite: numberIsFinite });

	var floor$6 = Math.floor;

	// `IsIntegralNumber` abstract operation
	// https://tc39.es/ecma262/#sec-isintegralnumber
	// eslint-disable-next-line es-x/no-number-isinteger -- safe
	var isIntegralNumber = Number.isInteger || function isInteger(it) {
	  return !isObject$2(it) && isFinite(it) && floor$6(it) === it;
	};

	// `Number.isInteger` method
	// https://tc39.es/ecma262/#sec-number.isinteger
	_export({ target: 'Number', stat: true }, {
	  isInteger: isIntegralNumber
	});

	// `Number.isNaN` method
	// https://tc39.es/ecma262/#sec-number.isnan
	_export({ target: 'Number', stat: true }, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare -- NaN check
	    return number != number;
	  }
	});

	var abs$1 = Math.abs;

	// `Number.isSafeInteger` method
	// https://tc39.es/ecma262/#sec-number.issafeinteger
	_export({ target: 'Number', stat: true }, {
	  isSafeInteger: function isSafeInteger(number) {
	    return isIntegralNumber(number) && abs$1(number) <= 0x1FFFFFFFFFFFFF;
	  }
	});

	// `Number.MAX_SAFE_INTEGER` constant
	// https://tc39.es/ecma262/#sec-number.max_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	// `Number.MIN_SAFE_INTEGER` constant
	// https://tc39.es/ecma262/#sec-number.min_safe_integer
	_export({ target: 'Number', stat: true }, {
	  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
	});

	var trim$1 = stringTrim.trim;


	var charAt$f = functionUncurryThis(''.charAt);
	var n$ParseFloat = global_1.parseFloat;
	var Symbol$2 = global_1.Symbol;
	var ITERATOR$5 = Symbol$2 && Symbol$2.iterator;
	var FORCED$c = 1 / n$ParseFloat(whitespaces$1 + '-0') !== -Infinity
	  // MS Edge 18- broken with boxed symbols
	  || (ITERATOR$5 && !fails(function () { n$ParseFloat(Object(ITERATOR$5)); }));

	// `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string
	var numberParseFloat = FORCED$c ? function parseFloat(string) {
	  var trimmedString = trim$1(toString_1$1(string));
	  var result = n$ParseFloat(trimmedString);
	  return result === 0 && charAt$f(trimmedString, 0) == '-' ? -0 : result;
	} : n$ParseFloat;

	// `Number.parseFloat` method
	// https://tc39.es/ecma262/#sec-number.parseFloat
	// eslint-disable-next-line es-x/no-number-parsefloat -- required for testing
	_export({ target: 'Number', stat: true, forced: Number.parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	var trim = stringTrim.trim;


	var $parseInt = global_1.parseInt;
	var Symbol$1 = global_1.Symbol;
	var ITERATOR$4 = Symbol$1 && Symbol$1.iterator;
	var hex = /^[+-]?0x/i;
	var exec$8 = functionUncurryThis(hex.exec);
	var FORCED$b = $parseInt(whitespaces$1 + '08') !== 8 || $parseInt(whitespaces$1 + '0x16') !== 22
	  // MS Edge 18- broken with boxed symbols
	  || (ITERATOR$4 && !fails(function () { $parseInt(Object(ITERATOR$4)); }));

	// `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix
	var numberParseInt = FORCED$b ? function parseInt(string, radix) {
	  var S = trim(toString_1$1(string));
	  return $parseInt(S, (radix >>> 0) || (exec$8(hex, S) ? 16 : 10));
	} : $parseInt;

	// `Number.parseInt` method
	// https://tc39.es/ecma262/#sec-number.parseint
	// eslint-disable-next-line es-x/no-number-parseint -- required for testing
	_export({ target: 'Number', stat: true, forced: Number.parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	var RangeError$a = global_1.RangeError;
	var String$3 = global_1.String;
	var isFinite$1 = global_1.isFinite;
	var abs = Math.abs;
	var floor$5 = Math.floor;
	var pow$2 = Math.pow;
	var round = Math.round;
	var un$ToExponential = functionUncurryThis(1.0.toExponential);
	var repeat$1 = functionUncurryThis(stringRepeat);
	var stringSlice$e = functionUncurryThis(''.slice);

	// Edge 17-
	var ROUNDS_PROPERLY = un$ToExponential(-6.9e-11, 4) === '-6.9000e-11'
	  // IE11- && Edge 14-
	  && un$ToExponential(1.255, 2) === '1.25e+0'
	  // FF86-, V8 ~ Chrome 49-50
	  && un$ToExponential(12345, 3) === '1.235e+4'
	  // FF86-, V8 ~ Chrome 49-50
	  && un$ToExponential(25, 0) === '3e+1';

	// IE8-
	var THROWS_ON_INFINITY_FRACTION = fails(function () {
	  un$ToExponential(1, Infinity);
	}) && fails(function () {
	  un$ToExponential(1, -Infinity);
	});

	// Safari <11 && FF <50
	var PROPER_NON_FINITE_THIS_CHECK = !fails(function () {
	  un$ToExponential(Infinity, Infinity);
	}) && !fails(function () {
	  un$ToExponential(NaN, Infinity);
	});

	var FORCED$a = !ROUNDS_PROPERLY || !THROWS_ON_INFINITY_FRACTION || !PROPER_NON_FINITE_THIS_CHECK;

	// `Number.prototype.toExponential` method
	// https://tc39.es/ecma262/#sec-number.prototype.toexponential
	_export({ target: 'Number', proto: true, forced: FORCED$a }, {
	  toExponential: function toExponential(fractionDigits) {
	    var x = thisNumberValue(this);
	    if (fractionDigits === undefined) return un$ToExponential(x);
	    var f = toIntegerOrInfinity(fractionDigits);
	    if (!isFinite$1(x)) return String$3(x);
	    // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation
	    if (f < 0 || f > 20) throw RangeError$a('Incorrect fraction digits');
	    if (ROUNDS_PROPERLY) return un$ToExponential(x, f);
	    var s = '';
	    var m = '';
	    var e = 0;
	    var c = '';
	    var d = '';
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x === 0) {
	      e = 0;
	      m = repeat$1('0', f + 1);
	    } else {
	      // this block is based on https://gist.github.com/SheetJSDev/1100ad56b9f856c95299ed0e068eea08
	      // TODO: improve accuracy with big fraction digits
	      var l = mathLog10(x);
	      e = floor$5(l);
	      var n = 0;
	      var w = pow$2(10, e - f);
	      n = round(x / w);
	      if (2 * x >= (2 * n + 1) * w) {
	        n += 1;
	      }
	      if (n >= pow$2(10, f + 1)) {
	        n /= 10;
	        e += 1;
	      }
	      m = String$3(n);
	    }
	    if (f !== 0) {
	      m = stringSlice$e(m, 0, 1) + '.' + stringSlice$e(m, 1);
	    }
	    if (e === 0) {
	      c = '+';
	      d = '0';
	    } else {
	      c = e > 0 ? '+' : '-';
	      d = String$3(abs(e));
	    }
	    m += 'e' + c + d;
	    return s + m;
	  }
	});

	var RangeError$9 = global_1.RangeError;
	var String$2 = global_1.String;
	var floor$4 = Math.floor;
	var repeat = functionUncurryThis(stringRepeat);
	var stringSlice$d = functionUncurryThis(''.slice);
	var un$ToFixed = functionUncurryThis(1.0.toFixed);

	var pow$1 = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow$1(x, n - 1, acc * x) : pow$1(x * x, n / 2, acc);
	};

	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};

	var multiply = function (data, n, c) {
	  var index = -1;
	  var c2 = c;
	  while (++index < 6) {
	    c2 += n * data[index];
	    data[index] = c2 % 1e7;
	    c2 = floor$4(c2 / 1e7);
	  }
	};

	var divide = function (data, n) {
	  var index = 6;
	  var c = 0;
	  while (--index >= 0) {
	    c += data[index];
	    data[index] = floor$4(c / n);
	    c = (c % n) * 1e7;
	  }
	};

	var dataToString = function (data) {
	  var index = 6;
	  var s = '';
	  while (--index >= 0) {
	    if (s !== '' || index === 0 || data[index] !== 0) {
	      var t = String$2(data[index]);
	      s = s === '' ? t : s + repeat('0', 7 - t.length) + t;
	    }
	  } return s;
	};

	var FORCED$9 = fails(function () {
	  return un$ToFixed(0.00008, 3) !== '0.000' ||
	    un$ToFixed(0.9, 0) !== '1' ||
	    un$ToFixed(1.255, 2) !== '1.25' ||
	    un$ToFixed(1000000000000000128.0, 0) !== '1000000000000000128';
	}) || !fails(function () {
	  // V8 ~ Android 4.3-
	  un$ToFixed({});
	});

	// `Number.prototype.toFixed` method
	// https://tc39.es/ecma262/#sec-number.prototype.tofixed
	_export({ target: 'Number', proto: true, forced: FORCED$9 }, {
	  toFixed: function toFixed(fractionDigits) {
	    var number = thisNumberValue(this);
	    var fractDigits = toIntegerOrInfinity(fractionDigits);
	    var data = [0, 0, 0, 0, 0, 0];
	    var sign = '';
	    var result = '0';
	    var e, z, j, k;

	    // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation
	    if (fractDigits < 0 || fractDigits > 20) throw RangeError$9('Incorrect fraction digits');
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (number != number) return 'NaN';
	    if (number <= -1e21 || number >= 1e21) return String$2(number);
	    if (number < 0) {
	      sign = '-';
	      number = -number;
	    }
	    if (number > 1e-21) {
	      e = log(number * pow$1(2, 69, 1)) - 69;
	      z = e < 0 ? number * pow$1(2, -e, 1) : number / pow$1(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(data, 0, z);
	        j = fractDigits;
	        while (j >= 7) {
	          multiply(data, 1e7, 0);
	          j -= 7;
	        }
	        multiply(data, pow$1(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(data, 1 << 23);
	          j -= 23;
	        }
	        divide(data, 1 << j);
	        multiply(data, 1, 1);
	        divide(data, 2);
	        result = dataToString(data);
	      } else {
	        multiply(data, 0, z);
	        multiply(data, 1 << -e, 0);
	        result = dataToString(data) + repeat('0', fractDigits);
	      }
	    }
	    if (fractDigits > 0) {
	      k = result.length;
	      result = sign + (k <= fractDigits
	        ? '0.' + repeat('0', fractDigits - k) + result
	        : stringSlice$d(result, 0, k - fractDigits) + '.' + stringSlice$d(result, k - fractDigits));
	    } else {
	      result = sign + result;
	    } return result;
	  }
	});

	var un$ToPrecision = functionUncurryThis(1.0.toPrecision);

	var FORCED$8 = fails(function () {
	  // IE7-
	  return un$ToPrecision(1, undefined) !== '1';
	}) || !fails(function () {
	  // V8 ~ Android 4.3-
	  un$ToPrecision({});
	});

	// `Number.prototype.toPrecision` method
	// https://tc39.es/ecma262/#sec-number.prototype.toprecision
	_export({ target: 'Number', proto: true, forced: FORCED$8 }, {
	  toPrecision: function toPrecision(precision) {
	    return precision === undefined
	      ? un$ToPrecision(thisNumberValue(this))
	      : un$ToPrecision(thisNumberValue(this), precision);
	  }
	});

	// eslint-disable-next-line es-x/no-object-assign -- safe
	var $assign = Object.assign;
	// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
	var defineProperty$9 = Object.defineProperty;
	var concat$2 = functionUncurryThis([].concat);

	// `Object.assign` method
	// https://tc39.es/ecma262/#sec-object.assign
	var objectAssign = !$assign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && $assign({ b: 1 }, $assign(defineProperty$9({}, 'a', {
	    enumerable: true,
	    get: function () {
	      defineProperty$9(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), { b: 2 })).b !== 1) return true;
	  // should work with symbols and should have deterministic property order (V8 bug)
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line es-x/no-symbol -- safe
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
	  return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? concat$2(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || functionCall(propertyIsEnumerable, S, key)) T[key] = S[key];
	    }
	  } return T;
	} : $assign;

	// `Object.assign` method
	// https://tc39.es/ecma262/#sec-object.assign
	// eslint-disable-next-line es-x/no-object-assign -- required for testing
	_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
	  assign: objectAssign
	});

	// TODO: Remove from `core-js@4`




	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  create: objectCreate
	});

	// Forced replacement object prototype accessors methods
	var objectPrototypeAccessorsForced = !fails(function () {
	  // This feature detection crashes old WebKit
	  // https://github.com/zloirock/core-js/issues/232
	  if (engineWebkitVersion && engineWebkitVersion < 535) return;
	  var key = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call, es-x/no-legacy-object-prototype-accessor-methods -- required for testing
	  __defineSetter__.call(null, key, function () { /* empty */ });
	  delete global_1[key];
	});

	// `Object.prototype.__defineGetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__defineGetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __defineGetter__: function __defineGetter__(P, getter) {
	      objectDefineProperty.f(toObject(this), P, { get: aCallable(getter), enumerable: true, configurable: true });
	    }
	  });
	}

	var defineProperties$3 = objectDefineProperties.f;

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es-x/no-object-defineproperties -- safe
	_export({ target: 'Object', stat: true, forced: Object.defineProperties !== defineProperties$3, sham: !descriptors }, {
	  defineProperties: defineProperties$3
	});

	var defineProperty$8 = objectDefineProperty.f;

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	// eslint-disable-next-line es-x/no-object-defineproperty -- safe
	_export({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty$8, sham: !descriptors }, {
	  defineProperty: defineProperty$8
	});

	// `Object.prototype.__defineSetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__defineSetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __defineSetter__: function __defineSetter__(P, setter) {
	      objectDefineProperty.f(toObject(this), P, { set: aCallable(setter), enumerable: true, configurable: true });
	    }
	  });
	}

	var $propertyIsEnumerable = objectPropertyIsEnumerable.f;

	var propertyIsEnumerable$2 = functionUncurryThis($propertyIsEnumerable);
	var push$h = functionUncurryThis([].push);

	// `Object.{ entries, values }` methods implementation
	var createMethod$3 = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys$1(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable$2(O, key)) {
	        push$h(result, TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.es/ecma262/#sec-object.entries
	  entries: createMethod$3(true),
	  // `Object.values` method
	  // https://tc39.es/ecma262/#sec-object.values
	  values: createMethod$3(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.es/ecma262/#sec-object.entries
	_export({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var onFreeze$2 = internalMetadata.onFreeze;

	// eslint-disable-next-line es-x/no-object-freeze -- safe
	var $freeze = Object.freeze;
	var FAILS_ON_PRIMITIVES$8 = fails(function () { $freeze(1); });

	// `Object.freeze` method
	// https://tc39.es/ecma262/#sec-object.freeze
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$8, sham: !freezing }, {
	  freeze: function freeze(it) {
	    return $freeze && isObject$2(it) ? $freeze(onFreeze$2(it)) : it;
	  }
	});

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries
	_export({ target: 'Object', stat: true }, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, { AS_ENTRIES: true });
	    return obj;
	  }
	});

	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;


	var FAILS_ON_PRIMITIVES$7 = fails(function () { nativeGetOwnPropertyDescriptor(1); });
	var FORCED$7 = !descriptors || FAILS_ON_PRIMITIVES$7;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	_export({ target: 'Object', stat: true, forced: FORCED$7, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
	  }
	});

	// `Object.getOwnPropertyDescriptors` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIndexedObject(object);
	    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var index = 0;
	    var key, descriptor;
	    while (keys.length > index) {
	      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
	      if (descriptor !== undefined) createProperty(result, key, descriptor);
	    }
	    return result;
	  }
	});

	var getOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;

	// eslint-disable-next-line es-x/no-object-getownpropertynames -- required for testing
	var FAILS_ON_PRIMITIVES$6 = fails(function () { return !Object.getOwnPropertyNames(1); });

	// `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$6 }, {
	  getOwnPropertyNames: getOwnPropertyNames$1
	});

	var FAILS_ON_PRIMITIVES$5 = fails(function () { objectGetPrototypeOf(1); });

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$5, sham: !correctPrototypeGetter }, {
	  getPrototypeOf: function getPrototypeOf(it) {
	    return objectGetPrototypeOf(toObject(it));
	  }
	});

	// `Object.hasOwn` method
	// https://github.com/tc39/proposal-accessible-object-hasownproperty
	_export({ target: 'Object', stat: true }, {
	  hasOwn: hasOwnProperty_1
	});

	// `SameValue` abstract operation
	// https://tc39.es/ecma262/#sec-samevalue
	// eslint-disable-next-line es-x/no-object-is -- safe
	var sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// `Object.is` method
	// https://tc39.es/ecma262/#sec-object.is
	_export({ target: 'Object', stat: true }, {
	  is: sameValue
	});

	// `Object.isExtensible` method
	// https://tc39.es/ecma262/#sec-object.isextensible
	// eslint-disable-next-line es-x/no-object-isextensible -- safe
	_export({ target: 'Object', stat: true, forced: Object.isExtensible !== objectIsExtensible }, {
	  isExtensible: objectIsExtensible
	});

	// eslint-disable-next-line es-x/no-object-isfrozen -- safe
	var $isFrozen = Object.isFrozen;
	var FAILS_ON_PRIMITIVES$4 = fails(function () { $isFrozen(1); });

	// `Object.isFrozen` method
	// https://tc39.es/ecma262/#sec-object.isfrozen
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$4 || arrayBufferNonExtensible }, {
	  isFrozen: function isFrozen(it) {
	    if (!isObject$2(it)) return true;
	    if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return true;
	    return $isFrozen ? $isFrozen(it) : false;
	  }
	});

	// eslint-disable-next-line es-x/no-object-issealed -- safe
	var $isSealed = Object.isSealed;
	var FAILS_ON_PRIMITIVES$3 = fails(function () { $isSealed(1); });

	// `Object.isSealed` method
	// https://tc39.es/ecma262/#sec-object.issealed
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$3 || arrayBufferNonExtensible }, {
	  isSealed: function isSealed(it) {
	    if (!isObject$2(it)) return true;
	    if (arrayBufferNonExtensible && classofRaw(it) == 'ArrayBuffer') return true;
	    return $isSealed ? $isSealed(it) : false;
	  }
	});

	var FAILS_ON_PRIMITIVES$2 = fails(function () { objectKeys$1(1); });

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
	  keys: function keys(it) {
	    return objectKeys$1(toObject(it));
	  }
	});

	var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupGetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__lookupGetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __lookupGetter__: function __lookupGetter__(P) {
	      var O = toObject(this);
	      var key = toPropertyKey(P);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$6(O, key)) return desc.get;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupSetter__` method
	// https://tc39.es/ecma262/#sec-object.prototype.__lookupSetter__
	if (descriptors) {
	  _export({ target: 'Object', proto: true, forced: objectPrototypeAccessorsForced }, {
	    __lookupSetter__: function __lookupSetter__(P) {
	      var O = toObject(this);
	      var key = toPropertyKey(P);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$5(O, key)) return desc.set;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var onFreeze$1 = internalMetadata.onFreeze;



	// eslint-disable-next-line es-x/no-object-preventextensions -- safe
	var $preventExtensions = Object.preventExtensions;
	var FAILS_ON_PRIMITIVES$1 = fails(function () { $preventExtensions(1); });

	// `Object.preventExtensions` method
	// https://tc39.es/ecma262/#sec-object.preventextensions
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$1, sham: !freezing }, {
	  preventExtensions: function preventExtensions(it) {
	    return $preventExtensions && isObject$2(it) ? $preventExtensions(onFreeze$1(it)) : it;
	  }
	});

	var onFreeze = internalMetadata.onFreeze;



	// eslint-disable-next-line es-x/no-object-seal -- safe
	var $seal = Object.seal;
	var FAILS_ON_PRIMITIVES = fails(function () { $seal(1); });

	// `Object.seal` method
	// https://tc39.es/ecma262/#sec-object.seal
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !freezing }, {
	  seal: function seal(it) {
	    return $seal && isObject$2(it) ? $seal(onFreeze(it)) : it;
	  }
	});

	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	_export({ target: 'Object', stat: true }, {
	  setPrototypeOf: objectSetPrototypeOf
	});

	// `Object.prototype.toString` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.tostring
	var objectToString$1 = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// `Object.prototype.toString` method
	// https://tc39.es/ecma262/#sec-object.prototype.tostring
	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString$1, { unsafe: true });
	}

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.es/ecma262/#sec-object.values
	_export({ target: 'Object', stat: true }, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string
	_export({ global: true, forced: parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	// `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix
	_export({ global: true, forced: parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	var TypeError$o = global_1.TypeError;

	var validateArgumentsLength = function (passed, required) {
	  if (passed < required) throw TypeError$o('Not enough arguments');
	  return passed;
	};

	var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(engineUserAgent);

	var set$2 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$3 = global_1.process;
	var Dispatch = global_1.Dispatch;
	var Function$2 = global_1.Function;
	var MessageChannel = global_1.MessageChannel;
	var String$1 = global_1.String;
	var counter = 0;
	var queue$1 = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var location$1, defer, channel, port$1;

	try {
	  // Deno throws a ReferenceError on `location` access without `--location` flag
	  location$1 = global_1.location;
	} catch (error) { /* empty */ }

	var run = function (id) {
	  if (hasOwnProperty_1(queue$1, id)) {
	    var fn = queue$1[id];
	    delete queue$1[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(String$1(id), location$1.protocol + '//' + location$1.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$2 || !clear) {
	  set$2 = function setImmediate(handler) {
	    validateArgumentsLength(arguments.length, 1);
	    var fn = isCallable(handler) ? handler : Function$2(handler);
	    var args = arraySlice$1(arguments, 1);
	    queue$1[++counter] = function () {
	      functionApply(fn, undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue$1[id];
	  };
	  // Node.js 0.8-
	  if (engineIsNode) {
	    defer = function (id) {
	      process$3.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port$1 = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port$1.postMessage, port$1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    isCallable(global_1.postMessage) &&
	    !global_1.importScripts &&
	    location$1 && location$1.protocol !== 'file:' &&
	    !fails(post)
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html$1.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html$1.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task$1 = {
	  set: set$2,
	  clear: clear
	};

	var engineIsIosPebble = /ipad|iphone|ipod/i.test(engineUserAgent) && global_1.Pebble !== undefined;

	var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;
	var macrotask = task$1.set;





	var MutationObserver = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var document$2 = global_1.document;
	var process$2 = global_1.process;
	var Promise$5 = global_1.Promise;
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$4(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify$1, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (engineIsNode && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify$1();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
	  if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver(flush).observe(node, { characterData: true });
	    notify$1 = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (!engineIsIosPebble && Promise$5 && Promise$5.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$5.resolve(undefined);
	    // workaround of WebKit ~ iOS Safari 10.1 bug
	    promise.constructor = Promise$5;
	    then = functionBindContext(promise.then, promise);
	    notify$1 = function () {
	      then(flush);
	    };
	  // Node.js without promises
	  } else if (engineIsNode) {
	    notify$1 = function () {
	      process$2.nextTick(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessage
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    // strange IE + webpack dev server bug - use .bind(global)
	    macrotask = functionBindContext(macrotask, global_1);
	    notify$1 = function () {
	      macrotask(flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify$1();
	  } last = task;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length == 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var Queue = function () {
	  this.head = null;
	  this.tail = null;
	};

	Queue.prototype = {
	  add: function (item) {
	    var entry = { item: item, next: null };
	    if (this.head) this.tail.next = entry;
	    else this.head = entry;
	    this.tail = entry;
	  },
	  get: function () {
	    var entry = this.head;
	    if (entry) {
	      this.head = entry.next;
	      if (this.tail === entry) this.tail = null;
	      return entry.item;
	    }
	  }
	};

	var queue = Queue;

	var promiseNativeConstructor = global_1.Promise;

	var engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';

	promiseNativeConstructor && promiseNativeConstructor.prototype;
	var SPECIES$1 = wellKnownSymbol('species');
	var SUBCLASSING = false;
	var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable(global_1.PromiseRejectionEvent);

	var FORCED_PROMISE_CONSTRUCTOR$5 = isForced_1('Promise', function () {
	  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(promiseNativeConstructor);
	  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(promiseNativeConstructor);
	  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	  // We can't detect it synchronously, so just check versions
	  if (!GLOBAL_CORE_JS_PROMISE && engineV8Version === 66) return true;
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = new promiseNativeConstructor(function (resolve) { resolve(1); });
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$1] = FakePromise;
	  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
	  if (!SUBCLASSING) return true;
	  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	  return !GLOBAL_CORE_JS_PROMISE && engineIsBrowser && !NATIVE_PROMISE_REJECTION_EVENT$1;
	});

	var promiseConstructorDetection = {
	  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
	  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
	  SUBCLASSING: SUBCLASSING
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aCallable(resolve);
	  this.reject = aCallable(reject);
	};

	// `NewPromiseCapability` abstract operation
	// https://tc39.es/ecma262/#sec-newpromisecapability
	var f = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability$1 = {
		f: f
	};

	var task = task$1.set;









	var PROMISE = 'Promise';
	var FORCED_PROMISE_CONSTRUCTOR$4 = promiseConstructorDetection.CONSTRUCTOR;
	var NATIVE_PROMISE_REJECTION_EVENT = promiseConstructorDetection.REJECTION_EVENT;
	var NATIVE_PROMISE_SUBCLASSING = promiseConstructorDetection.SUBCLASSING;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var setInternalState$e = internalState.set;
	var NativePromisePrototype$2 = promiseNativeConstructor && promiseNativeConstructor.prototype;
	var PromiseConstructor = promiseNativeConstructor;
	var PromisePrototype = NativePromisePrototype$2;
	var TypeError$n = global_1.TypeError;
	var document$1 = global_1.document;
	var process$1 = global_1.process;
	var newPromiseCapability = newPromiseCapability$1.f;
	var newGenericPromiseCapability = newPromiseCapability;

	var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global_1.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;

	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject$2(it) && isCallable(then = it.then) ? then : false;
	};

	var callReaction = function (reaction, state) {
	  var value = state.value;
	  var ok = state.state == FULFILLED;
	  var handler = ok ? reaction.ok : reaction.fail;
	  var resolve = reaction.resolve;
	  var reject = reaction.reject;
	  var domain = reaction.domain;
	  var result, then, exited;
	  try {
	    if (handler) {
	      if (!ok) {
	        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
	        state.rejection = HANDLED;
	      }
	      if (handler === true) result = value;
	      else {
	        if (domain) domain.enter();
	        result = handler(value); // can throw
	        if (domain) {
	          domain.exit();
	          exited = true;
	        }
	      }
	      if (result === reaction.promise) {
	        reject(TypeError$n('Promise-chain cycle'));
	      } else if (then = isThenable(result)) {
	        functionCall(then, result, resolve, reject);
	      } else resolve(result);
	    } else reject(value);
	  } catch (error) {
	    if (domain && !exited) domain.exit();
	    reject(error);
	  }
	};

	var notify = function (state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  microtask(function () {
	    var reactions = state.reactions;
	    var reaction;
	    while (reaction = reactions.get()) {
	      callReaction(reaction, state);
	    }
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(state);
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$1.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (state) {
	  functionCall(task, global_1, function () {
	    var promise = state.facade;
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (engineIsNode) {
	          process$1.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (state) {
	  functionCall(task, global_1, function () {
	    var promise = state.facade;
	    if (engineIsNode) {
	      process$1.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind = function (fn, state, unwrap) {
	  return function (value) {
	    fn(state, value, unwrap);
	  };
	};

	var internalReject = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify(state, true);
	};

	var internalResolve = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (state.facade === value) throw TypeError$n("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          functionCall(then, value,
	            bind(internalResolve, wrapper, state),
	            bind(internalReject, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify(state, false);
	    }
	  } catch (error) {
	    internalReject({ done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED_PROMISE_CONSTRUCTOR$4) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromisePrototype);
	    aCallable(executor);
	    functionCall(Internal, this);
	    var state = getInternalPromiseState(this);
	    try {
	      executor(bind(internalResolve, state), bind(internalReject, state));
	    } catch (error) {
	      internalReject(state, error);
	    }
	  };

	  PromisePrototype = PromiseConstructor.prototype;

	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  Internal = function Promise(executor) {
	    setInternalState$e(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: new queue(),
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };

	  Internal.prototype = redefineAll(PromisePrototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.es/ecma262/#sec-promise.prototype.then
	    // eslint-disable-next-line unicorn/no-thenable -- safe
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
	      state.parent = true;
	      reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
	      reaction.fail = isCallable(onRejected) && onRejected;
	      reaction.domain = engineIsNode ? process$1.domain : undefined;
	      if (state.state == PENDING) state.reactions.add(reaction);
	      else microtask(function () {
	        callReaction(reaction, state);
	      });
	      return reaction.promise;
	    }
	  });

	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalPromiseState(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, state);
	    this.reject = bind(internalReject, state);
	  };

	  newPromiseCapability$1.f = newPromiseCapability = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };

	  if (isCallable(promiseNativeConstructor) && NativePromisePrototype$2 !== Object.prototype) {
	    nativeThen = NativePromisePrototype$2.then;

	    if (!NATIVE_PROMISE_SUBCLASSING) {
	      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
	      redefine(NativePromisePrototype$2, 'then', function then(onFulfilled, onRejected) {
	        var that = this;
	        return new PromiseConstructor(function (resolve, reject) {
	          functionCall(nativeThen, that, resolve, reject);
	        }).then(onFulfilled, onRejected);
	      // https://github.com/zloirock/core-js/issues/640
	      }, { unsafe: true });
	    }

	    // make `.constructor === Promise` work for native promise-based APIs
	    try {
	      delete NativePromisePrototype$2.constructor;
	    } catch (error) { /* empty */ }

	    // make `instanceof Promise` work for native promise-based APIs
	    if (objectSetPrototypeOf) {
	      objectSetPrototypeOf(NativePromisePrototype$2, PromisePrototype);
	    }
	  }
	}

	_export({ global: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);

	var FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;

	var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function (iterable) {
	  promiseNativeConstructor.all(iterable).then(undefined, function () { /* empty */ });
	});

	// `Promise.all` method
	// https://tc39.es/ecma262/#sec-promise.all
	_export({ target: 'Promise', stat: true, forced: promiseStaticsIncorrectIteration }, {
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aCallable(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        remaining++;
	        functionCall($promiseResolve, C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;





	var NativePromisePrototype$1 = promiseNativeConstructor && promiseNativeConstructor.prototype;

	// `Promise.prototype.catch` method
	// https://tc39.es/ecma262/#sec-promise.prototype.catch
	_export({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
	  'catch': function (onRejected) {
	    return this.then(undefined, onRejected);
	  }
	});

	// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
	if (isCallable(promiseNativeConstructor)) {
	  var method$1 = getBuiltIn('Promise').prototype['catch'];
	  if (NativePromisePrototype$1['catch'] !== method$1) {
	    redefine(NativePromisePrototype$1, 'catch', method$1, { unsafe: true });
	  }
	}

	// `Promise.race` method
	// https://tc39.es/ecma262/#sec-promise.race
	_export({ target: 'Promise', stat: true, forced: promiseStaticsIncorrectIteration }, {
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1.f(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aCallable(C.resolve);
	      iterate(iterable, function (promise) {
	        functionCall($promiseResolve, C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;

	// `Promise.reject` method
	// https://tc39.es/ecma262/#sec-promise.reject
	_export({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1.f(this);
	    functionCall(capability.reject, undefined, r);
	    return capability.promise;
	  }
	});

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject$2(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability$1.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;


	getBuiltIn('Promise');

	// `Promise.resolve` method
	// https://tc39.es/ecma262/#sec-promise.resolve
	_export({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
	  resolve: function resolve(x) {
	    return promiseResolve(this, x);
	  }
	});

	// `Promise.allSettled` method
	// https://tc39.es/ecma262/#sec-promise.allsettled
	_export({ target: 'Promise', stat: true }, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aCallable(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        remaining++;
	        functionCall(promiseResolve, C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'fulfilled', value: value };
	          --remaining || resolve(values);
	        }, function (error) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'rejected', reason: error };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var PROMISE_ANY_ERROR = 'No one promise resolved';

	// `Promise.any` method
	// https://tc39.es/ecma262/#sec-promise.any
	_export({ target: 'Promise', stat: true }, {
	  any: function any(iterable) {
	    var C = this;
	    var AggregateError = getBuiltIn('AggregateError');
	    var capability = newPromiseCapability$1.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aCallable(C.resolve);
	      var errors = [];
	      var counter = 0;
	      var remaining = 1;
	      var alreadyResolved = false;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyRejected = false;
	        remaining++;
	        functionCall(promiseResolve, C, promise).then(function (value) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyResolved = true;
	          resolve(value);
	        }, function (error) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyRejected = true;
	          errors[index] = error;
	          --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	        });
	      });
	      --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var NativePromisePrototype = promiseNativeConstructor && promiseNativeConstructor.prototype;

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
	var NON_GENERIC = !!promiseNativeConstructor && fails(function () {
	  // eslint-disable-next-line unicorn/no-thenable -- required for testing
	  NativePromisePrototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
	});

	// `Promise.prototype.finally` method
	// https://tc39.es/ecma262/#sec-promise.prototype.finally
	_export({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = isCallable(onFinally);
	    return this.then(
	      isFunction ? function (x) {
	        return promiseResolve(C, onFinally()).then(function () { return x; });
	      } : onFinally,
	      isFunction ? function (e) {
	        return promiseResolve(C, onFinally()).then(function () { throw e; });
	      } : onFinally
	    );
	  }
	});

	// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
	if (isCallable(promiseNativeConstructor)) {
	  var method = getBuiltIn('Promise').prototype['finally'];
	  if (NativePromisePrototype['finally'] !== method) {
	    redefine(NativePromisePrototype, 'finally', method, { unsafe: true });
	  }
	}

	// MS Edge argumentsList argument is optional
	var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
	  // eslint-disable-next-line es-x/no-reflect -- required for testing
	  Reflect.apply(function () { /* empty */ });
	});

	// `Reflect.apply` method
	// https://tc39.es/ecma262/#sec-reflect.apply
	_export({ target: 'Reflect', stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
	  apply: function apply(target, thisArgument, argumentsList) {
	    return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
	  }
	});

	var nativeConstruct = getBuiltIn('Reflect', 'construct');
	var ObjectPrototype = Object.prototype;
	var push$g = [].push;

	// `Reflect.construct` method
	// https://tc39.es/ecma262/#sec-reflect.construct
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
	});

	var ARGS_BUG = !fails(function () {
	  nativeConstruct(function () { /* empty */ });
	});

	var FORCED$6 = NEW_TARGET_BUG || ARGS_BUG;

	_export({ target: 'Reflect', stat: true, forced: FORCED$6, sham: FORCED$6 }, {
	  construct: function construct(Target, args /* , newTarget */) {
	    aConstructor(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      functionApply(push$g, $args, args);
	      return new (functionApply(functionBind, Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = objectCreate(isObject$2(proto) ? proto : ObjectPrototype);
	    var result = functionApply(Target, instance, args);
	    return isObject$2(result) ? result : instance;
	  }
	});

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	var ERROR_INSTEAD_OF_FALSE = fails(function () {
	  // eslint-disable-next-line es-x/no-reflect -- required for testing
	  Reflect.defineProperty(objectDefineProperty.f({}, 1, { value: 1 }), 1, { value: 2 });
	});

	// `Reflect.defineProperty` method
	// https://tc39.es/ecma262/#sec-reflect.defineproperty
	_export({ target: 'Reflect', stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !descriptors }, {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    var key = toPropertyKey(propertyKey);
	    anObject(attributes);
	    try {
	      objectDefineProperty.f(target, key, attributes);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;

	// `Reflect.deleteProperty` method
	// https://tc39.es/ecma262/#sec-reflect.deleteproperty
	_export({ target: 'Reflect', stat: true }, {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var descriptor = getOwnPropertyDescriptor$3(anObject(target), propertyKey);
	    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
	  }
	});

	var isDataDescriptor = function (descriptor) {
	  return descriptor !== undefined && (hasOwnProperty_1(descriptor, 'value') || hasOwnProperty_1(descriptor, 'writable'));
	};

	// `Reflect.get` method
	// https://tc39.es/ecma262/#sec-reflect.get
	function get$1(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var descriptor, prototype;
	  if (anObject(target) === receiver) return target[propertyKey];
	  descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey);
	  if (descriptor) return isDataDescriptor(descriptor)
	    ? descriptor.value
	    : descriptor.get === undefined ? undefined : functionCall(descriptor.get, receiver);
	  if (isObject$2(prototype = objectGetPrototypeOf(target))) return get$1(prototype, propertyKey, receiver);
	}

	_export({ target: 'Reflect', stat: true }, {
	  get: get$1
	});

	// `Reflect.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor
	_export({ target: 'Reflect', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  }
	});

	// `Reflect.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-reflect.getprototypeof
	_export({ target: 'Reflect', stat: true, sham: !correctPrototypeGetter }, {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return objectGetPrototypeOf(anObject(target));
	  }
	});

	// `Reflect.has` method
	// https://tc39.es/ecma262/#sec-reflect.has
	_export({ target: 'Reflect', stat: true }, {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	// `Reflect.isExtensible` method
	// https://tc39.es/ecma262/#sec-reflect.isextensible
	_export({ target: 'Reflect', stat: true }, {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return objectIsExtensible(target);
	  }
	});

	// `Reflect.ownKeys` method
	// https://tc39.es/ecma262/#sec-reflect.ownkeys
	_export({ target: 'Reflect', stat: true }, {
	  ownKeys: ownKeys
	});

	// `Reflect.preventExtensions` method
	// https://tc39.es/ecma262/#sec-reflect.preventextensions
	_export({ target: 'Reflect', stat: true, sham: !freezing }, {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
	      if (objectPreventExtensions) objectPreventExtensions(target);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	// `Reflect.set` method
	// https://tc39.es/ecma262/#sec-reflect.set
	function set$1(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  var existingDescriptor, prototype, setter;
	  if (!ownDescriptor) {
	    if (isObject$2(prototype = objectGetPrototypeOf(target))) {
	      return set$1(prototype, propertyKey, V, receiver);
	    }
	    ownDescriptor = createPropertyDescriptor(0);
	  }
	  if (isDataDescriptor(ownDescriptor)) {
	    if (ownDescriptor.writable === false || !isObject$2(receiver)) return false;
	    if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
	    } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));
	  } else {
	    setter = ownDescriptor.set;
	    if (setter === undefined) return false;
	    functionCall(setter, receiver, V);
	  } return true;
	}

	// MS Edge 17-18 Reflect.set allows setting the property to object
	// with non-writable property on the prototype
	var MS_EDGE_BUG = fails(function () {
	  var Constructor = function () { /* empty */ };
	  var object = objectDefineProperty.f(new Constructor(), 'a', { configurable: true });
	  // eslint-disable-next-line es-x/no-reflect -- required for testing
	  return Reflect.set(Constructor.prototype, 'a', 1, object) !== false;
	});

	_export({ target: 'Reflect', stat: true, forced: MS_EDGE_BUG }, {
	  set: set$1
	});

	// `Reflect.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-reflect.setprototypeof
	if (objectSetPrototypeOf) _export({ target: 'Reflect', stat: true }, {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    anObject(target);
	    aPossiblePrototype(proto);
	    try {
	      objectSetPrototypeOf(target, proto);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	_export({ global: true }, { Reflect: {} });

	// Reflect[@@toStringTag] property
	// https://tc39.es/ecma262/#sec-reflect-@@tostringtag
	setToStringTag(global_1.Reflect, 'Reflect', true);

	var MATCH$2 = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.es/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject$2(it) && ((isRegExp = it[MATCH$2]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
	var $RegExp$2 = global_1.RegExp;

	var UNSUPPORTED_Y$3 = fails(function () {
	  var re = $RegExp$2('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	});

	// UC Browser bug
	// https://github.com/zloirock/core-js/issues/1008
	var MISSED_STICKY$2 = UNSUPPORTED_Y$3 || fails(function () {
	  return !$RegExp$2('a', 'y').sticky;
	});

	var BROKEN_CARET = UNSUPPORTED_Y$3 || fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = $RegExp$2('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});

	var regexpStickyHelpers = {
	  BROKEN_CARET: BROKEN_CARET,
	  MISSED_STICKY: MISSED_STICKY$2,
	  UNSUPPORTED_Y: UNSUPPORTED_Y$3
	};

	// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
	var $RegExp$1 = global_1.RegExp;

	var regexpUnsupportedDotAll = fails(function () {
	  var re = $RegExp$1('.', 's');
	  return !(re.dotAll && re.exec('\n') && re.flags === 's');
	});

	// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
	var $RegExp = global_1.RegExp;

	var regexpUnsupportedNcg = fails(function () {
	  var re = $RegExp('(?<a>b)', 'g');
	  return re.exec('b').groups.a !== 'b' ||
	    'b'.replace(re, '$<a>c') !== 'bc';
	});

	var getOwnPropertyNames = objectGetOwnPropertyNames.f;









	var enforceInternalState$1 = internalState.enforce;





	var MATCH$1 = wellKnownSymbol('match');
	var NativeRegExp = global_1.RegExp;
	var RegExpPrototype$7 = NativeRegExp.prototype;
	var SyntaxError$2 = global_1.SyntaxError;
	var getFlags$4 = functionUncurryThis(regexpFlags);
	var exec$7 = functionUncurryThis(RegExpPrototype$7.exec);
	var charAt$e = functionUncurryThis(''.charAt);
	var replace$7 = functionUncurryThis(''.replace);
	var stringIndexOf$4 = functionUncurryThis(''.indexOf);
	var stringSlice$c = functionUncurryThis(''.slice);
	// TODO: Use only propper RegExpIdentifierName
	var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
	var re1 = /a/g;
	var re2 = /a/g;

	// "new" should create a new object, old webkit bug
	var CORRECT_NEW = new NativeRegExp(re1) !== re1;

	var MISSED_STICKY$1 = regexpStickyHelpers.MISSED_STICKY;
	var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y;

	var BASE_FORCED = descriptors &&
	  (!CORRECT_NEW || MISSED_STICKY$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg || fails(function () {
	    re2[MATCH$1] = false;
	    // RegExp constructor can alter flags and IsRegExp works correct with @@match
	    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
	  }));

	var handleDotAll = function (string) {
	  var length = string.length;
	  var index = 0;
	  var result = '';
	  var brackets = false;
	  var chr;
	  for (; index <= length; index++) {
	    chr = charAt$e(string, index);
	    if (chr === '\\') {
	      result += chr + charAt$e(string, ++index);
	      continue;
	    }
	    if (!brackets && chr === '.') {
	      result += '[\\s\\S]';
	    } else {
	      if (chr === '[') {
	        brackets = true;
	      } else if (chr === ']') {
	        brackets = false;
	      } result += chr;
	    }
	  } return result;
	};

	var handleNCG = function (string) {
	  var length = string.length;
	  var index = 0;
	  var result = '';
	  var named = [];
	  var names = {};
	  var brackets = false;
	  var ncg = false;
	  var groupid = 0;
	  var groupname = '';
	  var chr;
	  for (; index <= length; index++) {
	    chr = charAt$e(string, index);
	    if (chr === '\\') {
	      chr = chr + charAt$e(string, ++index);
	    } else if (chr === ']') {
	      brackets = false;
	    } else if (!brackets) switch (true) {
	      case chr === '[':
	        brackets = true;
	        break;
	      case chr === '(':
	        if (exec$7(IS_NCG, stringSlice$c(string, index + 1))) {
	          index += 2;
	          ncg = true;
	        }
	        result += chr;
	        groupid++;
	        continue;
	      case chr === '>' && ncg:
	        if (groupname === '' || hasOwnProperty_1(names, groupname)) {
	          throw new SyntaxError$2('Invalid capture group name');
	        }
	        names[groupname] = true;
	        named[named.length] = [groupname, groupid];
	        ncg = false;
	        groupname = '';
	        continue;
	    }
	    if (ncg) groupname += chr;
	    else result += chr;
	  } return [result, named];
	};

	// `RegExp` constructor
	// https://tc39.es/ecma262/#sec-regexp-constructor
	if (isForced_1('RegExp', BASE_FORCED)) {
	  var RegExpWrapper = function RegExp(pattern, flags) {
	    var thisIsRegExp = objectIsPrototypeOf(RegExpPrototype$7, this);
	    var patternIsRegExp = isRegexp(pattern);
	    var flagsAreUndefined = flags === undefined;
	    var groups = [];
	    var rawPattern = pattern;
	    var rawFlags, dotAll, sticky, handled, result, state;

	    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
	      return pattern;
	    }

	    if (patternIsRegExp || objectIsPrototypeOf(RegExpPrototype$7, pattern)) {
	      pattern = pattern.source;
	      if (flagsAreUndefined) flags = 'flags' in rawPattern ? rawPattern.flags : getFlags$4(rawPattern);
	    }

	    pattern = pattern === undefined ? '' : toString_1$1(pattern);
	    flags = flags === undefined ? '' : toString_1$1(flags);
	    rawPattern = pattern;

	    if (regexpUnsupportedDotAll && 'dotAll' in re1) {
	      dotAll = !!flags && stringIndexOf$4(flags, 's') > -1;
	      if (dotAll) flags = replace$7(flags, /s/g, '');
	    }

	    rawFlags = flags;

	    if (MISSED_STICKY$1 && 'sticky' in re1) {
	      sticky = !!flags && stringIndexOf$4(flags, 'y') > -1;
	      if (sticky && UNSUPPORTED_Y$2) flags = replace$7(flags, /y/g, '');
	    }

	    if (regexpUnsupportedNcg) {
	      handled = handleNCG(pattern);
	      pattern = handled[0];
	      groups = handled[1];
	    }

	    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype$7, RegExpWrapper);

	    if (dotAll || sticky || groups.length) {
	      state = enforceInternalState$1(result);
	      if (dotAll) {
	        state.dotAll = true;
	        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
	      }
	      if (sticky) state.sticky = true;
	      if (groups.length) state.groups = groups;
	    }

	    if (pattern !== rawPattern) try {
	      // fails in old engines, but we have no alternatives for unsupported regex syntax
	      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
	    } catch (error) { /* empty */ }

	    return result;
	  };

	  for (var keys$1 = getOwnPropertyNames(NativeRegExp), index$1 = 0; keys$1.length > index$1;) {
	    proxyAccessor(RegExpWrapper, NativeRegExp, keys$1[index$1++]);
	  }

	  RegExpPrototype$7.constructor = RegExpWrapper;
	  RegExpWrapper.prototype = RegExpPrototype$7;
	  redefine(global_1, 'RegExp', RegExpWrapper);
	}

	// https://tc39.es/ecma262/#sec-get-regexp-@@species
	setSpecies('RegExp');

	var defineProperty$7 = objectDefineProperty.f;
	var getInternalState$c = internalState.get;

	var RegExpPrototype$6 = RegExp.prototype;
	var TypeError$m = global_1.TypeError;

	// `RegExp.prototype.dotAll` getter
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.dotall
	if (descriptors && regexpUnsupportedDotAll) {
	  defineProperty$7(RegExpPrototype$6, 'dotAll', {
	    configurable: true,
	    get: function () {
	      if (this === RegExpPrototype$6) return undefined;
	      // We can't use InternalStateModule.getterFor because
	      // we don't add metadata for regexps created by a literal.
	      if (classofRaw(this) === 'RegExp') {
	        return !!getInternalState$c(this).dotAll;
	      }
	      throw TypeError$m('Incompatible receiver, RegExp required');
	    }
	  });
	}

	/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
	/* eslint-disable regexp/no-useless-quantifier -- testing */







	var getInternalState$b = internalState.get;



	var nativeReplace = shared('native-string-replace', String.prototype.replace);
	var nativeExec = RegExp.prototype.exec;
	var patchedExec = nativeExec;
	var charAt$d = functionUncurryThis(''.charAt);
	var indexOf$1 = functionUncurryThis(''.indexOf);
	var replace$6 = functionUncurryThis(''.replace);
	var stringSlice$b = functionUncurryThis(''.slice);

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  functionCall(nativeExec, re1, 'a');
	  functionCall(nativeExec, re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	})();

	var UNSUPPORTED_Y$1 = regexpStickyHelpers.BROKEN_CARET;

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || regexpUnsupportedDotAll || regexpUnsupportedNcg;

	if (PATCH) {
	  patchedExec = function exec(string) {
	    var re = this;
	    var state = getInternalState$b(re);
	    var str = toString_1$1(string);
	    var raw = state.raw;
	    var result, reCopy, lastIndex, match, i, object, group;

	    if (raw) {
	      raw.lastIndex = re.lastIndex;
	      result = functionCall(patchedExec, raw, str);
	      re.lastIndex = raw.lastIndex;
	      return result;
	    }

	    var groups = state.groups;
	    var sticky = UNSUPPORTED_Y$1 && re.sticky;
	    var flags = functionCall(regexpFlags, re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = replace$6(flags, 'y', '');
	      if (indexOf$1(flags, 'g') === -1) {
	        flags += 'g';
	      }

	      strCopy = stringSlice$b(str, re.lastIndex);
	      // Support anchored sticky behavior.
	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$d(str, re.lastIndex - 1) !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      }
	      // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.
	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

	    match = functionCall(nativeExec, sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = stringSlice$b(match.input, charsAdded);
	        match[0] = stringSlice$b(match[0], charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      functionCall(nativeReplace, match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    if (match && groups) {
	      match.groups = object = objectCreate(null);
	      for (i = 0; i < groups.length; i++) {
	        group = groups[i];
	        object[group[0]] = match[group[1]];
	      }
	    }

	    return match;
	  };
	}

	var regexpExec = patchedExec;

	// `RegExp.prototype.exec` method
	// https://tc39.es/ecma262/#sec-regexp.prototype.exec
	_export({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
	  exec: regexpExec
	});

	var RegExpPrototype$5 = RegExp.prototype;

	var FORCED$5 = descriptors && fails(function () {
	  // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
	  return Object.getOwnPropertyDescriptor(RegExpPrototype$5, 'flags').get.call({ dotAll: true, sticky: true }) !== 'sy';
	});

	// `RegExp.prototype.flags` getter
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
	if (FORCED$5) objectDefineProperty.f(RegExpPrototype$5, 'flags', {
	  configurable: true,
	  get: regexpFlags
	});

	var MISSED_STICKY = regexpStickyHelpers.MISSED_STICKY;

	var defineProperty$6 = objectDefineProperty.f;
	var getInternalState$a = internalState.get;

	var RegExpPrototype$4 = RegExp.prototype;
	var TypeError$l = global_1.TypeError;

	// `RegExp.prototype.sticky` getter
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky
	if (descriptors && MISSED_STICKY) {
	  defineProperty$6(RegExpPrototype$4, 'sticky', {
	    configurable: true,
	    get: function () {
	      if (this === RegExpPrototype$4) return undefined;
	      // We can't use InternalStateModule.getterFor because
	      // we don't add metadata for regexps created by a literal.
	      if (classofRaw(this) === 'RegExp') {
	        return !!getInternalState$a(this).sticky;
	      }
	      throw TypeError$l('Incompatible receiver, RegExp required');
	    }
	  });
	}

	// TODO: Remove from `core-js@4` since it's moved to entry points








	var DELEGATES_TO_EXEC = function () {
	  var execCalled = false;
	  var re = /[ac]/;
	  re.exec = function () {
	    execCalled = true;
	    return /./.exec.apply(this, arguments);
	  };
	  return re.test('abc') === true && execCalled;
	}();

	var Error$4 = global_1.Error;
	var un$Test = functionUncurryThis(/./.test);

	// `RegExp.prototype.test` method
	// https://tc39.es/ecma262/#sec-regexp.prototype.test
	_export({ target: 'RegExp', proto: true, forced: !DELEGATES_TO_EXEC }, {
	  test: function (str) {
	    var exec = this.exec;
	    if (!isCallable(exec)) return un$Test(this, str);
	    var result = functionCall(exec, this, str);
	    if (result !== null && !isObject$2(result)) {
	      throw new Error$4('RegExp exec method returned something other than an Object or null');
	    }
	    return !!result;
	  }
	});

	var PROPER_FUNCTION_NAME$1 = functionName.PROPER;







	var TO_STRING = 'toString';
	var RegExpPrototype$3 = RegExp.prototype;
	var n$ToString = RegExpPrototype$3[TO_STRING];
	var getFlags$3 = functionUncurryThis(regexpFlags);

	var NOT_GENERIC = fails(function () { return n$ToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
	// FF44- RegExp#toString has a wrong name
	var INCORRECT_NAME = PROPER_FUNCTION_NAME$1 && n$ToString.name != TO_STRING;

	// `RegExp.prototype.toString` method
	// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
	if (NOT_GENERIC || INCORRECT_NAME) {
	  redefine(RegExp.prototype, TO_STRING, function toString() {
	    var R = anObject(this);
	    var p = toString_1$1(R.source);
	    var rf = R.flags;
	    var f = toString_1$1(rf === undefined && objectIsPrototypeOf(RegExpPrototype$3, R) && !('flags' in RegExpPrototype$3) ? getFlags$3(R) : rf);
	    return '/' + p + '/' + f;
	  }, { unsafe: true });
	}

	// `Set` constructor
	// https://tc39.es/ecma262/#sec-set-objects
	collection('Set', function (init) {
	  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	var charAt$c = functionUncurryThis(''.charAt);

	var FORCED$4 = fails(function () {
	  // eslint-disable-next-line es-x/no-array-string-prototype-at -- safe
	  return 'Ã° Â®Â·'.at(-2) !== '\uD842';
	});

	// `String.prototype.at` method
	// https://github.com/tc39/proposal-relative-indexing-method
	_export({ target: 'String', proto: true, forced: FORCED$4 }, {
	  at: function at(index) {
	    var S = toString_1$1(requireObjectCoercible(this));
	    var len = S.length;
	    var relativeIndex = toIntegerOrInfinity(index);
	    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
	    return (k < 0 || k >= len) ? undefined : charAt$c(S, k);
	  }
	});

	var charAt$b = functionUncurryThis(''.charAt);
	var charCodeAt$2 = functionUncurryThis(''.charCodeAt);
	var stringSlice$a = functionUncurryThis(''.slice);

	var createMethod$2 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = toString_1$1(requireObjectCoercible($this));
	    var position = toIntegerOrInfinity(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = charCodeAt$2(S, position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = charCodeAt$2(S, position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING
	          ? charAt$b(S, position)
	          : first
	        : CONVERT_TO_STRING
	          ? stringSlice$a(S, position, position + 2)
	          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$2(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$2(true)
	};

	var codeAt$2 = stringMultibyte.codeAt;

	// `String.prototype.codePointAt` method
	// https://tc39.es/ecma262/#sec-string.prototype.codepointat
	_export({ target: 'String', proto: true }, {
	  codePointAt: function codePointAt(pos) {
	    return codeAt$2(this, pos);
	  }
	});

	var TypeError$k = global_1.TypeError;

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError$k("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (error1) {
	    try {
	      regexp[MATCH] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (error2) { /* empty */ }
	  } return false;
	};

	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;







	// eslint-disable-next-line es-x/no-string-prototype-endswith -- safe
	var un$EndsWith = functionUncurryThis(''.endsWith);
	var slice = functionUncurryThis(''.slice);
	var min$6 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('endsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG$1 = !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
	  var descriptor = getOwnPropertyDescriptor$2(String.prototype, 'endsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.endsWith` method
	// https://tc39.es/ecma262/#sec-string.prototype.endswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1 }, {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = toString_1$1(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = that.length;
	    var end = endPosition === undefined ? len : min$6(toLength(endPosition), len);
	    var search = toString_1$1(searchString);
	    return un$EndsWith
	      ? un$EndsWith(that, search, end)
	      : slice(that, end - search.length, end) === search;
	  }
	});

	var RangeError$8 = global_1.RangeError;
	var fromCharCode$3 = String.fromCharCode;
	// eslint-disable-next-line es-x/no-string-fromcodepoint -- required for testing
	var $fromCodePoint = String.fromCodePoint;
	var join$6 = functionUncurryThis([].join);

	// length should be 1, old FF problem
	var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length != 1;

	// `String.fromCodePoint` method
	// https://tc39.es/ecma262/#sec-string.fromcodepoint
	_export({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  fromCodePoint: function fromCodePoint(x) {
	    var elements = [];
	    var length = arguments.length;
	    var i = 0;
	    var code;
	    while (length > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError$8(code + ' is not a valid code point');
	      elements[i] = code < 0x10000
	        ? fromCharCode$3(code)
	        : fromCharCode$3(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00);
	    } return join$6(elements, '');
	  }
	});

	var stringIndexOf$3 = functionUncurryThis(''.indexOf);

	// `String.prototype.includes` method
	// https://tc39.es/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~stringIndexOf$3(
	      toString_1$1(requireObjectCoercible(this)),
	      toString_1$1(notARegexp(searchString)),
	      arguments.length > 1 ? arguments[1] : undefined
	    );
	  }
	});

	var charAt$a = stringMultibyte.charAt;




	var STRING_ITERATOR$1 = 'String Iterator';
	var setInternalState$d = internalState.set;
	var getInternalState$9 = internalState.getterFor(STRING_ITERATOR$1);

	// `String.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$d(this, {
	    type: STRING_ITERATOR$1,
	    string: toString_1$1(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$9(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt$a(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	// TODO: Remove from `core-js@4` since it's moved to entry points








	var SPECIES = wellKnownSymbol('species');
	var RegExpPrototype$2 = RegExp.prototype;

	var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
	  var SYMBOL = wellKnownSymbol(KEY);

	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {};
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES] = function () { return re; };
	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }

	    re.exec = function () { execCalled = true; return null; };

	    re[SYMBOL]('');
	    return !execCalled;
	  });

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    FORCED
	  ) {
	    var uncurriedNativeRegExpMethod = functionUncurryThis(/./[SYMBOL]);
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      var uncurriedNativeMethod = functionUncurryThis(nativeMethod);
	      var $exec = regexp.exec;
	      if ($exec === regexpExec || $exec === RegExpPrototype$2.exec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
	        }
	        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
	      }
	      return { done: false };
	    });

	    redefine(String.prototype, KEY, methods[0]);
	    redefine(RegExpPrototype$2, SYMBOL, methods[1]);
	  }

	  if (SHAM) createNonEnumerableProperty(RegExpPrototype$2[SYMBOL], 'sham', true);
	};

	var charAt$9 = stringMultibyte.charAt;

	// `AdvanceStringIndex` abstract operation
	// https://tc39.es/ecma262/#sec-advancestringindex
	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt$9(S, index).length : 1);
	};

	var TypeError$j = global_1.TypeError;

	// `RegExpExec` abstract operation
	// https://tc39.es/ecma262/#sec-regexpexec
	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (isCallable(exec)) {
	    var result = functionCall(exec, R, S);
	    if (result !== null) anObject(result);
	    return result;
	  }
	  if (classofRaw(R) === 'RegExp') return functionCall(regexpExec, R, S);
	  throw TypeError$j('RegExp#exec called on incompatible receiver');
	};

	// @@match logic
	fixRegexpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
	  return [
	    // `String.prototype.match` method
	    // https://tc39.es/ecma262/#sec-string.prototype.match
	    function match(regexp) {
	      var O = requireObjectCoercible(this);
	      var matcher = regexp == undefined ? undefined : getMethod(regexp, MATCH);
	      return matcher ? functionCall(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString_1$1(O));
	    },
	    // `RegExp.prototype[@@match]` method
	    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
	    function (string) {
	      var rx = anObject(this);
	      var S = toString_1$1(string);
	      var res = maybeCallNative(nativeMatch, rx, S);

	      if (res.done) return res.value;

	      if (!rx.global) return regexpExecAbstract(rx, S);

	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	      var A = [];
	      var n = 0;
	      var result;
	      while ((result = regexpExecAbstract(rx, S)) !== null) {
	        var matchStr = toString_1$1(result[0]);
	        A[n] = matchStr;
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	        n++;
	      }
	      return n === 0 ? null : A;
	    }
	  ];
	});

	/* eslint-disable es-x/no-string-prototype-matchall -- safe */























	var MATCH_ALL = wellKnownSymbol('matchAll');
	var REGEXP_STRING = 'RegExp String';
	var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
	var setInternalState$c = internalState.set;
	var getInternalState$8 = internalState.getterFor(REGEXP_STRING_ITERATOR);
	var RegExpPrototype$1 = RegExp.prototype;
	var TypeError$i = global_1.TypeError;
	var getFlags$2 = functionUncurryThis(regexpFlags);
	var stringIndexOf$2 = functionUncurryThis(''.indexOf);
	var un$MatchAll = functionUncurryThis(''.matchAll);

	var WORKS_WITH_NON_GLOBAL_REGEX = !!un$MatchAll && !fails(function () {
	  un$MatchAll('a', /./);
	});

	var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
	  setInternalState$c(this, {
	    type: REGEXP_STRING_ITERATOR,
	    regexp: regexp,
	    string: string,
	    global: $global,
	    unicode: fullUnicode,
	    done: false
	  });
	}, REGEXP_STRING, function next() {
	  var state = getInternalState$8(this);
	  if (state.done) return { value: undefined, done: true };
	  var R = state.regexp;
	  var S = state.string;
	  var match = regexpExecAbstract(R, S);
	  if (match === null) return { value: undefined, done: state.done = true };
	  if (state.global) {
	    if (toString_1$1(match[0]) === '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
	    return { value: match, done: false };
	  }
	  state.done = true;
	  return { value: match, done: false };
	});

	var $matchAll = function (string) {
	  var R = anObject(this);
	  var S = toString_1$1(string);
	  var C, flagsValue, flags, matcher, $global, fullUnicode;
	  C = speciesConstructor(R, RegExp);
	  flagsValue = R.flags;
	  if (flagsValue === undefined && objectIsPrototypeOf(RegExpPrototype$1, R) && !('flags' in RegExpPrototype$1)) {
	    flagsValue = getFlags$2(R);
	  }
	  flags = flagsValue === undefined ? '' : toString_1$1(flagsValue);
	  matcher = new C(C === RegExp ? R.source : R, flags);
	  $global = !!~stringIndexOf$2(flags, 'g');
	  fullUnicode = !!~stringIndexOf$2(flags, 'u');
	  matcher.lastIndex = toLength(R.lastIndex);
	  return new $RegExpStringIterator(matcher, S, $global, fullUnicode);
	};

	// `String.prototype.matchAll` method
	// https://tc39.es/ecma262/#sec-string.prototype.matchall
	_export({ target: 'String', proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
	  matchAll: function matchAll(regexp) {
	    var O = requireObjectCoercible(this);
	    var flags, S, matcher, rx;
	    if (regexp != null) {
	      if (isRegexp(regexp)) {
	        flags = toString_1$1(requireObjectCoercible('flags' in RegExpPrototype$1
	          ? regexp.flags
	          : getFlags$2(regexp)
	        ));
	        if (!~stringIndexOf$2(flags, 'g')) throw TypeError$i('`.matchAll` does not allow non-global regexes');
	      }
	      if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);
	      matcher = getMethod(regexp, MATCH_ALL);
	      if (matcher === undefined && isPure && classofRaw(regexp) == 'RegExp') matcher = $matchAll;
	      if (matcher) return functionCall(matcher, regexp, O);
	    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return un$MatchAll(O, regexp);
	    S = toString_1$1(O);
	    rx = new RegExp(regexp, 'g');
	    return rx[MATCH_ALL](S);
	  }
	});

	MATCH_ALL in RegExpPrototype$1 || redefine(RegExpPrototype$1, MATCH_ALL, $matchAll);

	// https://github.com/zloirock/core-js/issues/280


	var stringPadWebkitBug = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(engineUserAgent);

	var $padEnd = stringPad.end;


	// `String.prototype.padEnd` method
	// https://tc39.es/ecma262/#sec-string.prototype.padend
	_export({ target: 'String', proto: true, forced: stringPadWebkitBug }, {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $padStart = stringPad.start;


	// `String.prototype.padStart` method
	// https://tc39.es/ecma262/#sec-string.prototype.padstart
	_export({ target: 'String', proto: true, forced: stringPadWebkitBug }, {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var push$f = functionUncurryThis([].push);
	var join$5 = functionUncurryThis([].join);

	// `String.raw` method
	// https://tc39.es/ecma262/#sec-string.raw
	_export({ target: 'String', stat: true }, {
	  raw: function raw(template) {
	    var rawTemplate = toIndexedObject(toObject(template).raw);
	    var literalSegments = lengthOfArrayLike(rawTemplate);
	    var argumentsLength = arguments.length;
	    var elements = [];
	    var i = 0;
	    while (literalSegments > i) {
	      push$f(elements, toString_1$1(rawTemplate[i++]));
	      if (i === literalSegments) return join$5(elements, '');
	      if (i < argumentsLength) push$f(elements, toString_1$1(arguments[i]));
	    }
	  }
	});

	// `String.prototype.repeat` method
	// https://tc39.es/ecma262/#sec-string.prototype.repeat
	_export({ target: 'String', proto: true }, {
	  repeat: stringRepeat
	});

	var floor$3 = Math.floor;
	var charAt$8 = functionUncurryThis(''.charAt);
	var replace$5 = functionUncurryThis(''.replace);
	var stringSlice$9 = functionUncurryThis(''.slice);
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

	// `GetSubstitution` abstract operation
	// https://tc39.es/ecma262/#sec-getsubstitution
	var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
	  var tailPos = position + matched.length;
	  var m = captures.length;
	  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	  if (namedCaptures !== undefined) {
	    namedCaptures = toObject(namedCaptures);
	    symbols = SUBSTITUTION_SYMBOLS;
	  }
	  return replace$5(replacement, symbols, function (match, ch) {
	    var capture;
	    switch (charAt$8(ch, 0)) {
	      case '$': return '$';
	      case '&': return matched;
	      case '`': return stringSlice$9(str, 0, position);
	      case "'": return stringSlice$9(str, tailPos);
	      case '<':
	        capture = namedCaptures[stringSlice$9(ch, 1, -1)];
	        break;
	      default: // \d\d?
	        var n = +ch;
	        if (n === 0) return match;
	        if (n > m) {
	          var f = floor$3(n / 10);
	          if (f === 0) return match;
	          if (f <= m) return captures[f - 1] === undefined ? charAt$8(ch, 1) : captures[f - 1] + charAt$8(ch, 1);
	          return match;
	        }
	        capture = captures[n - 1];
	    }
	    return capture === undefined ? '' : capture;
	  });
	};

	var REPLACE$1 = wellKnownSymbol('replace');
	var max$4 = Math.max;
	var min$5 = Math.min;
	var concat$1 = functionUncurryThis([].concat);
	var push$e = functionUncurryThis([].push);
	var stringIndexOf$1 = functionUncurryThis(''.indexOf);
	var stringSlice$8 = functionUncurryThis(''.slice);

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
	var REPLACE_KEEPS_$0 = (function () {
	  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
	  return 'a'.replace(/./, '$0') === '$0';
	})();

	// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
	  if (/./[REPLACE$1]) {
	    return /./[REPLACE$1]('a', '$0') === '';
	  }
	  return false;
	})();

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
	  return ''.replace(re, '$<a>') !== '7';
	});

	// @@replace logic
	fixRegexpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

	  return [
	    // `String.prototype.replace` method
	    // https://tc39.es/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = requireObjectCoercible(this);
	      var replacer = searchValue == undefined ? undefined : getMethod(searchValue, REPLACE$1);
	      return replacer
	        ? functionCall(replacer, searchValue, O, replaceValue)
	        : functionCall(nativeReplace, toString_1$1(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
	    function (string, replaceValue) {
	      var rx = anObject(this);
	      var S = toString_1$1(string);

	      if (
	        typeof replaceValue == 'string' &&
	        stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
	        stringIndexOf$1(replaceValue, '$<') === -1
	      ) {
	        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
	        if (res.done) return res.value;
	      }

	      var functionalReplace = isCallable(replaceValue);
	      if (!functionalReplace) replaceValue = toString_1$1(replaceValue);

	      var global = rx.global;
	      if (global) {
	        var fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }
	      var results = [];
	      while (true) {
	        var result = regexpExecAbstract(rx, S);
	        if (result === null) break;

	        push$e(results, result);
	        if (!global) break;

	        var matchStr = toString_1$1(result[0]);
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      }

	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];

	        var matched = toString_1$1(result[0]);
	        var position = max$4(min$5(toIntegerOrInfinity(result.index), S.length), 0);
	        var captures = [];
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) push$e(captures, maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = concat$1([matched], captures, position, S);
	          if (namedCaptures !== undefined) push$e(replacerArgs, namedCaptures);
	          var replacement = toString_1$1(functionApply(replaceValue, undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += stringSlice$8(S, nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }
	      return accumulatedResult + stringSlice$8(S, nextSourcePosition);
	    }
	  ];
	}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

	var REPLACE = wellKnownSymbol('replace');
	var RegExpPrototype = RegExp.prototype;
	var TypeError$h = global_1.TypeError;
	var getFlags$1 = functionUncurryThis(regexpFlags);
	var indexOf = functionUncurryThis(''.indexOf);
	functionUncurryThis(''.replace);
	var stringSlice$7 = functionUncurryThis(''.slice);
	var max$3 = Math.max;

	var stringIndexOf = function (string, searchValue, fromIndex) {
	  if (fromIndex > string.length) return -1;
	  if (searchValue === '') return fromIndex;
	  return indexOf(string, searchValue, fromIndex);
	};

	// `String.prototype.replaceAll` method
	// https://tc39.es/ecma262/#sec-string.prototype.replaceall
	_export({ target: 'String', proto: true }, {
	  replaceAll: function replaceAll(searchValue, replaceValue) {
	    var O = requireObjectCoercible(this);
	    var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
	    var position = 0;
	    var endOfLastMatch = 0;
	    var result = '';
	    if (searchValue != null) {
	      IS_REG_EXP = isRegexp(searchValue);
	      if (IS_REG_EXP) {
	        flags = toString_1$1(requireObjectCoercible('flags' in RegExpPrototype
	          ? searchValue.flags
	          : getFlags$1(searchValue)
	        ));
	        if (!~indexOf(flags, 'g')) throw TypeError$h('`.replaceAll` does not allow non-global regexes');
	      }
	      replacer = getMethod(searchValue, REPLACE);
	      if (replacer) {
	        return functionCall(replacer, searchValue, O, replaceValue);
	      }
	    }
	    string = toString_1$1(O);
	    searchString = toString_1$1(searchValue);
	    functionalReplace = isCallable(replaceValue);
	    if (!functionalReplace) replaceValue = toString_1$1(replaceValue);
	    searchLength = searchString.length;
	    advanceBy = max$3(1, searchLength);
	    position = stringIndexOf(string, searchString, 0);
	    while (position !== -1) {
	      replacement = functionalReplace
	        ? toString_1$1(replaceValue(searchString, position, string))
	        : getSubstitution(searchString, string, position, [], undefined, replaceValue);
	      result += stringSlice$7(string, endOfLastMatch, position) + replacement;
	      endOfLastMatch = position + searchLength;
	      position = stringIndexOf(string, searchString, position + advanceBy);
	    }
	    if (endOfLastMatch < string.length) {
	      result += stringSlice$7(string, endOfLastMatch);
	    }
	    return result;
	  }
	});

	// @@search logic
	fixRegexpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
	  return [
	    // `String.prototype.search` method
	    // https://tc39.es/ecma262/#sec-string.prototype.search
	    function search(regexp) {
	      var O = requireObjectCoercible(this);
	      var searcher = regexp == undefined ? undefined : getMethod(regexp, SEARCH);
	      return searcher ? functionCall(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString_1$1(O));
	    },
	    // `RegExp.prototype[@@search]` method
	    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
	    function (string) {
	      var rx = anObject(this);
	      var S = toString_1$1(string);
	      var res = maybeCallNative(nativeSearch, rx, S);

	      if (res.done) return res.value;

	      var previousLastIndex = rx.lastIndex;
	      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	      var result = regexpExecAbstract(rx, S);
	      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	      return result === null ? -1 : result.index;
	    }
	  ];
	});

	var UNSUPPORTED_Y = regexpStickyHelpers.UNSUPPORTED_Y;
	var MAX_UINT32 = 0xFFFFFFFF;
	var min$4 = Math.min;
	var $push = [].push;
	var exec$6 = functionUncurryThis(/./.exec);
	var push$d = functionUncurryThis($push);
	var stringSlice$6 = functionUncurryThis(''.slice);

	// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	// Weex JS has frozen built-in prototypes, so use try / catch wrapper
	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
	  // eslint-disable-next-line regexp/no-empty-group -- required for testing
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () { return originalExec.apply(this, arguments); };
	  var result = 'ab'.split(re);
	  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
	});

	// @@split logic
	fixRegexpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
	  var internalSplit;
	  if (
	    'abbc'.split(/(b)*/)[1] == 'c' ||
	    // eslint-disable-next-line regexp/no-empty-group -- required for testing
	    'test'.split(/(?:)/, -1).length != 4 ||
	    'ab'.split(/(?:ab)*/).length != 2 ||
	    '.'.split(/(.?)(.?)/).length != 4 ||
	    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
	    '.'.split(/()()/).length > 1 ||
	    ''.split(/.?/).length
	  ) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function (separator, limit) {
	      var string = toString_1$1(requireObjectCoercible(this));
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (separator === undefined) return [string];
	      // If `separator` is not a regex, use native split
	      if (!isRegexp(separator)) {
	        return functionCall(nativeSplit, string, separator, lim);
	      }
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = functionCall(regexpExec, separatorCopy, string)) {
	        lastIndex = separatorCopy.lastIndex;
	        if (lastIndex > lastLastIndex) {
	          push$d(output, stringSlice$6(string, lastLastIndex, match.index));
	          if (match.length > 1 && match.index < string.length) functionApply($push, output, arraySliceSimple(match, 1));
	          lastLength = match[0].length;
	          lastLastIndex = lastIndex;
	          if (output.length >= lim) break;
	        }
	        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string.length) {
	        if (lastLength || !exec$6(separatorCopy, '')) push$d(output, '');
	      } else push$d(output, stringSlice$6(string, lastLastIndex));
	      return output.length > lim ? arraySliceSimple(output, 0, lim) : output;
	    };
	  // Chakra, V8
	  } else if ('0'.split(undefined, 0).length) {
	    internalSplit = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : functionCall(nativeSplit, this, separator, limit);
	    };
	  } else internalSplit = nativeSplit;

	  return [
	    // `String.prototype.split` method
	    // https://tc39.es/ecma262/#sec-string.prototype.split
	    function split(separator, limit) {
	      var O = requireObjectCoercible(this);
	      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);
	      return splitter
	        ? functionCall(splitter, separator, O, limit)
	        : functionCall(internalSplit, toString_1$1(O), separator, limit);
	    },
	    // `RegExp.prototype[@@split]` method
	    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
	    //
	    // NOTE: This cannot be properly polyfilled in engines that don't support
	    // the 'y' flag.
	    function (string, limit) {
	      var rx = anObject(this);
	      var S = toString_1$1(string);
	      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

	      if (res.done) return res.value;

	      var C = speciesConstructor(rx, RegExp);

	      var unicodeMatching = rx.unicode;
	      var flags = (rx.ignoreCase ? 'i' : '') +
	                  (rx.multiline ? 'm' : '') +
	                  (rx.unicode ? 'u' : '') +
	                  (UNSUPPORTED_Y ? 'g' : 'y');

	      // ^(? + rx + ) is needed, in combination with some S slicing, to
	      // simulate the 'y' flag.
	      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
	      var p = 0;
	      var q = 0;
	      var A = [];
	      while (q < S.length) {
	        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
	        var z = regexpExecAbstract(splitter, UNSUPPORTED_Y ? stringSlice$6(S, q) : S);
	        var e;
	        if (
	          z === null ||
	          (e = min$4(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
	        ) {
	          q = advanceStringIndex(S, q, unicodeMatching);
	        } else {
	          push$d(A, stringSlice$6(S, p, q));
	          if (A.length === lim) return A;
	          for (var i = 1; i <= z.length - 1; i++) {
	            push$d(A, z[i]);
	            if (A.length === lim) return A;
	          }
	          q = p = e;
	        }
	      }
	      push$d(A, stringSlice$6(S, p));
	      return A;
	    }
	  ];
	}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;







	// eslint-disable-next-line es-x/no-string-prototype-startswith -- safe
	var un$StartsWith = functionUncurryThis(''.startsWith);
	var stringSlice$5 = functionUncurryThis(''.slice);
	var min$3 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor$1(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.startsWith` method
	// https://tc39.es/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = toString_1$1(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$3(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = toString_1$1(searchString);
	    return un$StartsWith
	      ? un$StartsWith(that, search, index)
	      : stringSlice$5(that, index, index + search.length) === search;
	  }
	});

	var stringSlice$4 = functionUncurryThis(''.slice);
	var max$2 = Math.max;
	var min$2 = Math.min;

	// eslint-disable-next-line unicorn/prefer-string-slice, es-x/no-string-prototype-substr -- required for testing
	var FORCED$3 = !''.substr || 'ab'.substr(-1) !== 'b';

	// `String.prototype.substr` method
	// https://tc39.es/ecma262/#sec-string.prototype.substr
	_export({ target: 'String', proto: true, forced: FORCED$3 }, {
	  substr: function substr(start, length) {
	    var that = toString_1$1(requireObjectCoercible(this));
	    var size = that.length;
	    var intStart = toIntegerOrInfinity(start);
	    var intLength, intEnd;
	    if (intStart === Infinity) intStart = 0;
	    if (intStart < 0) intStart = max$2(size + intStart, 0);
	    intLength = length === undefined ? size : toIntegerOrInfinity(length);
	    if (intLength <= 0 || intLength === Infinity) return '';
	    intEnd = min$2(intStart + intLength, size);
	    return intStart >= intEnd ? '' : stringSlice$4(that, intStart, intEnd);
	  }
	});

	var PROPER_FUNCTION_NAME = functionName.PROPER;



	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces$1[METHOD_NAME]()
	      || non[METHOD_NAME]() !== non
	      || (PROPER_FUNCTION_NAME && whitespaces$1[METHOD_NAME].name !== METHOD_NAME);
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.es/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var $trimEnd = stringTrim.end;


	// `String.prototype.{ trimEnd, trimRight }` method
	// https://tc39.es/ecma262/#sec-string.prototype.trimend
	// https://tc39.es/ecma262/#String.prototype.trimright
	var stringTrimEnd = stringTrimForced('trimEnd') ? function trimEnd() {
	  return $trimEnd(this);
	// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
	} : ''.trimEnd;

	// `String.prototype.trimRight` method
	// https://tc39.es/ecma262/#sec-string.prototype.trimend
	// eslint-disable-next-line es-x/no-string-prototype-trimleft-trimright -- safe
	_export({ target: 'String', proto: true, name: 'trimEnd', forced: ''.trimRight !== stringTrimEnd }, {
	  trimRight: stringTrimEnd
	});

	// TODO: Remove this line from `core-js@4`




	// `String.prototype.trimEnd` method
	// https://tc39.es/ecma262/#sec-string.prototype.trimend
	// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
	_export({ target: 'String', proto: true, name: 'trimEnd', forced: ''.trimEnd !== stringTrimEnd }, {
	  trimEnd: stringTrimEnd
	});

	var $trimStart = stringTrim.start;


	// `String.prototype.{ trimStart, trimLeft }` method
	// https://tc39.es/ecma262/#sec-string.prototype.trimstart
	// https://tc39.es/ecma262/#String.prototype.trimleft
	var stringTrimStart = stringTrimForced('trimStart') ? function trimStart() {
	  return $trimStart(this);
	// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
	} : ''.trimStart;

	// `String.prototype.trimLeft` method
	// https://tc39.es/ecma262/#sec-string.prototype.trimleft
	// eslint-disable-next-line es-x/no-string-prototype-trimleft-trimright -- safe
	_export({ target: 'String', proto: true, name: 'trimStart', forced: ''.trimLeft !== stringTrimStart }, {
	  trimLeft: stringTrimStart
	});

	// TODO: Remove this line from `core-js@4`




	// `String.prototype.trimStart` method
	// https://tc39.es/ecma262/#sec-string.prototype.trimstart
	// eslint-disable-next-line es-x/no-string-prototype-trimstart-trimend -- safe
	_export({ target: 'String', proto: true, name: 'trimStart', forced: ''.trimStart !== stringTrimStart }, {
	  trimStart: stringTrimStart
	});

	var quot = /"/g;
	var replace$4 = functionUncurryThis(''.replace);

	// `CreateHTML` abstract operation
	// https://tc39.es/ecma262/#sec-createhtml
	var createHtml = function (string, tag, attribute, value) {
	  var S = toString_1$1(requireObjectCoercible(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + replace$4(toString_1$1(value), quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};

	// check the existence of a method, lowercase
	// of a tag and escaping quotes in arguments
	var stringHtmlForced = function (METHOD_NAME) {
	  return fails(function () {
	    var test = ''[METHOD_NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  });
	};

	// `String.prototype.anchor` method
	// https://tc39.es/ecma262/#sec-string.prototype.anchor
	_export({ target: 'String', proto: true, forced: stringHtmlForced('anchor') }, {
	  anchor: function anchor(name) {
	    return createHtml(this, 'a', 'name', name);
	  }
	});

	// `String.prototype.big` method
	// https://tc39.es/ecma262/#sec-string.prototype.big
	_export({ target: 'String', proto: true, forced: stringHtmlForced('big') }, {
	  big: function big() {
	    return createHtml(this, 'big', '', '');
	  }
	});

	// `String.prototype.blink` method
	// https://tc39.es/ecma262/#sec-string.prototype.blink
	_export({ target: 'String', proto: true, forced: stringHtmlForced('blink') }, {
	  blink: function blink() {
	    return createHtml(this, 'blink', '', '');
	  }
	});

	// `String.prototype.bold` method
	// https://tc39.es/ecma262/#sec-string.prototype.bold
	_export({ target: 'String', proto: true, forced: stringHtmlForced('bold') }, {
	  bold: function bold() {
	    return createHtml(this, 'b', '', '');
	  }
	});

	// `String.prototype.fixed` method
	// https://tc39.es/ecma262/#sec-string.prototype.fixed
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fixed') }, {
	  fixed: function fixed() {
	    return createHtml(this, 'tt', '', '');
	  }
	});

	// `String.prototype.fontcolor` method
	// https://tc39.es/ecma262/#sec-string.prototype.fontcolor
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fontcolor') }, {
	  fontcolor: function fontcolor(color) {
	    return createHtml(this, 'font', 'color', color);
	  }
	});

	// `String.prototype.fontsize` method
	// https://tc39.es/ecma262/#sec-string.prototype.fontsize
	_export({ target: 'String', proto: true, forced: stringHtmlForced('fontsize') }, {
	  fontsize: function fontsize(size) {
	    return createHtml(this, 'font', 'size', size);
	  }
	});

	// `String.prototype.italics` method
	// https://tc39.es/ecma262/#sec-string.prototype.italics
	_export({ target: 'String', proto: true, forced: stringHtmlForced('italics') }, {
	  italics: function italics() {
	    return createHtml(this, 'i', '', '');
	  }
	});

	// `String.prototype.link` method
	// https://tc39.es/ecma262/#sec-string.prototype.link
	_export({ target: 'String', proto: true, forced: stringHtmlForced('link') }, {
	  link: function link(url) {
	    return createHtml(this, 'a', 'href', url);
	  }
	});

	// `String.prototype.small` method
	// https://tc39.es/ecma262/#sec-string.prototype.small
	_export({ target: 'String', proto: true, forced: stringHtmlForced('small') }, {
	  small: function small() {
	    return createHtml(this, 'small', '', '');
	  }
	});

	// `String.prototype.strike` method
	// https://tc39.es/ecma262/#sec-string.prototype.strike
	_export({ target: 'String', proto: true, forced: stringHtmlForced('strike') }, {
	  strike: function strike() {
	    return createHtml(this, 'strike', '', '');
	  }
	});

	// `String.prototype.sub` method
	// https://tc39.es/ecma262/#sec-string.prototype.sub
	_export({ target: 'String', proto: true, forced: stringHtmlForced('sub') }, {
	  sub: function sub() {
	    return createHtml(this, 'sub', '', '');
	  }
	});

	// `String.prototype.sup` method
	// https://tc39.es/ecma262/#sec-string.prototype.sup
	_export({ target: 'String', proto: true, forced: stringHtmlForced('sup') }, {
	  sup: function sup() {
	    return createHtml(this, 'sup', '', '');
	  }
	});

	/* eslint-disable no-new -- required for testing */



	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	var ArrayBuffer$1 = global_1.ArrayBuffer;
	var Int8Array$3 = global_1.Int8Array;

	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
	  Int8Array$3(1);
	}) || !fails(function () {
	  new Int8Array$3(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$3();
	  new Int8Array$3(null);
	  new Int8Array$3(1.5);
	  new Int8Array$3(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$3(new ArrayBuffer$1(2), 1, undefined).length !== 1;
	});

	var RangeError$7 = global_1.RangeError;

	var toPositiveInteger = function (it) {
	  var result = toIntegerOrInfinity(it);
	  if (result < 0) throw RangeError$7("The argument can't be less than 0");
	  return result;
	};

	var RangeError$6 = global_1.RangeError;

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError$6('Wrong offset');
	  return offset;
	};

	var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;

	var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
	  var C = aConstructor(this);
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;
	  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = getIterator(O, iteratorMethod);
	    next = iterator.next;
	    O = [];
	    while (!(step = functionCall(next, iterator)).done) {
	      O.push(step.value);
	    }
	  }
	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2]);
	  }
	  length = lengthOfArrayLike(O);
	  result = new (aTypedArrayConstructor$3(C))(length);
	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }
	  return result;
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {






















	var getOwnPropertyNames = objectGetOwnPropertyNames.f;

	var forEach = arrayIteration.forEach;






	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var round = Math.round;
	var RangeError = global_1.RangeError;
	var ArrayBuffer = arrayBuffer.ArrayBuffer;
	var ArrayBufferPrototype = ArrayBuffer.prototype;
	var DataView = arrayBuffer.DataView;
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var TYPED_ARRAY_CONSTRUCTOR = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
	var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	var TypedArray = arrayBufferViewCore.TypedArray;
	var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var isTypedArray = arrayBufferViewCore.isTypedArray;
	var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	var WRONG_LENGTH = 'Wrong length';

	var fromList = function (C, list) {
	  aTypedArrayConstructor(C);
	  var index = 0;
	  var length = list.length;
	  var result = new C(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	};

	var addGetter = function (it, key) {
	  nativeDefineProperty(it, key, { get: function () {
	    return getInternalState(this)[key];
	  } });
	};

	var isArrayBuffer = function (it) {
	  var klass;
	  return objectIsPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	};

	var isTypedArrayIndex = function (target, key) {
	  return isTypedArray(target)
	    && !isSymbol$1(key)
	    && key in target
	    && isIntegralNumber(+key)
	    && key >= 0;
	};

	var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	  key = toPropertyKey(key);
	  return isTypedArrayIndex(target, key)
	    ? createPropertyDescriptor(2, target[key])
	    : nativeGetOwnPropertyDescriptor(target, key);
	};

	var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	  key = toPropertyKey(key);
	  if (isTypedArrayIndex(target, key)
	    && isObject$2(descriptor)
	    && hasOwnProperty_1(descriptor, 'value')
	    && !hasOwnProperty_1(descriptor, 'get')
	    && !hasOwnProperty_1(descriptor, 'set')
	    // TODO: add validation descriptor w/o calling accessors
	    && !descriptor.configurable
	    && (!hasOwnProperty_1(descriptor, 'writable') || descriptor.writable)
	    && (!hasOwnProperty_1(descriptor, 'enumerable') || descriptor.enumerable)
	  ) {
	    target[key] = descriptor.value;
	    return target;
	  } return nativeDefineProperty(target, key, descriptor);
	};

	if (descriptors) {
	  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	    objectDefineProperty.f = wrappedDefineProperty;
	    addGetter(TypedArrayPrototype, 'buffer');
	    addGetter(TypedArrayPrototype, 'byteOffset');
	    addGetter(TypedArrayPrototype, 'byteLength');
	    addGetter(TypedArrayPrototype, 'length');
	  }

	  _export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
	    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	    defineProperty: wrappedDefineProperty
	  });

	  module.exports = function (TYPE, wrapper, CLAMPED) {
	    var BYTES = TYPE.match(/\d+$/)[0] / 8;
	    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + TYPE;
	    var SETTER = 'set' + TYPE;
	    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	    var TypedArrayConstructor = NativeTypedArrayConstructor;
	    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	    var exported = {};

	    var getter = function (that, index) {
	      var data = getInternalState(that);
	      return data.view[GETTER](index * BYTES + data.byteOffset, true);
	    };

	    var setter = function (that, index, value) {
	      var data = getInternalState(that);
	      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	    };

	    var addElement = function (that, index) {
	      nativeDefineProperty(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };

	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	        anInstance(that, TypedArrayConstructorPrototype);
	        var index = 0;
	        var byteOffset = 0;
	        var buffer, byteLength, length;
	        if (!isObject$2(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new ArrayBuffer(byteLength);
	        } else if (isArrayBuffer(data)) {
	          buffer = data;
	          byteOffset = toOffset(offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - byteOffset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (isTypedArray(data)) {
	          return fromList(TypedArrayConstructor, data);
	        } else {
	          return functionCall(typedArrayFrom, TypedArrayConstructor, data);
	        }
	        setInternalState(that, {
	          buffer: buffer,
	          byteOffset: byteOffset,
	          byteLength: byteLength,
	          length: length,
	          view: new DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });

	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
	    } else if (typedArrayConstructorsRequireWrappers) {
	      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	        anInstance(dummy, TypedArrayConstructorPrototype);
	        return inheritIfRequired(function () {
	          if (!isObject$2(data)) return new NativeTypedArrayConstructor(toIndex(data));
	          if (isArrayBuffer(data)) return $length !== undefined
	            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
	            : typedArrayOffset !== undefined
	              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
	              : new NativeTypedArrayConstructor(data);
	          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	          return functionCall(typedArrayFrom, TypedArrayConstructor, data);
	        }(), dummy, TypedArrayConstructor);
	      });

	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	        if (!(key in TypedArrayConstructor)) {
	          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	        }
	      });
	      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	    }

	    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	    }

	    createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);

	    if (TYPED_ARRAY_TAG) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	    }

	    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

	    _export({
	      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, exported);

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	    }

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	    }

	    setSpecies(CONSTRUCTOR_NAME);
	  };
	} else module.exports = function () { /* empty */ };
	});

	// `Float32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float64Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float64', function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int8Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int8', function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int16Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int16', function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int32', function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8ClampedArray` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	// `Uint16Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint16', function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint32', function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var aTypedArray$w = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$x = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.at` method
	// https://github.com/tc39/proposal-relative-indexing-method
	exportTypedArrayMethod$x('at', function at(index) {
	  var O = aTypedArray$w(this);
	  var len = lengthOfArrayLike(O);
	  var relativeIndex = toIntegerOrInfinity(index);
	  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
	  return (k < 0 || k >= len) ? undefined : O[k];
	});

	var u$ArrayCopyWithin = functionUncurryThis(arrayCopyWithin);
	var aTypedArray$v = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$w = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.copyWithin` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
	exportTypedArrayMethod$w('copyWithin', function copyWithin(target, start /* , end */) {
	  return u$ArrayCopyWithin(aTypedArray$v(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	});

	var $every$1 = arrayIteration.every;

	var aTypedArray$u = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$v = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.every` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
	exportTypedArrayMethod$v('every', function every(callbackfn /* , thisArg */) {
	  return $every$1(aTypedArray$u(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$t = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$u = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.fill` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
	exportTypedArrayMethod$u('fill', function fill(value /* , start, end */) {
	  var length = arguments.length;
	  return functionCall(
	    arrayFill,
	    aTypedArray$t(this),
	    value,
	    length > 1 ? arguments[1] : undefined,
	    length > 2 ? arguments[2] : undefined
	  );
	});

	var arrayFromConstructorAndList = function (Constructor, list) {
	  var index = 0;
	  var length = lengthOfArrayLike(list);
	  var result = new Constructor(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	};

	var TYPED_ARRAY_CONSTRUCTOR$4 = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;

	// a part of `TypedArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#typedarray-species-create
	var typedArraySpeciesConstructor = function (originalArray) {
	  return aTypedArrayConstructor$2(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR$4]));
	};

	var typedArrayFromSpeciesAndList = function (instance, list) {
	  return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
	};

	var $filter = arrayIteration.filter;


	var aTypedArray$s = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$t = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.filter` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
	exportTypedArrayMethod$t('filter', function filter(callbackfn /* , thisArg */) {
	  var list = $filter(aTypedArray$s(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  return typedArrayFromSpeciesAndList(this, list);
	});

	var $find$1 = arrayIteration.find;

	var aTypedArray$r = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$s = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.find` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
	exportTypedArrayMethod$s('find', function find(predicate /* , thisArg */) {
	  return $find$1(aTypedArray$r(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findIndex = arrayIteration.findIndex;

	var aTypedArray$q = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$r = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.findIndex` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
	exportTypedArrayMethod$r('findIndex', function findIndex(predicate /* , thisArg */) {
	  return $findIndex(aTypedArray$q(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $forEach$1 = arrayIteration.forEach;

	var aTypedArray$p = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$q = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.forEach` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
	exportTypedArrayMethod$q('forEach', function forEach(callbackfn /* , thisArg */) {
	  $forEach$1(aTypedArray$p(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;


	// `%TypedArray%.from` method
	// https://tc39.es/ecma262/#sec-%typedarray%.from
	exportTypedArrayStaticMethod$2('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

	var $includes = arrayIncludes$1.includes;

	var aTypedArray$o = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$p = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.includes` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
	exportTypedArrayMethod$p('includes', function includes(searchElement /* , fromIndex */) {
	  return $includes(aTypedArray$o(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $indexOf = arrayIncludes$1.indexOf;

	var aTypedArray$n = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$o = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.indexOf` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
	exportTypedArrayMethod$o('indexOf', function indexOf(searchElement /* , fromIndex */) {
	  return $indexOf(aTypedArray$n(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var Uint8Array$2 = global_1.Uint8Array;
	var arrayValues = functionUncurryThis(es_array_iterator.values);
	var arrayKeys = functionUncurryThis(es_array_iterator.keys);
	var arrayEntries = functionUncurryThis(es_array_iterator.entries);
	var aTypedArray$m = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;
	var TypedArrayPrototype = Uint8Array$2 && Uint8Array$2.prototype;

	var GENERIC = !fails(function () {
	  TypedArrayPrototype[ITERATOR$3].call([1]);
	});

	var ITERATOR_IS_VALUES = !!TypedArrayPrototype
	  && TypedArrayPrototype.values
	  && TypedArrayPrototype[ITERATOR$3] === TypedArrayPrototype.values
	  && TypedArrayPrototype.values.name === 'values';

	var typedArrayValues = function values() {
	  return arrayValues(aTypedArray$m(this));
	};

	// `%TypedArray%.prototype.entries` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
	exportTypedArrayMethod$n('entries', function entries() {
	  return arrayEntries(aTypedArray$m(this));
	}, GENERIC);
	// `%TypedArray%.prototype.keys` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
	exportTypedArrayMethod$n('keys', function keys() {
	  return arrayKeys(aTypedArray$m(this));
	}, GENERIC);
	// `%TypedArray%.prototype.values` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
	exportTypedArrayMethod$n('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });
	// `%TypedArray%.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
	exportTypedArrayMethod$n(ITERATOR$3, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });

	var aTypedArray$l = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
	var $join = functionUncurryThis([].join);

	// `%TypedArray%.prototype.join` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
	exportTypedArrayMethod$m('join', function join(separator) {
	  return $join(aTypedArray$l(this), separator);
	});

	var aTypedArray$k = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.lastIndexOf` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
	exportTypedArrayMethod$l('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
	  var length = arguments.length;
	  return functionApply(arrayLastIndexOf, aTypedArray$k(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
	});

	var $map = arrayIteration.map;


	var aTypedArray$j = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.map` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
	exportTypedArrayMethod$k('map', function map(mapfn /* , thisArg */) {
	  return $map(aTypedArray$j(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
	    return new (typedArraySpeciesConstructor(O))(length);
	  });
	});

	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;

	// `%TypedArray%.of` method
	// https://tc39.es/ecma262/#sec-%typedarray%.of
	exportTypedArrayStaticMethod$1('of', function of(/* ...items */) {
	  var index = 0;
	  var length = arguments.length;
	  var result = new (aTypedArrayConstructor$1(this))(length);
	  while (length > index) result[index] = arguments[index++];
	  return result;
	}, typedArrayConstructorsRequireWrappers);

	var $reduce = arrayReduce.left;

	var aTypedArray$i = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduce` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
	exportTypedArrayMethod$j('reduce', function reduce(callbackfn /* , initialValue */) {
	  var length = arguments.length;
	  return $reduce(aTypedArray$i(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
	});

	var $reduceRight = arrayReduce.right;

	var aTypedArray$h = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduceRicht` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
	exportTypedArrayMethod$i('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
	  var length = arguments.length;
	  return $reduceRight(aTypedArray$h(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$g = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;
	var floor$2 = Math.floor;

	// `%TypedArray%.prototype.reverse` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
	exportTypedArrayMethod$h('reverse', function reverse() {
	  var that = this;
	  var length = aTypedArray$g(that).length;
	  var middle = floor$2(length / 2);
	  var index = 0;
	  var value;
	  while (index < middle) {
	    value = that[index];
	    that[index++] = that[--length];
	    that[length] = value;
	  } return that;
	});

	var RangeError$5 = global_1.RangeError;
	var Int8Array$2 = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;
	var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
	var aTypedArray$f = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;

	var WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails(function () {
	  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing
	  var array = new Uint8ClampedArray(2);
	  functionCall($set, array, { length: 1, 0: 3 }, 1);
	  return array[1] !== 3;
	});

	// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
	var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
	  var array = new Int8Array$2(2);
	  array.set(1);
	  array.set('2', 1);
	  return array[0] !== 0 || array[1] !== 2;
	});

	// `%TypedArray%.prototype.set` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
	exportTypedArrayMethod$g('set', function set(arrayLike /* , offset */) {
	  aTypedArray$f(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var src = toObject(arrayLike);
	  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return functionCall($set, this, src, offset);
	  var length = this.length;
	  var len = lengthOfArrayLike(src);
	  var index = 0;
	  if (len + offset > length) throw RangeError$5('Wrong length');
	  while (index < len) this[offset + index] = src[index++];
	}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);

	var aTypedArray$e = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;

	var FORCED$2 = fails(function () {
	  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing
	  new Int8Array(1).slice();
	});

	// `%TypedArray%.prototype.slice` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
	exportTypedArrayMethod$f('slice', function slice(start, end) {
	  var list = arraySlice$1(aTypedArray$e(this), start, end);
	  var C = typedArraySpeciesConstructor(this);
	  var index = 0;
	  var length = list.length;
	  var result = new C(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	}, FORCED$2);

	var $some$1 = arrayIteration.some;

	var aTypedArray$d = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.some` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
	exportTypedArrayMethod$e('some', function some(callbackfn /* , thisArg */) {
	  return $some$1(aTypedArray$d(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$c = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;
	var Uint16Array = global_1.Uint16Array;
	var un$Sort = Uint16Array && functionUncurryThis(Uint16Array.prototype.sort);

	// WebKit
	var ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails(function () {
	  un$Sort(new Uint16Array(2), null);
	}) && fails(function () {
	  un$Sort(new Uint16Array(2), {});
	}));

	var STABLE_SORT = !!un$Sort && !fails(function () {
	  // feature detection can be too slow, so check engines versions
	  if (engineV8Version) return engineV8Version < 74;
	  if (engineFfVersion) return engineFfVersion < 67;
	  if (engineIsIeOrEdge) return true;
	  if (engineWebkitVersion) return engineWebkitVersion < 602;

	  var array = new Uint16Array(516);
	  var expected = Array(516);
	  var index, mod;

	  for (index = 0; index < 516; index++) {
	    mod = index % 4;
	    array[index] = 515 - index;
	    expected[index] = index - 2 * mod + 3;
	  }

	  un$Sort(array, function (a, b) {
	    return (a / 4 | 0) - (b / 4 | 0);
	  });

	  for (index = 0; index < 516; index++) {
	    if (array[index] !== expected[index]) return true;
	  }
	});

	var getSortCompare = function (comparefn) {
	  return function (x, y) {
	    if (comparefn !== undefined) return +comparefn(x, y) || 0;
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (y !== y) return -1;
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (x !== x) return 1;
	    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
	    return x > y;
	  };
	};

	// `%TypedArray%.prototype.sort` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
	exportTypedArrayMethod$d('sort', function sort(comparefn) {
	  if (comparefn !== undefined) aCallable(comparefn);
	  if (STABLE_SORT) return un$Sort(this, comparefn);

	  return arraySort(aTypedArray$c(this), getSortCompare(comparefn));
	}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

	var aTypedArray$b = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.subarray` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
	exportTypedArrayMethod$c('subarray', function subarray(begin, end) {
	  var O = aTypedArray$b(this);
	  var length = O.length;
	  var beginIndex = toAbsoluteIndex(begin, length);
	  var C = typedArraySpeciesConstructor(O);
	  return new C(
	    O.buffer,
	    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
	    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
	  );
	});

	var Int8Array$1 = global_1.Int8Array;
	var aTypedArray$a = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
	var $toLocaleString = [].toLocaleString;

	// iOS Safari 6.x fails here
	var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails(function () {
	  $toLocaleString.call(new Int8Array$1(1));
	});

	var FORCED$1 = fails(function () {
	  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();
	}) || !fails(function () {
	  Int8Array$1.prototype.toLocaleString.call([1, 2]);
	});

	// `%TypedArray%.prototype.toLocaleString` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
	exportTypedArrayMethod$b('toLocaleString', function toLocaleString() {
	  return functionApply(
	    $toLocaleString,
	    TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray$a(this)) : aTypedArray$a(this),
	    arraySlice$1(arguments)
	  );
	}, FORCED$1);

	var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;




	var Uint8Array$1 = global_1.Uint8Array;
	var Uint8ArrayPrototype = Uint8Array$1 && Uint8Array$1.prototype || {};
	var arrayToString = [].toString;
	var join$4 = functionUncurryThis([].join);

	if (fails(function () { arrayToString.call({}); })) {
	  arrayToString = function toString() {
	    return join$4(this);
	  };
	}

	var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

	// `%TypedArray%.prototype.toString` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
	exportTypedArrayMethod$a('toString', arrayToString, IS_NOT_ARRAY_METHOD);

	var fromCharCode$2 = String.fromCharCode;
	var charAt$7 = functionUncurryThis(''.charAt);
	var exec$5 = functionUncurryThis(/./.exec);
	var stringSlice$3 = functionUncurryThis(''.slice);

	var hex2 = /^[\da-f]{2}$/i;
	var hex4 = /^[\da-f]{4}$/i;

	// `unescape` method
	// https://tc39.es/ecma262/#sec-unescape-string
	_export({ global: true }, {
	  unescape: function unescape(string) {
	    var str = toString_1$1(string);
	    var result = '';
	    var length = str.length;
	    var index = 0;
	    var chr, part;
	    while (index < length) {
	      chr = charAt$7(str, index++);
	      if (chr === '%') {
	        if (charAt$7(str, index) === 'u') {
	          part = stringSlice$3(str, index + 1, index + 5);
	          if (exec$5(hex4, part)) {
	            result += fromCharCode$2(parseInt(part, 16));
	            index += 5;
	            continue;
	          }
	        } else {
	          part = stringSlice$3(str, index, index + 2);
	          if (exec$5(hex2, part)) {
	            result += fromCharCode$2(parseInt(part, 16));
	            index += 2;
	            continue;
	          }
	        }
	      }
	      result += chr;
	    } return result;
	  }
	});

	var getWeakData = internalMetadata.getWeakData;








	var setInternalState$b = internalState.set;
	var internalStateGetterFor = internalState.getterFor;
	var find$1 = arrayIteration.find;
	var findIndex = arrayIteration.findIndex;
	var splice$2 = functionUncurryThis([].splice);
	var id = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (store) {
	  return store.frozen || (store.frozen = new UncaughtFrozenStore());
	};

	var UncaughtFrozenStore = function () {
	  this.entries = [];
	};

	var findUncaughtFrozen = function (store, key) {
	  return find$1(store.entries, function (it) {
	    return it[0] === key;
	  });
	};

	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.entries.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = findIndex(this.entries, function (it) {
	      return it[0] === key;
	    });
	    if (~index) splice$2(this.entries, index, 1);
	    return !!~index;
	  }
	};

	var collectionWeak = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var Constructor = wrapper(function (that, iterable) {
	      anInstance(that, Prototype);
	      setInternalState$b(that, {
	        type: CONSTRUCTOR_NAME,
	        id: id++,
	        frozen: undefined
	      });
	      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
	    });

	    var Prototype = Constructor.prototype;

	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var data = getWeakData(anObject(key), true);
	      if (data === true) uncaughtFrozenStore(state).set(key, value);
	      else data[state.id] = value;
	      return that;
	    };

	    redefineAll(Prototype, {
	      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
	      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
	      'delete': function (key) {
	        var state = getInternalState(this);
	        if (!isObject$2(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
	        return data && hasOwnProperty_1(data, state.id) && delete data[state.id];
	      },
	      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
	      // https://tc39.es/ecma262/#sec-weakset.prototype.has
	      has: function has(key) {
	        var state = getInternalState(this);
	        if (!isObject$2(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state).has(key);
	        return data && hasOwnProperty_1(data, state.id);
	      }
	    });

	    redefineAll(Prototype, IS_MAP ? {
	      // `WeakMap.prototype.get(key)` method
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
	      get: function get(key) {
	        var state = getInternalState(this);
	        if (isObject$2(key)) {
	          var data = getWeakData(key);
	          if (data === true) return uncaughtFrozenStore(state).get(key);
	          return data ? data[state.id] : undefined;
	        }
	      },
	      // `WeakMap.prototype.set(key, value)` method
	      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
	      set: function set(key, value) {
	        return define(this, key, value);
	      }
	    } : {
	      // `WeakSet.prototype.add(value)` method
	      // https://tc39.es/ecma262/#sec-weakset.prototype.add
	      add: function add(value) {
	        return define(this, value, true);
	      }
	    });

	    return Constructor;
	  }
	};
	collectionWeak.getConstructor;

	var enforceInternalState = internalState.enforce;


	var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;
	var InternalWeakMap;

	var wrapper = function (init) {
	  return function WeakMap() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	};

	// `WeakMap` constructor
	// https://tc39.es/ecma262/#sec-weakmap-constructor
	var $WeakMap = collection('WeakMap', wrapper, collectionWeak);

	// IE11 WeakMap frozen keys fix
	// We can't use feature detection because it crash some old IE builds
	// https://github.com/zloirock/core-js/issues/485
	if (nativeWeakMap && IS_IE11) {
	  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
	  internalMetadata.enable();
	  var WeakMapPrototype = $WeakMap.prototype;
	  var nativeDelete = functionUncurryThis(WeakMapPrototype['delete']);
	  var nativeHas = functionUncurryThis(WeakMapPrototype.has);
	  var nativeGet = functionUncurryThis(WeakMapPrototype.get);
	  var nativeSet = functionUncurryThis(WeakMapPrototype.set);
	  redefineAll(WeakMapPrototype, {
	    'delete': function (key) {
	      if (isObject$2(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeDelete(this, key) || state.frozen['delete'](key);
	      } return nativeDelete(this, key);
	    },
	    has: function has(key) {
	      if (isObject$2(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas(this, key) || state.frozen.has(key);
	      } return nativeHas(this, key);
	    },
	    get: function get(key) {
	      if (isObject$2(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
	      } return nativeGet(this, key);
	    },
	    set: function set(key, value) {
	      if (isObject$2(key) && !objectIsExtensible(key)) {
	        var state = enforceInternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
	      } else nativeSet(this, key, value);
	      return this;
	    }
	  });
	}

	// `WeakSet` constructor
	// https://tc39.es/ecma262/#sec-weakset-constructor
	collection('WeakSet', function (init) {
	  return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionWeak);

	var USE_FUNCTION_CONSTRUCTOR = 'USE_FUNCTION_CONSTRUCTOR';
	var ASYNC_ITERATOR$3 = wellKnownSymbol('asyncIterator');
	var AsyncIterator = global_1.AsyncIterator;
	var PassedAsyncIteratorPrototype = sharedStore.AsyncIteratorPrototype;
	var AsyncIteratorPrototype, prototype;

	if (PassedAsyncIteratorPrototype) {
	  AsyncIteratorPrototype = PassedAsyncIteratorPrototype;
	} else if (isCallable(AsyncIterator)) {
	  AsyncIteratorPrototype = AsyncIterator.prototype;
	} else if (sharedStore[USE_FUNCTION_CONSTRUCTOR] || global_1[USE_FUNCTION_CONSTRUCTOR]) {
	  try {
	    // eslint-disable-next-line no-new-func -- we have no alternatives without usage of modern syntax
	    prototype = objectGetPrototypeOf(objectGetPrototypeOf(objectGetPrototypeOf(Function('return async function*(){}()')())));
	    if (objectGetPrototypeOf(prototype) === Object.prototype) AsyncIteratorPrototype = prototype;
	  } catch (error) { /* empty */ }
	}

	if (!AsyncIteratorPrototype) AsyncIteratorPrototype = {};

	if (!isCallable(AsyncIteratorPrototype[ASYNC_ITERATOR$3])) {
	  redefine(AsyncIteratorPrototype, ASYNC_ITERATOR$3, function () {
	    return this;
	  });
	}

	var asyncIteratorPrototype = AsyncIteratorPrototype;

	var Promise$4 = getBuiltIn('Promise');

	var ASYNC_FROM_SYNC_ITERATOR = 'AsyncFromSyncIterator';
	var setInternalState$a = internalState.set;
	var getInternalState$7 = internalState.getterFor(ASYNC_FROM_SYNC_ITERATOR);

	var asyncFromSyncIteratorContinuation = function (result, resolve, reject) {
	  var done = result.done;
	  Promise$4.resolve(result.value).then(function (value) {
	    resolve({ done: done, value: value });
	  }, reject);
	};

	var AsyncFromSyncIterator = function AsyncIterator(iterator) {
	  setInternalState$a(this, {
	    type: ASYNC_FROM_SYNC_ITERATOR,
	    iterator: anObject(iterator),
	    next: iterator.next
	  });
	};

	AsyncFromSyncIterator.prototype = redefineAll(objectCreate(asyncIteratorPrototype), {
	  next: function next(arg) {
	    var state = getInternalState$7(this);
	    var hasArg = !!arguments.length;
	    return new Promise$4(function (resolve, reject) {
	      var result = anObject(functionApply(state.next, state.iterator, hasArg ? [arg] : []));
	      asyncFromSyncIteratorContinuation(result, resolve, reject);
	    });
	  },
	  'return': function (arg) {
	    var iterator = getInternalState$7(this).iterator;
	    var hasArg = !!arguments.length;
	    return new Promise$4(function (resolve, reject) {
	      var $return = getMethod(iterator, 'return');
	      if ($return === undefined) return resolve({ done: true, value: arg });
	      var result = anObject(functionApply($return, iterator, hasArg ? [arg] : []));
	      asyncFromSyncIteratorContinuation(result, resolve, reject);
	    });
	  },
	  'throw': function (arg) {
	    var iterator = getInternalState$7(this).iterator;
	    var hasArg = !!arguments.length;
	    return new Promise$4(function (resolve, reject) {
	      var $throw = getMethod(iterator, 'throw');
	      if ($throw === undefined) return reject(arg);
	      var result = anObject(functionApply($throw, iterator, hasArg ? [arg] : []));
	      asyncFromSyncIteratorContinuation(result, resolve, reject);
	    });
	  }
	});

	var asyncFromSyncIterator = AsyncFromSyncIterator;

	var ASYNC_ITERATOR$2 = wellKnownSymbol('asyncIterator');

	var getAsyncIterator = function (it, usingIterator) {
	  var method = arguments.length < 2 ? getMethod(it, ASYNC_ITERATOR$2) : usingIterator;
	  return method ? anObject(functionCall(method, it)) : new asyncFromSyncIterator(getIterator(it));
	};

	var entryVirtual = function (CONSTRUCTOR) {
	  return global_1[CONSTRUCTOR].prototype;
	};

	// https://github.com/tc39/proposal-iterator-helpers
	// https://github.com/tc39/proposal-array-from-async







	var MAX_SAFE_INTEGER$3 = 0x1FFFFFFFFFFFFF;
	var TypeError$g = global_1.TypeError;

	var createMethod$1 = function (TYPE) {
	  var IS_TO_ARRAY = TYPE == 0;
	  var IS_FOR_EACH = TYPE == 1;
	  var IS_EVERY = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  return function (iterator, fn, target) {
	    anObject(iterator);
	    var Promise = getBuiltIn('Promise');
	    var next = aCallable(iterator.next);
	    var index = 0;
	    var MAPPING = fn !== undefined;
	    if (MAPPING || !IS_TO_ARRAY) aCallable(fn);

	    return new Promise(function (resolve, reject) {
	      var closeIteration = function (method, argument) {
	        try {
	          var returnMethod = getMethod(iterator, 'return');
	          if (returnMethod) {
	            return Promise.resolve(functionCall(returnMethod, iterator)).then(function () {
	              method(argument);
	            }, function (error) {
	              reject(error);
	            });
	          }
	        } catch (error2) {
	          return reject(error2);
	        } method(argument);
	      };

	      var onError = function (error) {
	        closeIteration(reject, error);
	      };

	      var loop = function () {
	        try {
	          if (IS_TO_ARRAY && (index > MAX_SAFE_INTEGER$3) && MAPPING) {
	            throw TypeError$g('The allowed number of iterations has been exceeded');
	          }
	          Promise.resolve(anObject(functionCall(next, iterator))).then(function (step) {
	            try {
	              if (anObject(step).done) {
	                if (IS_TO_ARRAY) {
	                  target.length = index;
	                  resolve(target);
	                } else resolve(IS_SOME ? false : IS_EVERY || undefined);
	              } else {
	                var value = step.value;
	                if (MAPPING) {
	                  Promise.resolve(IS_TO_ARRAY ? fn(value, index) : fn(value)).then(function (result) {
	                    if (IS_FOR_EACH) {
	                      loop();
	                    } else if (IS_EVERY) {
	                      result ? loop() : closeIteration(resolve, false);
	                    } else if (IS_TO_ARRAY) {
	                      target[index++] = result;
	                      loop();
	                    } else {
	                      result ? closeIteration(resolve, IS_SOME || value) : loop();
	                    }
	                  }, onError);
	                } else {
	                  target[index++] = value;
	                  loop();
	                }
	              }
	            } catch (error) { onError(error); }
	          }, onError);
	        } catch (error2) { onError(error2); }
	      };

	      loop();
	    });
	  };
	};

	var asyncIteratorIteration = {
	  toArray: createMethod$1(0),
	  forEach: createMethod$1(1),
	  every: createMethod$1(2),
	  some: createMethod$1(3),
	  find: createMethod$1(4)
	};

	var toArray = asyncIteratorIteration.toArray;

	var ASYNC_ITERATOR$1 = wellKnownSymbol('asyncIterator');
	var arrayIterator = entryVirtual('Array').values;

	// `Array.fromAsync` method implementation
	// https://github.com/tc39/proposal-array-from-async
	var arrayFromAsync = function fromAsync(asyncItems /* , mapfn = undefined, thisArg = undefined */) {
	  var C = this;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var thisArg = argumentsLength > 2 ? arguments[2] : undefined;
	  return new (getBuiltIn('Promise'))(function (resolve) {
	    var O = toObject(asyncItems);
	    if (mapfn !== undefined) mapfn = functionBindContext(mapfn, thisArg);
	    var usingAsyncIterator = getMethod(O, ASYNC_ITERATOR$1);
	    var usingSyncIterator = usingAsyncIterator ? undefined : getIteratorMethod(O) || arrayIterator;
	    var A = isConstructor(C) ? new C() : [];
	    var iterator = usingAsyncIterator
	      ? getAsyncIterator(O, usingAsyncIterator)
	      : new asyncFromSyncIterator(getIterator(O, usingSyncIterator));
	    resolve(toArray(iterator, mapfn, A));
	  });
	};

	// `Array.fromAsync` method
	// https://github.com/tc39/proposal-array-from-async
	_export({ target: 'Array', stat: true, forced: true }, {
	  fromAsync: arrayFromAsync
	});

	// TODO: remove from `core-js@4`

	var $filterReject$3 = arrayIteration.filterReject;


	// `Array.prototype.filterOut` method
	// https://github.com/tc39/proposal-array-filtering
	_export({ target: 'Array', proto: true, forced: true }, {
	  filterOut: function filterOut(callbackfn /* , thisArg */) {
	    return $filterReject$3(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	addToUnscopables('filterOut');

	var $filterReject$2 = arrayIteration.filterReject;


	// `Array.prototype.filterReject` method
	// https://github.com/tc39/proposal-array-filtering
	_export({ target: 'Array', proto: true, forced: true }, {
	  filterReject: function filterReject(callbackfn /* , thisArg */) {
	    return $filterReject$2(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	addToUnscopables('filterReject');

	// `Array.prototype.{ findLast, findLastIndex }` methods implementation
	var createMethod = function (TYPE) {
	  var IS_FIND_LAST_INDEX = TYPE == 1;
	  return function ($this, callbackfn, that) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that);
	    var index = lengthOfArrayLike(self);
	    var value, result;
	    while (index-- > 0) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (result) switch (TYPE) {
	        case 0: return value; // findLast
	        case 1: return index; // findLastIndex
	      }
	    }
	    return IS_FIND_LAST_INDEX ? -1 : undefined;
	  };
	};

	var arrayIterationFromLast = {
	  // `Array.prototype.findLast` method
	  // https://github.com/tc39/proposal-array-find-from-last
	  findLast: createMethod(0),
	  // `Array.prototype.findLastIndex` method
	  // https://github.com/tc39/proposal-array-find-from-last
	  findLastIndex: createMethod(1)
	};

	var $findLast$1 = arrayIterationFromLast.findLast;


	// `Array.prototype.findLast` method
	// https://github.com/tc39/proposal-array-find-from-last
	_export({ target: 'Array', proto: true }, {
	  findLast: function findLast(callbackfn /* , that = undefined */) {
	    return $findLast$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	addToUnscopables('findLast');

	var $findLastIndex$1 = arrayIterationFromLast.findLastIndex;


	// `Array.prototype.findLastIndex` method
	// https://github.com/tc39/proposal-array-find-from-last
	_export({ target: 'Array', proto: true }, {
	  findLastIndex: function findLastIndex(callbackfn /* , that = undefined */) {
	    return $findLastIndex$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	addToUnscopables('findLastIndex');

	var Array$6 = global_1.Array;
	var push$c = functionUncurryThis([].push);

	var arrayGroupBy = function ($this, callbackfn, that, specificConstructor) {
	  var O = toObject($this);
	  var self = indexedObject(O);
	  var boundFunction = functionBindContext(callbackfn, that);
	  var target = objectCreate(null);
	  var length = lengthOfArrayLike(self);
	  var index = 0;
	  var Constructor, key, value;
	  for (;length > index; index++) {
	    value = self[index];
	    key = toPropertyKey(boundFunction(value, index, O));
	    // in some IE10 builds, `hasOwnProperty` returns incorrect result on integer keys
	    // but since it's a `null` prototype object, we can safely use `in`
	    if (key in target) push$c(target[key], value);
	    else target[key] = [value];
	  }
	  // TODO: Remove this block from `core-js@4`
	  if (specificConstructor) {
	    Constructor = specificConstructor(O);
	    if (Constructor !== Array$6) {
	      for (key in target) target[key] = arrayFromConstructorAndList(Constructor, target[key]);
	    }
	  } return target;
	};

	// `Array.prototype.groupBy` method
	// https://github.com/tc39/proposal-array-grouping
	// https://bugs.webkit.org/show_bug.cgi?id=236541
	_export({ target: 'Array', proto: true, forced: !arrayMethodIsStrict('groupBy') }, {
	  groupBy: function groupBy(callbackfn /* , thisArg */) {
	    var thisArg = arguments.length > 1 ? arguments[1] : undefined;
	    return arrayGroupBy(this, callbackfn, thisArg);
	  }
	});

	addToUnscopables('groupBy');

	var Map$6 = getBuiltIn('Map');
	var MapPrototype$2 = Map$6.prototype;
	var mapGet$1 = functionUncurryThis(MapPrototype$2.get);
	var mapHas$2 = functionUncurryThis(MapPrototype$2.has);
	var mapSet$2 = functionUncurryThis(MapPrototype$2.set);
	var push$b = functionUncurryThis([].push);

	// `Array.prototype.groupByToMap` method
	// https://github.com/tc39/proposal-array-grouping
	// https://bugs.webkit.org/show_bug.cgi?id=236541
	_export({ target: 'Array', proto: true, forced: !arrayMethodIsStrict('groupByToMap') }, {
	  groupByToMap: function groupByToMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    var map = new Map$6();
	    var length = lengthOfArrayLike(self);
	    var index = 0;
	    var key, value;
	    for (;length > index; index++) {
	      value = self[index];
	      key = boundFunction(value, index, O);
	      if (mapHas$2(map, key)) push$b(mapGet$1(map, key), value);
	      else mapSet$2(map, key, [value]);
	    } return map;
	  }
	});

	addToUnscopables('groupByToMap');

	// eslint-disable-next-line es-x/no-object-isfrozen -- safe
	var isFrozen = Object.isFrozen;

	var isFrozenStringArray = function (array, allowUndefined) {
	  if (!isFrozen || !isArray$2(array) || !isFrozen(array)) return false;
	  var index = 0;
	  var length = array.length;
	  var element;
	  while (index < length) {
	    element = array[index++];
	    if (!(typeof element == 'string' || (allowUndefined && typeof element == 'undefined'))) {
	      return false;
	    }
	  } return length !== 0;
	};

	// `Array.isTemplateObject` method
	// https://github.com/tc39/proposal-array-is-template-object
	_export({ target: 'Array', stat: true, sham: true, forced: true }, {
	  isTemplateObject: function isTemplateObject(value) {
	    if (!isFrozenStringArray(value, true)) return false;
	    var raw = value.raw;
	    return raw.length === value.length && isFrozenStringArray(raw, false);
	  }
	});

	// TODO: Remove from `core-js@4`




	var defineProperty$5 = objectDefineProperty.f;

	// `Array.prototype.lastIndex` getter
	// https://github.com/keithamus/proposal-array-last
	if (descriptors) {
	  defineProperty$5(Array.prototype, 'lastIndex', {
	    configurable: true,
	    get: function lastIndex() {
	      var O = toObject(this);
	      var len = lengthOfArrayLike(O);
	      return len == 0 ? 0 : len - 1;
	    }
	  });

	  addToUnscopables('lastIndex');
	}

	// TODO: Remove from `core-js@4`




	var defineProperty$4 = objectDefineProperty.f;

	// `Array.prototype.lastIndex` accessor
	// https://github.com/keithamus/proposal-array-last
	if (descriptors) {
	  defineProperty$4(Array.prototype, 'lastItem', {
	    configurable: true,
	    get: function lastItem() {
	      var O = toObject(this);
	      var len = lengthOfArrayLike(O);
	      return len == 0 ? undefined : O[len - 1];
	    },
	    set: function lastItem(value) {
	      var O = toObject(this);
	      var len = lengthOfArrayLike(O);
	      return O[len == 0 ? 0 : len - 1] = value;
	    }
	  });

	  addToUnscopables('lastItem');
	}

	// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed
	// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
	var arrayToReversed = function (O, C) {
	  var len = lengthOfArrayLike(O);
	  var A = new C(len);
	  var k = 0;
	  for (; k < len; k++) A[k] = O[len - k - 1];
	  return A;
	};

	var Array$5 = global_1.Array;

	// `Array.prototype.toReversed` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed
	_export({ target: 'Array', proto: true }, {
	  toReversed: function toReversed() {
	    return arrayToReversed(toIndexedObject(this), Array$5);
	  }
	});

	addToUnscopables('toReversed');

	var Array$4 = global_1.Array;
	var sort$1 = functionUncurryThis(entryVirtual('Array').sort);

	// `Array.prototype.toSorted` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toSorted
	_export({ target: 'Array', proto: true }, {
	  toSorted: function toSorted(compareFn) {
	    if (compareFn !== undefined) aCallable(compareFn);
	    var O = toIndexedObject(this);
	    var A = arrayFromConstructorAndList(Array$4, O);
	    return sort$1(A, compareFn);
	  }
	});

	addToUnscopables('toSorted');

	var $TypeError = TypeError;
	var max$1 = Math.max;
	var min$1 = Math.min;
	var MAX_SAFE_INTEGER$2 = 0x1FFFFFFFFFFFFF;

	// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toSpliced
	// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSpliced
	var arrayToSpliced = function (O, C, args) {
	  var start = args[0];
	  var deleteCount = args[1];
	  var len = lengthOfArrayLike(O);
	  var actualStart = toAbsoluteIndex(start, len);
	  var argumentsLength = args.length;
	  var k = 0;
	  var insertCount, actualDeleteCount, newLen, A;
	  if (argumentsLength === 0) {
	    insertCount = actualDeleteCount = 0;
	  } else if (argumentsLength === 1) {
	    insertCount = 0;
	    actualDeleteCount = len - actualStart;
	  } else {
	    insertCount = argumentsLength - 2;
	    actualDeleteCount = min$1(max$1(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
	  }
	  newLen = len + insertCount - actualDeleteCount;
	  if (newLen > MAX_SAFE_INTEGER$2) throw $TypeError('Maximum allowed length exceeded');
	  A = new C(newLen);

	  for (; k < actualStart; k++) A[k] = O[k];
	  for (; k < actualStart + insertCount; k++) A[k] = args[k - actualStart + 2];
	  for (; k < newLen; k++) A[k] = O[k + actualDeleteCount - insertCount];

	  return A;
	};

	var Array$3 = global_1.Array;

	// `Array.prototype.toSpliced` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toSpliced
	_export({ target: 'Array', proto: true }, {
	  // eslint-disable-next-line no-unused-vars -- required for .length
	  toSpliced: function toSpliced(start, deleteCount /* , ...items */) {
	    return arrayToSpliced(toIndexedObject(this), Array$3, arraySlice$1(arguments));
	  }
	});

	addToUnscopables('toSpliced');

	var Map$5 = getBuiltIn('Map');
	var MapPrototype$1 = Map$5.prototype;
	var mapForEach = functionUncurryThis(MapPrototype$1.forEach);
	var mapHas$1 = functionUncurryThis(MapPrototype$1.has);
	var mapSet$1 = functionUncurryThis(MapPrototype$1.set);
	var push$a = functionUncurryThis([].push);

	// `Array.prototype.uniqueBy` method
	// https://github.com/tc39/proposal-array-unique
	var arrayUniqueBy$2 = function uniqueBy(resolver) {
	  var that = toObject(this);
	  var length = lengthOfArrayLike(that);
	  var result = arraySpeciesCreate(that, 0);
	  var map = new Map$5();
	  var resolverFunction = resolver != null ? aCallable(resolver) : function (value) {
	    return value;
	  };
	  var index, item, key;
	  for (index = 0; index < length; index++) {
	    item = that[index];
	    key = resolverFunction(item);
	    if (!mapHas$1(map, key)) mapSet$1(map, key, item);
	  }
	  mapForEach(map, function (value) {
	    push$a(result, value);
	  });
	  return result;
	};

	// `Array.prototype.uniqueBy` method
	// https://github.com/tc39/proposal-array-unique
	_export({ target: 'Array', proto: true, forced: true }, {
	  uniqueBy: arrayUniqueBy$2
	});

	addToUnscopables('uniqueBy');

	var RangeError$4 = global_1.RangeError;

	// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with
	// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
	var arrayWith = function (O, C, index, value) {
	  var len = lengthOfArrayLike(O);
	  var relativeIndex = toIntegerOrInfinity(index);
	  var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
	  if (actualIndex >= len || actualIndex < 0) throw RangeError$4('Incorrect index');
	  var A = new C(len);
	  var k = 0;
	  for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
	  return A;
	};

	var Array$2 = global_1.Array;

	// `Array.prototype.with` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with
	_export({ target: 'Array', proto: true }, {
	  'with': function (index, value) {
	    return arrayWith(toIndexedObject(this), Array$2, index, value);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers








	var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');

	var AsyncIteratorConstructor = function AsyncIterator() {
	  anInstance(this, asyncIteratorPrototype);
	};

	AsyncIteratorConstructor.prototype = asyncIteratorPrototype;

	if (!hasOwnProperty_1(asyncIteratorPrototype, TO_STRING_TAG$4)) {
	  createNonEnumerableProperty(asyncIteratorPrototype, TO_STRING_TAG$4, 'AsyncIterator');
	}

	if (!hasOwnProperty_1(asyncIteratorPrototype, 'constructor') || asyncIteratorPrototype.constructor === Object) {
	  createNonEnumerableProperty(asyncIteratorPrototype, 'constructor', AsyncIteratorConstructor);
	}

	_export({ global: true, forced: isPure }, {
	  AsyncIterator: AsyncIteratorConstructor
	});

	var Promise$3 = getBuiltIn('Promise');

	var ASYNC_ITERATOR_PROXY = 'AsyncIteratorProxy';
	var setInternalState$9 = internalState.set;
	var getInternalState$6 = internalState.getterFor(ASYNC_ITERATOR_PROXY);

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');

	var asyncIteratorCreateProxy = function (nextHandler, IS_ITERATOR) {
	  var AsyncIteratorProxy = function AsyncIterator(state) {
	    state.type = ASYNC_ITERATOR_PROXY;
	    state.next = aCallable(state.iterator.next);
	    state.done = false;
	    state.ignoreArgument = !IS_ITERATOR;
	    setInternalState$9(this, state);
	  };

	  AsyncIteratorProxy.prototype = redefineAll(objectCreate(asyncIteratorPrototype), {
	    next: function next(arg) {
	      var that = this;
	      var hasArgument = !!arguments.length;
	      return new Promise$3(function (resolve) {
	        var state = getInternalState$6(that);
	        var args = hasArgument ? [state.ignoreArgument ? undefined : arg] : IS_ITERATOR ? [] : [undefined];
	        state.ignoreArgument = false;
	        resolve(state.done ? { done: true, value: undefined } : anObject(functionCall(nextHandler, state, Promise$3, args)));
	      });
	    },
	    'return': function (value) {
	      var that = this;
	      return new Promise$3(function (resolve, reject) {
	        var state = getInternalState$6(that);
	        var iterator = state.iterator;
	        state.done = true;
	        var $$return = getMethod(iterator, 'return');
	        if ($$return === undefined) return resolve({ done: true, value: value });
	        Promise$3.resolve(functionCall($$return, iterator, value)).then(function (result) {
	          anObject(result);
	          resolve({ done: true, value: value });
	        }, reject);
	      });
	    },
	    'throw': function (value) {
	      var that = this;
	      return new Promise$3(function (resolve, reject) {
	        var state = getInternalState$6(that);
	        var iterator = state.iterator;
	        state.done = true;
	        var $$throw = getMethod(iterator, 'throw');
	        if ($$throw === undefined) return reject(value);
	        resolve(functionCall($$throw, iterator, value));
	      });
	    }
	  });

	  if (!IS_ITERATOR) {
	    createNonEnumerableProperty(AsyncIteratorProxy.prototype, TO_STRING_TAG$3, 'Generator');
	  }

	  return AsyncIteratorProxy;
	};

	// https://github.com/tc39/proposal-iterator-helpers





	var AsyncIteratorProxy$6 = asyncIteratorCreateProxy(function (Promise, args) {
	  var state = this;
	  var iterator = state.iterator;

	  return Promise.resolve(anObject(functionApply(state.next, iterator, args))).then(function (step) {
	    if (anObject(step).done) {
	      state.done = true;
	      return { done: true, value: undefined };
	    }
	    return { done: false, value: [state.index++, step.value] };
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  asIndexedPairs: function asIndexedPairs() {
	    return new AsyncIteratorProxy$6({
	      iterator: anObject(this),
	      index: 0
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers






	var AsyncIteratorProxy$5 = asyncIteratorCreateProxy(function (Promise, args) {
	  var state = this;

	  return new Promise(function (resolve, reject) {
	    var loop = function () {
	      try {
	        Promise.resolve(
	          anObject(functionApply(state.next, state.iterator, state.remaining ? [] : args))
	        ).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve({ done: true, value: undefined });
	            } else if (state.remaining) {
	              state.remaining--;
	              loop();
	            } else resolve({ done: false, value: step.value });
	          } catch (err) { reject(err); }
	        }, reject);
	      } catch (error) { reject(error); }
	    };

	    loop();
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  drop: function drop(limit) {
	    return new AsyncIteratorProxy$5({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $every = asyncIteratorIteration.every;

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  every: function every(fn) {
	    return $every(this, fn);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers






	var AsyncIteratorProxy$4 = asyncIteratorCreateProxy(function (Promise, args) {
	  var state = this;
	  var filterer = state.filterer;

	  return new Promise(function (resolve, reject) {
	    var loop = function () {
	      try {
	        Promise.resolve(anObject(functionApply(state.next, state.iterator, args))).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve({ done: true, value: undefined });
	            } else {
	              var value = step.value;
	              Promise.resolve(filterer(value)).then(function (selected) {
	                selected ? resolve({ done: false, value: value }) : loop();
	              }, reject);
	            }
	          } catch (err) { reject(err); }
	        }, reject);
	      } catch (error) { reject(error); }
	    };

	    loop();
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  filter: function filter(filterer) {
	    return new AsyncIteratorProxy$4({
	      iterator: anObject(this),
	      filterer: aCallable(filterer)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $find = asyncIteratorIteration.find;

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  find: function find(fn) {
	    return $find(this, fn);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var AsyncIteratorProxy$3 = asyncIteratorCreateProxy(function (Promise) {
	  var state = this;
	  var mapper = state.mapper;
	  var innerIterator;

	  return new Promise(function (resolve, reject) {
	    var outerLoop = function () {
	      try {
	        Promise.resolve(anObject(functionCall(state.next, state.iterator))).then(function (step) {
	          try {
	            if (anObject(step).done) {
	              state.done = true;
	              resolve({ done: true, value: undefined });
	            } else {
	              Promise.resolve(mapper(step.value)).then(function (mapped) {
	                try {
	                  state.innerIterator = innerIterator = getAsyncIterator(mapped);
	                  state.innerNext = aCallable(innerIterator.next);
	                  return innerLoop();
	                } catch (error2) { reject(error2); }
	              }, reject);
	            }
	          } catch (error1) { reject(error1); }
	        }, reject);
	      } catch (error) { reject(error); }
	    };

	    var innerLoop = function () {
	      if (innerIterator = state.innerIterator) {
	        try {
	          Promise.resolve(anObject(functionCall(state.innerNext, innerIterator))).then(function (result) {
	            try {
	              if (anObject(result).done) {
	                state.innerIterator = state.innerNext = null;
	                outerLoop();
	              } else resolve({ done: false, value: result.value });
	            } catch (error1) { reject(error1); }
	          }, reject);
	        } catch (error) { reject(error); }
	      } else outerLoop();
	    };

	    innerLoop();
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  flatMap: function flatMap(mapper) {
	    return new AsyncIteratorProxy$3({
	      iterator: anObject(this),
	      mapper: aCallable(mapper),
	      innerIterator: null,
	      innerNext: null
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $forEach = asyncIteratorIteration.forEach;

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  forEach: function forEach(fn) {
	    return $forEach(this, fn);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers














	var ASYNC_ITERATOR = wellKnownSymbol('asyncIterator');

	var AsyncIteratorProxy$2 = asyncIteratorCreateProxy(function (Promise, args) {
	  return anObject(functionApply(this.next, this.iterator, args));
	}, true);

	_export({ target: 'AsyncIterator', stat: true, forced: true }, {
	  from: function from(O) {
	    var object = toObject(O);
	    var usingIterator = getMethod(object, ASYNC_ITERATOR);
	    var iterator;
	    if (usingIterator) {
	      iterator = getAsyncIterator(object, usingIterator);
	      if (objectIsPrototypeOf(asyncIteratorPrototype, iterator)) return iterator;
	    }
	    if (iterator === undefined) {
	      usingIterator = getIteratorMethod(object);
	      if (usingIterator) return new asyncFromSyncIterator(getIterator(object, usingIterator));
	    }
	    return new AsyncIteratorProxy$2({ iterator: iterator !== undefined ? iterator : object });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers






	var AsyncIteratorProxy$1 = asyncIteratorCreateProxy(function (Promise, args) {
	  var state = this;
	  var mapper = state.mapper;

	  return Promise.resolve(anObject(functionApply(state.next, state.iterator, args))).then(function (step) {
	    if (anObject(step).done) {
	      state.done = true;
	      return { done: true, value: undefined };
	    }
	    return Promise.resolve(mapper(step.value)).then(function (value) {
	      return { done: false, value: value };
	    });
	  });
	});

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  map: function map(mapper) {
	    return new AsyncIteratorProxy$1({
	      iterator: anObject(this),
	      mapper: aCallable(mapper)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var Promise$2 = getBuiltIn('Promise');
	var TypeError$f = global_1.TypeError;

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  reduce: function reduce(reducer /* , initialValue */) {
	    var iterator = anObject(this);
	    var next = aCallable(iterator.next);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    aCallable(reducer);

	    return new Promise$2(function (resolve, reject) {
	      var loop = function () {
	        try {
	          Promise$2.resolve(anObject(functionCall(next, iterator))).then(function (step) {
	            try {
	              if (anObject(step).done) {
	                noInitial ? reject(TypeError$f('Reduce of empty iterator with no initial value')) : resolve(accumulator);
	              } else {
	                var value = step.value;
	                if (noInitial) {
	                  noInitial = false;
	                  accumulator = value;
	                  loop();
	                } else {
	                  Promise$2.resolve(reducer(accumulator, value)).then(function (result) {
	                    accumulator = result;
	                    loop();
	                  }, reject);
	                }
	              }
	            } catch (err) { reject(err); }
	          }, reject);
	        } catch (error) { reject(error); }
	      };

	      loop();
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $some = asyncIteratorIteration.some;

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  some: function some(fn) {
	    return $some(this, fn);
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var AsyncIteratorProxy = asyncIteratorCreateProxy(function (Promise, args) {
	  var iterator = this.iterator;
	  var returnMethod, result;
	  if (!this.remaining--) {
	    result = { done: true, value: undefined };
	    this.done = true;
	    returnMethod = iterator['return'];
	    if (returnMethod !== undefined) {
	      return Promise.resolve(functionCall(returnMethod, iterator)).then(function () {
	        return result;
	      });
	    }
	    return result;
	  } return functionApply(this.next, iterator, args);
	});

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  take: function take(limit) {
	    return new AsyncIteratorProxy({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers

	var $toArray = asyncIteratorIteration.toArray;

	_export({ target: 'AsyncIterator', proto: true, real: true, forced: true }, {
	  toArray: function toArray() {
	    return $toArray(this, undefined, []);
	  }
	});

	var defineProperties$2 = objectDefineProperties.f;


	var INCORRECT_RANGE = 'Incorrect Number.range arguments';
	var NUMERIC_RANGE_ITERATOR = 'NumericRangeIterator';

	var setInternalState$8 = internalState.set;
	var getInternalState$5 = internalState.getterFor(NUMERIC_RANGE_ITERATOR);

	var RangeError$3 = global_1.RangeError;
	var TypeError$e = global_1.TypeError;

	var $RangeIterator = createIteratorConstructor(function NumericRangeIterator(start, end, option, type, zero, one) {
	  if (typeof start != type || (end !== Infinity && end !== -Infinity && typeof end != type)) {
	    throw new TypeError$e(INCORRECT_RANGE);
	  }
	  if (start === Infinity || start === -Infinity) {
	    throw new RangeError$3(INCORRECT_RANGE);
	  }
	  var ifIncrease = end > start;
	  var inclusiveEnd = false;
	  var step;
	  if (option === undefined) {
	    step = undefined;
	  } else if (isObject$2(option)) {
	    step = option.step;
	    inclusiveEnd = !!option.inclusive;
	  } else if (typeof option == type) {
	    step = option;
	  } else {
	    throw new TypeError$e(INCORRECT_RANGE);
	  }
	  if (step == null) {
	    step = ifIncrease ? one : -one;
	  }
	  if (typeof step != type) {
	    throw new TypeError$e(INCORRECT_RANGE);
	  }
	  if (step === Infinity || step === -Infinity || (step === zero && start !== end)) {
	    throw new RangeError$3(INCORRECT_RANGE);
	  }
	  // eslint-disable-next-line no-self-compare -- NaN check
	  var hitsEnd = start != start || end != end || step != step || (end > start) !== (step > zero);
	  setInternalState$8(this, {
	    type: NUMERIC_RANGE_ITERATOR,
	    start: start,
	    end: end,
	    step: step,
	    inclusiveEnd: inclusiveEnd,
	    hitsEnd: hitsEnd,
	    currentCount: zero,
	    zero: zero
	  });
	  if (!descriptors) {
	    this.start = start;
	    this.end = end;
	    this.step = step;
	    this.inclusive = inclusiveEnd;
	  }
	}, NUMERIC_RANGE_ITERATOR, function next() {
	  var state = getInternalState$5(this);
	  if (state.hitsEnd) return { value: undefined, done: true };
	  var start = state.start;
	  var end = state.end;
	  var step = state.step;
	  var currentYieldingValue = start + (step * state.currentCount++);
	  if (currentYieldingValue === end) state.hitsEnd = true;
	  var inclusiveEnd = state.inclusiveEnd;
	  var endCondition;
	  if (end > start) {
	    endCondition = inclusiveEnd ? currentYieldingValue > end : currentYieldingValue >= end;
	  } else {
	    endCondition = inclusiveEnd ? end > currentYieldingValue : end >= currentYieldingValue;
	  }
	  if (endCondition) {
	    return { value: undefined, done: state.hitsEnd = true };
	  } return { value: currentYieldingValue, done: false };
	});

	var getter = function (fn) {
	  return { get: fn, set: function () { /* empty */ }, configurable: true, enumerable: false };
	};

	if (descriptors) {
	  defineProperties$2($RangeIterator.prototype, {
	    start: getter(function () {
	      return getInternalState$5(this).start;
	    }),
	    end: getter(function () {
	      return getInternalState$5(this).end;
	    }),
	    inclusive: getter(function () {
	      return getInternalState$5(this).inclusiveEnd;
	    }),
	    step: getter(function () {
	      return getInternalState$5(this).step;
	    })
	  });
	}

	var numericRangeIterator = $RangeIterator;

	/* eslint-disable es-x/no-bigint -- safe */



	// `BigInt.range` method
	// https://github.com/tc39/proposal-Number.range
	if (typeof BigInt == 'function') {
	  _export({ target: 'BigInt', stat: true, forced: true }, {
	    range: function range(start, end, option) {
	      return new numericRangeIterator(start, end, option, 'bigint', BigInt(0), BigInt(1));
	    }
	  });
	}

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`







	var Object$3 = global_1.Object;
	var TypeError$d = global_1.TypeError;
	var Map$4 = getBuiltIn('Map');
	var WeakMap$3 = getBuiltIn('WeakMap');

	var Node$1 = function () {
	  // keys
	  this.object = null;
	  this.symbol = null;
	  // child nodes
	  this.primitives = null;
	  this.objectsByIndex = objectCreate(null);
	};

	Node$1.prototype.get = function (key, initializer) {
	  return this[key] || (this[key] = initializer());
	};

	Node$1.prototype.next = function (i, it, IS_OBJECT) {
	  var store = IS_OBJECT
	    ? this.objectsByIndex[i] || (this.objectsByIndex[i] = new WeakMap$3())
	    : this.primitives || (this.primitives = new Map$4());
	  var entry = store.get(it);
	  if (!entry) store.set(it, entry = new Node$1());
	  return entry;
	};

	var root$1 = new Node$1();

	var compositeKey = function () {
	  var active = root$1;
	  var length = arguments.length;
	  var i, it;
	  // for prevent leaking, start from objects
	  for (i = 0; i < length; i++) {
	    if (isObject$2(it = arguments[i])) active = active.next(i, it, true);
	  }
	  if (this === Object$3 && active === root$1) throw TypeError$d('Composite keys must contain a non-primitive component');
	  for (i = 0; i < length; i++) {
	    if (!isObject$2(it = arguments[i])) active = active.next(i, it, false);
	  } return active;
	};

	var Object$2 = global_1.Object;

	var initializer = function () {
	  var freeze = getBuiltIn('Object', 'freeze');
	  return freeze ? freeze(objectCreate(null)) : objectCreate(null);
	};

	// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
	_export({ global: true, forced: true }, {
	  compositeKey: function compositeKey$1() {
	    return functionApply(compositeKey, Object$2, arguments).get('object', initializer);
	  }
	});

	// https://github.com/tc39/proposal-richer-keys/tree/master/compositeKey
	_export({ global: true, forced: true }, {
	  compositeSymbol: function compositeSymbol() {
	    if (arguments.length == 1 && typeof arguments[0] == 'string') return getBuiltIn('Symbol')['for'](arguments[0]);
	    return functionApply(compositeKey, null, arguments).get('symbol', getBuiltIn('Symbol'));
	  }
	});

	// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var classRegExp = /^\s*class\b/;
	var exec$4 = functionUncurryThis(classRegExp.exec);

	var isClassConstructor = function (argument) {
	  try {
	    // `Function#toString` throws on some built-it function in some legacy engines
	    // (for example, `DOMQuad` and similar in FF41-)
	    if (!descriptors || !exec$4(classRegExp, inspectSource(argument))) return false;
	  } catch (error) { /* empty */ }
	  var prototype = getOwnPropertyDescriptor(argument, 'prototype');
	  return !!prototype && hasOwnProperty_1(prototype, 'writable') && !prototype.writable;
	};

	// `Function.isCallable` method
	// https://github.com/caitp/TC39-Proposals/blob/trunk/tc39-reflect-isconstructor-iscallable.md
	_export({ target: 'Function', stat: true, sham: true, forced: true }, {
	  isCallable: function isCallable$1(argument) {
	    return isCallable(argument) && !isClassConstructor(argument);
	  }
	});

	// `Function.isConstructor` method
	// https://github.com/caitp/TC39-Proposals/blob/trunk/tc39-reflect-isconstructor-iscallable.md
	_export({ target: 'Function', stat: true, forced: true }, {
	  isConstructor: isConstructor
	});

	// `Function.prototype.unThis` method
	// https://github.com/js-choi/proposal-function-un-this
	_export({ target: 'Function', proto: true, forced: true }, {
	  unThis: function unThis() {
	    return functionUncurryThis(aCallable(this));
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers








	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;


	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

	var NativeIterator = global_1.Iterator;

	// FF56- have non-standard global helper `Iterator`
	var FORCED = !isCallable(NativeIterator)
	  || NativeIterator.prototype !== IteratorPrototype$2
	  // FF44- non-standard `Iterator` passes previous tests
	  || !fails(function () { NativeIterator({}); });

	var IteratorConstructor = function Iterator() {
	  anInstance(this, IteratorPrototype$2);
	};

	if (!hasOwnProperty_1(IteratorPrototype$2, TO_STRING_TAG$2)) {
	  createNonEnumerableProperty(IteratorPrototype$2, TO_STRING_TAG$2, 'Iterator');
	}

	if (FORCED || !hasOwnProperty_1(IteratorPrototype$2, 'constructor') || IteratorPrototype$2.constructor === Object) {
	  createNonEnumerableProperty(IteratorPrototype$2, 'constructor', IteratorConstructor);
	}

	IteratorConstructor.prototype = IteratorPrototype$2;

	_export({ global: true, forced: FORCED }, {
	  Iterator: IteratorConstructor
	});

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

	var ITERATOR_PROXY = 'IteratorProxy';
	var setInternalState$7 = internalState.set;
	var getInternalState$4 = internalState.getterFor(ITERATOR_PROXY);

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');

	var iteratorCreateProxy = function (nextHandler, IS_ITERATOR) {
	  var IteratorProxy = function Iterator(state) {
	    state.type = ITERATOR_PROXY;
	    state.next = aCallable(state.iterator.next);
	    state.done = false;
	    state.ignoreArg = !IS_ITERATOR;
	    setInternalState$7(this, state);
	  };

	  IteratorProxy.prototype = redefineAll(objectCreate(IteratorPrototype$1), {
	    next: function next(arg) {
	      var state = getInternalState$4(this);
	      var args = arguments.length ? [state.ignoreArg ? undefined : arg] : IS_ITERATOR ? [] : [undefined];
	      state.ignoreArg = false;
	      var result = state.done ? undefined : functionCall(nextHandler, state, args);
	      return { done: state.done, value: result };
	    },
	    'return': function (value) {
	      var state = getInternalState$4(this);
	      var iterator = state.iterator;
	      state.done = true;
	      var $$return = getMethod(iterator, 'return');
	      return { done: true, value: $$return ? anObject(functionCall($$return, iterator, value)).value : value };
	    },
	    'throw': function (value) {
	      var state = getInternalState$4(this);
	      var iterator = state.iterator;
	      state.done = true;
	      var $$throw = getMethod(iterator, 'throw');
	      if ($$throw) return functionCall($$throw, iterator, value);
	      throw value;
	    }
	  });

	  if (!IS_ITERATOR) {
	    createNonEnumerableProperty(IteratorProxy.prototype, TO_STRING_TAG$1, 'Generator');
	  }

	  return IteratorProxy;
	};

	// https://github.com/tc39/proposal-iterator-helpers





	var IteratorProxy$6 = iteratorCreateProxy(function (args) {
	  var result = anObject(functionApply(this.next, this.iterator, args));
	  var done = this.done = !!result.done;
	  if (!done) return [this.index++, result.value];
	});

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  asIndexedPairs: function asIndexedPairs() {
	    return new IteratorProxy$6({
	      iterator: anObject(this),
	      index: 0
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var IteratorProxy$5 = iteratorCreateProxy(function (args) {
	  var iterator = this.iterator;
	  var next = this.next;
	  var result, done;
	  while (this.remaining) {
	    this.remaining--;
	    result = anObject(functionCall(next, iterator));
	    done = this.done = !!result.done;
	    if (done) return;
	  }
	  result = anObject(functionApply(next, iterator, args));
	  done = this.done = !!result.done;
	  if (!done) return result.value;
	});

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  drop: function drop(limit) {
	    return new IteratorProxy$5({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  every: function every(fn) {
	    anObject(this);
	    aCallable(fn);
	    return !iterate(this, function (value, stop) {
	      if (!fn(value)) return stop();
	    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var IteratorProxy$4 = iteratorCreateProxy(function (args) {
	  var iterator = this.iterator;
	  var filterer = this.filterer;
	  var next = this.next;
	  var result, done, value;
	  while (true) {
	    result = anObject(functionApply(next, iterator, args));
	    done = this.done = !!result.done;
	    if (done) return;
	    value = result.value;
	    if (callWithSafeIterationClosing(iterator, filterer, value)) return value;
	  }
	});

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  filter: function filter(filterer) {
	    return new IteratorProxy$4({
	      iterator: anObject(this),
	      filterer: aCallable(filterer)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  find: function find(fn) {
	    anObject(this);
	    aCallable(fn);
	    return iterate(this, function (value, stop) {
	      if (fn(value)) return stop(value);
	    }, { IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers









	var TypeError$c = global_1.TypeError;

	var IteratorProxy$3 = iteratorCreateProxy(function () {
	  var iterator = this.iterator;
	  var mapper = this.mapper;
	  var result, mapped, iteratorMethod, innerIterator;

	  while (true) {
	    try {
	      if (innerIterator = this.innerIterator) {
	        result = anObject(functionCall(this.innerNext, innerIterator));
	        if (!result.done) return result.value;
	        this.innerIterator = this.innerNext = null;
	      }

	      result = anObject(functionCall(this.next, iterator));

	      if (this.done = !!result.done) return;

	      mapped = mapper(result.value);
	      iteratorMethod = getIteratorMethod(mapped);

	      if (!iteratorMethod) {
	        throw TypeError$c('.flatMap callback should return an iterable object');
	      }

	      this.innerIterator = innerIterator = anObject(functionCall(iteratorMethod, mapped));
	      this.innerNext = aCallable(innerIterator.next);
	    } catch (error) {
	      iteratorClose(iterator, 'throw', error);
	    }
	  }
	});

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  flatMap: function flatMap(mapper) {
	    return new IteratorProxy$3({
	      iterator: anObject(this),
	      mapper: aCallable(mapper),
	      innerIterator: null,
	      innerNext: null
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers




	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  forEach: function forEach(fn) {
	    iterate(anObject(this), fn, { IS_ITERATOR: true });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	var IteratorPrototype = iteratorsCore.IteratorPrototype;




	var IteratorProxy$2 = iteratorCreateProxy(function (args) {
	  var result = anObject(functionApply(this.next, this.iterator, args));
	  var done = this.done = !!result.done;
	  if (!done) return result.value;
	}, true);

	_export({ target: 'Iterator', stat: true, forced: true }, {
	  from: function from(O) {
	    var object = toObject(O);
	    var usingIterator = getIteratorMethod(object);
	    var iterator;
	    if (usingIterator) {
	      iterator = getIterator(object, usingIterator);
	      if (objectIsPrototypeOf(IteratorPrototype, iterator)) return iterator;
	    } else {
	      iterator = object;
	    } return new IteratorProxy$2({ iterator: iterator });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var IteratorProxy$1 = iteratorCreateProxy(function (args) {
	  var iterator = this.iterator;
	  var result = anObject(functionApply(this.next, iterator, args));
	  var done = this.done = !!result.done;
	  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, result.value);
	});

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  map: function map(mapper) {
	    return new IteratorProxy$1({
	      iterator: anObject(this),
	      mapper: aCallable(mapper)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers






	var TypeError$b = global_1.TypeError;

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  reduce: function reduce(reducer /* , initialValue */) {
	    anObject(this);
	    aCallable(reducer);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    iterate(this, function (value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = reducer(accumulator, value);
	      }
	    }, { IS_ITERATOR: true });
	    if (noInitial) throw TypeError$b('Reduce of empty iterator with no initial value');
	    return accumulator;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers





	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  some: function some(fn) {
	    anObject(this);
	    aCallable(fn);
	    return iterate(this, function (value, stop) {
	      if (fn(value)) return stop();
	    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers







	var IteratorProxy = iteratorCreateProxy(function (args) {
	  var iterator = this.iterator;
	  if (!this.remaining--) {
	    this.done = true;
	    return iteratorClose(iterator, 'normal', undefined);
	  }
	  var result = anObject(functionApply(this.next, iterator, args));
	  var done = this.done = !!result.done;
	  if (!done) return result.value;
	});

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  take: function take(limit) {
	    return new IteratorProxy({
	      iterator: anObject(this),
	      remaining: toPositiveInteger(limit)
	    });
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers




	var push$9 = [].push;

	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  toArray: function toArray() {
	    var result = [];
	    iterate(anObject(this), push$9, { that: result, IS_ITERATOR: true });
	    return result;
	  }
	});

	// https://github.com/tc39/proposal-iterator-helpers



	_export({ target: 'Iterator', proto: true, real: true, forced: true }, {
	  toAsync: function toAsync() {
	    return new asyncFromSyncIterator(this);
	  }
	});

	// https://github.com/tc39/collection-methods
	var collectionDeleteAll = function deleteAll(/* ...elements */) {
	  var collection = anObject(this);
	  var remover = aCallable(collection['delete']);
	  var allDeleted = true;
	  var wasDeleted;
	  for (var k = 0, len = arguments.length; k < len; k++) {
	    wasDeleted = functionCall(remover, collection, arguments[k]);
	    allDeleted = allDeleted && wasDeleted;
	  }
	  return !!allDeleted;
	};

	// `Map.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  deleteAll: collectionDeleteAll
	});

	// `Map.prototype.emplace` method
	// https://github.com/thumbsupep/proposal-upsert
	var mapEmplace = function emplace(key, handler) {
	  var map = anObject(this);
	  var get = aCallable(map.get);
	  var has = aCallable(map.has);
	  var set = aCallable(map.set);
	  var value = (functionCall(has, map, key) && 'update' in handler)
	    ? handler.update(functionCall(get, map, key), key, map)
	    : handler.insert(key, map);
	  functionCall(set, map, key, value);
	  return value;
	};

	// `Map.prototype.emplace` method
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  emplace: mapEmplace
	});

	var getMapIterator = function (it) {
	  // eslint-disable-next-line es-x/no-map -- safe
	  return functionCall(Map.prototype.entries, it);
	};

	// `Map.prototype.every` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  every: function every(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return !iterate(iterator, function (key, value, stop) {
	      if (!boundFunction(value, key, map)) return stop();
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Map.prototype.filter` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aCallable(newMap.set);
	    iterate(iterator, function (key, value) {
	      if (boundFunction(value, key, map)) functionCall(setter, newMap, key, value);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    return newMap;
	  }
	});

	// `Map.prototype.find` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  find: function find(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return iterate(iterator, function (key, value, stop) {
	      if (boundFunction(value, key, map)) return stop(value);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// `Map.prototype.findKey` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  findKey: function findKey(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return iterate(iterator, function (key, value, stop) {
	      if (boundFunction(value, key, map)) return stop(key);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// https://tc39.github.io/proposal-setmap-offrom/






	var push$8 = [].push;

	var collectionFrom = function from(source /* , mapFn, thisArg */) {
	  var length = arguments.length;
	  var mapFn = length > 1 ? arguments[1] : undefined;
	  var mapping, array, n, boundFunction;
	  aConstructor(this);
	  mapping = mapFn !== undefined;
	  if (mapping) aCallable(mapFn);
	  if (source == undefined) return new this();
	  array = [];
	  if (mapping) {
	    n = 0;
	    boundFunction = functionBindContext(mapFn, length > 2 ? arguments[2] : undefined);
	    iterate(source, function (nextItem) {
	      functionCall(push$8, array, boundFunction(nextItem, n++));
	    });
	  } else {
	    iterate(source, push$8, { that: array });
	  }
	  return new this(array);
	};

	// `Map.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	_export({ target: 'Map', stat: true, forced: true }, {
	  from: collectionFrom
	});

	var push$7 = functionUncurryThis([].push);

	// `Map.groupBy` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', stat: true, forced: true }, {
	  groupBy: function groupBy(iterable, keyDerivative) {
	    aCallable(keyDerivative);
	    var iterator = getIterator(iterable);
	    var newMap = new this();
	    var has = aCallable(newMap.has);
	    var get = aCallable(newMap.get);
	    var set = aCallable(newMap.set);
	    iterate(iterator, function (element) {
	      var derivedKey = keyDerivative(element);
	      if (!functionCall(has, newMap, derivedKey)) functionCall(set, newMap, derivedKey, [element]);
	      else push$7(functionCall(get, newMap, derivedKey), element);
	    }, { IS_ITERATOR: true });
	    return newMap;
	  }
	});

	// `SameValueZero` abstract operation
	// https://tc39.es/ecma262/#sec-samevaluezero
	var sameValueZero = function (x, y) {
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return x === y || x != x && y != y;
	};

	// `Map.prototype.includes` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  includes: function includes(searchElement) {
	    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {
	      if (sameValueZero(value, searchElement)) return stop();
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Map.keyBy` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', stat: true, forced: true }, {
	  keyBy: function keyBy(iterable, keyDerivative) {
	    var newMap = new this();
	    aCallable(keyDerivative);
	    var setter = aCallable(newMap.set);
	    iterate(iterable, function (element) {
	      functionCall(setter, newMap, keyDerivative(element), element);
	    });
	    return newMap;
	  }
	});

	// `Map.prototype.keyOf` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  keyOf: function keyOf(searchElement) {
	    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {
	      if (value === searchElement) return stop(key);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// `Map.prototype.mapKeys` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  mapKeys: function mapKeys(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aCallable(newMap.set);
	    iterate(iterator, function (key, value) {
	      functionCall(setter, newMap, boundFunction(value, key, map), value);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    return newMap;
	  }
	});

	// `Map.prototype.mapValues` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  mapValues: function mapValues(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aCallable(newMap.set);
	    iterate(iterator, function (key, value) {
	      functionCall(setter, newMap, key, boundFunction(value, key, map));
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    return newMap;
	  }
	});

	// `Map.prototype.merge` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  merge: function merge(iterable /* ...iterables */) {
	    var map = anObject(this);
	    var setter = aCallable(map.set);
	    var argumentsLength = arguments.length;
	    var i = 0;
	    while (i < argumentsLength) {
	      iterate(arguments[i++], setter, { that: map, AS_ENTRIES: true });
	    }
	    return map;
	  }
	});

	// https://tc39.github.io/proposal-setmap-offrom/
	var collectionOf = function of() {
	  return new this(arraySlice$1(arguments));
	};

	// `Map.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	_export({ target: 'Map', stat: true, forced: true }, {
	  of: collectionOf
	});

	var TypeError$a = global_1.TypeError;

	// `Map.prototype.reduce` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    aCallable(callbackfn);
	    iterate(iterator, function (key, value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = callbackfn(accumulator, value, key, map);
	      }
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    if (noInitial) throw TypeError$a('Reduce of empty map with no initial value');
	    return accumulator;
	  }
	});

	// `Set.prototype.some` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  some: function some(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return iterate(iterator, function (key, value, stop) {
	      if (boundFunction(value, key, map)) return stop();
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	var TypeError$9 = global_1.TypeError;

	// `Set.prototype.update` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  update: function update(key, callback /* , thunk */) {
	    var map = anObject(this);
	    var get = aCallable(map.get);
	    var has = aCallable(map.has);
	    var set = aCallable(map.set);
	    var length = arguments.length;
	    aCallable(callback);
	    var isPresentInMap = functionCall(has, map, key);
	    if (!isPresentInMap && length < 3) {
	      throw TypeError$9('Updating absent value');
	    }
	    var value = isPresentInMap ? functionCall(get, map, key) : aCallable(length > 2 ? arguments[2] : undefined)(key, map);
	    functionCall(set, map, key, callback(value, key, map));
	    return map;
	  }
	});

	var TypeError$8 = global_1.TypeError;

	// `Map.prototype.upsert` method
	// https://github.com/thumbsupep/proposal-upsert
	var mapUpsert = function upsert(key, updateFn /* , insertFn */) {
	  var map = anObject(this);
	  var get = aCallable(map.get);
	  var has = aCallable(map.has);
	  var set = aCallable(map.set);
	  var insertFn = arguments.length > 2 ? arguments[2] : undefined;
	  var value;
	  if (!isCallable(updateFn) && !isCallable(insertFn)) {
	    throw TypeError$8('At least one callback required');
	  }
	  if (functionCall(has, map, key)) {
	    value = functionCall(get, map, key);
	    if (isCallable(updateFn)) {
	      value = updateFn(value);
	      functionCall(set, map, key, value);
	    }
	  } else if (isCallable(insertFn)) {
	    value = insertFn();
	    functionCall(set, map, key, value);
	  } return value;
	};

	// TODO: remove from `core-js@4`



	// `Map.prototype.updateOrInsert` method (replaced by `Map.prototype.emplace`)
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, name: 'upsert', forced: true }, {
	  updateOrInsert: mapUpsert
	});

	// TODO: remove from `core-js@4`



	// `Map.prototype.upsert` method (replaced by `Map.prototype.emplace`)
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, forced: true }, {
	  upsert: mapUpsert
	});

	var min = Math.min;
	var max = Math.max;

	// `Math.clamp` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true, forced: true }, {
	  clamp: function clamp(x, lower, upper) {
	    return min(upper, max(lower, x));
	  }
	});

	// `Math.DEG_PER_RAD` constant
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true, forced: true }, {
	  DEG_PER_RAD: Math.PI / 180
	});

	var RAD_PER_DEG = 180 / Math.PI;

	// `Math.degrees` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true, forced: true }, {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});

	// `Math.scale` method implementation
	// https://rwaldron.github.io/proposal-math-extensions/
	var mathScale = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  var nx = +x;
	  var nInLow = +inLow;
	  var nInHigh = +inHigh;
	  var nOutLow = +outLow;
	  var nOutHigh = +outHigh;
	  // eslint-disable-next-line no-self-compare -- NaN check
	  if (nx != nx || nInLow != nInLow || nInHigh != nInHigh || nOutLow != nOutLow || nOutHigh != nOutHigh) return NaN;
	  if (nx === Infinity || nx === -Infinity) return nx;
	  return (nx - nInLow) * (nOutHigh - nOutLow) / (nInHigh - nInLow) + nOutLow;
	};

	// `Math.fscale` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true, forced: true }, {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return mathFround(mathScale(x, inLow, inHigh, outLow, outHigh));
	  }
	});

	// `Math.iaddh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true, forced: true }, {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

	// `Math.imulh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true, forced: true }, {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xFFFF;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

	// `Math.isubh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true, forced: true }, {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

	// `Math.RAD_PER_DEG` constant
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true, forced: true }, {
	  RAD_PER_DEG: 180 / Math.PI
	});

	var DEG_PER_RAD = Math.PI / 180;

	// `Math.radians` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true, forced: true }, {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});

	// `Math.scale` method
	// https://rwaldron.github.io/proposal-math-extensions/
	_export({ target: 'Math', stat: true, forced: true }, {
	  scale: mathScale
	});

	var SEEDED_RANDOM = 'Seeded Random';
	var SEEDED_RANDOM_GENERATOR = SEEDED_RANDOM + ' Generator';
	var SEED_TYPE_ERROR = 'Math.seededPRNG() argument should have a "seed" field with a finite value.';
	var setInternalState$6 = internalState.set;
	var getInternalState$3 = internalState.getterFor(SEEDED_RANDOM_GENERATOR);
	var TypeError$7 = global_1.TypeError;

	var $SeededRandomGenerator = createIteratorConstructor(function SeededRandomGenerator(seed) {
	  setInternalState$6(this, {
	    type: SEEDED_RANDOM_GENERATOR,
	    seed: seed % 2147483647
	  });
	}, SEEDED_RANDOM, function next() {
	  var state = getInternalState$3(this);
	  var seed = state.seed = (state.seed * 1103515245 + 12345) % 2147483647;
	  return { value: (seed & 1073741823) / 1073741823, done: false };
	});

	// `Math.seededPRNG` method
	// https://github.com/tc39/proposal-seeded-random
	// based on https://github.com/tc39/proposal-seeded-random/blob/78b8258835b57fc2100d076151ab506bc3202ae6/demo.html
	_export({ target: 'Math', stat: true, forced: true }, {
	  seededPRNG: function seededPRNG(it) {
	    var seed = anObject(it).seed;
	    if (!numberIsFinite(seed)) throw TypeError$7(SEED_TYPE_ERROR);
	    return new $SeededRandomGenerator(seed);
	  }
	});

	// `Math.signbit` method
	// https://github.com/tc39/proposal-Math.signbit
	_export({ target: 'Math', stat: true, forced: true }, {
	  signbit: function signbit(x) {
	    return (x = +x) == x && x == 0 ? 1 / x == -Infinity : x < 0;
	  }
	});

	// `Math.umulh` method
	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	// TODO: Remove from `core-js@4`
	_export({ target: 'Math', stat: true, forced: true }, {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xFFFF;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

	var INVALID_NUMBER_REPRESENTATION = 'Invalid number representation';
	var INVALID_RADIX = 'Invalid radix';
	var RangeError$2 = global_1.RangeError;
	var SyntaxError$1 = global_1.SyntaxError;
	var TypeError$6 = global_1.TypeError;
	var valid = /^[\da-z]+$/;
	var charAt$6 = functionUncurryThis(''.charAt);
	var exec$3 = functionUncurryThis(valid.exec);
	var numberToString$1 = functionUncurryThis(1.0.toString);
	var stringSlice$2 = functionUncurryThis(''.slice);

	// `Number.fromString` method
	// https://github.com/tc39/proposal-number-fromstring
	_export({ target: 'Number', stat: true, forced: true }, {
	  fromString: function fromString(string, radix) {
	    var sign = 1;
	    var R, mathNum;
	    if (typeof string != 'string') throw TypeError$6(INVALID_NUMBER_REPRESENTATION);
	    if (!string.length) throw SyntaxError$1(INVALID_NUMBER_REPRESENTATION);
	    if (charAt$6(string, 0) == '-') {
	      sign = -1;
	      string = stringSlice$2(string, 1);
	      if (!string.length) throw SyntaxError$1(INVALID_NUMBER_REPRESENTATION);
	    }
	    R = radix === undefined ? 10 : toIntegerOrInfinity(radix);
	    if (R < 2 || R > 36) throw RangeError$2(INVALID_RADIX);
	    if (!exec$3(valid, string) || numberToString$1(mathNum = numberParseInt(string, R), R) !== string) {
	      throw SyntaxError$1(INVALID_NUMBER_REPRESENTATION);
	    }
	    return sign * mathNum;
	  }
	});

	// `Number.range` method
	// https://github.com/tc39/proposal-Number.range
	_export({ target: 'Number', stat: true, forced: true }, {
	  range: function range(start, end, option) {
	    return new numericRangeIterator(start, end, option, 'number', 0, 1);
	  }
	});

	var OBJECT_ITERATOR = 'Object Iterator';
	var setInternalState$5 = internalState.set;
	var getInternalState$2 = internalState.getterFor(OBJECT_ITERATOR);

	var objectIterator = createIteratorConstructor(function ObjectIterator(source, mode) {
	  var object = toObject(source);
	  setInternalState$5(this, {
	    type: OBJECT_ITERATOR,
	    mode: mode,
	    object: object,
	    keys: objectKeys$1(object),
	    index: 0
	  });
	}, 'Object', function next() {
	  var state = getInternalState$2(this);
	  var keys = state.keys;
	  while (true) {
	    if (keys === null || state.index >= keys.length) {
	      state.object = state.keys = null;
	      return { value: undefined, done: true };
	    }
	    var key = keys[state.index++];
	    var object = state.object;
	    if (!hasOwnProperty_1(object, key)) continue;
	    switch (state.mode) {
	      case 'keys': return { value: key, done: false };
	      case 'values': return { value: object[key], done: false };
	    } /* entries */ return { value: [key, object[key]], done: false };
	  }
	});

	// TODO: Remove from `core-js@4`



	// `Object.iterateEntries` method
	// https://github.com/tc39/proposal-object-iteration
	_export({ target: 'Object', stat: true, forced: true }, {
	  iterateEntries: function iterateEntries(object) {
	    return new objectIterator(object, 'entries');
	  }
	});

	// TODO: Remove from `core-js@4`



	// `Object.iterateKeys` method
	// https://github.com/tc39/proposal-object-iteration
	_export({ target: 'Object', stat: true, forced: true }, {
	  iterateKeys: function iterateKeys(object) {
	    return new objectIterator(object, 'keys');
	  }
	});

	// TODO: Remove from `core-js@4`



	// `Object.iterateValues` method
	// https://github.com/tc39/proposal-object-iteration
	_export({ target: 'Object', stat: true, forced: true }, {
	  iterateValues: function iterateValues(object) {
	    return new objectIterator(object, 'values');
	  }
	});

	var $$OBSERVABLE$2 = wellKnownSymbol('observable');
	var NativeObservable = global_1.Observable;
	var NativeObservablePrototype = NativeObservable && NativeObservable.prototype;

	var observableForced = !isCallable(NativeObservable)
	  || !isCallable(NativeObservable.from)
	  || !isCallable(NativeObservable.of)
	  || !isCallable(NativeObservablePrototype.subscribe)
	  || !isCallable(NativeObservablePrototype[$$OBSERVABLE$2]);

	// https://github.com/tc39/proposal-observable










	var defineProperty$3 = objectDefineProperty.f;







	var $$OBSERVABLE$1 = wellKnownSymbol('observable');
	var OBSERVABLE = 'Observable';
	var SUBSCRIPTION = 'Subscription';
	var SUBSCRIPTION_OBSERVER = 'SubscriptionObserver';
	var getterFor$1 = internalState.getterFor;
	var setInternalState$4 = internalState.set;
	var getObservableInternalState = getterFor$1(OBSERVABLE);
	var getSubscriptionInternalState = getterFor$1(SUBSCRIPTION);
	var getSubscriptionObserverInternalState = getterFor$1(SUBSCRIPTION_OBSERVER);

	var SubscriptionState = function (observer) {
	  this.observer = anObject(observer);
	  this.cleanup = undefined;
	  this.subscriptionObserver = undefined;
	};

	SubscriptionState.prototype = {
	  type: SUBSCRIPTION,
	  clean: function () {
	    var cleanup = this.cleanup;
	    if (cleanup) {
	      this.cleanup = undefined;
	      try {
	        cleanup();
	      } catch (error) {
	        hostReportErrors(error);
	      }
	    }
	  },
	  close: function () {
	    if (!descriptors) {
	      var subscription = this.facade;
	      var subscriptionObserver = this.subscriptionObserver;
	      subscription.closed = true;
	      if (subscriptionObserver) subscriptionObserver.closed = true;
	    } this.observer = undefined;
	  },
	  isClosed: function () {
	    return this.observer === undefined;
	  }
	};

	var Subscription$1 = function (observer, subscriber) {
	  var subscriptionState = setInternalState$4(this, new SubscriptionState(observer));
	  var start;
	  if (!descriptors) this.closed = false;
	  try {
	    if (start = getMethod(observer, 'start')) functionCall(start, observer, this);
	  } catch (error) {
	    hostReportErrors(error);
	  }
	  if (subscriptionState.isClosed()) return;
	  var subscriptionObserver = subscriptionState.subscriptionObserver = new SubscriptionObserver(subscriptionState);
	  try {
	    var cleanup = subscriber(subscriptionObserver);
	    var subscription = cleanup;
	    if (cleanup != null) subscriptionState.cleanup = isCallable(cleanup.unsubscribe)
	      ? function () { subscription.unsubscribe(); }
	      : aCallable(cleanup);
	  } catch (error) {
	    subscriptionObserver.error(error);
	    return;
	  } if (subscriptionState.isClosed()) subscriptionState.clean();
	};

	Subscription$1.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe() {
	    var subscriptionState = getSubscriptionInternalState(this);
	    if (!subscriptionState.isClosed()) {
	      subscriptionState.close();
	      subscriptionState.clean();
	    }
	  }
	});

	if (descriptors) defineProperty$3(Subscription$1.prototype, 'closed', {
	  configurable: true,
	  get: function () {
	    return getSubscriptionInternalState(this).isClosed();
	  }
	});

	var SubscriptionObserver = function (subscriptionState) {
	  setInternalState$4(this, {
	    type: SUBSCRIPTION_OBSERVER,
	    subscriptionState: subscriptionState
	  });
	  if (!descriptors) this.closed = false;
	};

	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value) {
	    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
	    if (!subscriptionState.isClosed()) {
	      var observer = subscriptionState.observer;
	      try {
	        var nextMethod = getMethod(observer, 'next');
	        if (nextMethod) functionCall(nextMethod, observer, value);
	      } catch (error) {
	        hostReportErrors(error);
	      }
	    }
	  },
	  error: function error(value) {
	    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
	    if (!subscriptionState.isClosed()) {
	      var observer = subscriptionState.observer;
	      subscriptionState.close();
	      try {
	        var errorMethod = getMethod(observer, 'error');
	        if (errorMethod) functionCall(errorMethod, observer, value);
	        else hostReportErrors(value);
	      } catch (err) {
	        hostReportErrors(err);
	      } subscriptionState.clean();
	    }
	  },
	  complete: function complete() {
	    var subscriptionState = getSubscriptionObserverInternalState(this).subscriptionState;
	    if (!subscriptionState.isClosed()) {
	      var observer = subscriptionState.observer;
	      subscriptionState.close();
	      try {
	        var completeMethod = getMethod(observer, 'complete');
	        if (completeMethod) functionCall(completeMethod, observer);
	      } catch (error) {
	        hostReportErrors(error);
	      } subscriptionState.clean();
	    }
	  }
	});

	if (descriptors) defineProperty$3(SubscriptionObserver.prototype, 'closed', {
	  configurable: true,
	  get: function () {
	    return getSubscriptionObserverInternalState(this).subscriptionState.isClosed();
	  }
	});

	var $Observable = function Observable(subscriber) {
	  anInstance(this, ObservablePrototype);
	  setInternalState$4(this, {
	    type: OBSERVABLE,
	    subscriber: aCallable(subscriber)
	  });
	};

	var ObservablePrototype = $Observable.prototype;

	redefineAll(ObservablePrototype, {
	  subscribe: function subscribe(observer) {
	    var length = arguments.length;
	    return new Subscription$1(isCallable(observer) ? {
	      next: observer,
	      error: length > 1 ? arguments[1] : undefined,
	      complete: length > 2 ? arguments[2] : undefined
	    } : isObject$2(observer) ? observer : {}, getObservableInternalState(this).subscriber);
	  }
	});

	redefine(ObservablePrototype, $$OBSERVABLE$1, function () { return this; });

	_export({ global: true, forced: observableForced }, {
	  Observable: $Observable
	});

	setSpecies(OBSERVABLE);

	var $$OBSERVABLE = wellKnownSymbol('observable');

	// `Observable.from` method
	// https://github.com/tc39/proposal-observable
	_export({ target: 'Observable', stat: true, forced: observableForced }, {
	  from: function from(x) {
	    var C = isConstructor(this) ? this : getBuiltIn('Observable');
	    var observableMethod = getMethod(anObject(x), $$OBSERVABLE);
	    if (observableMethod) {
	      var observable = anObject(functionCall(observableMethod, x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    var iterator = getIterator(x);
	    return new C(function (observer) {
	      iterate(iterator, function (it, stop) {
	        observer.next(it);
	        if (observer.closed) return stop();
	      }, { IS_ITERATOR: true, INTERRUPTED: true });
	      observer.complete();
	    });
	  }
	});

	var Array$1 = getBuiltIn('Array');

	// `Observable.of` method
	// https://github.com/tc39/proposal-observable
	_export({ target: 'Observable', stat: true, forced: observableForced }, {
	  of: function of() {
	    var C = isConstructor(this) ? this : getBuiltIn('Observable');
	    var length = arguments.length;
	    var items = Array$1(length);
	    var index = 0;
	    while (index < length) items[index] = arguments[index++];
	    return new C(function (observer) {
	      for (var i = 0; i < length; i++) {
	        observer.next(items[i]);
	        if (observer.closed) return;
	      } observer.complete();
	    });
	  }
	});

	// TODO: Remove from `core-js@4`




	// `Promise.try` method
	// https://github.com/tc39/proposal-promise-try
	_export({ target: 'Promise', stat: true, forced: true }, {
	  'try': function (callbackfn) {
	    var promiseCapability = newPromiseCapability$1.f(this);
	    var result = perform(callbackfn);
	    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
	    return promiseCapability.promise;
	  }
	});

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`






	var Map$3 = getBuiltIn('Map');
	var WeakMap$2 = getBuiltIn('WeakMap');
	var push$6 = functionUncurryThis([].push);

	var metadata = shared('metadata');
	var store$1 = metadata.store || (metadata.store = new WeakMap$2());

	var getOrCreateMetadataMap$1 = function (target, targetKey, create) {
	  var targetMetadata = store$1.get(target);
	  if (!targetMetadata) {
	    if (!create) return;
	    store$1.set(target, targetMetadata = new Map$3());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return;
	    targetMetadata.set(targetKey, keyMetadata = new Map$3());
	  } return keyMetadata;
	};

	var ordinaryHasOwnMetadata$3 = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap$1(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};

	var ordinaryGetOwnMetadata$2 = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap$1(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};

	var ordinaryDefineOwnMetadata$2 = function (MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap$1(O, P, true).set(MetadataKey, MetadataValue);
	};

	var ordinaryOwnMetadataKeys$2 = function (target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap$1(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) { push$6(keys, key); });
	  return keys;
	};

	var toMetadataKey$9 = function (it) {
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};

	var reflectMetadata = {
	  store: store$1,
	  getMap: getOrCreateMetadataMap$1,
	  has: ordinaryHasOwnMetadata$3,
	  get: ordinaryGetOwnMetadata$2,
	  set: ordinaryDefineOwnMetadata$2,
	  keys: ordinaryOwnMetadataKeys$2,
	  toKey: toMetadataKey$9
	};

	// TODO: Remove from `core-js@4`




	var toMetadataKey$8 = reflectMetadata.toKey;
	var ordinaryDefineOwnMetadata$1 = reflectMetadata.set;

	// `Reflect.defineMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  defineMetadata: function defineMetadata(metadataKey, metadataValue, target /* , targetKey */) {
	    var targetKey = arguments.length < 4 ? undefined : toMetadataKey$8(arguments[3]);
	    ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, anObject(target), targetKey);
	  }
	});

	var toMetadataKey$7 = reflectMetadata.toKey;
	var getOrCreateMetadataMap = reflectMetadata.getMap;
	var store = reflectMetadata.store;

	// `Reflect.deleteMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$7(arguments[2]);
	    var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	    if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	    if (metadataMap.size) return true;
	    var targetMetadata = store.get(target);
	    targetMetadata['delete'](targetKey);
	    return !!targetMetadata.size || store['delete'](target);
	  }
	});

	// TODO: Remove from `core-js@4`





	var ordinaryHasOwnMetadata$2 = reflectMetadata.has;
	var ordinaryGetOwnMetadata$1 = reflectMetadata.get;
	var toMetadataKey$6 = reflectMetadata.toKey;

	var ordinaryGetMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$2(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata$1(MetadataKey, O, P);
	  var parent = objectGetPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};

	// `Reflect.getMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$6(arguments[2]);
	    return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
	  }
	});

	// TODO: Remove from `core-js@4`







	var arrayUniqueBy$1 = functionUncurryThis(arrayUniqueBy$2);
	var concat = functionUncurryThis([].concat);
	var ordinaryOwnMetadataKeys$1 = reflectMetadata.keys;
	var toMetadataKey$5 = reflectMetadata.toKey;

	var ordinaryMetadataKeys = function (O, P) {
	  var oKeys = ordinaryOwnMetadataKeys$1(O, P);
	  var parent = objectGetPrototypeOf(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? arrayUniqueBy$1(concat(oKeys, pKeys)) : pKeys : oKeys;
	};

	// `Reflect.getMetadataKeys` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	    var targetKey = arguments.length < 2 ? undefined : toMetadataKey$5(arguments[1]);
	    return ordinaryMetadataKeys(anObject(target), targetKey);
	  }
	});

	// TODO: Remove from `core-js@4`




	var ordinaryGetOwnMetadata = reflectMetadata.get;
	var toMetadataKey$4 = reflectMetadata.toKey;

	// `Reflect.getOwnMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$4(arguments[2]);
	    return ordinaryGetOwnMetadata(metadataKey, anObject(target), targetKey);
	  }
	});

	// TODO: Remove from `core-js@4`




	var ordinaryOwnMetadataKeys = reflectMetadata.keys;
	var toMetadataKey$3 = reflectMetadata.toKey;

	// `Reflect.getOwnMetadataKeys` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	    var targetKey = arguments.length < 2 ? undefined : toMetadataKey$3(arguments[1]);
	    return ordinaryOwnMetadataKeys(anObject(target), targetKey);
	  }
	});

	// TODO: Remove from `core-js@4`





	var ordinaryHasOwnMetadata$1 = reflectMetadata.has;
	var toMetadataKey$2 = reflectMetadata.toKey;

	var ordinaryHasMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata$1(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = objectGetPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};

	// `Reflect.hasMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$2(arguments[2]);
	    return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
	  }
	});

	// TODO: Remove from `core-js@4`




	var ordinaryHasOwnMetadata = reflectMetadata.has;
	var toMetadataKey$1 = reflectMetadata.toKey;

	// `Reflect.hasOwnMetadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	    var targetKey = arguments.length < 3 ? undefined : toMetadataKey$1(arguments[2]);
	    return ordinaryHasOwnMetadata(metadataKey, anObject(target), targetKey);
	  }
	});

	var toMetadataKey = reflectMetadata.toKey;
	var ordinaryDefineOwnMetadata = reflectMetadata.set;

	// `Reflect.metadata` method
	// https://github.com/rbuckton/reflect-metadata
	_export({ target: 'Reflect', stat: true }, {
	  metadata: function metadata(metadataKey, metadataValue) {
	    return function decorator(target, key) {
	      ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetadataKey(key));
	    };
	  }
	});

	// https://github.com/tc39/collection-methods
	var collectionAddAll = function addAll(/* ...elements */) {
	  var set = anObject(this);
	  var adder = aCallable(set.add);
	  for (var k = 0, len = arguments.length; k < len; k++) {
	    functionCall(adder, set, arguments[k]);
	  }
	  return set;
	};

	// `Set.prototype.addAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  addAll: collectionAddAll
	});

	// `Set.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  deleteAll: collectionDeleteAll
	});

	// `Set.prototype.difference` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  difference: function difference(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
	    var remover = aCallable(newSet['delete']);
	    iterate(iterable, function (value) {
	      functionCall(remover, newSet, value);
	    });
	    return newSet;
	  }
	});

	var getSetIterator = function (it) {
	  // eslint-disable-next-line es-x/no-set -- safe
	  return functionCall(Set.prototype.values, it);
	};

	// `Set.prototype.every` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  every: function every(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return !iterate(iterator, function (value, stop) {
	      if (!boundFunction(value, value, set)) return stop();
	    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Set.prototype.filter` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
	    var adder = aCallable(newSet.add);
	    iterate(iterator, function (value) {
	      if (boundFunction(value, value, set)) functionCall(adder, newSet, value);
	    }, { IS_ITERATOR: true });
	    return newSet;
	  }
	});

	// `Set.prototype.find` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  find: function find(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return iterate(iterator, function (value, stop) {
	      if (boundFunction(value, value, set)) return stop(value);
	    }, { IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// `Set.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	_export({ target: 'Set', stat: true, forced: true }, {
	  from: collectionFrom
	});

	// `Set.prototype.intersection` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  intersection: function intersection(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
	    var hasCheck = aCallable(set.has);
	    var adder = aCallable(newSet.add);
	    iterate(iterable, function (value) {
	      if (functionCall(hasCheck, set, value)) functionCall(adder, newSet, value);
	    });
	    return newSet;
	  }
	});

	// `Set.prototype.isDisjointFrom` method
	// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  isDisjointFrom: function isDisjointFrom(iterable) {
	    var set = anObject(this);
	    var hasCheck = aCallable(set.has);
	    return !iterate(iterable, function (value, stop) {
	      if (functionCall(hasCheck, set, value) === true) return stop();
	    }, { INTERRUPTED: true }).stopped;
	  }
	});

	// `Set.prototype.isSubsetOf` method
	// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  isSubsetOf: function isSubsetOf(iterable) {
	    var iterator = getIterator(this);
	    var otherSet = anObject(iterable);
	    var hasCheck = otherSet.has;
	    if (!isCallable(hasCheck)) {
	      otherSet = new (getBuiltIn('Set'))(iterable);
	      hasCheck = aCallable(otherSet.has);
	    }
	    return !iterate(iterator, function (value, stop) {
	      if (functionCall(hasCheck, otherSet, value) === false) return stop();
	    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Set.prototype.isSupersetOf` method
	// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  isSupersetOf: function isSupersetOf(iterable) {
	    var set = anObject(this);
	    var hasCheck = aCallable(set.has);
	    return !iterate(iterable, function (value, stop) {
	      if (functionCall(hasCheck, set, value) === false) return stop();
	    }, { INTERRUPTED: true }).stopped;
	  }
	});

	var arrayJoin = functionUncurryThis([].join);
	var push$5 = [].push;

	// `Set.prototype.join` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  join: function join(separator) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var sep = separator === undefined ? ',' : toString_1$1(separator);
	    var result = [];
	    iterate(iterator, push$5, { that: result, IS_ITERATOR: true });
	    return arrayJoin(result, sep);
	  }
	});

	// `Set.prototype.map` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  map: function map(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))();
	    var adder = aCallable(newSet.add);
	    iterate(iterator, function (value) {
	      functionCall(adder, newSet, boundFunction(value, value, set));
	    }, { IS_ITERATOR: true });
	    return newSet;
	  }
	});

	// `Set.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	_export({ target: 'Set', stat: true, forced: true }, {
	  of: collectionOf
	});

	var TypeError$5 = global_1.TypeError;

	// `Set.prototype.reduce` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    aCallable(callbackfn);
	    iterate(iterator, function (value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = callbackfn(accumulator, value, value, set);
	      }
	    }, { IS_ITERATOR: true });
	    if (noInitial) throw TypeError$5('Reduce of empty set with no initial value');
	    return accumulator;
	  }
	});

	// `Set.prototype.some` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  some: function some(callbackfn /* , thisArg */) {
	    var set = anObject(this);
	    var iterator = getSetIterator(set);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return iterate(iterator, function (value, stop) {
	      if (boundFunction(value, value, set)) return stop();
	    }, { IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Set.prototype.symmetricDifference` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  symmetricDifference: function symmetricDifference(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
	    var remover = aCallable(newSet['delete']);
	    var adder = aCallable(newSet.add);
	    iterate(iterable, function (value) {
	      functionCall(remover, newSet, value) || functionCall(adder, newSet, value);
	    });
	    return newSet;
	  }
	});

	// `Set.prototype.union` method
	// https://github.com/tc39/proposal-set-methods
	_export({ target: 'Set', proto: true, real: true, forced: true }, {
	  union: function union(iterable) {
	    var set = anObject(this);
	    var newSet = new (speciesConstructor(set, getBuiltIn('Set')))(set);
	    iterate(iterable, aCallable(newSet.add), { that: newSet });
	    return newSet;
	  }
	});

	// TODO: Remove from `core-js@4`

	var charAt$5 = stringMultibyte.charAt;




	// `String.prototype.at` method
	// https://github.com/mathiasbynens/String.prototype.at
	_export({ target: 'String', proto: true, forced: true }, {
	  at: function at(index) {
	    var S = toString_1$1(requireObjectCoercible(this));
	    var len = S.length;
	    var relativeIndex = toIntegerOrInfinity(index);
	    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
	    return (k < 0 || k >= len) ? undefined : charAt$5(S, k);
	  }
	});

	var TypeError$4 = global_1.TypeError;
	var ArrayPrototype = Array.prototype;
	var push$4 = functionUncurryThis(ArrayPrototype.push);
	var join$3 = functionUncurryThis(ArrayPrototype.join);

	// `String.cooked` method
	// https://github.com/tc39/proposal-string-cooked
	_export({ target: 'String', stat: true, forced: true }, {
	  cooked: function cooked(template /* , ...substitutions */) {
	    var cookedTemplate = toIndexedObject(template);
	    var literalSegments = lengthOfArrayLike(cookedTemplate);
	    var argumentsLength = arguments.length;
	    var elements = [];
	    var i = 0;
	    while (literalSegments > i) {
	      var nextVal = cookedTemplate[i++];
	      if (nextVal === undefined) throw TypeError$4('Incorrect template');
	      push$4(elements, toString_1$1(nextVal));
	      if (i === literalSegments) return join$3(elements, '');
	      if (i < argumentsLength) push$4(elements, toString_1$1(arguments[i]));
	    }
	  }
	});

	var codeAt$1 = stringMultibyte.codeAt;
	var charAt$4 = stringMultibyte.charAt;
	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$3 = internalState.set;
	var getInternalState$1 = internalState.getterFor(STRING_ITERATOR);

	// TODO: unify with String#@@iterator
	var $StringIterator = createIteratorConstructor(function StringIterator(string) {
	  setInternalState$3(this, {
	    type: STRING_ITERATOR,
	    string: string,
	    index: 0
	  });
	}, 'String', function next() {
	  var state = getInternalState$1(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt$4(string, index);
	  state.index += point.length;
	  return { value: { codePoint: codeAt$1(point, 0), position: index }, done: false };
	});

	// `String.prototype.codePoints` method
	// https://github.com/tc39/proposal-string-prototype-codepoints
	_export({ target: 'String', proto: true, forced: true }, {
	  codePoints: function codePoints() {
	    return new $StringIterator(toString_1$1(requireObjectCoercible(this)));
	  }
	});

	// `Symbol.asyncDispose` well-known symbol
	// https://github.com/tc39/proposal-using-statement
	defineWellKnownSymbol('asyncDispose');

	// `Symbol.dispose` well-known symbol
	// https://github.com/tc39/proposal-using-statement
	defineWellKnownSymbol('dispose');

	// `Symbol.matcher` well-known symbol
	// https://github.com/tc39/proposal-pattern-matching
	defineWellKnownSymbol('matcher');

	// `Symbol.metadata` well-known symbol
	// https://github.com/tc39/proposal-decorators
	defineWellKnownSymbol('metadata');

	// `Symbol.observable` well-known symbol
	// https://github.com/tc39/proposal-observable
	defineWellKnownSymbol('observable');

	// TODO: remove from `core-js@4`


	// `Symbol.patternMatch` well-known symbol
	// https://github.com/tc39/proposal-pattern-matching
	defineWellKnownSymbol('patternMatch');

	// TODO: remove from `core-js@4`


	defineWellKnownSymbol('replaceAll');

	// TODO: Remove from `core-js@4`






	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod;

	// `%TypedArray%.fromAsync` method
	// https://github.com/tc39/proposal-array-from-async
	exportTypedArrayStaticMethod('fromAsync', function fromAsync(asyncItems /* , mapfn = undefined, thisArg = undefined */) {
	  var C = this;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var thisArg = argumentsLength > 2 ? arguments[2] : undefined;
	  return new (getBuiltIn('Promise'))(function (resolve) {
	    aConstructor(C);
	    resolve(arrayFromAsync(asyncItems, mapfn, thisArg));
	  }).then(function (list) {
	    return arrayFromConstructorAndList(aTypedArrayConstructor(C), list);
	  });
	}, true);

	// TODO: Remove from `core-js@4`

	var $filterReject$1 = arrayIteration.filterReject;


	var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.filterOut` method
	// https://github.com/tc39/proposal-array-filtering
	exportTypedArrayMethod$9('filterOut', function filterOut(callbackfn /* , thisArg */) {
	  var list = $filterReject$1(aTypedArray$9(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  return typedArrayFromSpeciesAndList(this, list);
	}, true);

	var $filterReject = arrayIteration.filterReject;


	var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.filterReject` method
	// https://github.com/tc39/proposal-array-filtering
	exportTypedArrayMethod$8('filterReject', function filterReject(callbackfn /* , thisArg */) {
	  var list = $filterReject(aTypedArray$8(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  return typedArrayFromSpeciesAndList(this, list);
	}, true);

	var $findLast = arrayIterationFromLast.findLast;

	var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.findLast` method
	// https://github.com/tc39/proposal-array-find-from-last
	exportTypedArrayMethod$7('findLast', function findLast(predicate /* , thisArg */) {
	  return $findLast(aTypedArray$7(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findLastIndex = arrayIterationFromLast.findLastIndex;

	var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.findLastIndex` method
	// https://github.com/tc39/proposal-array-find-from-last
	exportTypedArrayMethod$6('findLastIndex', function findLastIndex(predicate /* , thisArg */) {
	  return $findLastIndex(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	// TODO: Remove from `core-js@4`




	var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.groupBy` method
	// https://github.com/tc39/proposal-array-grouping
	exportTypedArrayMethod$5('groupBy', function groupBy(callbackfn /* , thisArg */) {
	  var thisArg = arguments.length > 1 ? arguments[1] : undefined;
	  return arrayGroupBy(aTypedArray$5(this), callbackfn, thisArg, typedArraySpeciesConstructor);
	}, true);

	var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;
	var TYPED_ARRAY_CONSTRUCTOR$3 = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;

	// `%TypedArray%.prototype.toReversed` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
	exportTypedArrayMethod$4('toReversed', function toReversed() {
	  return arrayToReversed(aTypedArray$4(this), this[TYPED_ARRAY_CONSTRUCTOR$3]);
	});

	var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod;
	var TYPED_ARRAY_CONSTRUCTOR$2 = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
	var sort = functionUncurryThis(arrayBufferViewCore.TypedArrayPrototype.sort);

	// `%TypedArray%.prototype.toSorted` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted
	exportTypedArrayMethod$3('toSorted', function toSorted(compareFn) {
	  if (compareFn !== undefined) aCallable(compareFn);
	  var O = aTypedArray$3(this);
	  var A = arrayFromConstructorAndList(O[TYPED_ARRAY_CONSTRUCTOR$2], O);
	  return sort(A, compareFn);
	});

	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;
	var TYPED_ARRAY_CONSTRUCTOR$1 = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;

	// `%TypedArray%.prototype.toSpliced` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSpliced
	// eslint-disable-next-line no-unused-vars -- required for .length
	exportTypedArrayMethod$2('toSpliced', function toSpliced(start, deleteCount /* , ...items */) {
	  return arrayToSpliced(aTypedArray$2(this), this[TYPED_ARRAY_CONSTRUCTOR$1], arraySlice$1(arguments));
	});

	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;
	var arrayUniqueBy = functionUncurryThis(arrayUniqueBy$2);

	// `%TypedArray%.prototype.uniqueBy` method
	// https://github.com/tc39/proposal-array-unique
	exportTypedArrayMethod$1('uniqueBy', function uniqueBy(resolver) {
	  return typedArrayFromSpeciesAndList(this, arrayUniqueBy(aTypedArray$1(this), resolver));
	}, true);

	var aTypedArray = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod = arrayBufferViewCore.exportTypedArrayMethod;
	var TYPED_ARRAY_CONSTRUCTOR = arrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;

	// `%TypedArray%.prototype.with` method
	// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
	exportTypedArrayMethod('with', { 'with': function (index, value) {
	  return arrayWith(aTypedArray(this), this[TYPED_ARRAY_CONSTRUCTOR], index, value);
	} }['with']);

	// `WeakMap.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'WeakMap', proto: true, real: true, forced: true }, {
	  deleteAll: collectionDeleteAll
	});

	// `WeakMap.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	_export({ target: 'WeakMap', stat: true, forced: true }, {
	  from: collectionFrom
	});

	// `WeakMap.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	_export({ target: 'WeakMap', stat: true, forced: true }, {
	  of: collectionOf
	});

	// `WeakMap.prototype.emplace` method
	// https://github.com/tc39/proposal-upsert
	_export({ target: 'WeakMap', proto: true, real: true, forced: true }, {
	  emplace: mapEmplace
	});

	// TODO: remove from `core-js@4`



	// `WeakMap.prototype.upsert` method (replaced by `WeakMap.prototype.emplace`)
	// https://github.com/tc39/proposal-upsert
	_export({ target: 'WeakMap', proto: true, real: true, forced: true }, {
	  upsert: mapUpsert
	});

	// `WeakSet.prototype.addAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'WeakSet', proto: true, real: true, forced: true }, {
	  addAll: collectionAddAll
	});

	// `WeakSet.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'WeakSet', proto: true, real: true, forced: true }, {
	  deleteAll: collectionDeleteAll
	});

	// `WeakSet.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	_export({ target: 'WeakSet', stat: true, forced: true }, {
	  from: collectionFrom
	});

	// `WeakSet.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	_export({ target: 'WeakSet', stat: true, forced: true }, {
	  of: collectionOf
	});

	var itoc$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	var ctoi$1 = {};

	for (var index = 0; index < 66; index++) ctoi$1[itoc$1.charAt(index)] = index;

	var base64Map = {
	  itoc: itoc$1,
	  ctoi: ctoi$1
	};

	var ctoi = base64Map.ctoi;

	var disallowed = /[^\d+/a-z]/i;
	var whitespaces = /[\t\n\f\r ]+/g;
	var finalEq = /[=]+$/;

	var $atob = getBuiltIn('atob');
	var fromCharCode$1 = String.fromCharCode;
	var charAt$3 = functionUncurryThis(''.charAt);
	var replace$3 = functionUncurryThis(''.replace);
	var exec$2 = functionUncurryThis(disallowed.exec);

	var NO_SPACES_IGNORE = fails(function () {
	  return $atob(' ') !== '';
	});

	var NO_ENCODING_CHECK = !fails(function () {
	  $atob('a');
	});

	var NO_ARG_RECEIVING_CHECK$1 = !NO_SPACES_IGNORE && !NO_ENCODING_CHECK && !fails(function () {
	  $atob();
	});

	var WRONG_ARITY$1 = !NO_SPACES_IGNORE && !NO_ENCODING_CHECK && $atob.length !== 1;

	// `atob` method
	// https://html.spec.whatwg.org/multipage/webappapis.html#dom-atob
	_export({ global: true, enumerable: true, forced: NO_SPACES_IGNORE || NO_ENCODING_CHECK || NO_ARG_RECEIVING_CHECK$1 || WRONG_ARITY$1 }, {
	  atob: function atob(data) {
	    validateArgumentsLength(arguments.length, 1);
	    if (NO_ARG_RECEIVING_CHECK$1 || WRONG_ARITY$1) return $atob(data);
	    var string = replace$3(toString_1$1(data), whitespaces, '');
	    var output = '';
	    var position = 0;
	    var bc = 0;
	    var chr, bs;
	    if (string.length % 4 == 0) {
	      string = replace$3(string, finalEq, '');
	    }
	    if (string.length % 4 == 1 || exec$2(disallowed, string)) {
	      throw new (getBuiltIn('DOMException'))('The string is not correctly encoded', 'InvalidCharacterError');
	    }
	    while (chr = charAt$3(string, position++)) {
	      if (hasOwnProperty_1(ctoi, chr)) {
	        bs = bc % 4 ? bs * 64 + ctoi[chr] : ctoi[chr];
	        if (bc++ % 4) output += fromCharCode$1(255 & bs >> (-2 * bc & 6));
	      }
	    } return output;
	  }
	});

	var itoc = base64Map.itoc;

	var $btoa = getBuiltIn('btoa');
	var charAt$2 = functionUncurryThis(''.charAt);
	var charCodeAt$1 = functionUncurryThis(''.charCodeAt);

	var NO_ARG_RECEIVING_CHECK = !!$btoa && !fails(function () {
	  $btoa();
	});

	var WRONG_ARG_CONVERSION = !!$btoa && fails(function () {
	  return $btoa(null) !== 'bnVsbA==';
	});

	var WRONG_ARITY = !!$btoa && $btoa.length !== 1;

	// `btoa` method
	// https://html.spec.whatwg.org/multipage/webappapis.html#dom-btoa
	_export({ global: true, enumerable: true, forced: NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY }, {
	  btoa: function btoa(data) {
	    validateArgumentsLength(arguments.length, 1);
	    if (NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY) return $btoa(toString_1$1(data));
	    var string = toString_1$1(data);
	    var output = '';
	    var position = 0;
	    var map = itoc;
	    var block, charCode;
	    while (charAt$2(string, position) || (map = '=', position % 1)) {
	      charCode = charCodeAt$1(string, position += 3 / 4);
	      if (charCode > 0xFF) {
	        throw new (getBuiltIn('DOMException'))('The string contains characters outside of the Latin1 range', 'InvalidCharacterError');
	      }
	      block = block << 8 | charCode;
	      output += charAt$2(map, 63 & block >> 8 - position % 1 * 8);
	    } return output;
	  }
	});

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`


	var classList = documentCreateElement('span').classList;
	var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

	var domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;

	var handlePrototype$1 = function (CollectionPrototype) {
	  // some Chrome versions have non-configurable methods on DOMTokenList
	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  }
	};

	for (var COLLECTION_NAME$1 in domIterables) {
	  if (domIterables[COLLECTION_NAME$1]) {
	    handlePrototype$1(global_1[COLLECTION_NAME$1] && global_1[COLLECTION_NAME$1].prototype);
	  }
	}

	handlePrototype$1(domTokenListPrototype);

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;

	var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
	  if (CollectionPrototype) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {
	      createNonEnumerableProperty(CollectionPrototype, ITERATOR$2, ArrayValues);
	    } catch (error) {
	      CollectionPrototype[ITERATOR$2] = ArrayValues;
	    }
	    if (!CollectionPrototype[TO_STRING_TAG]) {
	      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
	    }
	    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
	        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      }
	    }
	  }
	};

	for (var COLLECTION_NAME in domIterables) {
	  handlePrototype(global_1[COLLECTION_NAME] && global_1[COLLECTION_NAME].prototype, COLLECTION_NAME);
	}

	handlePrototype(domTokenListPrototype, 'DOMTokenList');

	var tryNodeRequire = function (name) {
	  try {
	    // eslint-disable-next-line no-new-func -- safe
	    if (engineIsNode) return Function('return require("' + name + '")')();
	  } catch (error) { /* empty */ }
	};

	var domExceptionConstants = {
	  IndexSizeError: { s: 'INDEX_SIZE_ERR', c: 1, m: 1 },
	  DOMStringSizeError: { s: 'DOMSTRING_SIZE_ERR', c: 2, m: 0 },
	  HierarchyRequestError: { s: 'HIERARCHY_REQUEST_ERR', c: 3, m: 1 },
	  WrongDocumentError: { s: 'WRONG_DOCUMENT_ERR', c: 4, m: 1 },
	  InvalidCharacterError: { s: 'INVALID_CHARACTER_ERR', c: 5, m: 1 },
	  NoDataAllowedError: { s: 'NO_DATA_ALLOWED_ERR', c: 6, m: 0 },
	  NoModificationAllowedError: { s: 'NO_MODIFICATION_ALLOWED_ERR', c: 7, m: 1 },
	  NotFoundError: { s: 'NOT_FOUND_ERR', c: 8, m: 1 },
	  NotSupportedError: { s: 'NOT_SUPPORTED_ERR', c: 9, m: 1 },
	  InUseAttributeError: { s: 'INUSE_ATTRIBUTE_ERR', c: 10, m: 1 },
	  InvalidStateError: { s: 'INVALID_STATE_ERR', c: 11, m: 1 },
	  SyntaxError: { s: 'SYNTAX_ERR', c: 12, m: 1 },
	  InvalidModificationError: { s: 'INVALID_MODIFICATION_ERR', c: 13, m: 1 },
	  NamespaceError: { s: 'NAMESPACE_ERR', c: 14, m: 1 },
	  InvalidAccessError: { s: 'INVALID_ACCESS_ERR', c: 15, m: 1 },
	  ValidationError: { s: 'VALIDATION_ERR', c: 16, m: 0 },
	  TypeMismatchError: { s: 'TYPE_MISMATCH_ERR', c: 17, m: 1 },
	  SecurityError: { s: 'SECURITY_ERR', c: 18, m: 1 },
	  NetworkError: { s: 'NETWORK_ERR', c: 19, m: 1 },
	  AbortError: { s: 'ABORT_ERR', c: 20, m: 1 },
	  URLMismatchError: { s: 'URL_MISMATCH_ERR', c: 21, m: 1 },
	  QuotaExceededError: { s: 'QUOTA_EXCEEDED_ERR', c: 22, m: 1 },
	  TimeoutError: { s: 'TIMEOUT_ERR', c: 23, m: 1 },
	  InvalidNodeTypeError: { s: 'INVALID_NODE_TYPE_ERR', c: 24, m: 1 },
	  DataCloneError: { s: 'DATA_CLONE_ERR', c: 25, m: 1 }
	};
	domExceptionConstants.IndexSizeError;
	domExceptionConstants.DOMStringSizeError;
	domExceptionConstants.HierarchyRequestError;
	domExceptionConstants.WrongDocumentError;
	domExceptionConstants.InvalidCharacterError;
	domExceptionConstants.NoDataAllowedError;
	domExceptionConstants.NoModificationAllowedError;
	domExceptionConstants.NotFoundError;
	domExceptionConstants.NotSupportedError;
	domExceptionConstants.InUseAttributeError;
	domExceptionConstants.InvalidStateError;
	domExceptionConstants.InvalidModificationError;
	domExceptionConstants.NamespaceError;
	domExceptionConstants.InvalidAccessError;
	domExceptionConstants.ValidationError;
	domExceptionConstants.TypeMismatchError;
	domExceptionConstants.SecurityError;
	domExceptionConstants.NetworkError;
	domExceptionConstants.AbortError;
	domExceptionConstants.URLMismatchError;
	domExceptionConstants.QuotaExceededError;
	domExceptionConstants.TimeoutError;
	domExceptionConstants.InvalidNodeTypeError;
	domExceptionConstants.DataCloneError;

	var defineProperty$2 = objectDefineProperty.f;
	var defineProperties$1 = objectDefineProperties.f;












	var DOM_EXCEPTION$2 = 'DOMException';
	var DATA_CLONE_ERR = 'DATA_CLONE_ERR';
	var Error$3 = getBuiltIn('Error');
	// NodeJS < 17.0 does not expose `DOMException` to global
	var NativeDOMException$1 = getBuiltIn(DOM_EXCEPTION$2) || (function () {
	  try {
	    // NodeJS < 15.0 does not expose `MessageChannel` to global
	    var MessageChannel = getBuiltIn('MessageChannel') || tryNodeRequire('worker_threads').MessageChannel;
	    // eslint-disable-next-line es-x/no-weak-map, unicorn/require-post-message-target-origin -- safe
	    new MessageChannel().port1.postMessage(new WeakMap());
	  } catch (error) {
	    if (error.name == DATA_CLONE_ERR && error.code == 25) return error.constructor;
	  }
	})();
	var NativeDOMExceptionPrototype = NativeDOMException$1 && NativeDOMException$1.prototype;
	var ErrorPrototype = Error$3.prototype;
	var setInternalState$2 = internalState.set;
	var getInternalState = internalState.getterFor(DOM_EXCEPTION$2);
	var HAS_STACK = 'stack' in Error$3(DOM_EXCEPTION$2);

	var codeFor = function (name) {
	  return hasOwnProperty_1(domExceptionConstants, name) && domExceptionConstants[name].m ? domExceptionConstants[name].c : 0;
	};

	var $DOMException$1 = function DOMException() {
	  anInstance(this, DOMExceptionPrototype$1);
	  var argumentsLength = arguments.length;
	  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
	  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
	  var code = codeFor(name);
	  setInternalState$2(this, {
	    type: DOM_EXCEPTION$2,
	    name: name,
	    message: message,
	    code: code
	  });
	  if (!descriptors) {
	    this.name = name;
	    this.message = message;
	    this.code = code;
	  }
	  if (HAS_STACK) {
	    var error = Error$3(message);
	    error.name = DOM_EXCEPTION$2;
	    defineProperty$2(this, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
	  }
	};

	var DOMExceptionPrototype$1 = $DOMException$1.prototype = objectCreate(ErrorPrototype);

	var createGetterDescriptor = function (get) {
	  return { enumerable: true, configurable: true, get: get };
	};

	var getterFor = function (key) {
	  return createGetterDescriptor(function () {
	    return getInternalState(this)[key];
	  });
	};

	if (descriptors) defineProperties$1(DOMExceptionPrototype$1, {
	  name: getterFor('name'),
	  message: getterFor('message'),
	  code: getterFor('code')
	});

	defineProperty$2(DOMExceptionPrototype$1, 'constructor', createPropertyDescriptor(1, $DOMException$1));

	// FF36- DOMException is a function, but can't be constructed
	var INCORRECT_CONSTRUCTOR = fails(function () {
	  return !(new NativeDOMException$1() instanceof Error$3);
	});

	// Safari 10.1 / Chrome 32- / IE8- DOMException.prototype.toString bugs
	var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function () {
	  return ErrorPrototype.toString !== errorToString || String(new NativeDOMException$1(1, 2)) !== '2: 1';
	});

	// Deno 1.6.3- DOMException.prototype.code just missed
	var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function () {
	  return new NativeDOMException$1(1, 'DataCloneError').code !== 25;
	});

	// Deno 1.6.3- DOMException constants just missed
	INCORRECT_CONSTRUCTOR
	  || NativeDOMException$1[DATA_CLONE_ERR] !== 25
	  || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;

	var FORCED_CONSTRUCTOR$1 = INCORRECT_CONSTRUCTOR;

	// `DOMException` constructor
	// https://webidl.spec.whatwg.org/#idl-DOMException
	_export({ global: true, forced: FORCED_CONSTRUCTOR$1 }, {
	  DOMException: FORCED_CONSTRUCTOR$1 ? $DOMException$1 : NativeDOMException$1
	});

	var PolyfilledDOMException$1 = getBuiltIn(DOM_EXCEPTION$2);
	var PolyfilledDOMExceptionPrototype$1 = PolyfilledDOMException$1.prototype;

	if (INCORRECT_TO_STRING && (NativeDOMException$1 === PolyfilledDOMException$1)) {
	  redefine(PolyfilledDOMExceptionPrototype$1, 'toString', errorToString);
	}

	if (INCORRECT_CODE && descriptors && NativeDOMException$1 === PolyfilledDOMException$1) {
	  defineProperty$2(PolyfilledDOMExceptionPrototype$1, 'code', createGetterDescriptor(function () {
	    return codeFor(anObject(this).name);
	  }));
	}

	for (var key$1 in domExceptionConstants) if (hasOwnProperty_1(domExceptionConstants, key$1)) {
	  var constant$2 = domExceptionConstants[key$1];
	  var constantName$1 = constant$2.s;
	  var descriptor = createPropertyDescriptor(6, constant$2.c);
	  if (!hasOwnProperty_1(PolyfilledDOMException$1, constantName$1)) {
	    defineProperty$2(PolyfilledDOMException$1, constantName$1, descriptor);
	  }
	  if (!hasOwnProperty_1(PolyfilledDOMExceptionPrototype$1, constantName$1)) {
	    defineProperty$2(PolyfilledDOMExceptionPrototype$1, constantName$1, descriptor);
	  }
	}

	var defineProperty$1 = objectDefineProperty.f;








	var DOM_EXCEPTION$1 = 'DOMException';
	var Error$2 = getBuiltIn('Error');
	var NativeDOMException = getBuiltIn(DOM_EXCEPTION$1);

	var $DOMException = function DOMException() {
	  anInstance(this, DOMExceptionPrototype);
	  var argumentsLength = arguments.length;
	  var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);
	  var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');
	  var that = new NativeDOMException(message, name);
	  var error = Error$2(message);
	  error.name = DOM_EXCEPTION$1;
	  defineProperty$1(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
	  inheritIfRequired(that, this, $DOMException);
	  return that;
	};

	var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;

	var ERROR_HAS_STACK = 'stack' in Error$2(DOM_EXCEPTION$1);
	var DOM_EXCEPTION_HAS_STACK = 'stack' in new NativeDOMException(1, 2);
	var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !DOM_EXCEPTION_HAS_STACK;

	// `DOMException` constructor patch for `.stack` where it's required
	// https://webidl.spec.whatwg.org/#es-DOMException-specialness
	_export({ global: true, forced: FORCED_CONSTRUCTOR }, { // TODO: fix export logic
	  DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
	});

	var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION$1);
	var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;

	if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
	  {
	    defineProperty$1(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));
	  }

	  for (var key in domExceptionConstants) if (hasOwnProperty_1(domExceptionConstants, key)) {
	    var constant$1 = domExceptionConstants[key];
	    var constantName = constant$1.s;
	    if (!hasOwnProperty_1(PolyfilledDOMException, constantName)) {
	      defineProperty$1(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant$1.c));
	    }
	  }
	}

	var DOM_EXCEPTION = 'DOMException';

	setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);

	var clearImmediate = task$1.clear;

	// `clearImmediate` method
	// http://w3c.github.io/setImmediate/#si-clearImmediate
	_export({ global: true, bind: true, enumerable: true, forced: global_1.clearImmediate !== clearImmediate }, {
	  clearImmediate: clearImmediate
	});

	var setImmediate = task$1.set;

	// `setImmediate` method
	// http://w3c.github.io/setImmediate/#si-setImmediate
	_export({ global: true, bind: true, enumerable: true, forced: global_1.setImmediate !== setImmediate }, {
	  setImmediate: setImmediate
	});

	var process = global_1.process;

	// `queueMicrotask` method
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
	_export({ global: true, enumerable: true, noTargetGet: true }, {
	  queueMicrotask: function queueMicrotask(fn) {
	    validateArgumentsLength(arguments.length, 1);
	    aCallable(fn);
	    var domain = engineIsNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

	var Object$1 = global_1.Object;
	var Date$1 = global_1.Date;
	var Error$1 = global_1.Error;
	var EvalError = global_1.EvalError;
	var RangeError$1 = global_1.RangeError;
	var ReferenceError$1 = global_1.ReferenceError;
	var SyntaxError = global_1.SyntaxError;
	var TypeError$3 = global_1.TypeError;
	var URIError = global_1.URIError;
	var PerformanceMark = global_1.PerformanceMark;
	var WebAssembly = global_1.WebAssembly;
	var CompileError = WebAssembly && WebAssembly.CompileError || Error$1;
	var LinkError = WebAssembly && WebAssembly.LinkError || Error$1;
	var RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error$1;
	var DOMException = getBuiltIn('DOMException');
	var Set$2 = getBuiltIn('Set');
	var Map$2 = getBuiltIn('Map');
	var MapPrototype = Map$2.prototype;
	var mapHas = functionUncurryThis(MapPrototype.has);
	var mapGet = functionUncurryThis(MapPrototype.get);
	var mapSet = functionUncurryThis(MapPrototype.set);
	var setAdd = functionUncurryThis(Set$2.prototype.add);
	var objectKeys = getBuiltIn('Object', 'keys');
	var push$3 = functionUncurryThis([].push);
	var booleanValueOf = functionUncurryThis(true.valueOf);
	var numberValueOf = functionUncurryThis(1.0.valueOf);
	var stringValueOf = functionUncurryThis(''.valueOf);
	var getFlags = functionUncurryThis(regexpFlags);
	var getTime = functionUncurryThis(Date$1.prototype.getTime);
	var PERFORMANCE_MARK = uid('structuredClone');
	var DATA_CLONE_ERROR = 'DataCloneError';
	var TRANSFERRING = 'Transferring';

	var checkBasicSemantic = function (structuredCloneImplementation) {
	  return !fails(function () {
	    var set1 = new global_1.Set([7]);
	    var set2 = structuredCloneImplementation(set1);
	    var number = structuredCloneImplementation(Object$1(7));
	    return set2 == set1 || !set2.has(7) || typeof number != 'object' || number != 7;
	  }) && structuredCloneImplementation;
	};

	// https://github.com/whatwg/html/pull/5749
	var checkNewErrorsSemantic = function (structuredCloneImplementation) {
	  return !fails(function () {
	    var test = structuredCloneImplementation(new global_1.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
	    return test.name != 'AggregateError' || test.errors[0] != 1 || test.message != PERFORMANCE_MARK || test.cause != 3;
	  }) && structuredCloneImplementation;
	};

	// FF94+, Safari TP134+, Chrome Canary 98+, NodeJS 17.0+, Deno 1.13+
	// current FF and Safari implementations can't clone errors
	// https://bugzilla.mozilla.org/show_bug.cgi?id=1556604
	// no one of current implementations supports new (html/5749) error cloning semantic
	var nativeStructuredClone = global_1.structuredClone;

	var FORCED_REPLACEMENT = !checkNewErrorsSemantic(nativeStructuredClone);

	// Chrome 82+, Safari 14.1+, Deno 1.11+
	// Chrome 78-81 implementation swaps `.name` and `.message` of cloned `DOMException`
	// Safari 14.1 implementation doesn't clone some `RegExp` flags, so requires a workaround
	// current Safari implementation can't clone errors
	// Deno 1.2-1.10 implementations too naive
	// NodeJS 16.0+ does not have `PerformanceMark` constructor, structured cloning implementation
	//   from `performance.mark` is too naive and can't clone, for example, `RegExp` or some boxed primitives
	//   https://github.com/nodejs/node/issues/40840
	// no one of current implementations supports new (html/5749) error cloning semantic
	var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function (value) {
	  return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
	});

	var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;

	var throwUncloneable = function (type) {
	  throw new DOMException('Uncloneable type: ' + type, DATA_CLONE_ERROR);
	};

	var throwUnpolyfillable = function (type, kind) {
	  throw new DOMException((kind || 'Cloning') + ' of ' + type + ' cannot be properly polyfilled in this engine', DATA_CLONE_ERROR);
	};

	var structuredCloneInternal = function (value, map) {
	  if (isSymbol$1(value)) throwUncloneable('Symbol');
	  if (!isObject$2(value)) return value;
	  // effectively preserves circular references
	  if (map) {
	    if (mapHas(map, value)) return mapGet(map, value);
	  } else map = new Map$2();

	  var type = classof(value);
	  var deep = false;
	  var C, name, cloned, dataTransfer, i, length, keys, key, source, target;

	  switch (type) {
	    case 'Array':
	      cloned = [];
	      deep = true;
	      break;
	    case 'Object':
	      cloned = {};
	      deep = true;
	      break;
	    case 'Map':
	      cloned = new Map$2();
	      deep = true;
	      break;
	    case 'Set':
	      cloned = new Set$2();
	      deep = true;
	      break;
	    case 'RegExp':
	      // in this block because of a Safari 14.1 bug
	      // old FF does not clone regexes passed to the constructor, so get the source and flags directly
	      cloned = new RegExp(value.source, 'flags' in value ? value.flags : getFlags(value));
	      break;
	    case 'Error':
	      name = value.name;
	      switch (name) {
	        case 'AggregateError':
	          cloned = getBuiltIn('AggregateError')([]);
	          break;
	        case 'EvalError':
	          cloned = EvalError();
	          break;
	        case 'RangeError':
	          cloned = RangeError$1();
	          break;
	        case 'ReferenceError':
	          cloned = ReferenceError$1();
	          break;
	        case 'SyntaxError':
	          cloned = SyntaxError();
	          break;
	        case 'TypeError':
	          cloned = TypeError$3();
	          break;
	        case 'URIError':
	          cloned = URIError();
	          break;
	        case 'CompileError':
	          cloned = CompileError();
	          break;
	        case 'LinkError':
	          cloned = LinkError();
	          break;
	        case 'RuntimeError':
	          cloned = RuntimeError();
	          break;
	        default:
	          cloned = Error$1();
	      }
	      deep = true;
	      break;
	    case 'DOMException':
	      cloned = new DOMException(value.message, value.name);
	      deep = true;
	      break;
	    case 'DataView':
	    case 'Int8Array':
	    case 'Uint8Array':
	    case 'Uint8ClampedArray':
	    case 'Int16Array':
	    case 'Uint16Array':
	    case 'Int32Array':
	    case 'Uint32Array':
	    case 'Float32Array':
	    case 'Float64Array':
	    case 'BigInt64Array':
	    case 'BigUint64Array':
	      C = global_1[type];
	      // in some old engines like Safari 9, typeof C is 'object'
	      // on Uint8ClampedArray or some other constructors
	      if (!isObject$2(C)) throwUnpolyfillable(type);
	      cloned = new C(
	        // this is safe, since arraybuffer cannot have circular references
	        structuredCloneInternal(value.buffer, map),
	        value.byteOffset,
	        type === 'DataView' ? value.byteLength : value.length
	      );
	      break;
	    case 'DOMQuad':
	      try {
	        cloned = new DOMQuad(
	          structuredCloneInternal(value.p1, map),
	          structuredCloneInternal(value.p2, map),
	          structuredCloneInternal(value.p3, map),
	          structuredCloneInternal(value.p4, map)
	        );
	      } catch (error) {
	        if (nativeRestrictedStructuredClone) {
	          cloned = nativeRestrictedStructuredClone(value);
	        } else throwUnpolyfillable(type);
	      }
	      break;
	    case 'FileList':
	      C = global_1.DataTransfer;
	      if (isConstructor(C)) {
	        dataTransfer = new C();
	        for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
	          dataTransfer.items.add(structuredCloneInternal(value[i], map));
	        }
	        cloned = dataTransfer.files;
	      } else if (nativeRestrictedStructuredClone) {
	        cloned = nativeRestrictedStructuredClone(value);
	      } else throwUnpolyfillable(type);
	      break;
	    case 'ImageData':
	      // Safari 9 ImageData is a constructor, but typeof ImageData is 'object'
	      try {
	        cloned = new ImageData(
	          structuredCloneInternal(value.data, map),
	          value.width,
	          value.height,
	          { colorSpace: value.colorSpace }
	        );
	      } catch (error) {
	        if (nativeRestrictedStructuredClone) {
	          cloned = nativeRestrictedStructuredClone(value);
	        } else throwUnpolyfillable(type);
	      } break;
	    default:
	      if (nativeRestrictedStructuredClone) {
	        cloned = nativeRestrictedStructuredClone(value);
	      } else switch (type) {
	        case 'BigInt':
	          // can be a 3rd party polyfill
	          cloned = Object$1(value.valueOf());
	          break;
	        case 'Boolean':
	          cloned = Object$1(booleanValueOf(value));
	          break;
	        case 'Number':
	          cloned = Object$1(numberValueOf(value));
	          break;
	        case 'String':
	          cloned = Object$1(stringValueOf(value));
	          break;
	        case 'Date':
	          cloned = new Date$1(getTime(value));
	          break;
	        case 'ArrayBuffer':
	          C = global_1.DataView;
	          // `ArrayBuffer#slice` is not available in IE10
	          // `ArrayBuffer#slice` and `DataView` are not available in old FF
	          if (!C && typeof value.slice != 'function') throwUnpolyfillable(type);
	          // detached buffers throws in `DataView` and `.slice`
	          try {
	            if (typeof value.slice == 'function') {
	              cloned = value.slice(0);
	            } else {
	              length = value.byteLength;
	              cloned = new ArrayBuffer(length);
	              source = new C(value);
	              target = new C(cloned);
	              for (i = 0; i < length; i++) {
	                target.setUint8(i, source.getUint8(i));
	              }
	            }
	          } catch (error) {
	            throw new DOMException('ArrayBuffer is detached', DATA_CLONE_ERROR);
	          } break;
	        case 'SharedArrayBuffer':
	          // SharedArrayBuffer should use shared memory, we can't polyfill it, so return the original
	          cloned = value;
	          break;
	        case 'Blob':
	          try {
	            cloned = value.slice(0, value.size, value.type);
	          } catch (error) {
	            throwUnpolyfillable(type);
	          } break;
	        case 'DOMPoint':
	        case 'DOMPointReadOnly':
	          C = global_1[type];
	          try {
	            cloned = C.fromPoint
	              ? C.fromPoint(value)
	              : new C(value.x, value.y, value.z, value.w);
	          } catch (error) {
	            throwUnpolyfillable(type);
	          } break;
	        case 'DOMRect':
	        case 'DOMRectReadOnly':
	          C = global_1[type];
	          try {
	            cloned = C.fromRect
	              ? C.fromRect(value)
	              : new C(value.x, value.y, value.width, value.height);
	          } catch (error) {
	            throwUnpolyfillable(type);
	          } break;
	        case 'DOMMatrix':
	        case 'DOMMatrixReadOnly':
	          C = global_1[type];
	          try {
	            cloned = C.fromMatrix
	              ? C.fromMatrix(value)
	              : new C(value);
	          } catch (error) {
	            throwUnpolyfillable(type);
	          } break;
	        case 'AudioData':
	        case 'VideoFrame':
	          if (!isCallable(value.clone)) throwUnpolyfillable(type);
	          try {
	            cloned = value.clone();
	          } catch (error) {
	            throwUncloneable(type);
	          } break;
	        case 'File':
	          try {
	            cloned = new File([value], value.name, value);
	          } catch (error) {
	            throwUnpolyfillable(type);
	          } break;
	        case 'CryptoKey':
	        case 'GPUCompilationMessage':
	        case 'GPUCompilationInfo':
	        case 'ImageBitmap':
	        case 'RTCCertificate':
	        case 'WebAssembly.Module':
	          throwUnpolyfillable(type);
	          // break omitted
	        default:
	          throwUncloneable(type);
	      }
	  }

	  mapSet(map, value, cloned);

	  if (deep) switch (type) {
	    case 'Array':
	    case 'Object':
	      keys = objectKeys(value);
	      for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
	        key = keys[i];
	        createProperty(cloned, key, structuredCloneInternal(value[key], map));
	      } break;
	    case 'Map':
	      value.forEach(function (v, k) {
	        mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
	      });
	      break;
	    case 'Set':
	      value.forEach(function (v) {
	        setAdd(cloned, structuredCloneInternal(v, map));
	      });
	      break;
	    case 'Error':
	      createNonEnumerableProperty(cloned, 'message', structuredCloneInternal(value.message, map));
	      if (hasOwnProperty_1(value, 'cause')) {
	        createNonEnumerableProperty(cloned, 'cause', structuredCloneInternal(value.cause, map));
	      }
	      if (name == 'AggregateError') {
	        cloned.errors = structuredCloneInternal(value.errors, map);
	      } // break omitted
	    case 'DOMException':
	      if (errorStackInstallable) {
	        createNonEnumerableProperty(cloned, 'stack', structuredCloneInternal(value.stack, map));
	      }
	  }

	  return cloned;
	};

	var PROPER_TRANSFER = nativeStructuredClone && !fails(function () {
	  var buffer = new ArrayBuffer(8);
	  var clone = nativeStructuredClone(buffer, { transfer: [buffer] });
	  return buffer.byteLength != 0 || clone.byteLength != 8;
	});

	var tryToTransfer = function (rawTransfer, map) {
	  if (!isObject$2(rawTransfer)) throw TypeError$3('Transfer option cannot be converted to a sequence');

	  var transfer = [];

	  iterate(rawTransfer, function (value) {
	    push$3(transfer, anObject(value));
	  });

	  var i = 0;
	  var length = lengthOfArrayLike(transfer);
	  var value, type, C, transferredArray, transferred, canvas, context;

	  if (PROPER_TRANSFER) {
	    transferredArray = nativeStructuredClone(transfer, { transfer: transfer });
	    while (i < length) mapSet(map, transfer[i], transferredArray[i++]);
	  } else while (i < length) {
	    value = transfer[i++];
	    if (mapHas(map, value)) throw new DOMException('Duplicate transferable', DATA_CLONE_ERROR);

	    type = classof(value);

	    switch (type) {
	      case 'ImageBitmap':
	        C = global_1.OffscreenCanvas;
	        if (!isConstructor(C)) throwUnpolyfillable(type, TRANSFERRING);
	        try {
	          canvas = new C(value.width, value.height);
	          context = canvas.getContext('bitmaprenderer');
	          context.transferFromImageBitmap(value);
	          transferred = canvas.transferToImageBitmap();
	        } catch (error) { /* empty */ }
	        break;
	      case 'AudioData':
	      case 'VideoFrame':
	        if (!isCallable(value.clone) || !isCallable(value.close)) throwUnpolyfillable(type, TRANSFERRING);
	        try {
	          transferred = value.clone();
	          value.close();
	        } catch (error) { /* empty */ }
	        break;
	      case 'ArrayBuffer':
	      case 'MessagePort':
	      case 'OffscreenCanvas':
	      case 'ReadableStream':
	      case 'TransformStream':
	      case 'WritableStream':
	        throwUnpolyfillable(type, TRANSFERRING);
	    }

	    if (transferred === undefined) throw new DOMException('This object cannot be transferred: ' + type, DATA_CLONE_ERROR);
	    mapSet(map, value, transferred);
	  }
	};

	_export({ global: true, enumerable: true, sham: !PROPER_TRANSFER, forced: FORCED_REPLACEMENT }, {
	  structuredClone: function structuredClone(value /* , { transfer } */) {
	    var options = validateArgumentsLength(arguments.length, 1) > 1 && arguments[1] != null ? anObject(arguments[1]) : undefined;
	    var transfer = options ? options.transfer : undefined;
	    var map;

	    if (transfer !== undefined) {
	      map = new Map$2();
	      tryToTransfer(transfer, map);
	    }

	    return structuredCloneInternal(value, map);
	  }
	});

	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check
	var Function$1 = global_1.Function;

	var wrap = function (scheduler) {
	  return MSIE ? function (handler, timeout /* , ...arguments */) {
	    var boundArgs = validateArgumentsLength(arguments.length, 1) > 2;
	    var fn = isCallable(handler) ? handler : Function$1(handler);
	    var args = boundArgs ? arraySlice$1(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      functionApply(fn, this, args);
	    } : fn, timeout);
	  } : scheduler;
	};

	// ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
	var schedulersFix = {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap(global_1.setInterval)
	};

	var setInterval = schedulersFix.setInterval;

	// ie9- setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	_export({ global: true, bind: true, forced: global_1.setInterval !== setInterval }, {
	  setInterval: setInterval
	});

	var setTimeout$1 = schedulersFix.setTimeout;

	// ie9- setTimeout additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	_export({ global: true, bind: true, forced: global_1.setTimeout !== setTimeout$1 }, {
	  setTimeout: setTimeout$1
	});

	var ITERATOR$1 = wellKnownSymbol('iterator');

	var nativeUrl = !fails(function () {
	  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
	  var url = new URL('b?a=1&b=2&c=3', 'http://a');
	  var searchParams = url.searchParams;
	  var result = '';
	  url.pathname = 'c%20d';
	  searchParams.forEach(function (value, key) {
	    searchParams['delete']('b');
	    result += key + value;
	  });
	  return (isPure && !url.toJSON)
	    || !searchParams.sort
	    || url.href !== 'http://a/c%20d?a=1&c=3'
	    || searchParams.get('c') !== '3'
	    || String(new URLSearchParams('?a=1')) !== 'a=1'
	    || !searchParams[ITERATOR$1]
	    // throws in Edge
	    || new URL('https://a@b').username !== 'a'
	    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
	    // not punycoded in Edge
	    || new URL('http://ÃâÃÂµÃÂÃâ').host !== 'xn--e1aybc'
	    // not escaped in Chrome 62-
	    || new URL('http://a#ÃÂ±').hash !== '#%D0%B1'
	    // fails in Chrome 66-
	    || result !== 'a1c3'
	    // throws in Safari
	    || new URL('http://x', undefined).host !== 'x';
	});

	// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js



	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'
	var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
	var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
	var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
	var baseMinusTMin = base - tMin;

	var RangeError = global_1.RangeError;
	var exec$1 = functionUncurryThis(regexSeparators.exec);
	var floor$1 = Math.floor;
	var fromCharCode = String.fromCharCode;
	var charCodeAt = functionUncurryThis(''.charCodeAt);
	var join$2 = functionUncurryThis([].join);
	var push$2 = functionUncurryThis([].push);
	var replace$2 = functionUncurryThis(''.replace);
	var split$2 = functionUncurryThis(''.split);
	var toLowerCase$1 = functionUncurryThis(''.toLowerCase);

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 */
	var ucs2decode = function (string) {
	  var output = [];
	  var counter = 0;
	  var length = string.length;
	  while (counter < length) {
	    var value = charCodeAt(string, counter++);
	    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	      // It's a high surrogate, and there is a next character.
	      var extra = charCodeAt(string, counter++);
	      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
	        push$2(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	      } else {
	        // It's an unmatched surrogate; only append this code unit, in case the
	        // next code unit is the high surrogate of a surrogate pair.
	        push$2(output, value);
	        counter--;
	      }
	    } else {
	      push$2(output, value);
	    }
	  }
	  return output;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 */
	var digitToBasic = function (digit) {
	  //  0..25 map to ASCII a..z or A..Z
	  // 26..35 map to ASCII 0..9
	  return digit + 22 + 75 * (digit < 26);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 */
	var adapt = function (delta, numPoints, firstTime) {
	  var k = 0;
	  delta = firstTime ? floor$1(delta / damp) : delta >> 1;
	  delta += floor$1(delta / numPoints);
	  while (delta > baseMinusTMin * tMax >> 1) {
	    delta = floor$1(delta / baseMinusTMin);
	    k += base;
	  }
	  return floor$1(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 */
	var encode$1 = function (input) {
	  var output = [];

	  // Convert the input in UCS-2 to an array of Unicode code points.
	  input = ucs2decode(input);

	  // Cache the length.
	  var inputLength = input.length;

	  // Initialize the state.
	  var n = initialN;
	  var delta = 0;
	  var bias = initialBias;
	  var i, currentValue;

	  // Handle the basic code points.
	  for (i = 0; i < input.length; i++) {
	    currentValue = input[i];
	    if (currentValue < 0x80) {
	      push$2(output, fromCharCode(currentValue));
	    }
	  }

	  var basicLength = output.length; // number of basic code points.
	  var handledCPCount = basicLength; // number of code points that have been handled;

	  // Finish the basic string with a delimiter unless it's empty.
	  if (basicLength) {
	    push$2(output, delimiter);
	  }

	  // Main encoding loop:
	  while (handledCPCount < inputLength) {
	    // All non-basic code points < n have been handled already. Find the next larger one:
	    var m = maxInt;
	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue >= n && currentValue < m) {
	        m = currentValue;
	      }
	    }

	    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
	    var handledCPCountPlusOne = handledCPCount + 1;
	    if (m - n > floor$1((maxInt - delta) / handledCPCountPlusOne)) {
	      throw RangeError(OVERFLOW_ERROR);
	    }

	    delta += (m - n) * handledCPCountPlusOne;
	    n = m;

	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue < n && ++delta > maxInt) {
	        throw RangeError(OVERFLOW_ERROR);
	      }
	      if (currentValue == n) {
	        // Represent delta as a generalized variable-length integer.
	        var q = delta;
	        var k = base;
	        while (true) {
	          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	          if (q < t) break;
	          var qMinusT = q - t;
	          var baseMinusT = base - t;
	          push$2(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
	          q = floor$1(qMinusT / baseMinusT);
	          k += base;
	        }

	        push$2(output, fromCharCode(digitToBasic(q)));
	        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	        delta = 0;
	        handledCPCount++;
	      }
	    }

	    delta++;
	    n++;
	  }
	  return join$2(output, '');
	};

	var stringPunycodeToAscii = function (input) {
	  var encoded = [];
	  var labels = split$2(replace$2(toLowerCase$1(input), regexSeparators, '\u002E'), '.');
	  var i, label;
	  for (i = 0; i < labels.length; i++) {
	    label = labels[i];
	    push$2(encoded, exec$1(regexNonASCII, label) ? 'xn--' + encode$1(label) : label);
	  }
	  return join$2(encoded, '.');
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`




























	var ITERATOR = wellKnownSymbol('iterator');
	var URL_SEARCH_PARAMS = 'URLSearchParams';
	var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
	var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);

	var n$Fetch = getBuiltIn('fetch');
	var N$Request = getBuiltIn('Request');
	var Headers = getBuiltIn('Headers');
	var RequestPrototype = N$Request && N$Request.prototype;
	var HeadersPrototype = Headers && Headers.prototype;
	var RegExp$1 = global_1.RegExp;
	var TypeError$2 = global_1.TypeError;
	var decodeURIComponent$1 = global_1.decodeURIComponent;
	var encodeURIComponent$1 = global_1.encodeURIComponent;
	var charAt$1 = functionUncurryThis(''.charAt);
	var join$1 = functionUncurryThis([].join);
	var push$1 = functionUncurryThis([].push);
	var replace$1 = functionUncurryThis(''.replace);
	var shift$1 = functionUncurryThis([].shift);
	var splice$1 = functionUncurryThis([].splice);
	var split$1 = functionUncurryThis(''.split);
	var stringSlice$1 = functionUncurryThis(''.slice);

	var plus = /\+/g;
	var sequences = Array(4);

	var percentSequence = function (bytes) {
	  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp$1('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
	};

	var percentDecode = function (sequence) {
	  try {
	    return decodeURIComponent$1(sequence);
	  } catch (error) {
	    return sequence;
	  }
	};

	var deserialize = function (it) {
	  var result = replace$1(it, plus, ' ');
	  var bytes = 4;
	  try {
	    return decodeURIComponent$1(result);
	  } catch (error) {
	    while (bytes) {
	      result = replace$1(result, percentSequence(bytes--), percentDecode);
	    }
	    return result;
	  }
	};

	var find = /[!'()~]|%20/g;

	var replacements = {
	  '!': '%21',
	  "'": '%27',
	  '(': '%28',
	  ')': '%29',
	  '~': '%7E',
	  '%20': '+'
	};

	var replacer = function (match) {
	  return replacements[match];
	};

	var serialize = function (it) {
	  return replace$1(encodeURIComponent$1(it), find, replacer);
	};

	var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
	  setInternalState$1(this, {
	    type: URL_SEARCH_PARAMS_ITERATOR,
	    iterator: getIterator(getInternalParamsState(params).entries),
	    kind: kind
	  });
	}, 'Iterator', function next() {
	  var state = getInternalIteratorState(this);
	  var kind = state.kind;
	  var step = state.iterator.next();
	  var entry = step.value;
	  if (!step.done) {
	    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
	  } return step;
	}, true);

	var URLSearchParamsState = function (init) {
	  this.entries = [];
	  this.url = null;

	  if (init !== undefined) {
	    if (isObject$2(init)) this.parseObject(init);
	    else this.parseQuery(typeof init == 'string' ? charAt$1(init, 0) === '?' ? stringSlice$1(init, 1) : init : toString_1$1(init));
	  }
	};

	URLSearchParamsState.prototype = {
	  type: URL_SEARCH_PARAMS,
	  bindURL: function (url) {
	    this.url = url;
	    this.update();
	  },
	  parseObject: function (object) {
	    var iteratorMethod = getIteratorMethod(object);
	    var iterator, next, step, entryIterator, entryNext, first, second;

	    if (iteratorMethod) {
	      iterator = getIterator(object, iteratorMethod);
	      next = iterator.next;
	      while (!(step = functionCall(next, iterator)).done) {
	        entryIterator = getIterator(anObject(step.value));
	        entryNext = entryIterator.next;
	        if (
	          (first = functionCall(entryNext, entryIterator)).done ||
	          (second = functionCall(entryNext, entryIterator)).done ||
	          !functionCall(entryNext, entryIterator).done
	        ) throw TypeError$2('Expected sequence with length 2');
	        push$1(this.entries, { key: toString_1$1(first.value), value: toString_1$1(second.value) });
	      }
	    } else for (var key in object) if (hasOwnProperty_1(object, key)) {
	      push$1(this.entries, { key: key, value: toString_1$1(object[key]) });
	    }
	  },
	  parseQuery: function (query) {
	    if (query) {
	      var attributes = split$1(query, '&');
	      var index = 0;
	      var attribute, entry;
	      while (index < attributes.length) {
	        attribute = attributes[index++];
	        if (attribute.length) {
	          entry = split$1(attribute, '=');
	          push$1(this.entries, {
	            key: deserialize(shift$1(entry)),
	            value: deserialize(join$1(entry, '='))
	          });
	        }
	      }
	    }
	  },
	  serialize: function () {
	    var entries = this.entries;
	    var result = [];
	    var index = 0;
	    var entry;
	    while (index < entries.length) {
	      entry = entries[index++];
	      push$1(result, serialize(entry.key) + '=' + serialize(entry.value));
	    } return join$1(result, '&');
	  },
	  update: function () {
	    this.entries.length = 0;
	    this.parseQuery(this.url.query);
	  },
	  updateURL: function () {
	    if (this.url) this.url.update();
	  }
	};

	// `URLSearchParams` constructor
	// https://url.spec.whatwg.org/#interface-urlsearchparams
	var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
	  anInstance(this, URLSearchParamsPrototype);
	  var init = arguments.length > 0 ? arguments[0] : undefined;
	  setInternalState$1(this, new URLSearchParamsState(init));
	};

	var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

	redefineAll(URLSearchParamsPrototype, {
	  // `URLSearchParams.prototype.append` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
	  append: function append(name, value) {
	    validateArgumentsLength(arguments.length, 2);
	    var state = getInternalParamsState(this);
	    push$1(state.entries, { key: toString_1$1(name), value: toString_1$1(value) });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.delete` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
	  'delete': function (name) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var key = toString_1$1(name);
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index].key === key) splice$1(entries, index, 1);
	      else index++;
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.get` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
	  get: function get(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = toString_1$1(name);
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) return entries[index].value;
	    }
	    return null;
	  },
	  // `URLSearchParams.prototype.getAll` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
	  getAll: function getAll(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = toString_1$1(name);
	    var result = [];
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) push$1(result, entries[index].value);
	    }
	    return result;
	  },
	  // `URLSearchParams.prototype.has` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
	  has: function has(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = toString_1$1(name);
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index++].key === key) return true;
	    }
	    return false;
	  },
	  // `URLSearchParams.prototype.set` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
	  set: function set(name, value) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var found = false;
	    var key = toString_1$1(name);
	    var val = toString_1$1(value);
	    var index = 0;
	    var entry;
	    for (; index < entries.length; index++) {
	      entry = entries[index];
	      if (entry.key === key) {
	        if (found) splice$1(entries, index--, 1);
	        else {
	          found = true;
	          entry.value = val;
	        }
	      }
	    }
	    if (!found) push$1(entries, { key: key, value: val });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.sort` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
	  sort: function sort() {
	    var state = getInternalParamsState(this);
	    arraySort(state.entries, function (a, b) {
	      return a.key > b.key ? 1 : -1;
	    });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.forEach` method
	  forEach: function forEach(callback /* , thisArg */) {
	    var entries = getInternalParamsState(this).entries;
	    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined);
	    var index = 0;
	    var entry;
	    while (index < entries.length) {
	      entry = entries[index++];
	      boundFunction(entry.value, entry.key, this);
	    }
	  },
	  // `URLSearchParams.prototype.keys` method
	  keys: function keys() {
	    return new URLSearchParamsIterator(this, 'keys');
	  },
	  // `URLSearchParams.prototype.values` method
	  values: function values() {
	    return new URLSearchParamsIterator(this, 'values');
	  },
	  // `URLSearchParams.prototype.entries` method
	  entries: function entries() {
	    return new URLSearchParamsIterator(this, 'entries');
	  }
	}, { enumerable: true });

	// `URLSearchParams.prototype[@@iterator]` method
	redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

	// `URLSearchParams.prototype.toString` method
	// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
	redefine(URLSearchParamsPrototype, 'toString', function toString() {
	  return getInternalParamsState(this).serialize();
	}, { enumerable: true });

	setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

	_export({ global: true, forced: !nativeUrl }, {
	  URLSearchParams: URLSearchParamsConstructor
	});

	// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
	if (!nativeUrl && isCallable(Headers)) {
	  var headersHas = functionUncurryThis(HeadersPrototype.has);
	  var headersSet = functionUncurryThis(HeadersPrototype.set);

	  var wrapRequestOptions = function (init) {
	    if (isObject$2(init)) {
	      var body = init.body;
	      var headers;
	      if (classof(body) === URL_SEARCH_PARAMS) {
	        headers = init.headers ? new Headers(init.headers) : new Headers();
	        if (!headersHas(headers, 'content-type')) {
	          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	        }
	        return objectCreate(init, {
	          body: createPropertyDescriptor(0, toString_1$1(body)),
	          headers: createPropertyDescriptor(0, headers)
	        });
	      }
	    } return init;
	  };

	  if (isCallable(n$Fetch)) {
	    _export({ global: true, enumerable: true, forced: true }, {
	      fetch: function fetch(input /* , init */) {
	        return n$Fetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
	      }
	    });
	  }

	  if (isCallable(N$Request)) {
	    var RequestConstructor = function Request(input /* , init */) {
	      anInstance(this, RequestPrototype);
	      return new N$Request(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
	    };

	    RequestPrototype.constructor = RequestConstructor;
	    RequestConstructor.prototype = RequestPrototype;

	    _export({ global: true, forced: true }, {
	      Request: RequestConstructor
	    });
	  }
	}

	var web_urlSearchParams_constructor = {
	  URLSearchParams: URLSearchParamsConstructor,
	  getState: getInternalParamsState
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`







	var defineProperties = objectDefineProperties.f;






	var codeAt = stringMultibyte.codeAt;







	var setInternalState = internalState.set;
	var getInternalURLState = internalState.getterFor('URL');
	var URLSearchParams$1 = web_urlSearchParams_constructor.URLSearchParams;
	var getInternalSearchParamsState = web_urlSearchParams_constructor.getState;

	var NativeURL = global_1.URL;
	var TypeError$1 = global_1.TypeError;
	var parseInt$1 = global_1.parseInt;
	var floor = Math.floor;
	var pow = Math.pow;
	var charAt = functionUncurryThis(''.charAt);
	var exec = functionUncurryThis(/./.exec);
	var join = functionUncurryThis([].join);
	var numberToString = functionUncurryThis(1.0.toString);
	var pop = functionUncurryThis([].pop);
	var push = functionUncurryThis([].push);
	var replace = functionUncurryThis(''.replace);
	var shift = functionUncurryThis([].shift);
	var split = functionUncurryThis(''.split);
	var stringSlice = functionUncurryThis(''.slice);
	var toLowerCase = functionUncurryThis(''.toLowerCase);
	var unshift = functionUncurryThis([].unshift);

	var INVALID_AUTHORITY = 'Invalid authority';
	var INVALID_SCHEME = 'Invalid scheme';
	var INVALID_HOST = 'Invalid host';
	var INVALID_PORT = 'Invalid port';

	var ALPHA = /[a-z]/i;
	// eslint-disable-next-line regexp/no-obscure-range -- safe
	var ALPHANUMERIC = /[\d+-.a-z]/i;
	var DIGIT = /\d/;
	var HEX_START = /^0x/i;
	var OCT = /^[0-7]+$/;
	var DEC = /^\d+$/;
	var HEX = /^[\da-f]+$/i;
	/* eslint-disable regexp/no-control-character -- safe */
	var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
	var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
	var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
	var TAB_AND_NEW_LINE = /[\t\n\r]/g;
	/* eslint-enable regexp/no-control-character -- safe */
	var EOF;

	// https://url.spec.whatwg.org/#ipv4-number-parser
	var parseIPv4 = function (input) {
	  var parts = split(input, '.');
	  var partsLength, numbers, index, part, radix, number, ipv4;
	  if (parts.length && parts[parts.length - 1] == '') {
	    parts.length--;
	  }
	  partsLength = parts.length;
	  if (partsLength > 4) return input;
	  numbers = [];
	  for (index = 0; index < partsLength; index++) {
	    part = parts[index];
	    if (part == '') return input;
	    radix = 10;
	    if (part.length > 1 && charAt(part, 0) == '0') {
	      radix = exec(HEX_START, part) ? 16 : 8;
	      part = stringSlice(part, radix == 8 ? 1 : 2);
	    }
	    if (part === '') {
	      number = 0;
	    } else {
	      if (!exec(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;
	      number = parseInt$1(part, radix);
	    }
	    push(numbers, number);
	  }
	  for (index = 0; index < partsLength; index++) {
	    number = numbers[index];
	    if (index == partsLength - 1) {
	      if (number >= pow(256, 5 - partsLength)) return null;
	    } else if (number > 255) return null;
	  }
	  ipv4 = pop(numbers);
	  for (index = 0; index < numbers.length; index++) {
	    ipv4 += numbers[index] * pow(256, 3 - index);
	  }
	  return ipv4;
	};

	// https://url.spec.whatwg.org/#concept-ipv6-parser
	// eslint-disable-next-line max-statements -- TODO
	var parseIPv6 = function (input) {
	  var address = [0, 0, 0, 0, 0, 0, 0, 0];
	  var pieceIndex = 0;
	  var compress = null;
	  var pointer = 0;
	  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

	  var chr = function () {
	    return charAt(input, pointer);
	  };

	  if (chr() == ':') {
	    if (charAt(input, 1) != ':') return;
	    pointer += 2;
	    pieceIndex++;
	    compress = pieceIndex;
	  }
	  while (chr()) {
	    if (pieceIndex == 8) return;
	    if (chr() == ':') {
	      if (compress !== null) return;
	      pointer++;
	      pieceIndex++;
	      compress = pieceIndex;
	      continue;
	    }
	    value = length = 0;
	    while (length < 4 && exec(HEX, chr())) {
	      value = value * 16 + parseInt$1(chr(), 16);
	      pointer++;
	      length++;
	    }
	    if (chr() == '.') {
	      if (length == 0) return;
	      pointer -= length;
	      if (pieceIndex > 6) return;
	      numbersSeen = 0;
	      while (chr()) {
	        ipv4Piece = null;
	        if (numbersSeen > 0) {
	          if (chr() == '.' && numbersSeen < 4) pointer++;
	          else return;
	        }
	        if (!exec(DIGIT, chr())) return;
	        while (exec(DIGIT, chr())) {
	          number = parseInt$1(chr(), 10);
	          if (ipv4Piece === null) ipv4Piece = number;
	          else if (ipv4Piece == 0) return;
	          else ipv4Piece = ipv4Piece * 10 + number;
	          if (ipv4Piece > 255) return;
	          pointer++;
	        }
	        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
	        numbersSeen++;
	        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
	      }
	      if (numbersSeen != 4) return;
	      break;
	    } else if (chr() == ':') {
	      pointer++;
	      if (!chr()) return;
	    } else if (chr()) return;
	    address[pieceIndex++] = value;
	  }
	  if (compress !== null) {
	    swaps = pieceIndex - compress;
	    pieceIndex = 7;
	    while (pieceIndex != 0 && swaps > 0) {
	      swap = address[pieceIndex];
	      address[pieceIndex--] = address[compress + swaps - 1];
	      address[compress + --swaps] = swap;
	    }
	  } else if (pieceIndex != 8) return;
	  return address;
	};

	var findLongestZeroSequence = function (ipv6) {
	  var maxIndex = null;
	  var maxLength = 1;
	  var currStart = null;
	  var currLength = 0;
	  var index = 0;
	  for (; index < 8; index++) {
	    if (ipv6[index] !== 0) {
	      if (currLength > maxLength) {
	        maxIndex = currStart;
	        maxLength = currLength;
	      }
	      currStart = null;
	      currLength = 0;
	    } else {
	      if (currStart === null) currStart = index;
	      ++currLength;
	    }
	  }
	  if (currLength > maxLength) {
	    maxIndex = currStart;
	    maxLength = currLength;
	  }
	  return maxIndex;
	};

	// https://url.spec.whatwg.org/#host-serializing
	var serializeHost = function (host) {
	  var result, index, compress, ignore0;
	  // ipv4
	  if (typeof host == 'number') {
	    result = [];
	    for (index = 0; index < 4; index++) {
	      unshift(result, host % 256);
	      host = floor(host / 256);
	    } return join(result, '.');
	  // ipv6
	  } else if (typeof host == 'object') {
	    result = '';
	    compress = findLongestZeroSequence(host);
	    for (index = 0; index < 8; index++) {
	      if (ignore0 && host[index] === 0) continue;
	      if (ignore0) ignore0 = false;
	      if (compress === index) {
	        result += index ? ':' : '::';
	        ignore0 = true;
	      } else {
	        result += numberToString(host[index], 16);
	        if (index < 7) result += ':';
	      }
	    }
	    return '[' + result + ']';
	  } return host;
	};

	var C0ControlPercentEncodeSet = {};
	var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
	  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
	});
	var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
	  '#': 1, '?': 1, '{': 1, '}': 1
	});
	var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
	  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
	});

	var percentEncode = function (chr, set) {
	  var code = codeAt(chr, 0);
	  return code > 0x20 && code < 0x7F && !hasOwnProperty_1(set, chr) ? chr : encodeURIComponent(chr);
	};

	// https://url.spec.whatwg.org/#special-scheme
	var specialSchemes = {
	  ftp: 21,
	  file: null,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	};

	// https://url.spec.whatwg.org/#windows-drive-letter
	var isWindowsDriveLetter = function (string, normalized) {
	  var second;
	  return string.length == 2 && exec(ALPHA, charAt(string, 0))
	    && ((second = charAt(string, 1)) == ':' || (!normalized && second == '|'));
	};

	// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
	var startsWithWindowsDriveLetter = function (string) {
	  var third;
	  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (
	    string.length == 2 ||
	    ((third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#')
	  );
	};

	// https://url.spec.whatwg.org/#single-dot-path-segment
	var isSingleDot = function (segment) {
	  return segment === '.' || toLowerCase(segment) === '%2e';
	};

	// https://url.spec.whatwg.org/#double-dot-path-segment
	var isDoubleDot = function (segment) {
	  segment = toLowerCase(segment);
	  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
	};

	// States:
	var SCHEME_START = {};
	var SCHEME = {};
	var NO_SCHEME = {};
	var SPECIAL_RELATIVE_OR_AUTHORITY = {};
	var PATH_OR_AUTHORITY = {};
	var RELATIVE = {};
	var RELATIVE_SLASH = {};
	var SPECIAL_AUTHORITY_SLASHES = {};
	var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
	var AUTHORITY = {};
	var HOST = {};
	var HOSTNAME = {};
	var PORT = {};
	var FILE = {};
	var FILE_SLASH = {};
	var FILE_HOST = {};
	var PATH_START = {};
	var PATH = {};
	var CANNOT_BE_A_BASE_URL_PATH = {};
	var QUERY = {};
	var FRAGMENT = {};

	var URLState = function (url, isBase, base) {
	  var urlString = toString_1$1(url);
	  var baseState, failure, searchParams;
	  if (isBase) {
	    failure = this.parse(urlString);
	    if (failure) throw TypeError$1(failure);
	    this.searchParams = null;
	  } else {
	    if (base !== undefined) baseState = new URLState(base, true);
	    failure = this.parse(urlString, null, baseState);
	    if (failure) throw TypeError$1(failure);
	    searchParams = getInternalSearchParamsState(new URLSearchParams$1());
	    searchParams.bindURL(this);
	    this.searchParams = searchParams;
	  }
	};

	URLState.prototype = {
	  type: 'URL',
	  // https://url.spec.whatwg.org/#url-parsing
	  // eslint-disable-next-line max-statements -- TODO
	  parse: function (input, stateOverride, base) {
	    var url = this;
	    var state = stateOverride || SCHEME_START;
	    var pointer = 0;
	    var buffer = '';
	    var seenAt = false;
	    var seenBracket = false;
	    var seenPasswordToken = false;
	    var codePoints, chr, bufferCodePoints, failure;

	    input = toString_1$1(input);

	    if (!stateOverride) {
	      url.scheme = '';
	      url.username = '';
	      url.password = '';
	      url.host = null;
	      url.port = null;
	      url.path = [];
	      url.query = null;
	      url.fragment = null;
	      url.cannotBeABaseURL = false;
	      input = replace(input, LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
	    }

	    input = replace(input, TAB_AND_NEW_LINE, '');

	    codePoints = arrayFrom(input);

	    while (pointer <= codePoints.length) {
	      chr = codePoints[pointer];
	      switch (state) {
	        case SCHEME_START:
	          if (chr && exec(ALPHA, chr)) {
	            buffer += toLowerCase(chr);
	            state = SCHEME;
	          } else if (!stateOverride) {
	            state = NO_SCHEME;
	            continue;
	          } else return INVALID_SCHEME;
	          break;

	        case SCHEME:
	          if (chr && (exec(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) {
	            buffer += toLowerCase(chr);
	          } else if (chr == ':') {
	            if (stateOverride && (
	              (url.isSpecial() != hasOwnProperty_1(specialSchemes, buffer)) ||
	              (buffer == 'file' && (url.includesCredentials() || url.port !== null)) ||
	              (url.scheme == 'file' && !url.host)
	            )) return;
	            url.scheme = buffer;
	            if (stateOverride) {
	              if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;
	              return;
	            }
	            buffer = '';
	            if (url.scheme == 'file') {
	              state = FILE;
	            } else if (url.isSpecial() && base && base.scheme == url.scheme) {
	              state = SPECIAL_RELATIVE_OR_AUTHORITY;
	            } else if (url.isSpecial()) {
	              state = SPECIAL_AUTHORITY_SLASHES;
	            } else if (codePoints[pointer + 1] == '/') {
	              state = PATH_OR_AUTHORITY;
	              pointer++;
	            } else {
	              url.cannotBeABaseURL = true;
	              push(url.path, '');
	              state = CANNOT_BE_A_BASE_URL_PATH;
	            }
	          } else if (!stateOverride) {
	            buffer = '';
	            state = NO_SCHEME;
	            pointer = 0;
	            continue;
	          } else return INVALID_SCHEME;
	          break;

	        case NO_SCHEME:
	          if (!base || (base.cannotBeABaseURL && chr != '#')) return INVALID_SCHEME;
	          if (base.cannotBeABaseURL && chr == '#') {
	            url.scheme = base.scheme;
	            url.path = arraySliceSimple(base.path);
	            url.query = base.query;
	            url.fragment = '';
	            url.cannotBeABaseURL = true;
	            state = FRAGMENT;
	            break;
	          }
	          state = base.scheme == 'file' ? FILE : RELATIVE;
	          continue;

	        case SPECIAL_RELATIVE_OR_AUTHORITY:
	          if (chr == '/' && codePoints[pointer + 1] == '/') {
	            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	            pointer++;
	          } else {
	            state = RELATIVE;
	            continue;
	          } break;

	        case PATH_OR_AUTHORITY:
	          if (chr == '/') {
	            state = AUTHORITY;
	            break;
	          } else {
	            state = PATH;
	            continue;
	          }

	        case RELATIVE:
	          url.scheme = base.scheme;
	          if (chr == EOF) {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.query = base.query;
	          } else if (chr == '/' || (chr == '\\' && url.isSpecial())) {
	            state = RELATIVE_SLASH;
	          } else if (chr == '?') {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.query = '';
	            state = QUERY;
	          } else if (chr == '#') {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.query = base.query;
	            url.fragment = '';
	            state = FRAGMENT;
	          } else {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            url.path = arraySliceSimple(base.path);
	            url.path.length--;
	            state = PATH;
	            continue;
	          } break;

	        case RELATIVE_SLASH:
	          if (url.isSpecial() && (chr == '/' || chr == '\\')) {
	            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          } else if (chr == '/') {
	            state = AUTHORITY;
	          } else {
	            url.username = base.username;
	            url.password = base.password;
	            url.host = base.host;
	            url.port = base.port;
	            state = PATH;
	            continue;
	          } break;

	        case SPECIAL_AUTHORITY_SLASHES:
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          if (chr != '/' || charAt(buffer, pointer + 1) != '/') continue;
	          pointer++;
	          break;

	        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
	          if (chr != '/' && chr != '\\') {
	            state = AUTHORITY;
	            continue;
	          } break;

	        case AUTHORITY:
	          if (chr == '@') {
	            if (seenAt) buffer = '%40' + buffer;
	            seenAt = true;
	            bufferCodePoints = arrayFrom(buffer);
	            for (var i = 0; i < bufferCodePoints.length; i++) {
	              var codePoint = bufferCodePoints[i];
	              if (codePoint == ':' && !seenPasswordToken) {
	                seenPasswordToken = true;
	                continue;
	              }
	              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
	              if (seenPasswordToken) url.password += encodedCodePoints;
	              else url.username += encodedCodePoints;
	            }
	            buffer = '';
	          } else if (
	            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
	            (chr == '\\' && url.isSpecial())
	          ) {
	            if (seenAt && buffer == '') return INVALID_AUTHORITY;
	            pointer -= arrayFrom(buffer).length + 1;
	            buffer = '';
	            state = HOST;
	          } else buffer += chr;
	          break;

	        case HOST:
	        case HOSTNAME:
	          if (stateOverride && url.scheme == 'file') {
	            state = FILE_HOST;
	            continue;
	          } else if (chr == ':' && !seenBracket) {
	            if (buffer == '') return INVALID_HOST;
	            failure = url.parseHost(buffer);
	            if (failure) return failure;
	            buffer = '';
	            state = PORT;
	            if (stateOverride == HOSTNAME) return;
	          } else if (
	            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
	            (chr == '\\' && url.isSpecial())
	          ) {
	            if (url.isSpecial() && buffer == '') return INVALID_HOST;
	            if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;
	            failure = url.parseHost(buffer);
	            if (failure) return failure;
	            buffer = '';
	            state = PATH_START;
	            if (stateOverride) return;
	            continue;
	          } else {
	            if (chr == '[') seenBracket = true;
	            else if (chr == ']') seenBracket = false;
	            buffer += chr;
	          } break;

	        case PORT:
	          if (exec(DIGIT, chr)) {
	            buffer += chr;
	          } else if (
	            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
	            (chr == '\\' && url.isSpecial()) ||
	            stateOverride
	          ) {
	            if (buffer != '') {
	              var port = parseInt$1(buffer, 10);
	              if (port > 0xFFFF) return INVALID_PORT;
	              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;
	              buffer = '';
	            }
	            if (stateOverride) return;
	            state = PATH_START;
	            continue;
	          } else return INVALID_PORT;
	          break;

	        case FILE:
	          url.scheme = 'file';
	          if (chr == '/' || chr == '\\') state = FILE_SLASH;
	          else if (base && base.scheme == 'file') {
	            if (chr == EOF) {
	              url.host = base.host;
	              url.path = arraySliceSimple(base.path);
	              url.query = base.query;
	            } else if (chr == '?') {
	              url.host = base.host;
	              url.path = arraySliceSimple(base.path);
	              url.query = '';
	              state = QUERY;
	            } else if (chr == '#') {
	              url.host = base.host;
	              url.path = arraySliceSimple(base.path);
	              url.query = base.query;
	              url.fragment = '';
	              state = FRAGMENT;
	            } else {
	              if (!startsWithWindowsDriveLetter(join(arraySliceSimple(codePoints, pointer), ''))) {
	                url.host = base.host;
	                url.path = arraySliceSimple(base.path);
	                url.shortenPath();
	              }
	              state = PATH;
	              continue;
	            }
	          } else {
	            state = PATH;
	            continue;
	          } break;

	        case FILE_SLASH:
	          if (chr == '/' || chr == '\\') {
	            state = FILE_HOST;
	            break;
	          }
	          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join(arraySliceSimple(codePoints, pointer), ''))) {
	            if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
	            else url.host = base.host;
	          }
	          state = PATH;
	          continue;

	        case FILE_HOST:
	          if (chr == EOF || chr == '/' || chr == '\\' || chr == '?' || chr == '#') {
	            if (!stateOverride && isWindowsDriveLetter(buffer)) {
	              state = PATH;
	            } else if (buffer == '') {
	              url.host = '';
	              if (stateOverride) return;
	              state = PATH_START;
	            } else {
	              failure = url.parseHost(buffer);
	              if (failure) return failure;
	              if (url.host == 'localhost') url.host = '';
	              if (stateOverride) return;
	              buffer = '';
	              state = PATH_START;
	            } continue;
	          } else buffer += chr;
	          break;

	        case PATH_START:
	          if (url.isSpecial()) {
	            state = PATH;
	            if (chr != '/' && chr != '\\') continue;
	          } else if (!stateOverride && chr == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (!stateOverride && chr == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          } else if (chr != EOF) {
	            state = PATH;
	            if (chr != '/') continue;
	          } break;

	        case PATH:
	          if (
	            chr == EOF || chr == '/' ||
	            (chr == '\\' && url.isSpecial()) ||
	            (!stateOverride && (chr == '?' || chr == '#'))
	          ) {
	            if (isDoubleDot(buffer)) {
	              url.shortenPath();
	              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
	                push(url.path, '');
	              }
	            } else if (isSingleDot(buffer)) {
	              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
	                push(url.path, '');
	              }
	            } else {
	              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
	                if (url.host) url.host = '';
	                buffer = charAt(buffer, 0) + ':'; // normalize windows drive letter
	              }
	              push(url.path, buffer);
	            }
	            buffer = '';
	            if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) {
	              while (url.path.length > 1 && url.path[0] === '') {
	                shift(url.path);
	              }
	            }
	            if (chr == '?') {
	              url.query = '';
	              state = QUERY;
	            } else if (chr == '#') {
	              url.fragment = '';
	              state = FRAGMENT;
	            }
	          } else {
	            buffer += percentEncode(chr, pathPercentEncodeSet);
	          } break;

	        case CANNOT_BE_A_BASE_URL_PATH:
	          if (chr == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (chr == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          } else if (chr != EOF) {
	            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
	          } break;

	        case QUERY:
	          if (!stateOverride && chr == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          } else if (chr != EOF) {
	            if (chr == "'" && url.isSpecial()) url.query += '%27';
	            else if (chr == '#') url.query += '%23';
	            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
	          } break;

	        case FRAGMENT:
	          if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
	          break;
	      }

	      pointer++;
	    }
	  },
	  // https://url.spec.whatwg.org/#host-parsing
	  parseHost: function (input) {
	    var result, codePoints, index;
	    if (charAt(input, 0) == '[') {
	      if (charAt(input, input.length - 1) != ']') return INVALID_HOST;
	      result = parseIPv6(stringSlice(input, 1, -1));
	      if (!result) return INVALID_HOST;
	      this.host = result;
	    // opaque host
	    } else if (!this.isSpecial()) {
	      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
	      result = '';
	      codePoints = arrayFrom(input);
	      for (index = 0; index < codePoints.length; index++) {
	        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
	      }
	      this.host = result;
	    } else {
	      input = stringPunycodeToAscii(input);
	      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
	      result = parseIPv4(input);
	      if (result === null) return INVALID_HOST;
	      this.host = result;
	    }
	  },
	  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
	  cannotHaveUsernamePasswordPort: function () {
	    return !this.host || this.cannotBeABaseURL || this.scheme == 'file';
	  },
	  // https://url.spec.whatwg.org/#include-credentials
	  includesCredentials: function () {
	    return this.username != '' || this.password != '';
	  },
	  // https://url.spec.whatwg.org/#is-special
	  isSpecial: function () {
	    return hasOwnProperty_1(specialSchemes, this.scheme);
	  },
	  // https://url.spec.whatwg.org/#shorten-a-urls-path
	  shortenPath: function () {
	    var path = this.path;
	    var pathSize = path.length;
	    if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
	      path.length--;
	    }
	  },
	  // https://url.spec.whatwg.org/#concept-url-serializer
	  serialize: function () {
	    var url = this;
	    var scheme = url.scheme;
	    var username = url.username;
	    var password = url.password;
	    var host = url.host;
	    var port = url.port;
	    var path = url.path;
	    var query = url.query;
	    var fragment = url.fragment;
	    var output = scheme + ':';
	    if (host !== null) {
	      output += '//';
	      if (url.includesCredentials()) {
	        output += username + (password ? ':' + password : '') + '@';
	      }
	      output += serializeHost(host);
	      if (port !== null) output += ':' + port;
	    } else if (scheme == 'file') output += '//';
	    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
	    if (query !== null) output += '?' + query;
	    if (fragment !== null) output += '#' + fragment;
	    return output;
	  },
	  // https://url.spec.whatwg.org/#dom-url-href
	  setHref: function (href) {
	    var failure = this.parse(href);
	    if (failure) throw TypeError$1(failure);
	    this.searchParams.update();
	  },
	  // https://url.spec.whatwg.org/#dom-url-origin
	  getOrigin: function () {
	    var scheme = this.scheme;
	    var port = this.port;
	    if (scheme == 'blob') try {
	      return new URLConstructor(scheme.path[0]).origin;
	    } catch (error) {
	      return 'null';
	    }
	    if (scheme == 'file' || !this.isSpecial()) return 'null';
	    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
	  },
	  // https://url.spec.whatwg.org/#dom-url-protocol
	  getProtocol: function () {
	    return this.scheme + ':';
	  },
	  setProtocol: function (protocol) {
	    this.parse(toString_1$1(protocol) + ':', SCHEME_START);
	  },
	  // https://url.spec.whatwg.org/#dom-url-username
	  getUsername: function () {
	    return this.username;
	  },
	  setUsername: function (username) {
	    var codePoints = arrayFrom(toString_1$1(username));
	    if (this.cannotHaveUsernamePasswordPort()) return;
	    this.username = '';
	    for (var i = 0; i < codePoints.length; i++) {
	      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	    }
	  },
	  // https://url.spec.whatwg.org/#dom-url-password
	  getPassword: function () {
	    return this.password;
	  },
	  setPassword: function (password) {
	    var codePoints = arrayFrom(toString_1$1(password));
	    if (this.cannotHaveUsernamePasswordPort()) return;
	    this.password = '';
	    for (var i = 0; i < codePoints.length; i++) {
	      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	    }
	  },
	  // https://url.spec.whatwg.org/#dom-url-host
	  getHost: function () {
	    var host = this.host;
	    var port = this.port;
	    return host === null ? ''
	      : port === null ? serializeHost(host)
	      : serializeHost(host) + ':' + port;
	  },
	  setHost: function (host) {
	    if (this.cannotBeABaseURL) return;
	    this.parse(host, HOST);
	  },
	  // https://url.spec.whatwg.org/#dom-url-hostname
	  getHostname: function () {
	    var host = this.host;
	    return host === null ? '' : serializeHost(host);
	  },
	  setHostname: function (hostname) {
	    if (this.cannotBeABaseURL) return;
	    this.parse(hostname, HOSTNAME);
	  },
	  // https://url.spec.whatwg.org/#dom-url-port
	  getPort: function () {
	    var port = this.port;
	    return port === null ? '' : toString_1$1(port);
	  },
	  setPort: function (port) {
	    if (this.cannotHaveUsernamePasswordPort()) return;
	    port = toString_1$1(port);
	    if (port == '') this.port = null;
	    else this.parse(port, PORT);
	  },
	  // https://url.spec.whatwg.org/#dom-url-pathname
	  getPathname: function () {
	    var path = this.path;
	    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
	  },
	  setPathname: function (pathname) {
	    if (this.cannotBeABaseURL) return;
	    this.path = [];
	    this.parse(pathname, PATH_START);
	  },
	  // https://url.spec.whatwg.org/#dom-url-search
	  getSearch: function () {
	    var query = this.query;
	    return query ? '?' + query : '';
	  },
	  setSearch: function (search) {
	    search = toString_1$1(search);
	    if (search == '') {
	      this.query = null;
	    } else {
	      if ('?' == charAt(search, 0)) search = stringSlice(search, 1);
	      this.query = '';
	      this.parse(search, QUERY);
	    }
	    this.searchParams.update();
	  },
	  // https://url.spec.whatwg.org/#dom-url-searchparams
	  getSearchParams: function () {
	    return this.searchParams.facade;
	  },
	  // https://url.spec.whatwg.org/#dom-url-hash
	  getHash: function () {
	    var fragment = this.fragment;
	    return fragment ? '#' + fragment : '';
	  },
	  setHash: function (hash) {
	    hash = toString_1$1(hash);
	    if (hash == '') {
	      this.fragment = null;
	      return;
	    }
	    if ('#' == charAt(hash, 0)) hash = stringSlice(hash, 1);
	    this.fragment = '';
	    this.parse(hash, FRAGMENT);
	  },
	  update: function () {
	    this.query = this.searchParams.serialize() || null;
	  }
	};

	// `URL` constructor
	// https://url.spec.whatwg.org/#url-class
	var URLConstructor = function URL(url /* , base */) {
	  var that = anInstance(this, URLPrototype);
	  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;
	  var state = setInternalState(that, new URLState(url, false, base));
	  if (!descriptors) {
	    that.href = state.serialize();
	    that.origin = state.getOrigin();
	    that.protocol = state.getProtocol();
	    that.username = state.getUsername();
	    that.password = state.getPassword();
	    that.host = state.getHost();
	    that.hostname = state.getHostname();
	    that.port = state.getPort();
	    that.pathname = state.getPathname();
	    that.search = state.getSearch();
	    that.searchParams = state.getSearchParams();
	    that.hash = state.getHash();
	  }
	};

	var URLPrototype = URLConstructor.prototype;

	var accessorDescriptor = function (getter, setter) {
	  return {
	    get: function () {
	      return getInternalURLState(this)[getter]();
	    },
	    set: setter && function (value) {
	      return getInternalURLState(this)[setter](value);
	    },
	    configurable: true,
	    enumerable: true
	  };
	};

	if (descriptors) {
	  defineProperties(URLPrototype, {
	    // `URL.prototype.href` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-href
	    href: accessorDescriptor('serialize', 'setHref'),
	    // `URL.prototype.origin` getter
	    // https://url.spec.whatwg.org/#dom-url-origin
	    origin: accessorDescriptor('getOrigin'),
	    // `URL.prototype.protocol` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-protocol
	    protocol: accessorDescriptor('getProtocol', 'setProtocol'),
	    // `URL.prototype.username` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-username
	    username: accessorDescriptor('getUsername', 'setUsername'),
	    // `URL.prototype.password` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-password
	    password: accessorDescriptor('getPassword', 'setPassword'),
	    // `URL.prototype.host` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-host
	    host: accessorDescriptor('getHost', 'setHost'),
	    // `URL.prototype.hostname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hostname
	    hostname: accessorDescriptor('getHostname', 'setHostname'),
	    // `URL.prototype.port` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-port
	    port: accessorDescriptor('getPort', 'setPort'),
	    // `URL.prototype.pathname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-pathname
	    pathname: accessorDescriptor('getPathname', 'setPathname'),
	    // `URL.prototype.search` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-search
	    search: accessorDescriptor('getSearch', 'setSearch'),
	    // `URL.prototype.searchParams` getter
	    // https://url.spec.whatwg.org/#dom-url-searchparams
	    searchParams: accessorDescriptor('getSearchParams'),
	    // `URL.prototype.hash` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hash
	    hash: accessorDescriptor('getHash', 'setHash')
	  });
	}

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	redefine(URLPrototype, 'toJSON', function toJSON() {
	  return getInternalURLState(this).serialize();
	}, { enumerable: true });

	// `URL.prototype.toString` method
	// https://url.spec.whatwg.org/#URL-stringification-behavior
	redefine(URLPrototype, 'toString', function toString() {
	  return getInternalURLState(this).serialize();
	}, { enumerable: true });

	if (NativeURL) {
	  var nativeCreateObjectURL = NativeURL.createObjectURL;
	  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
	  // `URL.createObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
	  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', functionBindContext(nativeCreateObjectURL, NativeURL));
	  // `URL.revokeObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
	  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', functionBindContext(nativeRevokeObjectURL, NativeURL));
	}

	setToStringTag(URLConstructor, 'URL');

	_export({ global: true, forced: !nativeUrl, sham: !descriptors }, {
	  URL: URLConstructor
	});

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	_export({ target: 'URL', proto: true, enumerable: true }, {
	  toJSON: function toJSON() {
	    return functionCall(URL.prototype.toString, this);
	  }
	});

	createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }
	  try {
	    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
	    define({}, "");
	  } catch (err) {
	    define = function(obj, key, value) {
	      return obj[key] = value;
	    };
	  }

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = GeneratorFunctionPrototype;
	  define(Gp, "constructor", GeneratorFunctionPrototype);
	  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
	  GeneratorFunction.displayName = define(
	    GeneratorFunctionPrototype,
	    toStringTagSymbol,
	    "GeneratorFunction"
	  );

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      define(prototype, method, function(arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return PromiseImpl.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  });
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;

	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList),
	      PromiseImpl
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  define(Gp, toStringTagSymbol, "Generator");

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  define(Gp, iteratorSymbol, function() {
	    return this;
	  });

	  define(Gp, "toString", function() {
	    return "[object Generator]";
	  });

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	  module.exports 
	));

	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, in modern engines
	  // we can explicitly access globalThis. In older engines we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  if (typeof globalThis === "object") {
	    globalThis.regeneratorRuntime = runtime;
	  } else {
	    Function("r", "regeneratorRuntime = r")(runtime);
	  }
	}
	});

	function polyfill(window) {
	  var ElementPrototype = window.Element.prototype;

	  if (typeof ElementPrototype.matches !== 'function') {
	    ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.mozMatchesSelector || ElementPrototype.webkitMatchesSelector || function matches(selector) {
	      var element = this;
	      var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
	      var index = 0;

	      while (elements[index] && elements[index] !== element) {
	        ++index;
	      }

	      return Boolean(elements[index]);
	    };
	  }

	  if (typeof ElementPrototype.closest !== 'function') {
	    ElementPrototype.closest = function closest(selector) {
	      var element = this;

	      while (element && element.nodeType === 1) {
	        if (element.matches(selector)) {
	          return element;
	        }

	        element = element.parentNode;
	      }

	      return null;
	    };
	  }
	}

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, _typeof(obj);
	}

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  Object.defineProperty(subClass, "prototype", {
	    writable: false
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _construct(Parent, args, Class) {
	  if (_isNativeReflectConstruct()) {
	    _construct = Reflect.construct;
	  } else {
	    _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);
	      var Constructor = Function.bind.apply(Parent, a);
	      var instance = new Constructor();
	      if (Class) _setPrototypeOf(instance, Class.prototype);
	      return instance;
	    };
	  }

	  return _construct.apply(null, arguments);
	}

	function _isNativeFunction(fn) {
	  return Function.toString.call(fn).indexOf("[native code]") !== -1;
	}

	function _wrapNativeSuper(Class) {
	  var _cache = typeof Map === "function" ? new Map() : undefined;

	  _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !_isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
	    }

	    Wrapper.prototype = Object.create(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return _setPrototypeOf(Wrapper, Class);
	  };

	  return _wrapNativeSuper(Class);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (typeof call === "object" || typeof call === "function")) {
	    return call;
	  } else if (call !== void 0) {
	    throw new TypeError("Derived constructors may only return object or undefined");
	  }

	  return _assertThisInitialized(self);
	}

	function _createSuper(Derived) {
	  var hasNativeReflectConstruct = _isNativeReflectConstruct();

	  return function _createSuperInternal() {
	    var Super = _getPrototypeOf(Derived),
	        result;

	    if (hasNativeReflectConstruct) {
	      var NewTarget = _getPrototypeOf(this).constructor;

	      result = Reflect.construct(Super, arguments, NewTarget);
	    } else {
	      result = Super.apply(this, arguments);
	    }

	    return _possibleConstructorReturn(this, result);
	  };
	}

	function _superPropBase(object, property) {
	  while (!Object.prototype.hasOwnProperty.call(object, property)) {
	    object = _getPrototypeOf(object);
	    if (object === null) break;
	  }

	  return object;
	}

	function _get() {
	  if (typeof Reflect !== "undefined" && Reflect.get) {
	    _get = Reflect.get;
	  } else {
	    _get = function _get(target, property, receiver) {
	      var base = _superPropBase(target, property);

	      if (!base) return;
	      var desc = Object.getOwnPropertyDescriptor(base, property);

	      if (desc.get) {
	        return desc.get.call(arguments.length < 3 ? target : receiver);
	      }

	      return desc.value;
	    };
	  }

	  return _get.apply(this, arguments);
	}

	function _taggedTemplateLiteral(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }

	  return Object.freeze(Object.defineProperties(strings, {
	    raw: {
	      value: Object.freeze(raw)
	    }
	  }));
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}

	function _iterableToArrayLimit(arr, i) {
	  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

	  if (_i == null) return;
	  var _arr = [];
	  var _n = true;
	  var _d = false;

	  var _s, _e;

	  try {
	    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

	  if (!it) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function () {};

	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function () {
	      it = it.call(o);
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	// Maybe could be named something better?
	var Subscribable = /*#__PURE__*/function () {
	  function Subscribable() {
	    var dependencies = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

	    _classCallCheck(this, Subscribable);

	    this.disposed = false;
	    this.dependents = [];
	    this.id = Math.random();
	    this.dependencies = dependencies;
	  } // if (this.disposed)
	  //     return;
	  // if (this.dependents.length === 0)
	  //     return; // Must have dependents to run
	  // const newValue = this.action();
	  // if (newValue != this.value) {
	  //     this.value = newValue;
	  //     this.dependents.forEach(d => d.needsUpdate = true);
	  // }
	  //}


	  _createClass(Subscribable, [{
	    key: "addDependent",
	    value: function addDependent(subscriber) {
	      this.dependents.push(subscriber);
	    }
	  }, {
	    key: "removeDependent",
	    value: function removeDependent(id) {
	      this.dependents.splice(this.dependents.findIndex(function (d) {
	        return d.id === id;
	      }), 1);
	    }
	  }, {
	    key: "dispose",
	    value: function dispose() {
	      var _this = this;

	      this.disposed = true;
	      this.dependencies.forEach(function (d) {
	        return d.removeDependent(_this.id);
	      });
	      this.dependents.forEach(function (d) {
	        return d.dispose();
	      });
	    }
	  }]);

	  return Subscribable;
	}();

	// type ValueFromSubscribables<T extends Subscribable<any, any>[]> = { [K in keyof T]: T[K] extends Subscribable<any, any> ? ValueFromSubscribable<T[K]> : never}

	var LoopSubscriber = /*#__PURE__*/function (_Subscribable) {
	  _inherits(LoopSubscriber, _Subscribable);

	  var _super = _createSuper(LoopSubscriber);

	  function LoopSubscriber(action) {
	    var _this;

	    _classCallCheck(this, LoopSubscriber);

	    for (var _len = arguments.length, dependencies = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      dependencies[_key - 1] = arguments[_key];
	    }

	    _this = _super.call(this, dependencies);
	    _this.action = action;
	    _this.needsUpdate = true;

	    _this.dependencies.forEach(function (d) {
	      return d.addDependent(_assertThisInitialized(_this));
	    });

	    return _this;
	  }

	  _createClass(LoopSubscriber, [{
	    key: "evaluate",
	    value: function evaluate() {
	      if (this.disposed) return;
	      if (!this.needsUpdate) return;
	      var newValue = this.action.apply(this, _toConsumableArray(this.dependencies.map(function (d) {
	        return d.value;
	      })));

	      if (newValue != this.value) {
	        this.previousValue = this.value;
	        this.value = newValue;
	        this.dependents.forEach(function (d) {
	          return d.needsUpdate = true;
	        });
	      }

	      this.needsUpdate = false;
	    }
	  }]);

	  return LoopSubscriber;
	}(Subscribable);

	var LoopObserver = /*#__PURE__*/function (_Subscribable) {
	  _inherits(LoopObserver, _Subscribable);

	  var _super = _createSuper(LoopObserver);

	  function LoopObserver(action) {
	    var _this;

	    _classCallCheck(this, LoopObserver);

	    _this = _super.call(this);
	    _this.action = action;
	    return _this;
	  }

	  _createClass(LoopObserver, [{
	    key: "evaluate",
	    value: function evaluate() {
	      if (this.disposed) return;
	      if (this.dependents.length === 0) return; // Must have dependents to run

	      var newValue = this.action();

	      if (newValue != this.value) {
	        this.previousValue = this.value;
	        this.value = newValue;
	        this.dependents.forEach(function (d) {
	          return d.needsUpdate = true;
	        });
	      }
	    }
	  }]);

	  return LoopObserver;
	}(Subscribable);

	var main = createCommonjsModule(function (module, exports) {

	  Object.defineProperty(exports, "__esModule", {
	    value: true
	  });
	  exports.loop = void 0;
	  /**
	   * Similar to fastdom. Prevents layout thrashing by batching DOM read and DOM write operations
	   * It uses an frame-by-frame loop as its core, however.
	   */

	  var DomAnimationLoop;

	  (function (DomAnimationLoop) {
	    // Virtual frame number based on 60fps. Useful for throttling only. Not an actual frame number
	    DomAnimationLoop.frameNumber = 0;
	    DomAnimationLoop.phases = [{
	      name: "read",
	      handlers: []
	    }, {
	      name: "write",
	      handlers: []
	    }]; // Loop isn't created till at least one event added

	    DomAnimationLoop._firstEventAdded = false;

	    function _startLoop() {
	      // The main loop
	      var loop = function loop() {
	        DomAnimationLoop.phases.forEach(function (phase) {
	          // slice has to be used to duplicate array in case the array is mutated while execution of callbacks is taking place
	          var handlers = phase.handlers.slice(0);
	          handlers.forEach(function (h) {
	            return h.callback();
	          });
	        });
	        DomAnimationLoop.frameNumber++;
	        requestAnimationFrame(loop);
	      };

	      requestAnimationFrame(loop);
	    }

	    function _createPhase(name) {
	      return {
	        name: name,
	        handlers: []
	      };
	    }

	    function addPhaseBefore(newPhaseName, before) {
	      var existingPhase = _getPhaseIndex(before);

	      var phaseToInsert = _createPhase(newPhaseName);

	      DomAnimationLoop.phases.splice(existingPhase, 0, phaseToInsert);
	    }

	    DomAnimationLoop.addPhaseBefore = addPhaseBefore;

	    function addPhaseAfter(newPhaseName, after) {
	      var existingPhase = _getPhaseIndex(after);

	      var phaseToInsert = _createPhase(newPhaseName);

	      DomAnimationLoop.phases.splice(existingPhase + 1, 0, phaseToInsert);
	    }

	    DomAnimationLoop.addPhaseAfter = addPhaseAfter;

	    function add(phase, callback, once, throttle) {
	      if (once == null) once = true;
	      var resultCallback = callback;
	      if (once) resultCallback = function resultCallback() {
	        removeEventHandler(id);
	        callback();
	      };

	      if (throttle) {
	        var originalResultCallback = resultCallback;

	        resultCallback = function resultCallback() {
	          if (DomAnimationLoop.frameNumber % throttle === 0) originalResultCallback();
	        };
	      }

	      var id = _addEventHandler(phase, resultCallback);

	      return id;
	    }

	    DomAnimationLoop.add = add;
	    /**
	     * Perform some kind of DOM read operation, like retrieving width or height of element
	     * @param callback
	     * @param once Whether to run the callback once or on every frame
	     * @param throttle Run every nth frame (between 0 and 59)
	     */

	    function read(callback, once, throttle) {
	      return add("read", callback, once, throttle);
	    }

	    DomAnimationLoop.read = read;
	    /**
	     * Perform a mutate operation on the DOM. Like adding an element or changing CSS classes or style rules
	     * @param callback
	     * @param once Whether to run the callback once or on every frame
	     * @param throttle Run every nth frame (between 0 and 59)
	     */

	    function write(callback, once, throttle) {
	      return add("write", callback, once, throttle);
	    }

	    DomAnimationLoop.write = write;

	    function _getPhaseIndex(name) {
	      var phaseIndex = DomAnimationLoop.phases.findIndex(function (p) {
	        return p.name === name;
	      });

	      if (phaseIndex === -1) {
	        throw new Error("No DOM Animation loop phase with name " + name);
	      }

	      return phaseIndex;
	    }

	    function _getPhase(name) {
	      return DomAnimationLoop.phases[_getPhaseIndex(name)];
	    }

	    function _addEventHandler(phaseName, callback) {
	      var id = Math.random();

	      var phase = _getPhase(phaseName);

	      phase.handlers.push({
	        id: id,
	        callback: callback
	      }); // Initialize loop on first event

	      if (!DomAnimationLoop._firstEventAdded) {
	        DomAnimationLoop._firstEventAdded = true;

	        _startLoop();
	      }

	      return id;
	    }

	    function removeEventHandler(id) {
	      for (var i = 0; i < DomAnimationLoop.phases.length; i++) {
	        var phase = DomAnimationLoop.phases[i];
	        var index = phase.handlers.findIndex(function (h) {
	          return h.id === id;
	        });

	        if (index !== -1) {
	          phase.handlers.splice(index, 1);
	          return true;
	        }
	      }

	      return false;
	    }

	    DomAnimationLoop.removeEventHandler = removeEventHandler;
	  })(DomAnimationLoop || (DomAnimationLoop = {}));
	  /* istanbul ignore next */


	  if (!window["_domAnimationLoop"]) // This ensures only one loop will be instantiated even if multiple bundles include this
	    window["_domAnimationLoop"] = DomAnimationLoop;
	  /**
	   * Singleton instance of animation loop. A frame-by-frame loop used for animating DOM elements, as well as batching DOM read and write operations
	   */

	  exports.loop = window["_domAnimationLoop"];
	});
	unwrapExports(main);
	var main_1 = main.loop;

	// In the meantime, they should be roughly in the correct order because of typescript / bundling dependency management

	var LoopObserverRegistry = /*#__PURE__*/function () {
	  // Lazy compute edges based on whether _edges has been nullified
	  // private _edges = null;
	  // get edges() {
	  //     if (this._edges == null) {
	  //         // Generate edges
	  //     }
	  //     return this._edges;
	  // }
	  function LoopObserverRegistry() {
	    var _this = this;

	    _classCallCheck(this, LoopObserverRegistry);

	    //private needsSort = false;
	    this._observers = {
	      read: [],
	      calc: [],
	      midwrite: [],
	      recalc: [],
	      write: []
	    };
	    var start = -1;
	    main_1.addPhaseAfter("calc", "read");
	    main_1.addPhaseAfter("midwrite", "calc");
	    main_1.addPhaseAfter("recalc", "midwrite");
	    main_1.read(function () {
	      start = performance.now();

	      _this.observers.read.forEach(function (o) {
	        return o.evaluate();
	      }); // setTimeout(() => {
	      //     this.observers.calc.forEach(o => o.run());
	      //     // One-time write, queued after each calc cycle runs
	      //     //this.observers.write.forEach(o => o.run())
	      // }, 0);

	    }, false);
	    main_1.add("calc", function () {
	      _this.observers.calc.forEach(function (o) {
	        return o.evaluate();
	      });
	    }, false);
	    main_1.add("midwrite", function () {
	      _this.observers.midwrite.forEach(function (o) {
	        return o.evaluate();
	      });
	    }, false);
	    main_1.add("recalc", function () {
	      _this.observers.recalc.forEach(function (o) {
	        return o.evaluate();
	      });
	    }, false);
	    main_1.write(function () {
	      _this.observers.write.forEach(function (o) {
	        return o.evaluate();
	      });

	      var difference = performance.now() - start;

	      if (difference > 2000) {
	        console.warn("Frame animations took longer than 2ms");
	      }
	    }, false);
	  } // TODO: rename to observers


	  _createClass(LoopObserverRegistry, [{
	    key: "observers",
	    get: function get() {
	      // check if sort needed ... lazy sorting more efficient?
	      // if (needsSort) sort();
	      return this._observers;
	    }
	  }, {
	    key: "register",
	    value: function register(key, observer) {
	      //console.log("registering", observer);
	      this.observers[key].push(observer); // needsSort = true; // Invalidate current order 
	    }
	  }, {
	    key: "unregister",
	    value: function unregister(observer) {
	      var keys = Object.keys(this.observers);

	      for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];

	        for (var j = 0; j < this.observers[key].length; j++) {
	          var o = this.observers[key][j];

	          if (o == observer) {
	            this.observers[key].splice(j, 1);
	            return;
	          }
	        }
	      }
	    }
	  }]);

	  return LoopObserverRegistry;
	}();

	var loopObserverRegistry = new LoopObserverRegistry();

	var observe = function observe(key, action) {
	  for (var _len = arguments.length, dependencies = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    dependencies[_key - 2] = arguments[_key];
	  }

	  var observer = _construct(LoopSubscriber, [action].concat(dependencies));

	  loopObserverRegistry.register(key, observer);
	  return observer;
	};
	var read = function read(action) {
	  var observer = new LoopObserver(action);
	  loopObserverRegistry.register("read", observer);
	  return observer;
	};
	var write = function write(action) {
	  for (var _len2 = arguments.length, dependencies = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    dependencies[_key2 - 1] = arguments[_key2];
	  }

	  return observe.apply(void 0, ["write", action].concat(dependencies));
	};
	var calc = function calc(action) {
	  for (var _len3 = arguments.length, dependencies = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	    dependencies[_key3 - 1] = arguments[_key3];
	  }

	  return observe.apply(void 0, ["calc", action].concat(dependencies));
	};
	var test = read(function () {
	  return document.body.clientHeight;
	});
	write(function (t) {
	  return t;
	}, test);

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */

	/**
	 * True if the custom elements polyfill is in use.
	 */
	var isCEPolyfill = typeof window !== 'undefined' && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== undefined;
	/**
	 * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
	 * `container`.
	 */

	var removeNodes = function removeNodes(container, start) {
	  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	  while (start !== end) {
	    var n = start.nextSibling;
	    container.removeChild(start);
	    start = n;
	  }
	};

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */

	/**
	 * An expression marker with embedded unique key to avoid collision with
	 * possible text in templates.
	 */
	var marker = "{{lit-".concat(String(Math.random()).slice(2), "}}");
	/**
	 * An expression marker used text-positions, multi-binding attributes, and
	 * attributes with markup-like text values.
	 */

	var nodeMarker = "<!--".concat(marker, "-->");
	var markerRegex = new RegExp("".concat(marker, "|").concat(nodeMarker));
	/**
	 * Suffix appended to all bound attribute names.
	 */

	var boundAttributeSuffix = '$lit$';
	/**
	 * An updatable Template that tracks the location of dynamic parts.
	 */

	var Template = /*#__PURE__*/_createClass(function Template(result, element) {
	  _classCallCheck(this, Template);

	  this.parts = [];
	  this.element = element;
	  var nodesToRemove = [];
	  var stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

	  var walker = document.createTreeWalker(element.content, 133
	  /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
	  , null, false); // Keeps track of the last index associated with a part. We try to delete
	  // unnecessary nodes, but we never want to associate two different parts
	  // to the same index. They must have a constant node between.

	  var lastPartIndex = 0;
	  var index = -1;
	  var partIndex = 0;
	  var strings = result.strings,
	      length = result.values.length;

	  while (partIndex < length) {
	    var node = walker.nextNode();

	    if (node === null) {
	      // We've exhausted the content inside a nested template element.
	      // Because we still have parts (the outer for-loop), we know:
	      // - There is a template in the stack
	      // - The walker will find a nextNode outside the template
	      walker.currentNode = stack.pop();
	      continue;
	    }

	    index++;

	    if (node.nodeType === 1
	    /* Node.ELEMENT_NODE */
	    ) {
	      if (node.hasAttributes()) {
	        var attributes = node.attributes;
	        var _length = attributes.length; // Per
	        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
	        // attributes are not guaranteed to be returned in document order.
	        // In particular, Edge/IE can return them out of order, so we cannot
	        // assume a correspondence between part index and attribute index.

	        var count = 0;

	        for (var i = 0; i < _length; i++) {
	          if (endsWith(attributes[i].name, boundAttributeSuffix)) {
	            count++;
	          }
	        }

	        while (count-- > 0) {
	          // Get the template literal section leading up to the first
	          // expression in this attribute
	          var stringForPart = strings[partIndex]; // Find the attribute name

	          var name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute
	          // All bound attributes have had a suffix added in
	          // TemplateResult#getHTML to opt out of special attribute
	          // handling. To look up the attribute value we also need to add
	          // the suffix.

	          var attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
	          var attributeValue = node.getAttribute(attributeLookupName);
	          node.removeAttribute(attributeLookupName);
	          var statics = attributeValue.split(markerRegex);
	          this.parts.push({
	            type: 'attribute',
	            index: index,
	            name: name,
	            strings: statics
	          });
	          partIndex += statics.length - 1;
	        }
	      }

	      if (node.tagName === 'TEMPLATE') {
	        stack.push(node);
	        walker.currentNode = node.content;
	      }
	    } else if (node.nodeType === 3
	    /* Node.TEXT_NODE */
	    ) {
	      var data = node.data;

	      if (data.indexOf(marker) >= 0) {
	        var parent = node.parentNode;

	        var _strings = data.split(markerRegex);

	        var lastIndex = _strings.length - 1; // Generate a new text node for each literal section
	        // These nodes are also used as the markers for node parts

	        for (var _i = 0; _i < lastIndex; _i++) {
	          var insert = void 0;
	          var s = _strings[_i];

	          if (s === '') {
	            insert = createMarker();
	          } else {
	            var match = lastAttributeNameRegex.exec(s);

	            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
	              s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
	            }

	            insert = document.createTextNode(s);
	          }

	          parent.insertBefore(insert, node);
	          this.parts.push({
	            type: 'node',
	            index: ++index
	          });
	        } // If there's no text, we must insert a comment to mark our place.
	        // Else, we can trust it will stick around after cloning.


	        if (_strings[lastIndex] === '') {
	          parent.insertBefore(createMarker(), node);
	          nodesToRemove.push(node);
	        } else {
	          node.data = _strings[lastIndex];
	        } // We have a part for each match found


	        partIndex += lastIndex;
	      }
	    } else if (node.nodeType === 8
	    /* Node.COMMENT_NODE */
	    ) {
	      if (node.data === marker) {
	        var _parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of
	        // the following are true:
	        //  * We don't have a previousSibling
	        //  * The previousSibling is already the start of a previous part

	        if (node.previousSibling === null || index === lastPartIndex) {
	          index++;

	          _parent.insertBefore(createMarker(), node);
	        }

	        lastPartIndex = index;
	        this.parts.push({
	          type: 'node',
	          index: index
	        }); // If we don't have a nextSibling, keep this node so we have an end.
	        // Else, we can remove it to save future costs.

	        if (node.nextSibling === null) {
	          node.data = '';
	        } else {
	          nodesToRemove.push(node);
	          index--;
	        }

	        partIndex++;
	      } else {
	        var _i2 = -1;

	        while ((_i2 = node.data.indexOf(marker, _i2 + 1)) !== -1) {
	          // Comment node has a binding marker inside, make an inactive part
	          // The binding won't work, but subsequent bindings will
	          // TODO (justinfagnani): consider whether it's even worth it to
	          // make bindings in comments work
	          this.parts.push({
	            type: 'node',
	            index: -1
	          });
	          partIndex++;
	        }
	      }
	    }
	  } // Remove text binding nodes after the walk to not disturb the TreeWalker


	  for (var _i3 = 0, _nodesToRemove = nodesToRemove; _i3 < _nodesToRemove.length; _i3++) {
	    var n = _nodesToRemove[_i3];
	    n.parentNode.removeChild(n);
	  }
	});

	var endsWith = function endsWith(str, suffix) {
	  var index = str.length - suffix.length;
	  return index >= 0 && str.slice(index) === suffix;
	};

	var isTemplatePartActive = function isTemplatePartActive(part) {
	  return part.index !== -1;
	}; // Allows `document.createComment('')` to be renamed for a
	// small manual size-savings.

	var createMarker = function createMarker() {
	  return document.createComment('');
	};
	/**
	 * This regex extracts the attribute name preceding an attribute-position
	 * expression. It does this by matching the syntax allowed for attributes
	 * against the string literal directly preceding the expression, assuming that
	 * the expression is in an attribute-value position.
	 *
	 * See attributes in the HTML spec:
	 * https://www.w3.org/TR/html5/syntax.html#elements-attributes
	 *
	 * " \x09\x0a\x0c\x0d" are HTML space characters:
	 * https://www.w3.org/TR/html5/infrastructure.html#space-characters
	 *
	 * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
	 * space character except " ".
	 *
	 * So an attribute is:
	 *  * The name: any character except a control character, space character, ('),
	 *    ("), ">", "=", or "/"
	 *  * Followed by zero or more space characters
	 *  * Followed by "="
	 *  * Followed by zero or more space characters
	 *  * Followed by:
	 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
	 *    * (") then any non-("), or
	 *    * (') then any non-(')
	 */

	var lastAttributeNameRegex = // eslint-disable-next-line no-control-regex
	/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var walkerNodeFilter = 133
	/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
	;
	/**
	 * Removes the list of nodes from a Template safely. In addition to removing
	 * nodes from the Template, the Template part indices are updated to match
	 * the mutated Template DOM.
	 *
	 * As the template is walked the removal state is tracked and
	 * part indices are adjusted as needed.
	 *
	 * div
	 *   div#1 (remove) <-- start removing (removing node is div#1)
	 *     div
	 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
	 *         div
	 * div <-- stop removing since previous sibling is the removing node (div#1,
	 * removed 4 nodes)
	 */

	function removeNodesFromTemplate(template, nodesToRemove) {
	  var content = template.element.content,
	      parts = template.parts;
	  var walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
	  var partIndex = nextActiveIndexInTemplateParts(parts);
	  var part = parts[partIndex];
	  var nodeIndex = -1;
	  var removeCount = 0;
	  var nodesToRemoveInTemplate = [];
	  var currentRemovingNode = null;

	  while (walker.nextNode()) {
	    nodeIndex++;
	    var node = walker.currentNode; // End removal if stepped past the removing node

	    if (node.previousSibling === currentRemovingNode) {
	      currentRemovingNode = null;
	    } // A node to remove was found in the template


	    if (nodesToRemove.has(node)) {
	      nodesToRemoveInTemplate.push(node); // Track node we're removing

	      if (currentRemovingNode === null) {
	        currentRemovingNode = node;
	      }
	    } // When removing, increment count by which to adjust subsequent part indices


	    if (currentRemovingNode !== null) {
	      removeCount++;
	    }

	    while (part !== undefined && part.index === nodeIndex) {
	      // If part is in a removed node deactivate it by setting index to -1 or
	      // adjust the index as needed.
	      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.

	      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
	      part = parts[partIndex];
	    }
	  }

	  nodesToRemoveInTemplate.forEach(function (n) {
	    return n.parentNode.removeChild(n);
	  });
	}

	var countNodes = function countNodes(node) {
	  var count = node.nodeType === 11
	  /* Node.DOCUMENT_FRAGMENT_NODE */
	  ? 0 : 1;
	  var walker = document.createTreeWalker(node, walkerNodeFilter, null, false);

	  while (walker.nextNode()) {
	    count++;
	  }

	  return count;
	};

	var nextActiveIndexInTemplateParts = function nextActiveIndexInTemplateParts(parts) {
	  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

	  for (var i = startIndex + 1; i < parts.length; i++) {
	    var part = parts[i];

	    if (isTemplatePartActive(part)) {
	      return i;
	    }
	  }

	  return -1;
	};
	/**
	 * Inserts the given node into the Template, optionally before the given
	 * refNode. In addition to inserting the node into the Template, the Template
	 * part indices are updated to match the mutated Template DOM.
	 */


	function insertNodeIntoTemplate(template, node) {
	  var refNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	  var content = template.element.content,
	      parts = template.parts; // If there's no refNode, then put node at end of template.
	  // No part indices need to be shifted in this case.

	  if (refNode === null || refNode === undefined) {
	    content.appendChild(node);
	    return;
	  }

	  var walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
	  var partIndex = nextActiveIndexInTemplateParts(parts);
	  var insertCount = 0;
	  var walkerIndex = -1;

	  while (walker.nextNode()) {
	    walkerIndex++;
	    var walkerNode = walker.currentNode;

	    if (walkerNode === refNode) {
	      insertCount = countNodes(node);
	      refNode.parentNode.insertBefore(node, refNode);
	    }

	    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
	      // If we've inserted the node, simply adjust all subsequent parts
	      if (insertCount > 0) {
	        while (partIndex !== -1) {
	          parts[partIndex].index += insertCount;
	          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
	        }

	        return;
	      }

	      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
	    }
	  }
	}

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var directives = new WeakMap();
	/**
	 * Brands a function as a directive factory function so that lit-html will call
	 * the function during template rendering, rather than passing as a value.
	 *
	 * A _directive_ is a function that takes a Part as an argument. It has the
	 * signature: `(part: Part) => void`.
	 *
	 * A directive _factory_ is a function that takes arguments for data and
	 * configuration and returns a directive. Users of directive usually refer to
	 * the directive factory as the directive. For example, "The repeat directive".
	 *
	 * Usually a template author will invoke a directive factory in their template
	 * with relevant arguments, which will then return a directive function.
	 *
	 * Here's an example of using the `repeat()` directive factory that takes an
	 * array and a function to render an item:
	 *
	 * ```js
	 * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
	 * ```
	 *
	 * When `repeat` is invoked, it returns a directive function that closes over
	 * `items` and the template function. When the outer template is rendered, the
	 * return directive function is called with the Part for the expression.
	 * `repeat` then performs it's custom logic to render multiple items.
	 *
	 * @param f The directive factory function. Must be a function that returns a
	 * function of the signature `(part: Part) => void`. The returned function will
	 * be called with the part object.
	 *
	 * @example
	 *
	 * import {directive, html} from 'lit-html';
	 *
	 * const immutable = directive((v) => (part) => {
	 *   if (part.value !== v) {
	 *     part.setValue(v)
	 *   }
	 * });
	 */

	var directive = function directive(f) {
	  return function () {
	    var d = f.apply(void 0, arguments);
	    directives.set(d, true);
	    return d;
	  };
	};
	var isDirective = function isDirective(o) {
	  return typeof o === 'function' && directives.has(o);
	};

	/**
	 * @license
	 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */

	/**
	 * A sentinel value that signals that a value was handled by a directive and
	 * should not be written to the DOM.
	 */
	var noChange = {};
	/**
	 * A sentinel value that signals a NodePart to fully clear its content.
	 */

	var nothing = {};

	/**
	 * An instance of a `Template` that can be attached to the DOM and updated
	 * with new values.
	 */

	var TemplateInstance = /*#__PURE__*/function () {
	  function TemplateInstance(template, processor, options) {
	    _classCallCheck(this, TemplateInstance);

	    this.__parts = [];
	    this.template = template;
	    this.processor = processor;
	    this.options = options;
	  }

	  _createClass(TemplateInstance, [{
	    key: "update",
	    value: function update(values) {
	      var i = 0;

	      var _iterator = _createForOfIteratorHelper(this.__parts),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var part = _step.value;

	          if (part !== undefined) {
	            part.setValue(values[i]);
	          }

	          i++;
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      var _iterator2 = _createForOfIteratorHelper(this.__parts),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var _part = _step2.value;

	          if (_part !== undefined) {
	            _part.commit();
	          }
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }
	  }, {
	    key: "_clone",
	    value: function _clone() {
	      // There are a number of steps in the lifecycle of a template instance's
	      // DOM fragment:
	      //  1. Clone - create the instance fragment
	      //  2. Adopt - adopt into the main document
	      //  3. Process - find part markers and create parts
	      //  4. Upgrade - upgrade custom elements
	      //  5. Update - set node, attribute, property, etc., values
	      //  6. Connect - connect to the document. Optional and outside of this
	      //     method.
	      //
	      // We have a few constraints on the ordering of these steps:
	      //  * We need to upgrade before updating, so that property values will pass
	      //    through any property setters.
	      //  * We would like to process before upgrading so that we're sure that the
	      //    cloned fragment is inert and not disturbed by self-modifying DOM.
	      //  * We want custom elements to upgrade even in disconnected fragments.
	      //
	      // Given these constraints, with full custom elements support we would
	      // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
	      //
	      // But Safari does not implement CustomElementRegistry#upgrade, so we
	      // can not implement that order and still have upgrade-before-update and
	      // upgrade disconnected fragments. So we instead sacrifice the
	      // process-before-upgrade constraint, since in Custom Elements v1 elements
	      // must not modify their light DOM in the constructor. We still have issues
	      // when co-existing with CEv0 elements like Polymer 1, and with polyfills
	      // that don't strictly adhere to the no-modification rule because shadow
	      // DOM, which may be created in the constructor, is emulated by being placed
	      // in the light DOM.
	      //
	      // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
	      // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
	      // in one step.
	      //
	      // The Custom Elements v1 polyfill supports upgrade(), so the order when
	      // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
	      // Connect.
	      var fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
	      var stack = [];
	      var parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

	      var walker = document.createTreeWalker(fragment, 133
	      /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
	      , null, false);
	      var partIndex = 0;
	      var nodeIndex = 0;
	      var part;
	      var node = walker.nextNode(); // Loop through all the nodes and parts of a template

	      while (partIndex < parts.length) {
	        part = parts[partIndex];

	        if (!isTemplatePartActive(part)) {
	          this.__parts.push(undefined);

	          partIndex++;
	          continue;
	        } // Progress the tree walker until we find our next part's node.
	        // Note that multiple parts may share the same node (attribute parts
	        // on a single element), so this loop may not run at all.


	        while (nodeIndex < part.index) {
	          nodeIndex++;

	          if (node.nodeName === 'TEMPLATE') {
	            stack.push(node);
	            walker.currentNode = node.content;
	          }

	          if ((node = walker.nextNode()) === null) {
	            // We've exhausted the content inside a nested template element.
	            // Because we still have parts (the outer for-loop), we know:
	            // - There is a template in the stack
	            // - The walker will find a nextNode outside the template
	            walker.currentNode = stack.pop();
	            node = walker.nextNode();
	          }
	        } // We've arrived at our part's node.


	        if (part.type === 'node') {
	          var _part2 = this.processor.handleTextExpression(this.options);

	          _part2.insertAfterNode(node.previousSibling);

	          this.__parts.push(_part2);
	        } else {
	          var _this$__parts;

	          (_this$__parts = this.__parts).push.apply(_this$__parts, _toConsumableArray(this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options)));
	        }

	        partIndex++;
	      }

	      if (isCEPolyfill) {
	        document.adoptNode(fragment);
	        customElements.upgrade(fragment);
	      }

	      return fragment;
	    }
	  }]);

	  return TemplateInstance;
	}();

	/**
	 * Our TrustedTypePolicy for HTML which is declared using the html template
	 * tag function.
	 *
	 * That HTML is a developer-authored constant, and is parsed with innerHTML
	 * before any untrusted expressions have been mixed in. Therefor it is
	 * considered safe by construction.
	 */

	var policy = window.trustedTypes && trustedTypes.createPolicy('lit-html', {
	  createHTML: function createHTML(s) {
	    return s;
	  }
	});
	var commentMarker = " ".concat(marker, " ");
	/**
	 * The return type of `html`, which holds a Template and the values from
	 * interpolated expressions.
	 */

	var TemplateResult = /*#__PURE__*/function () {
	  function TemplateResult(strings, values, type, processor) {
	    _classCallCheck(this, TemplateResult);

	    this.strings = strings;
	    this.values = values;
	    this.type = type;
	    this.processor = processor;
	  }
	  /**
	   * Returns a string of HTML used to create a `<template>` element.
	   */


	  _createClass(TemplateResult, [{
	    key: "getHTML",
	    value: function getHTML() {
	      var l = this.strings.length - 1;
	      var html = '';
	      var isCommentBinding = false;

	      for (var i = 0; i < l; i++) {
	        var s = this.strings[i]; // For each binding we want to determine the kind of marker to insert
	        // into the template source before it's parsed by the browser's HTML
	        // parser. The marker type is based on whether the expression is in an
	        // attribute, text, or comment position.
	        //   * For node-position bindings we insert a comment with the marker
	        //     sentinel as its text content, like <!--{{lit-guid}}-->.
	        //   * For attribute bindings we insert just the marker sentinel for the
	        //     first binding, so that we support unquoted attribute bindings.
	        //     Subsequent bindings can use a comment marker because multi-binding
	        //     attributes must be quoted.
	        //   * For comment bindings we insert just the marker sentinel so we don't
	        //     close the comment.
	        //
	        // The following code scans the template source, but is *not* an HTML
	        // parser. We don't need to track the tree structure of the HTML, only
	        // whether a binding is inside a comment, and if not, if it appears to be
	        // the first binding in an attribute.

	        var commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following
	        // comment close. Because <-- can appear in an attribute value there can
	        // be false positives.

	        isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceding the
	        // expression. This can match "name=value" like structures in text,
	        // comments, and attribute values, so there can be false-positives.

	        var attributeMatch = lastAttributeNameRegex.exec(s);

	        if (attributeMatch === null) {
	          // We're only in this branch if we don't have a attribute-like
	          // preceding sequence. For comments, this guards against unusual
	          // attribute values like <div foo="<!--${'bar'}">. Cases like
	          // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
	          // below.
	          html += s + (isCommentBinding ? commentMarker : nodeMarker);
	        } else {
	          // For attributes we use just a marker sentinel, and also append a
	          // $lit$ suffix to the name to opt-out of attribute-specific parsing
	          // that IE and Edge do for style and certain SVG attributes.
	          html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
	        }
	      }

	      html += this.strings[l];
	      return html;
	    }
	  }, {
	    key: "getTemplateElement",
	    value: function getTemplateElement() {
	      var template = document.createElement('template');
	      var value = this.getHTML();

	      if (policy !== undefined) {
	        // this is secure because `this.strings` is a TemplateStringsArray.
	        // TODO: validate this when
	        // https://github.com/tc39/proposal-array-is-template-object is
	        // implemented.
	        value = policy.createHTML(value);
	      }

	      template.innerHTML = value;
	      return template;
	    }
	  }]);

	  return TemplateResult;
	}();

	var isPrimitive = function isPrimitive(value) {
	  return value === null || !(_typeof(value) === 'object' || typeof value === 'function');
	};
	var isIterable$1 = function isIterable(value) {
	  return Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
	  !!(value && value[Symbol.iterator]);
	};
	/**
	 * Writes attribute values to the DOM for a group of AttributeParts bound to a
	 * single attribute. The value is only set once even if there are multiple parts
	 * for an attribute.
	 */

	var AttributeCommitter = /*#__PURE__*/function () {
	  function AttributeCommitter(element, name, strings) {
	    _classCallCheck(this, AttributeCommitter);

	    this.dirty = true;
	    this.element = element;
	    this.name = name;
	    this.strings = strings;
	    this.parts = [];

	    for (var i = 0; i < strings.length - 1; i++) {
	      this.parts[i] = this._createPart();
	    }
	  }
	  /**
	   * Creates a single part. Override this to create a differnt type of part.
	   */


	  _createClass(AttributeCommitter, [{
	    key: "_createPart",
	    value: function _createPart() {
	      return new AttributePart(this);
	    }
	  }, {
	    key: "_getValue",
	    value: function _getValue() {
	      var strings = this.strings;
	      var l = strings.length - 1;
	      var parts = this.parts; // If we're assigning an attribute via syntax like:
	      //    attr="${foo}"  or  attr=${foo}
	      // but not
	      //    attr="${foo} ${bar}" or attr="${foo} baz"
	      // then we don't want to coerce the attribute value into one long
	      // string. Instead we want to just return the value itself directly,
	      // so that sanitizeDOMValue can get the actual value rather than
	      // String(value)
	      // The exception is if v is an array, in which case we do want to smash
	      // it together into a string without calling String() on the array.
	      //
	      // This also allows trusted values (when using TrustedTypes) being
	      // assigned to DOM sinks without being stringified in the process.

	      if (l === 1 && strings[0] === '' && strings[1] === '') {
	        var v = parts[0].value;

	        if (_typeof(v) === 'symbol') {
	          return String(v);
	        }

	        if (typeof v === 'string' || !isIterable$1(v)) {
	          return v;
	        }
	      }

	      var text = '';

	      for (var i = 0; i < l; i++) {
	        text += strings[i];
	        var part = parts[i];

	        if (part !== undefined) {
	          var _v = part.value;

	          if (isPrimitive(_v) || !isIterable$1(_v)) {
	            text += typeof _v === 'string' ? _v : String(_v);
	          } else {
	            var _iterator = _createForOfIteratorHelper(_v),
	                _step;

	            try {
	              for (_iterator.s(); !(_step = _iterator.n()).done;) {
	                var t = _step.value;
	                text += typeof t === 'string' ? t : String(t);
	              }
	            } catch (err) {
	              _iterator.e(err);
	            } finally {
	              _iterator.f();
	            }
	          }
	        }
	      }

	      text += strings[l];
	      return text;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.dirty) {
	        this.dirty = false;
	        this.element.setAttribute(this.name, this._getValue());
	      }
	    }
	  }]);

	  return AttributeCommitter;
	}();
	/**
	 * A Part that controls all or part of an attribute value.
	 */

	var AttributePart = /*#__PURE__*/function () {
	  function AttributePart(committer) {
	    _classCallCheck(this, AttributePart);

	    this.value = undefined;
	    this.committer = committer;
	  }

	  _createClass(AttributePart, [{
	    key: "setValue",
	    value: function setValue(value) {
	      if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
	        this.value = value; // If the value is a not a directive, dirty the committer so that it'll
	        // call setAttribute. If the value is a directive, it'll dirty the
	        // committer if it calls setValue().

	        if (!isDirective(value)) {
	          this.committer.dirty = true;
	        }
	      }
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      while (isDirective(this.value)) {
	        var directive = this.value;
	        this.value = noChange;
	        directive(this);
	      }

	      if (this.value === noChange) {
	        return;
	      }

	      this.committer.commit();
	    }
	  }]);

	  return AttributePart;
	}();
	/**
	 * A Part that controls a location within a Node tree. Like a Range, NodePart
	 * has start and end locations and can set and update the Nodes between those
	 * locations.
	 *
	 * NodeParts support several value types: primitives, Nodes, TemplateResults,
	 * as well as arrays and iterables of those types.
	 */

	var NodePart = /*#__PURE__*/function () {
	  function NodePart(options) {
	    _classCallCheck(this, NodePart);

	    this.value = undefined;
	    this.__pendingValue = undefined;
	    this.options = options;
	  }
	  /**
	   * Appends this part into a container.
	   *
	   * This part must be empty, as its contents are not automatically moved.
	   */


	  _createClass(NodePart, [{
	    key: "appendInto",
	    value: function appendInto(container) {
	      this.startNode = container.appendChild(createMarker());
	      this.endNode = container.appendChild(createMarker());
	    }
	    /**
	     * Inserts this part after the `ref` node (between `ref` and `ref`'s next
	     * sibling). Both `ref` and its next sibling must be static, unchanging nodes
	     * such as those that appear in a literal section of a template.
	     *
	     * This part must be empty, as its contents are not automatically moved.
	     */

	  }, {
	    key: "insertAfterNode",
	    value: function insertAfterNode(ref) {
	      this.startNode = ref;
	      this.endNode = ref.nextSibling;
	    }
	    /**
	     * Appends this part into a parent part.
	     *
	     * This part must be empty, as its contents are not automatically moved.
	     */

	  }, {
	    key: "appendIntoPart",
	    value: function appendIntoPart(part) {
	      part.__insert(this.startNode = createMarker());

	      part.__insert(this.endNode = createMarker());
	    }
	    /**
	     * Inserts this part after the `ref` part.
	     *
	     * This part must be empty, as its contents are not automatically moved.
	     */

	  }, {
	    key: "insertAfterPart",
	    value: function insertAfterPart(ref) {
	      ref.__insert(this.startNode = createMarker());

	      this.endNode = ref.endNode;
	      ref.endNode = this.startNode;
	    }
	  }, {
	    key: "setValue",
	    value: function setValue(value) {
	      this.__pendingValue = value;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.startNode.parentNode === null) {
	        return;
	      }

	      while (isDirective(this.__pendingValue)) {
	        var directive = this.__pendingValue;
	        this.__pendingValue = noChange;
	        directive(this);
	      }

	      var value = this.__pendingValue;

	      if (value === noChange) {
	        return;
	      }

	      if (isPrimitive(value)) {
	        if (value !== this.value) {
	          this.__commitText(value);
	        }
	      } else if (value instanceof TemplateResult) {
	        this.__commitTemplateResult(value);
	      } else if (value instanceof Node) {
	        this.__commitNode(value);
	      } else if (isIterable$1(value)) {
	        this.__commitIterable(value);
	      } else if (value === nothing) {
	        this.value = nothing;
	        this.clear();
	      } else {
	        // Fallback, will render the string representation
	        this.__commitText(value);
	      }
	    }
	  }, {
	    key: "__insert",
	    value: function __insert(node) {
	      this.endNode.parentNode.insertBefore(node, this.endNode);
	    }
	  }, {
	    key: "__commitNode",
	    value: function __commitNode(value) {
	      if (this.value === value) {
	        return;
	      }

	      this.clear();

	      this.__insert(value);

	      this.value = value;
	    }
	  }, {
	    key: "__commitText",
	    value: function __commitText(value) {
	      var node = this.startNode.nextSibling;
	      value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case
	      // it can't be implicitly converted - i.e. it's a symbol.

	      var valueAsString = typeof value === 'string' ? value : String(value);

	      if (node === this.endNode.previousSibling && node.nodeType === 3
	      /* Node.TEXT_NODE */
	      ) {
	        // If we only have a single text node between the markers, we can just
	        // set its value, rather than replacing it.
	        // TODO(justinfagnani): Can we just check if this.value is primitive?
	        node.data = valueAsString;
	      } else {
	        this.__commitNode(document.createTextNode(valueAsString));
	      }

	      this.value = value;
	    }
	  }, {
	    key: "__commitTemplateResult",
	    value: function __commitTemplateResult(value) {
	      var template = this.options.templateFactory(value);

	      if (this.value instanceof TemplateInstance && this.value.template === template) {
	        this.value.update(value.values);
	      } else {
	        // Make sure we propagate the template processor from the TemplateResult
	        // so that we use its syntax extension, etc. The template factory comes
	        // from the render function options so that it can control template
	        // caching and preprocessing.
	        var instance = new TemplateInstance(template, value.processor, this.options);

	        var fragment = instance._clone();

	        instance.update(value.values);

	        this.__commitNode(fragment);

	        this.value = instance;
	      }
	    }
	  }, {
	    key: "__commitIterable",
	    value: function __commitIterable(value) {
	      // For an Iterable, we create a new InstancePart per item, then set its
	      // value to the item. This is a little bit of overhead for every item in
	      // an Iterable, but it lets us recurse easily and efficiently update Arrays
	      // of TemplateResults that will be commonly returned from expressions like:
	      // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
	      // If _value is an array, then the previous render was of an
	      // iterable and _value will contain the NodeParts from the previous
	      // render. If _value is not an array, clear this part and make a new
	      // array for NodeParts.
	      if (!Array.isArray(this.value)) {
	        this.value = [];
	        this.clear();
	      } // Lets us keep track of how many items we stamped so we can clear leftover
	      // items from a previous render


	      var itemParts = this.value;
	      var partIndex = 0;
	      var itemPart;

	      var _iterator2 = _createForOfIteratorHelper(value),
	          _step2;

	      try {
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          var item = _step2.value;
	          // Try to reuse an existing part
	          itemPart = itemParts[partIndex]; // If no existing part, create a new one

	          if (itemPart === undefined) {
	            itemPart = new NodePart(this.options);
	            itemParts.push(itemPart);

	            if (partIndex === 0) {
	              itemPart.appendIntoPart(this);
	            } else {
	              itemPart.insertAfterPart(itemParts[partIndex - 1]);
	            }
	          }

	          itemPart.setValue(item);
	          itemPart.commit();
	          partIndex++;
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }

	      if (partIndex < itemParts.length) {
	        // Truncate the parts array so _value reflects the current state
	        itemParts.length = partIndex;
	        this.clear(itemPart && itemPart.endNode);
	      }
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var startNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.startNode;
	      removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
	    }
	  }]);

	  return NodePart;
	}();
	/**
	 * Implements a boolean attribute, roughly as defined in the HTML
	 * specification.
	 *
	 * If the value is truthy, then the attribute is present with a value of
	 * ''. If the value is falsey, the attribute is removed.
	 */

	var BooleanAttributePart = /*#__PURE__*/function () {
	  function BooleanAttributePart(element, name, strings) {
	    _classCallCheck(this, BooleanAttributePart);

	    this.value = undefined;
	    this.__pendingValue = undefined;

	    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
	      throw new Error('Boolean attributes can only contain a single expression');
	    }

	    this.element = element;
	    this.name = name;
	    this.strings = strings;
	  }

	  _createClass(BooleanAttributePart, [{
	    key: "setValue",
	    value: function setValue(value) {
	      this.__pendingValue = value;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      while (isDirective(this.__pendingValue)) {
	        var directive = this.__pendingValue;
	        this.__pendingValue = noChange;
	        directive(this);
	      }

	      if (this.__pendingValue === noChange) {
	        return;
	      }

	      var value = !!this.__pendingValue;

	      if (this.value !== value) {
	        if (value) {
	          this.element.setAttribute(this.name, '');
	        } else {
	          this.element.removeAttribute(this.name);
	        }

	        this.value = value;
	      }

	      this.__pendingValue = noChange;
	    }
	  }]);

	  return BooleanAttributePart;
	}();
	/**
	 * Sets attribute values for PropertyParts, so that the value is only set once
	 * even if there are multiple parts for a property.
	 *
	 * If an expression controls the whole property value, then the value is simply
	 * assigned to the property under control. If there are string literals or
	 * multiple expressions, then the strings are expressions are interpolated into
	 * a string first.
	 */

	var PropertyCommitter = /*#__PURE__*/function (_AttributeCommitter) {
	  _inherits(PropertyCommitter, _AttributeCommitter);

	  var _super = _createSuper(PropertyCommitter);

	  function PropertyCommitter(element, name, strings) {
	    var _this;

	    _classCallCheck(this, PropertyCommitter);

	    _this = _super.call(this, element, name, strings);
	    _this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
	    return _this;
	  }

	  _createClass(PropertyCommitter, [{
	    key: "_createPart",
	    value: function _createPart() {
	      return new PropertyPart(this);
	    }
	  }, {
	    key: "_getValue",
	    value: function _getValue() {
	      if (this.single) {
	        return this.parts[0].value;
	      }

	      return _get(_getPrototypeOf(PropertyCommitter.prototype), "_getValue", this).call(this);
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.dirty) {
	        this.dirty = false; // eslint-disable-next-line @typescript-eslint/no-explicit-any

	        this.element[this.name] = this._getValue();
	      }
	    }
	  }]);

	  return PropertyCommitter;
	}(AttributeCommitter);
	var PropertyPart = /*#__PURE__*/function (_AttributePart) {
	  _inherits(PropertyPart, _AttributePart);

	  var _super2 = _createSuper(PropertyPart);

	  function PropertyPart() {
	    _classCallCheck(this, PropertyPart);

	    return _super2.apply(this, arguments);
	  }

	  return _createClass(PropertyPart);
	}(AttributePart); // Detect event listener options support. If the `capture` property is read
	// from the options object, then options are supported. If not, then the third
	// argument to add/removeEventListener is interpreted as the boolean capture
	// value so we should only pass the `capture` property.

	var eventOptionsSupported = false; // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
	// blocks right into the body of a module

	(function () {
	  try {
	    var options = {
	      get capture() {
	        eventOptionsSupported = true;
	        return false;
	      }

	    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any

	    window.addEventListener('test', options, options); // eslint-disable-next-line @typescript-eslint/no-explicit-any

	    window.removeEventListener('test', options, options);
	  } catch (_e) {// event options not supported
	  }
	})();

	var EventPart = /*#__PURE__*/function () {
	  function EventPart(element, eventName, eventContext) {
	    var _this2 = this;

	    _classCallCheck(this, EventPart);

	    this.value = undefined;
	    this.__pendingValue = undefined;
	    this.element = element;
	    this.eventName = eventName;
	    this.eventContext = eventContext;

	    this.__boundHandleEvent = function (e) {
	      return _this2.handleEvent(e);
	    };
	  }

	  _createClass(EventPart, [{
	    key: "setValue",
	    value: function setValue(value) {
	      this.__pendingValue = value;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      while (isDirective(this.__pendingValue)) {
	        var directive = this.__pendingValue;
	        this.__pendingValue = noChange;
	        directive(this);
	      }

	      if (this.__pendingValue === noChange) {
	        return;
	      }

	      var newListener = this.__pendingValue;
	      var oldListener = this.value;
	      var shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
	      var shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

	      if (shouldRemoveListener) {
	        this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
	      }

	      if (shouldAddListener) {
	        this.__options = getOptions(newListener);
	        this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
	      }

	      this.value = newListener;
	      this.__pendingValue = noChange;
	    }
	  }, {
	    key: "handleEvent",
	    value: function handleEvent(event) {
	      if (typeof this.value === 'function') {
	        this.value.call(this.eventContext || this.element, event);
	      } else {
	        this.value.handleEvent(event);
	      }
	    }
	  }]);

	  return EventPart;
	}(); // We copy options because of the inconsistent behavior of browsers when reading
	// the third argument of add/removeEventListener. IE11 doesn't support options
	// at all. Chrome 41 only reads `capture` if the argument is an object.

	var getOptions = function getOptions(o) {
	  return o && (eventOptionsSupported ? {
	    capture: o.capture,
	    passive: o.passive,
	    once: o.once
	  } : o.capture);
	};

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	/**
	 * The default TemplateFactory which caches Templates keyed on
	 * result.type and result.strings.
	 */

	function templateFactory(result) {
	  var templateCache = templateCaches.get(result.type);

	  if (templateCache === undefined) {
	    templateCache = {
	      stringsArray: new WeakMap(),
	      keyString: new Map()
	    };
	    templateCaches.set(result.type, templateCache);
	  }

	  var template = templateCache.stringsArray.get(result.strings);

	  if (template !== undefined) {
	    return template;
	  } // If the TemplateStringsArray is new, generate a key from the strings
	  // This key is shared between all templates with identical content


	  var key = result.strings.join(marker); // Check if we already have a Template for this key

	  template = templateCache.keyString.get(key);

	  if (template === undefined) {
	    // If we have not seen this key before, create a new Template
	    template = new Template(result, result.getTemplateElement()); // Cache the Template for this key

	    templateCache.keyString.set(key, template);
	  } // Cache all future queries for this TemplateStringsArray


	  templateCache.stringsArray.set(result.strings, template);
	  return template;
	}
	var templateCaches = new Map();

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var parts = new WeakMap();
	/**
	 * Renders a template result or other value to a container.
	 *
	 * To update a container with new values, reevaluate the template literal and
	 * call `render` with the new result.
	 *
	 * @param result Any value renderable by NodePart - typically a TemplateResult
	 *     created by evaluating a template tag like `html` or `svg`.
	 * @param container A DOM parent to render to. The entire contents are either
	 *     replaced, or efficiently updated if the same result type was previous
	 *     rendered there.
	 * @param options RenderOptions for the entire render tree rendered to this
	 *     container. Render options must *not* change between renders to the same
	 *     container, as those changes will not effect previously rendered DOM.
	 */

	var render$1 = function render(result, container, options) {
	  var part = parts.get(container);

	  if (part === undefined) {
	    removeNodes(container, container.firstChild);
	    parts.set(container, part = new NodePart(Object.assign({
	      templateFactory: templateFactory
	    }, options)));
	    part.appendInto(container);
	  }

	  part.setValue(result);
	  part.commit();
	};

	/**
	 * Creates Parts when a template is instantiated.
	 */

	var DefaultTemplateProcessor = /*#__PURE__*/function () {
	  function DefaultTemplateProcessor() {
	    _classCallCheck(this, DefaultTemplateProcessor);
	  }

	  _createClass(DefaultTemplateProcessor, [{
	    key: "handleAttributeExpressions",
	    value:
	    /**
	     * Create parts for an attribute-position binding, given the event, attribute
	     * name, and string literals.
	     *
	     * @param element The element containing the binding
	     * @param name  The attribute name
	     * @param strings The string literals. There are always at least two strings,
	     *   event for fully-controlled bindings with a single expression.
	     */
	    function handleAttributeExpressions(element, name, strings, options) {
	      var prefix = name[0];

	      if (prefix === '.') {
	        var _committer = new PropertyCommitter(element, name.slice(1), strings);

	        return _committer.parts;
	      }

	      if (prefix === '@') {
	        return [new EventPart(element, name.slice(1), options.eventContext)];
	      }

	      if (prefix === '?') {
	        return [new BooleanAttributePart(element, name.slice(1), strings)];
	      }

	      var committer = new AttributeCommitter(element, name, strings);
	      return committer.parts;
	    }
	    /**
	     * Create parts for a text-position binding.
	     * @param templateFactory
	     */

	  }, {
	    key: "handleTextExpression",
	    value: function handleTextExpression(options) {
	      return new NodePart(options);
	    }
	  }]);

	  return DefaultTemplateProcessor;
	}();
	var defaultTemplateProcessor = new DefaultTemplateProcessor();

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	// This line will be used in regexes to search for lit-html usage.
	// TODO(justinfagnani): inject version number at build time

	if (typeof window !== 'undefined') {
	  (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');
	}
	/**
	 * Interprets a template literal as an HTML template that can efficiently
	 * render to and update a container.
	 */


	var html = function html(strings) {
	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  return new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
	};

	var getTemplateCacheKey = function getTemplateCacheKey(type, scopeName) {
	  return "".concat(type, "--").concat(scopeName);
	};

	var compatibleShadyCSSVersion = true;

	if (typeof window.ShadyCSS === 'undefined') {
	  compatibleShadyCSSVersion = false;
	} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
	  console.warn("Incompatible ShadyCSS version detected. " + "Please update to at least @webcomponents/webcomponentsjs@2.0.2 and " + "@webcomponents/shadycss@1.3.1.");
	  compatibleShadyCSSVersion = false;
	}
	/**
	 * Template factory which scopes template DOM using ShadyCSS.
	 * @param scopeName {string}
	 */


	var shadyTemplateFactory = function shadyTemplateFactory(scopeName) {
	  return function (result) {
	    var cacheKey = getTemplateCacheKey(result.type, scopeName);
	    var templateCache = templateCaches.get(cacheKey);

	    if (templateCache === undefined) {
	      templateCache = {
	        stringsArray: new WeakMap(),
	        keyString: new Map()
	      };
	      templateCaches.set(cacheKey, templateCache);
	    }

	    var template = templateCache.stringsArray.get(result.strings);

	    if (template !== undefined) {
	      return template;
	    }

	    var key = result.strings.join(marker);
	    template = templateCache.keyString.get(key);

	    if (template === undefined) {
	      var element = result.getTemplateElement();

	      if (compatibleShadyCSSVersion) {
	        window.ShadyCSS.prepareTemplateDom(element, scopeName);
	      }

	      template = new Template(result, element);
	      templateCache.keyString.set(key, template);
	    }

	    templateCache.stringsArray.set(result.strings, template);
	    return template;
	  };
	};
	var TEMPLATE_TYPES = ['html', 'svg'];
	/**
	 * Removes all style elements from Templates for the given scopeName.
	 */

	var removeStylesFromLitTemplates = function removeStylesFromLitTemplates(scopeName) {
	  TEMPLATE_TYPES.forEach(function (type) {
	    var templates = templateCaches.get(getTemplateCacheKey(type, scopeName));

	    if (templates !== undefined) {
	      templates.keyString.forEach(function (template) {
	        var content = template.element.content; // IE 11 doesn't support the iterable param Set constructor

	        var styles = new Set();
	        Array.from(content.querySelectorAll('style')).forEach(function (s) {
	          styles.add(s);
	        });
	        removeNodesFromTemplate(template, styles);
	      });
	    }
	  });
	};

	var shadyRenderSet = new Set();
	/**
	 * For the given scope name, ensures that ShadyCSS style scoping is performed.
	 * This is done just once per scope name so the fragment and template cannot
	 * be modified.
	 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
	 * to be scoped and appended to the document
	 * (2) removes style elements from all lit-html Templates for this scope name.
	 *
	 * Note, <style> elements can only be placed into templates for the
	 * initial rendering of the scope. If <style> elements are included in templates
	 * dynamically rendered to the scope (after the first scope render), they will
	 * not be scoped and the <style> will be left in the template and rendered
	 * output.
	 */

	var prepareTemplateStyles = function prepareTemplateStyles(scopeName, renderedDOM, template) {
	  shadyRenderSet.add(scopeName); // If `renderedDOM` is stamped from a Template, then we need to edit that
	  // Template's underlying template element. Otherwise, we create one here
	  // to give to ShadyCSS, which still requires one while scoping.

	  var templateElement = !!template ? template.element : document.createElement('template'); // Move styles out of rendered DOM and store.

	  var styles = renderedDOM.querySelectorAll('style');
	  var length = styles.length; // If there are no styles, skip unnecessary work

	  if (length === 0) {
	    // Ensure prepareTemplateStyles is called to support adding
	    // styles via `prepareAdoptedCssText` since that requires that
	    // `prepareTemplateStyles` is called.
	    //
	    // ShadyCSS will only update styles containing @apply in the template
	    // given to `prepareTemplateStyles`. If no lit Template was given,
	    // ShadyCSS will not be able to update uses of @apply in any relevant
	    // template. However, this is not a problem because we only create the
	    // template for the purpose of supporting `prepareAdoptedCssText`,
	    // which doesn't support @apply at all.
	    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
	    return;
	  }

	  var condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS
	  // manipulations will not prevent us from being able to fix up template
	  // part indices.
	  // NOTE: collecting styles is inefficient for browsers but ShadyCSS
	  // currently does this anyway. When it does not, this should be changed.

	  for (var i = 0; i < length; i++) {
	    var _style = styles[i];

	    _style.parentNode.removeChild(_style);

	    condensedStyle.textContent += _style.textContent;
	  } // Remove styles from nested templates in this scope.


	  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the "root" template passed in as
	  // `template`.

	  var content = templateElement.content;

	  if (!!template) {
	    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
	  } else {
	    content.insertBefore(condensedStyle, content.firstChild);
	  } // Note, it's important that ShadyCSS gets the template that `lit-html`
	  // will actually render so that it can update the style inside when
	  // needed (e.g. @apply native Shadow DOM case).


	  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
	  var style = content.querySelector('style');

	  if (window.ShadyCSS.nativeShadow && style !== null) {
	    // When in native Shadow DOM, ensure the style created by ShadyCSS is
	    // included in initially rendered output (`renderedDOM`).
	    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
	  } else if (!!template) {
	    // When no style is left in the template, parts will be broken as a
	    // result. To fix this, we put back the style node ShadyCSS removed
	    // and then tell lit to remove that node from the template.
	    // There can be no style in the template in 2 cases (1) when Shady DOM
	    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
	    // is in use ShadyCSS removes the style if it contains no content.
	    // NOTE, ShadyCSS creates its own style so we can safely add/remove
	    // `condensedStyle` here.
	    content.insertBefore(condensedStyle, content.firstChild);
	    var removes = new Set();
	    removes.add(condensedStyle);
	    removeNodesFromTemplate(template, removes);
	  }
	};
	/**
	 * Extension to the standard `render` method which supports rendering
	 * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
	 * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
	 * or when the webcomponentsjs
	 * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
	 *
	 * Adds a `scopeName` option which is used to scope element DOM and stylesheets
	 * when native ShadowDOM is unavailable. The `scopeName` will be added to
	 * the class attribute of all rendered DOM. In addition, any style elements will
	 * be automatically re-written with this `scopeName` selector and moved out
	 * of the rendered DOM and into the document `<head>`.
	 *
	 * It is common to use this render method in conjunction with a custom element
	 * which renders a shadowRoot. When this is done, typically the element's
	 * `localName` should be used as the `scopeName`.
	 *
	 * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
	 * custom properties (needed only on older browsers like IE11) and a shim for
	 * a deprecated feature called `@apply` that supports applying a set of css
	 * custom properties to a given location.
	 *
	 * Usage considerations:
	 *
	 * * Part values in `<style>` elements are only applied the first time a given
	 * `scopeName` renders. Subsequent changes to parts in style elements will have
	 * no effect. Because of this, parts in style elements should only be used for
	 * values that will never change, for example parts that set scope-wide theme
	 * values or parts which render shared style elements.
	 *
	 * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
	 * custom element's `constructor` is not supported. Instead rendering should
	 * either done asynchronously, for example at microtask timing (for example
	 * `Promise.resolve()`), or be deferred until the first time the element's
	 * `connectedCallback` runs.
	 *
	 * Usage considerations when using shimmed custom properties or `@apply`:
	 *
	 * * Whenever any dynamic changes are made which affect
	 * css custom properties, `ShadyCSS.styleElement(element)` must be called
	 * to update the element. There are two cases when this is needed:
	 * (1) the element is connected to a new parent, (2) a class is added to the
	 * element that causes it to match different custom properties.
	 * To address the first case when rendering a custom element, `styleElement`
	 * should be called in the element's `connectedCallback`.
	 *
	 * * Shimmed custom properties may only be defined either for an entire
	 * shadowRoot (for example, in a `:host` rule) or via a rule that directly
	 * matches an element with a shadowRoot. In other words, instead of flowing from
	 * parent to child as do native css custom properties, shimmed custom properties
	 * flow only from shadowRoots to nested shadowRoots.
	 *
	 * * When using `@apply` mixing css shorthand property names with
	 * non-shorthand names (for example `border` and `border-width`) is not
	 * supported.
	 */


	var render = function render(result, container, options) {
	  if (!options || _typeof(options) !== 'object' || !options.scopeName) {
	    throw new Error('The `scopeName` option is required.');
	  }

	  var scopeName = options.scopeName;
	  var hasRendered = parts.has(container);
	  var needsScoping = compatibleShadyCSSVersion && container.nodeType === 11
	  /* Node.DOCUMENT_FRAGMENT_NODE */
	  && !!container.host; // Handle first render to a scope specially...

	  var firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single
	  // fragment that is reused since nested renders can occur synchronously.

	  var renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
	  render$1(result, renderContainer, Object.assign({
	    templateFactory: shadyTemplateFactory(scopeName)
	  }, options)); // When performing first scope render,
	  // (1) We've rendered into a fragment so that there's a chance to
	  // `prepareTemplateStyles` before sub-elements hit the DOM
	  // (which might cause them to render based on a common pattern of
	  // rendering in a custom element's `connectedCallback`);
	  // (2) Scope the template with ShadyCSS one time only for this scope.
	  // (3) Render the fragment into the container and make sure the
	  // container knows its `part` is the one we just rendered. This ensures
	  // DOM will be re-used on subsequent renders.

	  if (firstScopeRender) {
	    var part = parts.get(renderContainer);
	    parts.delete(renderContainer); // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
	    // that should apply to `renderContainer` even if the rendered value is
	    // not a TemplateInstance. However, it will only insert scoped styles
	    // into the document if `prepareTemplateStyles` has already been called
	    // for the given scope name.

	    var template = part.value instanceof TemplateInstance ? part.value.template : undefined;
	    prepareTemplateStyles(scopeName, renderContainer, template);
	    removeNodes(container, container.firstChild);
	    container.appendChild(renderContainer);
	    parts.set(container, part);
	  } // After elements have hit the DOM, update styling if this is the
	  // initial render to this container.
	  // This is needed whenever dynamic changes are made so it would be
	  // safest to do every render; however, this would regress performance
	  // so we leave it up to the user to call `ShadyCSS.styleElement`
	  // for dynamic changes.


	  if (!hasRendered && needsScoping) {
	    window.ShadyCSS.styleElement(container.host);
	  }
	};

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var _a$1;
	/**
	 * Use this module if you want to create your own base class extending
	 * [[UpdatingElement]].
	 * @packageDocumentation
	 */

	/*
	 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
	 * replaced at compile time by the munged name for object[property]. We cannot
	 * alias this function, so we have to use a small shim that has the same
	 * behavior when not compiling.
	 */


	window.JSCompiler_renameProperty = function (prop, _obj) {
	  return prop;
	};

	var defaultConverter = {
	  toAttribute: function toAttribute(value, type) {
	    switch (type) {
	      case Boolean:
	        return value ? '' : null;

	      case Object:
	      case Array:
	        // if the value is `null` or `undefined` pass this through
	        // to allow removing/no change behavior.
	        return value == null ? value : JSON.stringify(value);
	    }

	    return value;
	  },
	  fromAttribute: function fromAttribute(value, type) {
	    switch (type) {
	      case Boolean:
	        return value !== null;

	      case Number:
	        return value === null ? null : Number(value);

	      case Object:
	      case Array:
	        // Type assert to adhere to Bazel's "must type assert JSON parse" rule.
	        return JSON.parse(value);
	    }

	    return value;
	  }
	};
	/**
	 * Change function that returns true if `value` is different from `oldValue`.
	 * This method is used as the default for a property's `hasChanged` function.
	 */

	var notEqual = function notEqual(value, old) {
	  // This ensures (old==NaN, value==NaN) always returns false
	  return old !== value && (old === old || value === value);
	};
	var defaultPropertyDeclaration = {
	  attribute: true,
	  type: String,
	  converter: defaultConverter,
	  reflect: false,
	  hasChanged: notEqual
	};
	var STATE_HAS_UPDATED = 1;
	var STATE_UPDATE_REQUESTED = 1 << 2;
	var STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
	var STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
	/**
	 * The Closure JS Compiler doesn't currently have good support for static
	 * property semantics where "this" is dynamic (e.g.
	 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
	 * this hack to bypass any rewriting by the compiler.
	 */

	var finalized = 'finalized';
	/**
	 * Base element class which manages element properties and attributes. When
	 * properties change, the `update` method is asynchronously called. This method
	 * should be supplied by subclassers to render updates as desired.
	 * @noInheritDoc
	 */

	var UpdatingElement = /*#__PURE__*/function (_HTMLElement) {
	  _inherits(UpdatingElement, _HTMLElement);

	  var _super = _createSuper(UpdatingElement);

	  function UpdatingElement() {
	    var _this;

	    _classCallCheck(this, UpdatingElement);

	    _this = _super.call(this);

	    _this.initialize();

	    return _this;
	  }
	  /**
	   * Returns a list of attributes corresponding to the registered properties.
	   * @nocollapse
	   */


	  _createClass(UpdatingElement, [{
	    key: "initialize",
	    value:
	    /**
	     * Performs element initialization. By default captures any pre-set values for
	     * registered properties.
	     */
	    function initialize() {
	      var _this2 = this;

	      this._updateState = 0;
	      this._updatePromise = new Promise(function (res) {
	        return _this2._enableUpdatingResolver = res;
	      });
	      this._changedProperties = new Map();

	      this._saveInstanceProperties(); // ensures first update will be caught by an early access of
	      // `updateComplete`


	      this.requestUpdateInternal();
	    }
	    /**
	     * Fixes any properties set on the instance before upgrade time.
	     * Otherwise these would shadow the accessor and break these properties.
	     * The properties are stored in a Map which is played back after the
	     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
	     * (<=41), properties created for native platform properties like (`id` or
	     * `name`) may not have default values set in the element constructor. On
	     * these browsers native properties appear on instances and therefore their
	     * default value will overwrite any element default (e.g. if the element sets
	     * this.id = 'id' in the constructor, the 'id' will become '' since this is
	     * the native platform default).
	     */

	  }, {
	    key: "_saveInstanceProperties",
	    value: function _saveInstanceProperties() {
	      var _this3 = this;

	      // Use forEach so this works even if for/of loops are compiled to for loops
	      // expecting arrays
	      this.constructor._classProperties.forEach(function (_v, p) {
	        if (_this3.hasOwnProperty(p)) {
	          var value = _this3[p];
	          delete _this3[p];

	          if (!_this3._instanceProperties) {
	            _this3._instanceProperties = new Map();
	          }

	          _this3._instanceProperties.set(p, value);
	        }
	      });
	    }
	    /**
	     * Applies previously saved instance properties.
	     */

	  }, {
	    key: "_applyInstanceProperties",
	    value: function _applyInstanceProperties() {
	      var _this4 = this;

	      // Use forEach so this works even if for/of loops are compiled to for loops
	      // expecting arrays
	      // tslint:disable-next-line:no-any
	      this._instanceProperties.forEach(function (v, p) {
	        return _this4[p] = v;
	      });

	      this._instanceProperties = undefined;
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      // Ensure first connection completes an update. Updates cannot complete
	      // before connection.
	      this.enableUpdating();
	    }
	  }, {
	    key: "enableUpdating",
	    value: function enableUpdating() {
	      if (this._enableUpdatingResolver !== undefined) {
	        this._enableUpdatingResolver();

	        this._enableUpdatingResolver = undefined;
	      }
	    }
	    /**
	     * Allows for `super.disconnectedCallback()` in extensions while
	     * reserving the possibility of making non-breaking feature additions
	     * when disconnecting at some point in the future.
	     */

	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {}
	    /**
	     * Synchronizes property values when attributes change.
	     */

	  }, {
	    key: "attributeChangedCallback",
	    value: function attributeChangedCallback(name, old, value) {
	      if (old !== value) {
	        this._attributeToProperty(name, value);
	      }
	    }
	  }, {
	    key: "_propertyToAttribute",
	    value: function _propertyToAttribute(name, value) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPropertyDeclaration;
	      var ctor = this.constructor;

	      var attr = ctor._attributeNameForProperty(name, options);

	      if (attr !== undefined) {
	        var attrValue = ctor._propertyValueToAttribute(value, options); // an undefined value does not change the attribute.


	        if (attrValue === undefined) {
	          return;
	        } // Track if the property is being reflected to avoid
	        // setting the property again via `attributeChangedCallback`. Note:
	        // 1. this takes advantage of the fact that the callback is synchronous.
	        // 2. will behave incorrectly if multiple attributes are in the reaction
	        // stack at time of calling. However, since we process attributes
	        // in `update` this should not be possible (or an extreme corner case
	        // that we'd like to discover).
	        // mark state reflecting


	        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;

	        if (attrValue == null) {
	          this.removeAttribute(attr);
	        } else {
	          this.setAttribute(attr, attrValue);
	        } // mark state not reflecting


	        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
	      }
	    }
	  }, {
	    key: "_attributeToProperty",
	    value: function _attributeToProperty(name, value) {
	      // Use tracking info to avoid deserializing attribute value if it was
	      // just set from a property setter.
	      if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
	        return;
	      }

	      var ctor = this.constructor; // Note, hint this as an `AttributeMap` so closure clearly understands
	      // the type; it has issues with tracking types through statics
	      // tslint:disable-next-line:no-unnecessary-type-assertion

	      var propName = ctor._attributeToPropertyMap.get(name);

	      if (propName !== undefined) {
	        var options = ctor.getPropertyOptions(propName); // mark state reflecting

	        this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
	        this[propName] = // tslint:disable-next-line:no-any
	        ctor._propertyValueFromAttribute(value, options); // mark state not reflecting

	        this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
	      }
	    }
	    /**
	     * This protected version of `requestUpdate` does not access or return the
	     * `updateComplete` promise. This promise can be overridden and is therefore
	     * not free to access.
	     */

	  }, {
	    key: "requestUpdateInternal",
	    value: function requestUpdateInternal(name, oldValue, options) {
	      var shouldRequestUpdate = true; // If we have a property key, perform property update steps.

	      if (name !== undefined) {
	        var ctor = this.constructor;
	        options = options || ctor.getPropertyOptions(name);

	        if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
	          if (!this._changedProperties.has(name)) {
	            this._changedProperties.set(name, oldValue);
	          } // Add to reflecting properties set.
	          // Note, it's important that every change has a chance to add the
	          // property to `_reflectingProperties`. This ensures setting
	          // attribute + property reflects correctly.


	          if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
	            if (this._reflectingProperties === undefined) {
	              this._reflectingProperties = new Map();
	            }

	            this._reflectingProperties.set(name, options);
	          }
	        } else {
	          // Abort the request if the property should not be considered changed.
	          shouldRequestUpdate = false;
	        }
	      }

	      if (!this._hasRequestedUpdate && shouldRequestUpdate) {
	        this._updatePromise = this._enqueueUpdate();
	      }
	    }
	    /**
	     * Requests an update which is processed asynchronously. This should
	     * be called when an element should update based on some state not triggered
	     * by setting a property. In this case, pass no arguments. It should also be
	     * called when manually implementing a property setter. In this case, pass the
	     * property `name` and `oldValue` to ensure that any configured property
	     * options are honored. Returns the `updateComplete` Promise which is resolved
	     * when the update completes.
	     *
	     * @param name {PropertyKey} (optional) name of requesting property
	     * @param oldValue {any} (optional) old value of requesting property
	     * @returns {Promise} A Promise that is resolved when the update completes.
	     */

	  }, {
	    key: "requestUpdate",
	    value: function requestUpdate(name, oldValue) {
	      this.requestUpdateInternal(name, oldValue);
	      return this.updateComplete;
	    }
	    /**
	     * Sets up the element to asynchronously update.
	     */

	  }, {
	    key: "_enqueueUpdate",
	    value: function () {
	      var _enqueueUpdate2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var result;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
	                _context.prev = 1;
	                _context.next = 4;
	                return this._updatePromise;

	              case 4:
	                _context.next = 8;
	                break;

	              case 6:
	                _context.prev = 6;
	                _context.t0 = _context["catch"](1);

	              case 8:
	                result = this.performUpdate(); // If `performUpdate` returns a Promise, we await it. This is done to
	                // enable coordinating updates with a scheduler. Note, the result is
	                // checked to avoid delaying an additional microtask unless we need to.

	                if (!(result != null)) {
	                  _context.next = 12;
	                  break;
	                }

	                _context.next = 12;
	                return result;

	              case 12:
	                return _context.abrupt("return", !this._hasRequestedUpdate);

	              case 13:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[1, 6]]);
	      }));

	      function _enqueueUpdate() {
	        return _enqueueUpdate2.apply(this, arguments);
	      }

	      return _enqueueUpdate;
	    }()
	  }, {
	    key: "_hasRequestedUpdate",
	    get: function get() {
	      return this._updateState & STATE_UPDATE_REQUESTED;
	    }
	  }, {
	    key: "hasUpdated",
	    get: function get() {
	      return this._updateState & STATE_HAS_UPDATED;
	    }
	    /**
	     * Performs an element update. Note, if an exception is thrown during the
	     * update, `firstUpdated` and `updated` will not be called.
	     *
	     * You can override this method to change the timing of updates. If this
	     * method is overridden, `super.performUpdate()` must be called.
	     *
	     * For instance, to schedule updates to occur just before the next frame:
	     *
	     * ```
	     * protected async performUpdate(): Promise<unknown> {
	     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
	     *   super.performUpdate();
	     * }
	     * ```
	     */

	  }, {
	    key: "performUpdate",
	    value: function performUpdate() {
	      // Abort any update if one is not pending when this is called.
	      // This can happen if `performUpdate` is called early to "flush"
	      // the update.
	      if (!this._hasRequestedUpdate) {
	        return;
	      } // Mixin instance properties once, if they exist.


	      if (this._instanceProperties) {
	        this._applyInstanceProperties();
	      }

	      var shouldUpdate = false;
	      var changedProperties = this._changedProperties;

	      try {
	        shouldUpdate = this.shouldUpdate(changedProperties);

	        if (shouldUpdate) {
	          this.update(changedProperties);
	        } else {
	          this._markUpdated();
	        }
	      } catch (e) {
	        // Prevent `firstUpdated` and `updated` from running when there's an
	        // update exception.
	        shouldUpdate = false; // Ensure element can accept additional updates after an exception.

	        this._markUpdated();

	        throw e;
	      }

	      if (shouldUpdate) {
	        if (!(this._updateState & STATE_HAS_UPDATED)) {
	          this._updateState = this._updateState | STATE_HAS_UPDATED;
	          this.firstUpdated(changedProperties);
	        }

	        this.updated(changedProperties);
	      }
	    }
	  }, {
	    key: "_markUpdated",
	    value: function _markUpdated() {
	      this._changedProperties = new Map();
	      this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
	    }
	    /**
	     * Returns a Promise that resolves when the element has completed updating.
	     * The Promise value is a boolean that is `true` if the element completed the
	     * update without triggering another update. The Promise result is `false` if
	     * a property was set inside `updated()`. If the Promise is rejected, an
	     * exception was thrown during the update.
	     *
	     * To await additional asynchronous work, override the `_getUpdateComplete`
	     * method. For example, it is sometimes useful to await a rendered element
	     * before fulfilling this Promise. To do this, first await
	     * `super._getUpdateComplete()`, then any subsequent state.
	     *
	     * @returns {Promise} The Promise returns a boolean that indicates if the
	     * update resolved without triggering another update.
	     */

	  }, {
	    key: "updateComplete",
	    get: function get() {
	      return this._getUpdateComplete();
	    }
	    /**
	     * Override point for the `updateComplete` promise.
	     *
	     * It is not safe to override the `updateComplete` getter directly due to a
	     * limitation in TypeScript which means it is not possible to call a
	     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
	     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
	     * This method should be overridden instead. For example:
	     *
	     *   class MyElement extends LitElement {
	     *     async _getUpdateComplete() {
	     *       await super._getUpdateComplete();
	     *       await this._myChild.updateComplete;
	     *     }
	     *   }
	     * @deprecated Override `getUpdateComplete()` instead for forward
	     *     compatibility with `lit-element` 3.0 / `@lit/reactive-element`.
	     */

	  }, {
	    key: "_getUpdateComplete",
	    value: function _getUpdateComplete() {
	      return this.getUpdateComplete();
	    }
	    /**
	     * Override point for the `updateComplete` promise.
	     *
	     * It is not safe to override the `updateComplete` getter directly due to a
	     * limitation in TypeScript which means it is not possible to call a
	     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
	     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
	     * This method should be overridden instead. For example:
	     *
	     *   class MyElement extends LitElement {
	     *     async getUpdateComplete() {
	     *       await super.getUpdateComplete();
	     *       await this._myChild.updateComplete;
	     *     }
	     *   }
	     */

	  }, {
	    key: "getUpdateComplete",
	    value: function getUpdateComplete() {
	      return this._updatePromise;
	    }
	    /**
	     * Controls whether or not `update` should be called when the element requests
	     * an update. By default, this method always returns `true`, but this can be
	     * customized to control when to update.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "shouldUpdate",
	    value: function shouldUpdate(_changedProperties) {
	      return true;
	    }
	    /**
	     * Updates the element. This method reflects property values to attributes.
	     * It can be overridden to render and keep updated element DOM.
	     * Setting properties inside this method will *not* trigger
	     * another update.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "update",
	    value: function update(_changedProperties) {
	      var _this5 = this;

	      if (this._reflectingProperties !== undefined && this._reflectingProperties.size > 0) {
	        // Use forEach so this works even if for/of loops are compiled to for
	        // loops expecting arrays
	        this._reflectingProperties.forEach(function (v, k) {
	          return _this5._propertyToAttribute(k, _this5[k], v);
	        });

	        this._reflectingProperties = undefined;
	      }

	      this._markUpdated();
	    }
	    /**
	     * Invoked whenever the element is updated. Implement to perform
	     * post-updating tasks via DOM APIs, for example, focusing an element.
	     *
	     * Setting properties inside this method will trigger the element to update
	     * again after this update cycle completes.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "updated",
	    value: function updated(_changedProperties) {}
	    /**
	     * Invoked when the element is first updated. Implement to perform one time
	     * work on the element after update.
	     *
	     * Setting properties inside this method will trigger the element to update
	     * again after this update cycle completes.
	     *
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "firstUpdated",
	    value: function firstUpdated(_changedProperties) {}
	  }], [{
	    key: "observedAttributes",
	    get: function get() {
	      var _this6 = this;

	      // note: piggy backing on this to ensure we're finalized.
	      this.finalize();
	      var attributes = []; // Use forEach so this works even if for/of loops are compiled to for loops
	      // expecting arrays

	      this._classProperties.forEach(function (v, p) {
	        var attr = _this6._attributeNameForProperty(p, v);

	        if (attr !== undefined) {
	          _this6._attributeToPropertyMap.set(attr, p);

	          attributes.push(attr);
	        }
	      });

	      return attributes;
	    }
	    /**
	     * Ensures the private `_classProperties` property metadata is created.
	     * In addition to `finalize` this is also called in `createProperty` to
	     * ensure the `@property` decorator can add property metadata.
	     */

	    /** @nocollapse */

	  }, {
	    key: "_ensureClassProperties",
	    value: function _ensureClassProperties() {
	      var _this7 = this;

	      // ensure private storage for property declarations.
	      if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
	        this._classProperties = new Map(); // NOTE: Workaround IE11 not supporting Map constructor argument.

	        var superProperties = Object.getPrototypeOf(this)._classProperties;

	        if (superProperties !== undefined) {
	          superProperties.forEach(function (v, k) {
	            return _this7._classProperties.set(k, v);
	          });
	        }
	      }
	    }
	    /**
	     * Creates a property accessor on the element prototype if one does not exist
	     * and stores a PropertyDeclaration for the property with the given options.
	     * The property setter calls the property's `hasChanged` property option
	     * or uses a strict identity check to determine whether or not to request
	     * an update.
	     *
	     * This method may be overridden to customize properties; however,
	     * when doing so, it's important to call `super.createProperty` to ensure
	     * the property is setup correctly. This method calls
	     * `getPropertyDescriptor` internally to get a descriptor to install.
	     * To customize what properties do when they are get or set, override
	     * `getPropertyDescriptor`. To customize the options for a property,
	     * implement `createProperty` like this:
	     *
	     * static createProperty(name, options) {
	     *   options = Object.assign(options, {myOption: true});
	     *   super.createProperty(name, options);
	     * }
	     *
	     * @nocollapse
	     */

	  }, {
	    key: "createProperty",
	    value: function createProperty(name) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultPropertyDeclaration;

	      // Note, since this can be called by the `@property` decorator which
	      // is called before `finalize`, we ensure storage exists for property
	      // metadata.
	      this._ensureClassProperties();

	      this._classProperties.set(name, options); // Do not generate an accessor if the prototype already has one, since
	      // it would be lost otherwise and that would never be the user's intention;
	      // Instead, we expect users to call `requestUpdate` themselves from
	      // user-defined accessors. Note that if the super has an accessor we will
	      // still overwrite it


	      if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
	        return;
	      }

	      var key = _typeof(name) === 'symbol' ? Symbol() : "__".concat(name);
	      var descriptor = this.getPropertyDescriptor(name, key, options);

	      if (descriptor !== undefined) {
	        Object.defineProperty(this.prototype, name, descriptor);
	      }
	    }
	    /**
	     * Returns a property descriptor to be defined on the given named property.
	     * If no descriptor is returned, the property will not become an accessor.
	     * For example,
	     *
	     *   class MyElement extends LitElement {
	     *     static getPropertyDescriptor(name, key, options) {
	     *       const defaultDescriptor =
	     *           super.getPropertyDescriptor(name, key, options);
	     *       const setter = defaultDescriptor.set;
	     *       return {
	     *         get: defaultDescriptor.get,
	     *         set(value) {
	     *           setter.call(this, value);
	     *           // custom action.
	     *         },
	     *         configurable: true,
	     *         enumerable: true
	     *       }
	     *     }
	     *   }
	     *
	     * @nocollapse
	     */

	  }, {
	    key: "getPropertyDescriptor",
	    value: function getPropertyDescriptor(name, key, options) {
	      return {
	        // tslint:disable-next-line:no-any no symbol in index
	        get: function get() {
	          return this[key];
	        },
	        set: function set(value) {
	          var oldValue = this[name];
	          this[key] = value;
	          this.requestUpdateInternal(name, oldValue, options);
	        },
	        configurable: true,
	        enumerable: true
	      };
	    }
	    /**
	     * Returns the property options associated with the given property.
	     * These options are defined with a PropertyDeclaration via the `properties`
	     * object or the `@property` decorator and are registered in
	     * `createProperty(...)`.
	     *
	     * Note, this method should be considered "final" and not overridden. To
	     * customize the options for a given property, override `createProperty`.
	     *
	     * @nocollapse
	     * @final
	     */

	  }, {
	    key: "getPropertyOptions",
	    value: function getPropertyOptions(name) {
	      return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
	    }
	    /**
	     * Creates property accessors for registered properties and ensures
	     * any superclasses are also finalized.
	     * @nocollapse
	     */

	  }, {
	    key: "finalize",
	    value: function finalize() {
	      // finalize any superclasses
	      var superCtor = Object.getPrototypeOf(this);

	      if (!superCtor.hasOwnProperty(finalized)) {
	        superCtor.finalize();
	      }

	      this[finalized] = true;

	      this._ensureClassProperties(); // initialize Map populated in observedAttributes


	      this._attributeToPropertyMap = new Map(); // make any properties
	      // Note, only process "own" properties since this element will inherit
	      // any properties defined on the superClass, and finalization ensures
	      // the entire prototype chain is finalized.

	      if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
	        var props = this.properties; // support symbols in properties (IE11 does not support this)

	        var propKeys = [].concat(_toConsumableArray(Object.getOwnPropertyNames(props)), _toConsumableArray(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : [])); // This for/of is ok because propKeys is an array

	        var _iterator = _createForOfIteratorHelper(propKeys),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var p = _step.value;
	            // note, use of `any` is due to TypeSript lack of support for symbol in
	            // index types
	            // tslint:disable-next-line:no-any no symbol in index
	            this.createProperty(p, props[p]);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	      }
	    }
	    /**
	     * Returns the property name for the given attribute `name`.
	     * @nocollapse
	     */

	  }, {
	    key: "_attributeNameForProperty",
	    value: function _attributeNameForProperty(name, options) {
	      var attribute = options.attribute;
	      return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;
	    }
	    /**
	     * Returns true if a property should request an update.
	     * Called when a property value is set and uses the `hasChanged`
	     * option for the property if present or a strict identity check.
	     * @nocollapse
	     */

	  }, {
	    key: "_valueHasChanged",
	    value: function _valueHasChanged(value, old) {
	      var hasChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : notEqual;
	      return hasChanged(value, old);
	    }
	    /**
	     * Returns the property value for the given attribute value.
	     * Called via the `attributeChangedCallback` and uses the property's
	     * `converter` or `converter.fromAttribute` property option.
	     * @nocollapse
	     */

	  }, {
	    key: "_propertyValueFromAttribute",
	    value: function _propertyValueFromAttribute(value, options) {
	      var type = options.type;
	      var converter = options.converter || defaultConverter;
	      var fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;
	      return fromAttribute ? fromAttribute(value, type) : value;
	    }
	    /**
	     * Returns the attribute value for the given property value. If this
	     * returns undefined, the property will *not* be reflected to an attribute.
	     * If this returns null, the attribute will be removed, otherwise the
	     * attribute will be set to the value.
	     * This uses the property's `reflect` and `type.toAttribute` property options.
	     * @nocollapse
	     */

	  }, {
	    key: "_propertyValueToAttribute",
	    value: function _propertyValueToAttribute(value, options) {
	      if (options.reflect === undefined) {
	        return;
	      }

	      var type = options.type;
	      var converter = options.converter;
	      var toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
	      return toAttribute(value, type);
	    }
	  }]);

	  return UpdatingElement;
	}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
	_a$1 = finalized;
	/**
	 * Marks class as having finished creating properties.
	 */

	UpdatingElement[_a$1] = true;

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var legacyCustomElement = function legacyCustomElement(tagName, clazz) {
	  window.customElements.define(tagName, clazz); // Cast as any because TS doesn't recognize the return type as being a
	  // subtype of the decorated class when clazz is typed as
	  // `Constructor<HTMLElement>` for some reason.
	  // `Constructor<HTMLElement>` is helpful to make sure the decorator is
	  // applied to elements however.
	  // tslint:disable-next-line:no-any

	  return clazz;
	};

	var standardCustomElement = function standardCustomElement(tagName, descriptor) {
	  var kind = descriptor.kind,
	      elements = descriptor.elements;
	  return {
	    kind: kind,
	    elements: elements,
	    // This callback is called once the class is otherwise fully defined
	    finisher: function finisher(clazz) {
	      window.customElements.define(tagName, clazz);
	    }
	  };
	};
	/**
	 * Class decorator factory that defines the decorated class as a custom element.
	 *
	 * ```
	 * @customElement('my-element')
	 * class MyElement {
	 *   render() {
	 *     return html``;
	 *   }
	 * }
	 * ```
	 * @category Decorator
	 * @param tagName The name of the custom element to define.
	 */


	var customElement = function customElement(tagName) {
	  return function (classOrDescriptor) {
	    return typeof classOrDescriptor === 'function' ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
	  };
	};

	var standardProperty = function standardProperty(options, element) {
	  // When decorating an accessor, pass it through and add property metadata.
	  // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
	  // stomp over the user's accessor.
	  if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
	    return Object.assign(Object.assign({}, element), {
	      finisher: function finisher(clazz) {
	        clazz.createProperty(element.key, options);
	      }
	    });
	  } else {
	    // createProperty() takes care of defining the property, but we still
	    // must return some kind of descriptor, so return a descriptor for an
	    // unused prototype field. The finisher calls createProperty().
	    return {
	      kind: 'field',
	      key: Symbol(),
	      placement: 'own',
	      descriptor: {},
	      // When @babel/plugin-proposal-decorators implements initializers,
	      // do this instead of the initializer below. See:
	      // https://github.com/babel/babel/issues/9260 extras: [
	      //   {
	      //     kind: 'initializer',
	      //     placement: 'own',
	      //     initializer: descriptor.initializer,
	      //   }
	      // ],
	      initializer: function initializer() {
	        if (typeof element.initializer === 'function') {
	          this[element.key] = element.initializer.call(this);
	        }
	      },
	      finisher: function finisher(clazz) {
	        clazz.createProperty(element.key, options);
	      }
	    };
	  }
	};

	var legacyProperty = function legacyProperty(options, proto, name) {
	  proto.constructor.createProperty(name, options);
	};
	/**
	 * A property decorator which creates a LitElement property which reflects a
	 * corresponding attribute value. A [[`PropertyDeclaration`]] may optionally be
	 * supplied to configure property features.
	 *
	 * This decorator should only be used for public fields. Private or protected
	 * fields should use the [[`internalProperty`]] decorator.
	 *
	 * @example
	 * ```ts
	 * class MyElement {
	 *   @property({ type: Boolean })
	 *   clicked = false;
	 * }
	 * ```
	 * @category Decorator
	 * @ExportDecoratedItems
	 */


	function property$1(options) {
	  // tslint:disable-next-line:no-any decorator
	  return function (protoOrDescriptor, name) {
	    return name !== undefined ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
	  };
	}
	/**
	 * Declares a private or protected property that still triggers updates to the
	 * element when it changes.
	 *
	 * Properties declared this way must not be used from HTML or HTML templating
	 * systems, they're solely for properties internal to the element. These
	 * properties may be renamed by optimization tools like the Closure Compiler.
	 * @category Decorator
	 * @deprecated `internalProperty` has been renamed to `state` in lit-element
	 *     3.0. Please update to `state` now to be compatible with 3.0.
	 */

	function internalProperty(options) {
	  return property$1({
	    attribute: false,
	    hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged
	  });
	}
	/**
	 * Declares a private or protected property that still triggers updates to the
	 * element when it changes.
	 *
	 * Properties declared this way must not be used from HTML or HTML templating
	 * systems, they're solely for properties internal to the element. These
	 * properties may be renamed by optimization tools like the Closure Compiler.
	 * @category Decorator
	 */

	var state = function state(options) {
	  return internalProperty(options);
	};
	/**
	 * A property decorator that converts a class property into a getter that
	 * executes a querySelector on the element's renderRoot.
	 *
	 * @param selector A DOMString containing one or more selectors to match.
	 * @param cache An optional boolean which when true performs the DOM query only
	 * once and caches the result.
	 *
	 * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
	 *
	 * @example
	 *
	 * ```ts
	 * class MyElement {
	 *   @query('#first')
	 *   first;
	 *
	 *   render() {
	 *     return html`
	 *       <div id="first"></div>
	 *       <div id="second"></div>
	 *     `;
	 *   }
	 * }
	 * ```
	 * @category Decorator
	 */

	function query(selector, cache) {
	  return function (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
	  name) {
	    var descriptor = {
	      get: function get() {
	        return this.renderRoot.querySelector(selector);
	      },
	      enumerable: true,
	      configurable: true
	    };

	    if (cache) {
	      var prop = name !== undefined ? name : protoOrDescriptor.key;
	      var key = _typeof(prop) === 'symbol' ? Symbol() : "__".concat(prop);

	      descriptor.get = function () {
	        if (this[key] === undefined) {
	          this[key] = this.renderRoot.querySelector(selector);
	        }

	        return this[key];
	      };
	    }

	    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
	  };
	} // Note, in the future, we may extend this decorator to support the use case
	/**
	 * A property decorator that converts a class property into a getter
	 * that executes a querySelectorAll on the element's renderRoot.
	 *
	 * @param selector A DOMString containing one or more selectors to match.
	 *
	 * See:
	 * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll
	 *
	 * @example
	 * ```ts
	 * class MyElement {
	 *   @queryAll('div')
	 *   divs;
	 *
	 *   render() {
	 *     return html`
	 *       <div id="first"></div>
	 *       <div id="second"></div>
	 *     `;
	 *   }
	 * }
	 * ```
	 * @category Decorator
	 */

	function queryAll(selector) {
	  return function (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
	  name) {
	    var descriptor = {
	      get: function get() {
	        return this.renderRoot.querySelectorAll(selector);
	      },
	      enumerable: true,
	      configurable: true
	    };
	    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
	  };
	}

	var legacyQuery = function legacyQuery(descriptor, proto, name) {
	  Object.defineProperty(proto, name, descriptor);
	};

	var standardQuery = function standardQuery(descriptor, element) {
	  return {
	    kind: 'method',
	    placement: 'prototype',
	    key: element.key,
	    descriptor: descriptor
	  };
	};

	/**
	@license
	Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
	This code may only be used under the BSD style license found at
	http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
	http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
	found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
	part of the polymer project is also subject to an additional IP rights grant
	found at http://polymer.github.io/PATENTS.txt
	*/

	/**
	 * Whether the current browser supports `adoptedStyleSheets`.
	 */
	var supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) && 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;
	var constructionToken = Symbol();
	var CSSResult = /*#__PURE__*/function () {
	  function CSSResult(cssText, safeToken) {
	    _classCallCheck(this, CSSResult);

	    if (safeToken !== constructionToken) {
	      throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
	    }

	    this.cssText = cssText;
	  } // Note, this is a getter so that it's lazy. In practice, this means
	  // stylesheets are not created until the first element instance is made.


	  _createClass(CSSResult, [{
	    key: "styleSheet",
	    get: function get() {
	      if (this._styleSheet === undefined) {
	        // Note, if `supportsAdoptingStyleSheets` is true then we assume
	        // CSSStyleSheet is constructable.
	        if (supportsAdoptingStyleSheets) {
	          this._styleSheet = new CSSStyleSheet();

	          this._styleSheet.replaceSync(this.cssText);
	        } else {
	          this._styleSheet = null;
	        }
	      }

	      return this._styleSheet;
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return this.cssText;
	    }
	  }]);

	  return CSSResult;
	}();
	/**
	 * Wrap a value for interpolation in a [[`css`]] tagged template literal.
	 *
	 * This is unsafe because untrusted CSS text can be used to phone home
	 * or exfiltrate data to an attacker controlled site. Take care to only use
	 * this with trusted input.
	 */

	var unsafeCSS = function unsafeCSS(value) {
	  return new CSSResult(String(value), constructionToken);
	};

	// This line will be used in regexes to search for LitElement usage.
	// TODO(justinfagnani): inject version number at build time

	(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.5.1');
	/**
	 * Sentinal value used to avoid calling lit-html's render function when
	 * subclasses do not implement `render`
	 */

	var renderNotImplemented = {};
	/**
	 * Base element class that manages element properties and attributes, and
	 * renders a lit-html template.
	 *
	 * To define a component, subclass `LitElement` and implement a
	 * `render` method to provide the component's template. Define properties
	 * using the [[`properties`]] property or the [[`property`]] decorator.
	 */

	var LitElement = /*#__PURE__*/function (_UpdatingElement) {
	  _inherits(LitElement, _UpdatingElement);

	  var _super = _createSuper(LitElement);

	  function LitElement() {
	    _classCallCheck(this, LitElement);

	    return _super.apply(this, arguments);
	  }

	  _createClass(LitElement, [{
	    key: "initialize",
	    value:
	    /**
	     * Performs element initialization. By default this calls
	     * [[`createRenderRoot`]] to create the element [[`renderRoot`]] node and
	     * captures any pre-set values for registered properties.
	     */
	    function initialize() {
	      _get(_getPrototypeOf(LitElement.prototype), "initialize", this).call(this);

	      this.constructor._getUniqueStyles();

	      this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
	      // element's getRootNode(). While this could be done, we're choosing not to
	      // support this now since it would require different logic around de-duping.

	      if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
	        this.adoptStyles();
	      }
	    }
	    /**
	     * Returns the node into which the element should render and by default
	     * creates and returns an open shadowRoot. Implement to customize where the
	     * element's DOM is rendered. For example, to render into the element's
	     * childNodes, return `this`.
	     * @returns {Element|DocumentFragment} Returns a node into which to render.
	     */

	  }, {
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      return this.attachShadow(this.constructor.shadowRootOptions);
	    }
	    /**
	     * Applies styling to the element shadowRoot using the [[`styles`]]
	     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
	     * available and will fallback otherwise. When Shadow DOM is polyfilled,
	     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
	     * is available but `adoptedStyleSheets` is not, styles are appended to the
	     * end of the `shadowRoot` to [mimic spec
	     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
	     */

	  }, {
	    key: "adoptStyles",
	    value: function adoptStyles() {
	      var styles = this.constructor._styles;

	      if (styles.length === 0) {
	        return;
	      } // There are three separate cases here based on Shadow DOM support.
	      // (1) shadowRoot polyfilled: use ShadyCSS
	      // (2) shadowRoot.adoptedStyleSheets available: use it
	      // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
	      // rendering


	      if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
	        window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(function (s) {
	          return s.cssText;
	        }), this.localName);
	      } else if (supportsAdoptingStyleSheets) {
	        this.renderRoot.adoptedStyleSheets = styles.map(function (s) {
	          return s instanceof CSSStyleSheet ? s : s.styleSheet;
	        });
	      } else {
	        // This must be done after rendering so the actual style insertion is done
	        // in `update`.
	        this._needsShimAdoptedStyleSheets = true;
	      }
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(LitElement.prototype), "connectedCallback", this).call(this); // Note, first update/render handles styleElement so we only call this if
	      // connected after first update.


	      if (this.hasUpdated && window.ShadyCSS !== undefined) {
	        window.ShadyCSS.styleElement(this);
	      }
	    }
	    /**
	     * Updates the element. This method reflects property values to attributes
	     * and calls `render` to render DOM via lit-html. Setting properties inside
	     * this method will *not* trigger another update.
	     * @param _changedProperties Map of changed properties with old values
	     */

	  }, {
	    key: "update",
	    value: function update(changedProperties) {
	      var _this = this;

	      // Setting properties in `render` should not trigger an update. Since
	      // updates are allowed after super.update, it's important to call `render`
	      // before that.
	      var templateResult = this.render();

	      _get(_getPrototypeOf(LitElement.prototype), "update", this).call(this, changedProperties); // If render is not implemented by the component, don't call lit-html render


	      if (templateResult !== renderNotImplemented) {
	        this.constructor.render(templateResult, this.renderRoot, {
	          scopeName: this.localName,
	          eventContext: this
	        });
	      } // When native Shadow DOM is used but adoptedStyles are not supported,
	      // insert styling after rendering to ensure adoptedStyles have highest
	      // priority.


	      if (this._needsShimAdoptedStyleSheets) {
	        this._needsShimAdoptedStyleSheets = false;

	        this.constructor._styles.forEach(function (s) {
	          var style = document.createElement('style');
	          style.textContent = s.cssText;

	          _this.renderRoot.appendChild(style);
	        });
	      }
	    }
	    /**
	     * Invoked on each update to perform rendering tasks. This method may return
	     * any value renderable by lit-html's `NodePart` - typically a
	     * `TemplateResult`. Setting properties inside this method will *not* trigger
	     * the element to update.
	     */

	  }, {
	    key: "render",
	    value: function render() {
	      return renderNotImplemented;
	    }
	  }], [{
	    key: "getStyles",
	    value:
	    /**
	     * Return the array of styles to apply to the element.
	     * Override this method to integrate into a style management system.
	     *
	     * @nocollapse
	     */
	    function getStyles() {
	      return this.styles;
	    }
	    /** @nocollapse */

	  }, {
	    key: "_getUniqueStyles",
	    value: function _getUniqueStyles() {
	      // Only gather styles once per class
	      if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {
	        return;
	      } // Take care not to call `this.getStyles()` multiple times since this
	      // generates new CSSResults each time.
	      // TODO(sorvell): Since we do not cache CSSResults by input, any
	      // shared styles will generate new stylesheet objects, which is wasteful.
	      // This should be addressed when a browser ships constructable
	      // stylesheets.


	      var userStyles = this.getStyles();

	      if (Array.isArray(userStyles)) {
	        // De-duplicate styles preserving the _last_ instance in the set.
	        // This is a performance optimization to avoid duplicated styles that can
	        // occur especially when composing via subclassing.
	        // The last item is kept to try to preserve the cascade order with the
	        // assumption that it's most important that last added styles override
	        // previous styles.
	        var addStyles = function addStyles(styles, set) {
	          return styles.reduceRight(function (set, s) {
	            return (// Note: On IE set.add() does not return the set
	              Array.isArray(s) ? addStyles(s, set) : (set.add(s), set)
	            );
	          }, set);
	        }; // Array.from does not work on Set in IE, otherwise return
	        // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()


	        var set = addStyles(userStyles, new Set());
	        var styles = [];
	        set.forEach(function (v) {
	          return styles.unshift(v);
	        });
	        this._styles = styles;
	      } else {
	        this._styles = userStyles === undefined ? [] : [userStyles];
	      } // Ensure that there are no invalid CSSStyleSheet instances here. They are
	      // invalid in two conditions.
	      // (1) the sheet is non-constructible (`sheet` of a HTMLStyleElement), but
	      //     this is impossible to check except via .replaceSync or use
	      // (2) the ShadyCSS polyfill is enabled (:. supportsAdoptingStyleSheets is
	      //     false)


	      this._styles = this._styles.map(function (s) {
	        if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
	          // Flatten the cssText from the passed constructible stylesheet (or
	          // undetectable non-constructible stylesheet). The user might have
	          // expected to update their stylesheets over time, but the alternative
	          // is a crash.
	          var cssText = Array.prototype.slice.call(s.cssRules).reduce(function (css, rule) {
	            return css + rule.cssText;
	          }, '');
	          return unsafeCSS(cssText);
	        }

	        return s;
	      });
	    }
	  }]);

	  return LitElement;
	}(UpdatingElement);
	/**
	 * Ensure this class is marked as `finalized` as an optimization ensuring
	 * it will not needlessly try to `finalize`.
	 *
	 * Note this property name is a string to prevent breaking Closure JS Compiler
	 * optimizations. See updating-element.ts for more information.
	 */

	LitElement['finalized'] = true;
	/**
	 * Reference to the underlying library method used to render the element's
	 * DOM. By default, points to the `render` method from lit-html's shady-render
	 * module.
	 *
	 * **Most users will never need to touch this property.**
	 *
	 * This  property should not be confused with the `render` instance method,
	 * which should be overridden to define a template for the element.
	 *
	 * Advanced users creating a new base class based on LitElement can override
	 * this property to point to a custom render method with a signature that
	 * matches [shady-render's `render`
	 * method](https://lit-html.polymer-project.org/api/modules/shady_render.html#render).
	 *
	 * @nocollapse
	 */

	LitElement.render = render;
	/** @nocollapse */

	LitElement.shadowRootOptions = {
	  mode: 'open'
	};

	var _templateObject$o;

	var __decorate$r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var SliderElement = /*#__PURE__*/function (_LitElement) {
	  _inherits(SliderElement, _LitElement);

	  var _super = _createSuper(SliderElement);

	  function SliderElement() {
	    var _this;

	    _classCallCheck(this, SliderElement);

	    _this = _super.apply(this, arguments);

	    _this.prevClicked = function (e) {
	      e.preventDefault();
	      var prevSlideIndex = _this.closestChildIndex.value - 1;

	      if (prevSlideIndex > -1) {
	        _this.scrollWrapperEl.scrollTo(_this.slides[prevSlideIndex].left.value, 0);
	      }
	    };

	    _this.nextClicked = function (e) {
	      e.preventDefault();
	      var nextSlideIndex = _this.closestChildIndex.value + 1;

	      if (nextSlideIndex < _this.slides.length) {
	        _this.scrollWrapperEl.scrollTo(_this.slides[nextSlideIndex].left.value, 0);
	      }
	    };

	    return _this;
	  }

	  _createClass(SliderElement, [{
	    key: "firstUpdated",
	    value: function firstUpdated() {
	      var _this2 = this;

	      var slideEls = Array.from(this.slideElements);
	      var scrollX = read(function () {
	        return _this2.scrollWrapperEl.scrollLeft;
	      });
	      var scrollWidth = read(function () {
	        return _this2.scrollWrapperEl.scrollWidth;
	      });
	      var scrollElWidth = read(function () {
	        return _this2.scrollWrapperEl.clientWidth;
	      }); // calc(x => console.log(x), scrollX);
	      // calc(x => console.log(x), scrollWidth);

	      this.scrollEnd = calc(function (x, w, scrollW) {
	        return x >= scrollW - w - 34;
	      }, scrollX, scrollElWidth, scrollWidth);
	      this.scrollStart = calc(function (x) {
	        return x <= 34;
	      }, scrollX);
	      calc(function () {
	        return _this2.requestUpdate();
	      }, this.scrollEnd, this.scrollStart);
	      write(function (x) {
	        return x ? _this2.classList.add("or-slider-start") : _this2.classList.remove("or-slider-start");
	      }, this.scrollStart);
	      write(function (x) {
	        return x ? _this2.classList.add("or-slider-end") : _this2.classList.remove("or-slider-end");
	      }, this.scrollEnd);
	      this.slides = slideEls.map(function (el) {
	        var left = read(function () {
	          return el.offsetLeft;
	        });
	        var width = read(function () {
	          return el.clientWidth;
	        });
	        var computedStyle = read(function () {
	          return getComputedStyle(el);
	        });
	        var paddingLeft = calc(function (c) {
	          return parseFloat(c.paddingLeft);
	        }, computedStyle);
	        var paddingRight = calc(function (c) {
	          return parseFloat(c.paddingRight);
	        }, computedStyle);
	        var innerLeft = calc(function (l, p) {
	          return l + p;
	        }, left, paddingLeft);
	        var innerWidth = calc(function (w, l, r) {
	          return w - l - r;
	        }, width, paddingLeft, paddingRight);
	        var r = {
	          element: el,
	          left: left,
	          inView: calc(function (sx, sw, il, iw) {
	            return il >= sx && il + iw <= sx + sw;
	          }, scrollX, scrollElWidth, innerLeft, innerWidth)
	        };
	        write(function (i) {
	          return i ? el.classList.add("or-slide-visible") : el.classList.remove("or-slide-visible");
	        }, r.inView);
	        return r;
	      });
	      this.closestChildIndex = calc.apply(void 0, [function (x) {
	        var highest = Infinity;
	        var index = 0;

	        _this2.slides.forEach(function (obj, i) {
	          var difference = x - obj.left.value;
	          if (difference < 0) difference = -difference;

	          if (difference < highest) {
	            highest = difference;
	            index = i;
	          }
	        });

	        return index;
	      }, scrollX].concat(_toConsumableArray(this.slides.map(function (s) {
	        return s.left;
	      })))); // write(i => {
	      //     this.
	      //     this.scrollWrapperEl.children[i]?.classList.add("text-left")
	      // }, this.closestChildIndex);
	    }
	  }, {
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      return this;
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this3 = this;

	      _get(_getPrototypeOf(SliderElement.prototype), "connectedCallback", this).call(this);

	      this.initialChildren = Array.from(this.children);
	      window.addEventListener("resize", function () {
	        _this3.scrollWrapperEl.scrollTo(_this3.slides[_this3.closestChildIndex.value].left.value, 0);
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _a, _b;

	      return html(_templateObject$o || (_templateObject$o = _taggedTemplateLiteral(["\n            <div class=\"or-slider-wrapper\">\n                <div class=\"or-slider-scroll-wrapper\">\n                    ", "\n                </div>\n\n                <button class=\"or-slider-prev\"  @click=", " ?disabled=", ">\n                    <i aria-hidden=\"true\" class=\"far fa-chevron-left\"></i>\n                    <span class=\"sr-only\">Previous</span>\n                </button>\n\n                <button class=\"or-slider-next\"  @click=", " ?disabled=", ">\n                    <i aria-hidden=\"true\" class=\"far fa-chevron-right\"></i>\n                    <span class=\"sr-only\">Next</span>\n                </button>\n\n            </div>\n        "])), this.initialChildren, this.prevClicked, (_a = this.scrollStart) === null || _a === void 0 ? void 0 : _a.value, this.nextClicked, (_b = this.scrollEnd) === null || _b === void 0 ? void 0 : _b.value);
	    }
	  }]);

	  return SliderElement;
	}(LitElement);

	__decorate$r([query(".or-slider-scroll-wrapper")], SliderElement.prototype, "scrollWrapperEl", void 0);

	__decorate$r([queryAll(".or-slide")], SliderElement.prototype, "slideElements", void 0);

	__decorate$r([query(".or-slider-next")], SliderElement.prototype, "nextElement", void 0);

	SliderElement = __decorate$r([customElement("or-slider")], SliderElement);

	var ClassList = /*#__PURE__*/function () {
	  function ClassList(element) {
	    _classCallCheck(this, ClassList);

	    this.classes = new Set();
	    this.changed = false;
	    this.element = element;
	    var classList = (element.getAttribute('class') || '').split(/\s+/);

	    var _iterator = _createForOfIteratorHelper(classList),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var cls = _step.value;
	        this.classes.add(cls);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  }

	  _createClass(ClassList, [{
	    key: "add",
	    value: function add(cls) {
	      this.classes.add(cls);
	      this.changed = true;
	    }
	  }, {
	    key: "remove",
	    value: function remove(cls) {
	      this.classes.delete(cls);
	      this.changed = true;
	    }
	  }, {
	    key: "commit",
	    value: function commit() {
	      if (this.changed) {
	        var classString = '';
	        this.classes.forEach(function (cls) {
	          return classString += cls + ' ';
	        });
	        this.element.setAttribute('class', classString);
	      }
	    }
	  }]);

	  return ClassList;
	}();
	/**
	 * Stores the ClassInfo object applied to a given AttributePart.
	 * Used to unset existing values when a new ClassInfo object is applied.
	 */


	var previousClassesCache = new WeakMap();
	/**
	 * A directive that applies CSS classes. This must be used in the `class`
	 * attribute and must be the only part used in the attribute. It takes each
	 * property in the `classInfo` argument and adds the property name to the
	 * element's `class` if the property value is truthy; if the property value is
	 * falsey, the property name is removed from the element's `class`. For example
	 * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
	 * @param classInfo {ClassInfo}
	 */

	var classMap = directive(function (classInfo) {
	  return function (part) {
	    if (!(part instanceof AttributePart) || part instanceof PropertyPart || part.committer.name !== 'class' || part.committer.parts.length > 1) {
	      throw new Error('The `classMap` directive must be used in the `class` attribute ' + 'and must be the only part in the attribute.');
	    }

	    var committer = part.committer;
	    var element = committer.element;
	    var previousClasses = previousClassesCache.get(part);

	    if (previousClasses === undefined) {
	      // Write static classes once
	      // Use setAttribute() because className isn't a string on SVG elements
	      element.setAttribute('class', committer.strings.join(' '));
	      previousClassesCache.set(part, previousClasses = new Set());
	    }

	    var classList = element.classList || new ClassList(element); // Remove old classes that no longer apply
	    // We use forEach() instead of for-of so that re don't require down-level
	    // iteration.

	    previousClasses.forEach(function (name) {
	      if (!(name in classInfo)) {
	        classList.remove(name);
	        previousClasses.delete(name);
	      }
	    }); // Add or remove classes based on their classMap value

	    for (var name in classInfo) {
	      var value = classInfo[name];

	      if (value != previousClasses.has(name)) {
	        // We explicitly want a loose truthy check of `value` because it seems
	        // more convenient that '' and 0 are skipped.
	        if (value) {
	          classList.add(name);
	          previousClasses.add(name);
	        } else {
	          classList.remove(name);
	          previousClasses.delete(name);
	        }
	      }
	    }

	    if (typeof classList.commit === 'function') {
	      classList.commit();
	    }
	  };
	});

	var __awaiter$i = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};
	var BaseElement = /*#__PURE__*/function (_LitElement) {
	  _inherits(BaseElement, _LitElement);

	  var _super2 = _createSuper(BaseElement);

	  function BaseElement() {
	    _classCallCheck(this, BaseElement);

	    return _super2.apply(this, arguments);
	  }

	  _createClass(BaseElement, [{
	    key: "createRenderRoot",
	    value: function createRenderRoot() {
	      return this;
	    }
	  }, {
	    key: "performUpdate",
	    value: function performUpdate() {
	      var _this = this;

	      var _super = Object.create(null, {
	        performUpdate: {
	          get: function get() {
	            return _get(_getPrototypeOf(BaseElement.prototype), "performUpdate", _this);
	          }
	        }
	      });

	      return __awaiter$i(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return new Promise(function (resolve) {
	                  return write(function () {
	                    return resolve();
	                  });
	                });

	              case 2:
	                _super.performUpdate.call(this);

	              case 3:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }]);

	  return BaseElement;
	}(LitElement);

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	/* global Reflect, Promise */
	var _extendStatics = function extendStatics(d, b) {
	  _extendStatics = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) {
	      if (b.hasOwnProperty(p)) d[p] = b[p];
	    }
	  };

	  return _extendStatics(d, b);
	};

	function __extends(d, b) {
	  _extendStatics(d, b);

	  function __() {
	    this.constructor = d;
	  }

	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function isFunction$1(x) {
	  return typeof x === 'function';
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	var _enable_super_gross_mode_that_will_cause_bad_things = false;
	var config = {
	  Promise: undefined,

	  set useDeprecatedSynchronousErrorHandling(value) {
	    if (value) {
	      var error = /*@__PURE__*/new Error();
	      /*@__PURE__*/

	      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
	    }

	    _enable_super_gross_mode_that_will_cause_bad_things = value;
	  },

	  get useDeprecatedSynchronousErrorHandling() {
	    return _enable_super_gross_mode_that_will_cause_bad_things;
	  }

	};
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	function hostReportError(err) {
	  setTimeout(function () {
	    throw err;
	  });
	}
	/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */


	var empty = {
	  closed: true,
	  next: function next(value) {},
	  error: function error(err) {
	    if (config.useDeprecatedSynchronousErrorHandling) {
	      throw err;
	    } else {
	      hostReportError(err);
	    }
	  },
	  complete: function complete() {}
	};
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	var isArray$1 = Array.isArray || function (x) {
	  return x && typeof x.length === 'number';
	};
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function isObject$1(x) {
	  return x != null && _typeof(x) === 'object';
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	var errorObject = {
	  e: {}
	};
	/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */

	var tryCatchTarget;

	function tryCatcher() {
	  try {
	    return tryCatchTarget.apply(this, arguments);
	  } catch (e) {
	    errorObject.e = e;
	    return errorObject;
	  }
	}

	function tryCatch(fn) {
	  tryCatchTarget = fn;
	  return tryCatcher;
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function UnsubscriptionErrorImpl(errors) {
	  Error.call(this);
	  this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
	    return i + 1 + ") " + err.toString();
	  }).join('\n  ') : '';
	  this.name = 'UnsubscriptionError';
	  this.errors = errors;
	  return this;
	}

	UnsubscriptionErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);
	var UnsubscriptionError = UnsubscriptionErrorImpl;
	/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */

	var Subscription = /*@__PURE__*/function () {
	  function Subscription(unsubscribe) {
	    this.closed = false;
	    this._parent = null;
	    this._parents = null;
	    this._subscriptions = null;

	    if (unsubscribe) {
	      this._unsubscribe = unsubscribe;
	    }
	  }

	  Subscription.prototype.unsubscribe = function () {
	    var hasErrors = false;
	    var errors;

	    if (this.closed) {
	      return;
	    }

	    var _a = this,
	        _parent = _a._parent,
	        _parents = _a._parents,
	        _unsubscribe = _a._unsubscribe,
	        _subscriptions = _a._subscriptions;

	    this.closed = true;
	    this._parent = null;
	    this._parents = null;
	    this._subscriptions = null;
	    var index = -1;
	    var len = _parents ? _parents.length : 0;

	    while (_parent) {
	      _parent.remove(this);

	      _parent = ++index < len && _parents[index] || null;
	    }

	    if (isFunction$1(_unsubscribe)) {
	      var trial = tryCatch(_unsubscribe).call(this);

	      if (trial === errorObject) {
	        hasErrors = true;
	        errors = errors || (errorObject.e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
	      }
	    }

	    if (isArray$1(_subscriptions)) {
	      index = -1;
	      len = _subscriptions.length;

	      while (++index < len) {
	        var sub = _subscriptions[index];

	        if (isObject$1(sub)) {
	          var trial = tryCatch(sub.unsubscribe).call(sub);

	          if (trial === errorObject) {
	            hasErrors = true;
	            errors = errors || [];
	            var err = errorObject.e;

	            if (err instanceof UnsubscriptionError) {
	              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	            } else {
	              errors.push(err);
	            }
	          }
	        }
	      }
	    }

	    if (hasErrors) {
	      throw new UnsubscriptionError(errors);
	    }
	  };

	  Subscription.prototype.add = function (teardown) {
	    if (!teardown || teardown === Subscription.EMPTY) {
	      return Subscription.EMPTY;
	    }

	    if (teardown === this) {
	      return this;
	    }

	    var subscription = teardown;

	    switch (_typeof(teardown)) {
	      case 'function':
	        subscription = new Subscription(teardown);

	      case 'object':
	        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	          return subscription;
	        } else if (this.closed) {
	          subscription.unsubscribe();
	          return subscription;
	        } else if (typeof subscription._addParent !== 'function') {
	          var tmp = subscription;
	          subscription = new Subscription();
	          subscription._subscriptions = [tmp];
	        }

	        break;

	      default:
	        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	    }

	    var subscriptions = this._subscriptions || (this._subscriptions = []);
	    subscriptions.push(subscription);

	    subscription._addParent(this);

	    return subscription;
	  };

	  Subscription.prototype.remove = function (subscription) {
	    var subscriptions = this._subscriptions;

	    if (subscriptions) {
	      var subscriptionIndex = subscriptions.indexOf(subscription);

	      if (subscriptionIndex !== -1) {
	        subscriptions.splice(subscriptionIndex, 1);
	      }
	    }
	  };

	  Subscription.prototype._addParent = function (parent) {
	    var _a = this,
	        _parent = _a._parent,
	        _parents = _a._parents;

	    if (!_parent || _parent === parent) {
	      this._parent = parent;
	    } else if (!_parents) {
	      this._parents = [parent];
	    } else if (_parents.indexOf(parent) === -1) {
	      _parents.push(parent);
	    }
	  };

	  Subscription.EMPTY = function (empty) {
	    empty.closed = true;
	    return empty;
	  }(new Subscription());

	  return Subscription;
	}();

	function flattenUnsubscriptionErrors(errors) {
	  return errors.reduce(function (errs, err) {
	    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
	  }, []);
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	var rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? /*@__PURE__*/Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */

	var Subscriber = /*@__PURE__*/function (_super) {
	  __extends(Subscriber, _super);

	  function Subscriber(destinationOrNext, error, complete) {
	    var _this = _super.call(this) || this;

	    _this.syncErrorValue = null;
	    _this.syncErrorThrown = false;
	    _this.syncErrorThrowable = false;
	    _this.isStopped = false;
	    _this._parentSubscription = null;

	    switch (arguments.length) {
	      case 0:
	        _this.destination = empty;
	        break;

	      case 1:
	        if (!destinationOrNext) {
	          _this.destination = empty;
	          break;
	        }

	        if (_typeof(destinationOrNext) === 'object') {
	          if (isTrustedSubscriber(destinationOrNext)) {
	            var trustedSubscriber = destinationOrNext[rxSubscriber]();
	            _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
	            _this.destination = trustedSubscriber;

	            trustedSubscriber._addParentTeardownLogic(_this);
	          } else {
	            _this.syncErrorThrowable = true;
	            _this.destination = new SafeSubscriber(_this, destinationOrNext);
	          }

	          break;
	        }

	      default:
	        _this.syncErrorThrowable = true;
	        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
	        break;
	    }

	    return _this;
	  }

	  Subscriber.prototype[rxSubscriber] = function () {
	    return this;
	  };

	  Subscriber.create = function (next, error, complete) {
	    var subscriber = new Subscriber(next, error, complete);
	    subscriber.syncErrorThrowable = false;
	    return subscriber;
	  };

	  Subscriber.prototype.next = function (value) {
	    if (!this.isStopped) {
	      this._next(value);
	    }
	  };

	  Subscriber.prototype.error = function (err) {
	    if (!this.isStopped) {
	      this.isStopped = true;

	      this._error(err);

	      this._unsubscribeParentSubscription();
	    }
	  };

	  Subscriber.prototype.complete = function () {
	    if (!this.isStopped) {
	      this.isStopped = true;

	      this._complete();

	      this._unsubscribeParentSubscription();
	    }
	  };

	  Subscriber.prototype.unsubscribe = function () {
	    if (this.closed) {
	      return;
	    }

	    this.isStopped = true;

	    _super.prototype.unsubscribe.call(this);
	  };

	  Subscriber.prototype._next = function (value) {
	    this.destination.next(value);
	  };

	  Subscriber.prototype._error = function (err) {
	    this.destination.error(err);
	    this.unsubscribe();
	  };

	  Subscriber.prototype._complete = function () {
	    this.destination.complete();
	    this.unsubscribe();
	  };

	  Subscriber.prototype._addParentTeardownLogic = function (parentTeardownLogic) {
	    if (parentTeardownLogic !== this) {
	      this._parentSubscription = this.add(parentTeardownLogic);
	    }
	  };

	  Subscriber.prototype._unsubscribeParentSubscription = function () {
	    if (this._parentSubscription !== null) {
	      this._parentSubscription.unsubscribe();
	    }
	  };

	  Subscriber.prototype._unsubscribeAndRecycle = function () {
	    var _a = this,
	        _parent = _a._parent,
	        _parents = _a._parents;

	    this._parent = null;
	    this._parents = null;
	    this.unsubscribe();
	    this.closed = false;
	    this.isStopped = false;
	    this._parent = _parent;
	    this._parents = _parents;
	    this._parentSubscription = null;
	    return this;
	  };

	  return Subscriber;
	}(Subscription);

	var SafeSubscriber = /*@__PURE__*/function (_super) {
	  __extends(SafeSubscriber, _super);

	  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	    var _this = _super.call(this) || this;

	    _this._parentSubscriber = _parentSubscriber;
	    var next;
	    var context = _this;

	    if (isFunction$1(observerOrNext)) {
	      next = observerOrNext;
	    } else if (observerOrNext) {
	      next = observerOrNext.next;
	      error = observerOrNext.error;
	      complete = observerOrNext.complete;

	      if (observerOrNext !== empty) {
	        context = Object.create(observerOrNext);

	        if (isFunction$1(context.unsubscribe)) {
	          _this.add(context.unsubscribe.bind(context));
	        }

	        context.unsubscribe = _this.unsubscribe.bind(_this);
	      }
	    }

	    _this._context = context;
	    _this._next = next;
	    _this._error = error;
	    _this._complete = complete;
	    return _this;
	  }

	  SafeSubscriber.prototype.next = function (value) {
	    if (!this.isStopped && this._next) {
	      var _parentSubscriber = this._parentSubscriber;

	      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	        this.__tryOrUnsub(this._next, value);
	      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	        this.unsubscribe();
	      }
	    }
	  };

	  SafeSubscriber.prototype.error = function (err) {
	    if (!this.isStopped) {
	      var _parentSubscriber = this._parentSubscriber;
	      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;

	      if (this._error) {
	        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	          this.__tryOrUnsub(this._error, err);

	          this.unsubscribe();
	        } else {
	          this.__tryOrSetError(_parentSubscriber, this._error, err);

	          this.unsubscribe();
	        }
	      } else if (!_parentSubscriber.syncErrorThrowable) {
	        this.unsubscribe();

	        if (useDeprecatedSynchronousErrorHandling) {
	          throw err;
	        }

	        hostReportError(err);
	      } else {
	        if (useDeprecatedSynchronousErrorHandling) {
	          _parentSubscriber.syncErrorValue = err;
	          _parentSubscriber.syncErrorThrown = true;
	        } else {
	          hostReportError(err);
	        }

	        this.unsubscribe();
	      }
	    }
	  };

	  SafeSubscriber.prototype.complete = function () {
	    var _this = this;

	    if (!this.isStopped) {
	      var _parentSubscriber = this._parentSubscriber;

	      if (this._complete) {
	        var wrappedComplete = function wrappedComplete() {
	          return _this._complete.call(_this._context);
	        };

	        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
	          this.__tryOrUnsub(wrappedComplete);

	          this.unsubscribe();
	        } else {
	          this.__tryOrSetError(_parentSubscriber, wrappedComplete);

	          this.unsubscribe();
	        }
	      } else {
	        this.unsubscribe();
	      }
	    }
	  };

	  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	    try {
	      fn.call(this._context, value);
	    } catch (err) {
	      this.unsubscribe();

	      if (config.useDeprecatedSynchronousErrorHandling) {
	        throw err;
	      } else {
	        hostReportError(err);
	      }
	    }
	  };

	  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	    if (!config.useDeprecatedSynchronousErrorHandling) {
	      throw new Error('bad call');
	    }

	    try {
	      fn.call(this._context, value);
	    } catch (err) {
	      if (config.useDeprecatedSynchronousErrorHandling) {
	        parent.syncErrorValue = err;
	        parent.syncErrorThrown = true;
	        return true;
	      } else {
	        hostReportError(err);
	        return true;
	      }
	    }

	    return false;
	  };

	  SafeSubscriber.prototype._unsubscribe = function () {
	    var _parentSubscriber = this._parentSubscriber;
	    this._context = null;
	    this._parentSubscriber = null;

	    _parentSubscriber.unsubscribe();
	  };

	  return SafeSubscriber;
	}(Subscriber);

	function isTrustedSubscriber(obj) {
	  return obj instanceof Subscriber || '_addParentTeardownLogic' in obj && obj[rxSubscriber];
	}
	/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */


	function toSubscriber(nextOrObserver, error, complete) {
	  if (nextOrObserver) {
	    if (nextOrObserver instanceof Subscriber) {
	      return nextOrObserver;
	    }

	    if (nextOrObserver[rxSubscriber]) {
	      return nextOrObserver[rxSubscriber]();
	    }
	  }

	  if (!nextOrObserver && !error && !complete) {
	    return new Subscriber(empty);
	  }

	  return new Subscriber(nextOrObserver, error, complete);
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	function noop$1() {}
	/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */


	function pipeFromArray(fns) {
	  if (!fns) {
	    return noop$1;
	  }

	  if (fns.length === 1) {
	    return fns[0];
	  }

	  return function piped(input) {
	    return fns.reduce(function (prev, fn) {
	      return fn(prev);
	    }, input);
	  };
	}
	/** PURE_IMPORTS_START _util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */


	var Observable = /*@__PURE__*/function () {
	  function Observable(subscribe) {
	    this._isScalar = false;

	    if (subscribe) {
	      this._subscribe = subscribe;
	    }
	  }

	  Observable.prototype.lift = function (operator) {
	    var observable$$1 = new Observable();
	    observable$$1.source = this;
	    observable$$1.operator = operator;
	    return observable$$1;
	  };

	  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	    var operator = this.operator;
	    var sink = toSubscriber(observerOrNext, error, complete);

	    if (operator) {
	      operator.call(sink, this.source);
	    } else {
	      sink._addParentTeardownLogic(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
	    }

	    if (config.useDeprecatedSynchronousErrorHandling) {
	      if (sink.syncErrorThrowable) {
	        sink.syncErrorThrowable = false;

	        if (sink.syncErrorThrown) {
	          throw sink.syncErrorValue;
	        }
	      }
	    }

	    return sink;
	  };

	  Observable.prototype._trySubscribe = function (sink) {
	    try {
	      return this._subscribe(sink);
	    } catch (err) {
	      if (config.useDeprecatedSynchronousErrorHandling) {
	        sink.syncErrorThrown = true;
	        sink.syncErrorValue = err;
	      }

	      sink.error(err);
	    }
	  };

	  Observable.prototype.forEach = function (next, promiseCtor) {
	    var _this = this;

	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var subscription;
	      subscription = _this.subscribe(function (value) {
	        try {
	          next(value);
	        } catch (err) {
	          reject(err);

	          if (subscription) {
	            subscription.unsubscribe();
	          }
	        }
	      }, reject, resolve);
	    });
	  };

	  Observable.prototype._subscribe = function (subscriber) {
	    var source = this.source;
	    return source && source.subscribe(subscriber);
	  };

	  Observable.prototype[observable] = function () {
	    return this;
	  };

	  Observable.prototype.pipe = function () {
	    var operations = [];

	    for (var _i = 0; _i < arguments.length; _i++) {
	      operations[_i] = arguments[_i];
	    }

	    if (operations.length === 0) {
	      return this;
	    }

	    return pipeFromArray(operations)(this);
	  };

	  Observable.prototype.toPromise = function (promiseCtor) {
	    var _this = this;

	    promiseCtor = getPromiseCtor(promiseCtor);
	    return new promiseCtor(function (resolve, reject) {
	      var value;

	      _this.subscribe(function (x) {
	        return value = x;
	      }, function (err) {
	        return reject(err);
	      }, function () {
	        return resolve(value);
	      });
	    });
	  };

	  Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	  };

	  return Observable;
	}();

	function getPromiseCtor(promiseCtor) {
	  if (!promiseCtor) {
	    promiseCtor = Promise;
	  }

	  if (!promiseCtor) {
	    throw new Error('no Promise impl found');
	  }

	  return promiseCtor;
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function ObjectUnsubscribedErrorImpl() {
	  Error.call(this);
	  this.message = 'object unsubscribed';
	  this.name = 'ObjectUnsubscribedError';
	  return this;
	}

	ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);
	var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
	/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */

	var SubjectSubscription = /*@__PURE__*/function (_super) {
	  __extends(SubjectSubscription, _super);

	  function SubjectSubscription(subject, subscriber) {
	    var _this = _super.call(this) || this;

	    _this.subject = subject;
	    _this.subscriber = subscriber;
	    _this.closed = false;
	    return _this;
	  }

	  SubjectSubscription.prototype.unsubscribe = function () {
	    if (this.closed) {
	      return;
	    }

	    this.closed = true;
	    var subject = this.subject;
	    var observers = subject.observers;
	    this.subject = null;

	    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	      return;
	    }

	    var subscriberIndex = observers.indexOf(this.subscriber);

	    if (subscriberIndex !== -1) {
	      observers.splice(subscriberIndex, 1);
	    }
	  };

	  return SubjectSubscription;
	}(Subscription);
	/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */


	var SubjectSubscriber = /*@__PURE__*/function (_super) {
	  __extends(SubjectSubscriber, _super);

	  function SubjectSubscriber(destination) {
	    var _this = _super.call(this, destination) || this;

	    _this.destination = destination;
	    return _this;
	  }

	  return SubjectSubscriber;
	}(Subscriber);

	var Subject = /*@__PURE__*/function (_super) {
	  __extends(Subject, _super);

	  function Subject() {
	    var _this = _super.call(this) || this;

	    _this.observers = [];
	    _this.closed = false;
	    _this.isStopped = false;
	    _this.hasError = false;
	    _this.thrownError = null;
	    return _this;
	  }

	  Subject.prototype[rxSubscriber] = function () {
	    return new SubjectSubscriber(this);
	  };

	  Subject.prototype.lift = function (operator) {
	    var subject = new AnonymousSubject(this, this);
	    subject.operator = operator;
	    return subject;
	  };

	  Subject.prototype.next = function (value) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    }

	    if (!this.isStopped) {
	      var observers = this.observers;
	      var len = observers.length;
	      var copy = observers.slice();

	      for (var i = 0; i < len; i++) {
	        copy[i].next(value);
	      }
	    }
	  };

	  Subject.prototype.error = function (err) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    }

	    this.hasError = true;
	    this.thrownError = err;
	    this.isStopped = true;
	    var observers = this.observers;
	    var len = observers.length;
	    var copy = observers.slice();

	    for (var i = 0; i < len; i++) {
	      copy[i].error(err);
	    }

	    this.observers.length = 0;
	  };

	  Subject.prototype.complete = function () {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    }

	    this.isStopped = true;
	    var observers = this.observers;
	    var len = observers.length;
	    var copy = observers.slice();

	    for (var i = 0; i < len; i++) {
	      copy[i].complete();
	    }

	    this.observers.length = 0;
	  };

	  Subject.prototype.unsubscribe = function () {
	    this.isStopped = true;
	    this.closed = true;
	    this.observers = null;
	  };

	  Subject.prototype._trySubscribe = function (subscriber) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    } else {
	      return _super.prototype._trySubscribe.call(this, subscriber);
	    }
	  };

	  Subject.prototype._subscribe = function (subscriber) {
	    if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    } else if (this.hasError) {
	      subscriber.error(this.thrownError);
	      return Subscription.EMPTY;
	    } else if (this.isStopped) {
	      subscriber.complete();
	      return Subscription.EMPTY;
	    } else {
	      this.observers.push(subscriber);
	      return new SubjectSubscription(this, subscriber);
	    }
	  };

	  Subject.prototype.asObservable = function () {
	    var observable = new Observable();
	    observable.source = this;
	    return observable;
	  };

	  Subject.create = function (destination, source) {
	    return new AnonymousSubject(destination, source);
	  };

	  return Subject;
	}(Observable);

	var AnonymousSubject = /*@__PURE__*/function (_super) {
	  __extends(AnonymousSubject, _super);

	  function AnonymousSubject(destination, source) {
	    var _this = _super.call(this) || this;

	    _this.destination = destination;
	    _this.source = source;
	    return _this;
	  }

	  AnonymousSubject.prototype.next = function (value) {
	    var destination = this.destination;

	    if (destination && destination.next) {
	      destination.next(value);
	    }
	  };

	  AnonymousSubject.prototype.error = function (err) {
	    var destination = this.destination;

	    if (destination && destination.error) {
	      this.destination.error(err);
	    }
	  };

	  AnonymousSubject.prototype.complete = function () {
	    var destination = this.destination;

	    if (destination && destination.complete) {
	      this.destination.complete();
	    }
	  };

	  AnonymousSubject.prototype._subscribe = function (subscriber) {
	    var source = this.source;

	    if (source) {
	      return this.source.subscribe(subscriber);
	    } else {
	      return Subscription.EMPTY;
	    }
	  };

	  return AnonymousSubject;
	}(Subject);
	/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */


	var BehaviorSubject = /*@__PURE__*/function (_super) {
	  __extends(BehaviorSubject, _super);

	  function BehaviorSubject(_value) {
	    var _this = _super.call(this) || this;

	    _this._value = _value;
	    return _this;
	  }

	  Object.defineProperty(BehaviorSubject.prototype, "value", {
	    get: function get() {
	      return this.getValue();
	    },
	    enumerable: true,
	    configurable: true
	  });

	  BehaviorSubject.prototype._subscribe = function (subscriber) {
	    var subscription = _super.prototype._subscribe.call(this, subscriber);

	    if (subscription && !subscription.closed) {
	      subscriber.next(this._value);
	    }

	    return subscription;
	  };

	  BehaviorSubject.prototype.getValue = function () {
	    if (this.hasError) {
	      throw this.thrownError;
	    } else if (this.closed) {
	      throw new ObjectUnsubscribedError();
	    } else {
	      return this._value;
	    }
	  };

	  BehaviorSubject.prototype.next = function (value) {
	    _super.prototype.next.call(this, this._value = value);
	  };

	  return BehaviorSubject;
	}(Subject);
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function isScheduler(value) {
	  return value && typeof value.schedule === 'function';
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	var subscribeToArray = function subscribeToArray(array) {
	  return function (subscriber) {
	    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
	      subscriber.next(array[i]);
	    }

	    if (!subscriber.closed) {
	      subscriber.complete();
	    }
	  };
	};
	/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */


	function fromArray(input, scheduler) {
	  if (!scheduler) {
	    return new Observable(subscribeToArray(input));
	  } else {
	    return new Observable(function (subscriber) {
	      var sub = new Subscription();
	      var i = 0;
	      sub.add(scheduler.schedule(function () {
	        if (i === input.length) {
	          subscriber.complete();
	          return;
	        }

	        subscriber.next(input[i++]);

	        if (!subscriber.closed) {
	          sub.add(this.schedule());
	        }
	      }));
	      return sub;
	    });
	  }
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function identity$1(x) {
	  return x;
	}
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

	function map(project, thisArg) {
	  return function mapOperation(source) {
	    if (typeof project !== 'function') {
	      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }

	    return source.lift(new MapOperator(project, thisArg));
	  };
	}

	var MapOperator = /*@__PURE__*/function () {
	  function MapOperator(project, thisArg) {
	    this.project = project;
	    this.thisArg = thisArg;
	  }

	  MapOperator.prototype.call = function (subscriber, source) {
	    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	  };

	  return MapOperator;
	}();

	var MapSubscriber = /*@__PURE__*/function (_super) {
	  __extends(MapSubscriber, _super);

	  function MapSubscriber(destination, project, thisArg) {
	    var _this = _super.call(this, destination) || this;

	    _this.project = project;
	    _this.count = 0;
	    _this.thisArg = thisArg || _this;
	    return _this;
	  }

	  MapSubscriber.prototype._next = function (value) {
	    var result;

	    try {
	      result = this.project.call(this.thisArg, value, this.count++);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.destination.next(result);
	  };

	  return MapSubscriber;
	}(Subscriber);
	/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isArray,_util_isScheduler PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isScheduler,_util_isArray PURE_IMPORTS_END */

	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


	var OuterSubscriber = /*@__PURE__*/function (_super) {
	  __extends(OuterSubscriber, _super);

	  function OuterSubscriber() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }

	  OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.destination.next(innerValue);
	  };

	  OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	    this.destination.error(error);
	  };

	  OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	    this.destination.complete();
	  };

	  return OuterSubscriber;
	}(Subscriber);
	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


	var InnerSubscriber = /*@__PURE__*/function (_super) {
	  __extends(InnerSubscriber, _super);

	  function InnerSubscriber(parent, outerValue, outerIndex) {
	    var _this = _super.call(this) || this;

	    _this.parent = parent;
	    _this.outerValue = outerValue;
	    _this.outerIndex = outerIndex;
	    _this.index = 0;
	    return _this;
	  }

	  InnerSubscriber.prototype._next = function (value) {
	    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	  };

	  InnerSubscriber.prototype._error = function (error) {
	    this.parent.notifyError(error, this);
	    this.unsubscribe();
	  };

	  InnerSubscriber.prototype._complete = function () {
	    this.parent.notifyComplete(this);
	    this.unsubscribe();
	  };

	  return InnerSubscriber;
	}(Subscriber);
	/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */


	var subscribeToPromise = function subscribeToPromise(promise) {
	  return function (subscriber) {
	    promise.then(function (value) {
	      if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	      }
	    }, function (err) {
	      return subscriber.error(err);
	    }).then(null, hostReportError);
	    return subscriber;
	  };
	};
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function getSymbolIterator() {
	  if (typeof Symbol !== 'function' || !Symbol.iterator) {
	    return '@@iterator';
	  }

	  return Symbol.iterator;
	}

	var iterator = /*@__PURE__*/getSymbolIterator();
	/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

	var subscribeToIterable = function subscribeToIterable(iterable) {
	  return function (subscriber) {
	    var iterator$$1 = iterable[iterator]();

	    do {
	      var item = iterator$$1.next();

	      if (item.done) {
	        subscriber.complete();
	        break;
	      }

	      subscriber.next(item.value);

	      if (subscriber.closed) {
	        break;
	      }
	    } while (true);

	    if (typeof iterator$$1.return === 'function') {
	      subscriber.add(function () {
	        if (iterator$$1.return) {
	          iterator$$1.return();
	        }
	      });
	    }

	    return subscriber;
	  };
	};
	/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */


	var subscribeToObservable = function subscribeToObservable(obj) {
	  return function (subscriber) {
	    var obs = obj[observable]();

	    if (typeof obs.subscribe !== 'function') {
	      throw new TypeError('Provided object does not correctly implement Symbol.observable');
	    } else {
	      return obs.subscribe(subscriber);
	    }
	  };
	};
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	var isArrayLike$1 = function isArrayLike(x) {
	  return x && typeof x.length === 'number' && typeof x !== 'function';
	};
	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	function isPromise(value) {
	  return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */


	var subscribeTo = function subscribeTo(result) {
	  if (result instanceof Observable) {
	    return function (subscriber) {
	      if (result._isScalar) {
	        subscriber.next(result.value);
	        subscriber.complete();
	        return undefined;
	      } else {
	        return result.subscribe(subscriber);
	      }
	    };
	  } else if (result && typeof result[observable] === 'function') {
	    return subscribeToObservable(result);
	  } else if (isArrayLike$1(result)) {
	    return subscribeToArray(result);
	  } else if (isPromise(result)) {
	    return subscribeToPromise(result);
	  } else if (result && typeof result[iterator] === 'function') {
	    return subscribeToIterable(result);
	  } else {
	    var value = isObject$1(result) ? 'an invalid object' : "'" + result + "'";
	    var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
	    throw new TypeError(msg);
	  }
	};
	/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */


	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
	  if (destination === void 0) {
	    destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	  }

	  if (destination.closed) {
	    return;
	  }

	  return subscribeTo(result)(destination);
	}
	/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */


	function isInteropObservable(input) {
	  return input && typeof input[observable] === 'function';
	}
	/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */


	function isIterable(input) {
	  return input && typeof input[iterator] === 'function';
	}
	/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */


	function fromPromise(input, scheduler) {
	  if (!scheduler) {
	    return new Observable(subscribeToPromise(input));
	  } else {
	    return new Observable(function (subscriber) {
	      var sub = new Subscription();
	      sub.add(scheduler.schedule(function () {
	        return input.then(function (value) {
	          sub.add(scheduler.schedule(function () {
	            subscriber.next(value);
	            sub.add(scheduler.schedule(function () {
	              return subscriber.complete();
	            }));
	          }));
	        }, function (err) {
	          sub.add(scheduler.schedule(function () {
	            return subscriber.error(err);
	          }));
	        });
	      }));
	      return sub;
	    });
	  }
	}
	/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */


	function fromIterable(input, scheduler) {
	  if (!input) {
	    throw new Error('Iterable cannot be null');
	  }

	  if (!scheduler) {
	    return new Observable(subscribeToIterable(input));
	  } else {
	    return new Observable(function (subscriber) {
	      var sub = new Subscription();
	      var iterator$$1;
	      sub.add(function () {
	        if (iterator$$1 && typeof iterator$$1.return === 'function') {
	          iterator$$1.return();
	        }
	      });
	      sub.add(scheduler.schedule(function () {
	        iterator$$1 = input[iterator]();
	        sub.add(scheduler.schedule(function () {
	          if (subscriber.closed) {
	            return;
	          }

	          var value;
	          var done;

	          try {
	            var result = iterator$$1.next();
	            value = result.value;
	            done = result.done;
	          } catch (err) {
	            subscriber.error(err);
	            return;
	          }

	          if (done) {
	            subscriber.complete();
	          } else {
	            subscriber.next(value);
	            this.schedule();
	          }
	        }));
	      }));
	      return sub;
	    });
	  }
	}
	/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */


	function fromObservable(input, scheduler) {
	  if (!scheduler) {
	    return new Observable(subscribeToObservable(input));
	  } else {
	    return new Observable(function (subscriber) {
	      var sub = new Subscription();
	      sub.add(scheduler.schedule(function () {
	        var observable$$1 = input[observable]();
	        sub.add(observable$$1.subscribe({
	          next: function next(value) {
	            sub.add(scheduler.schedule(function () {
	              return subscriber.next(value);
	            }));
	          },
	          error: function error(err) {
	            sub.add(scheduler.schedule(function () {
	              return subscriber.error(err);
	            }));
	          },
	          complete: function complete() {
	            sub.add(scheduler.schedule(function () {
	              return subscriber.complete();
	            }));
	          }
	        }));
	      }));
	      return sub;
	    });
	  }
	}
	/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */


	function from(input, scheduler) {
	  if (!scheduler) {
	    if (input instanceof Observable) {
	      return input;
	    }

	    return new Observable(subscribeTo(input));
	  }

	  if (input != null) {
	    if (isInteropObservable(input)) {
	      return fromObservable(input, scheduler);
	    } else if (isPromise(input)) {
	      return fromPromise(input, scheduler);
	    } else if (isArrayLike$1(input)) {
	      return fromArray(input, scheduler);
	    } else if (isIterable(input) || typeof input === 'string') {
	      return fromIterable(input, scheduler);
	    }
	  }

	  throw new TypeError((input !== null && _typeof(input) || input) + ' is not observable');
	}
	/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */


	function mergeMap(project, resultSelector, concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Number.POSITIVE_INFINITY;
	  }

	  if (typeof resultSelector === 'function') {
	    return function (source) {
	      return source.pipe(mergeMap(function (a, i) {
	        return from(project(a, i)).pipe(map(function (b, ii) {
	          return resultSelector(a, b, i, ii);
	        }));
	      }, concurrent));
	    };
	  } else if (typeof resultSelector === 'number') {
	    concurrent = resultSelector;
	  }

	  return function (source) {
	    return source.lift(new MergeMapOperator(project, concurrent));
	  };
	}

	var MergeMapOperator = /*@__PURE__*/function () {
	  function MergeMapOperator(project, concurrent) {
	    if (concurrent === void 0) {
	      concurrent = Number.POSITIVE_INFINITY;
	    }

	    this.project = project;
	    this.concurrent = concurrent;
	  }

	  MergeMapOperator.prototype.call = function (observer, source) {
	    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
	  };

	  return MergeMapOperator;
	}();

	var MergeMapSubscriber = /*@__PURE__*/function (_super) {
	  __extends(MergeMapSubscriber, _super);

	  function MergeMapSubscriber(destination, project, concurrent) {
	    if (concurrent === void 0) {
	      concurrent = Number.POSITIVE_INFINITY;
	    }

	    var _this = _super.call(this, destination) || this;

	    _this.project = project;
	    _this.concurrent = concurrent;
	    _this.hasCompleted = false;
	    _this.buffer = [];
	    _this.active = 0;
	    _this.index = 0;
	    return _this;
	  }

	  MergeMapSubscriber.prototype._next = function (value) {
	    if (this.active < this.concurrent) {
	      this._tryNext(value);
	    } else {
	      this.buffer.push(value);
	    }
	  };

	  MergeMapSubscriber.prototype._tryNext = function (value) {
	    var result;
	    var index = this.index++;

	    try {
	      result = this.project(value, index);
	    } catch (err) {
	      this.destination.error(err);
	      return;
	    }

	    this.active++;

	    this._innerSub(result, value, index);
	  };

	  MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	    var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
	    this.add(innerSubscriber);
	    subscribeToResult(this, ish, value, index, innerSubscriber);
	  };

	  MergeMapSubscriber.prototype._complete = function () {
	    this.hasCompleted = true;

	    if (this.active === 0 && this.buffer.length === 0) {
	      this.destination.complete();
	    }
	  };

	  MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	    this.destination.next(innerValue);
	  };

	  MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	    var buffer = this.buffer;
	    this.remove(innerSub);
	    this.active--;

	    if (buffer.length > 0) {
	      this._next(buffer.shift());
	    } else if (this.active === 0 && this.hasCompleted) {
	      this.destination.complete();
	    }
	  };

	  return MergeMapSubscriber;
	}(OuterSubscriber);
	/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */


	function mergeAll(concurrent) {
	  if (concurrent === void 0) {
	    concurrent = Number.POSITIVE_INFINITY;
	  }

	  return mergeMap(identity$1, concurrent);
	}
	/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */


	function merge() {
	  var observables = [];

	  for (var _i = 0; _i < arguments.length; _i++) {
	    observables[_i] = arguments[_i];
	  }

	  var concurrent = Number.POSITIVE_INFINITY;
	  var scheduler = null;
	  var last = observables[observables.length - 1];

	  if (isScheduler(last)) {
	    scheduler = observables.pop();

	    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	      concurrent = observables.pop();
	    }
	  } else if (typeof last === 'number') {
	    concurrent = observables.pop();
	  }

	  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
	    return observables[0];
	  }

	  return mergeAll(concurrent)(fromArray(observables, scheduler));
	}
	/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */


	function distinctUntilChanged(compare, keySelector) {
	  return function (source) {
	    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
	  };
	}

	var DistinctUntilChangedOperator = /*@__PURE__*/function () {
	  function DistinctUntilChangedOperator(compare, keySelector) {
	    this.compare = compare;
	    this.keySelector = keySelector;
	  }

	  DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
	    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
	  };

	  return DistinctUntilChangedOperator;
	}();

	var DistinctUntilChangedSubscriber = /*@__PURE__*/function (_super) {
	  __extends(DistinctUntilChangedSubscriber, _super);

	  function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	    var _this = _super.call(this, destination) || this;

	    _this.keySelector = keySelector;
	    _this.hasKey = false;

	    if (typeof compare === 'function') {
	      _this.compare = compare;
	    }

	    return _this;
	  }

	  DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	    return x === y;
	  };

	  DistinctUntilChangedSubscriber.prototype._next = function (value) {
	    var keySelector = this.keySelector;
	    var key = value;

	    if (keySelector) {
	      key = tryCatch(this.keySelector)(value);

	      if (key === errorObject) {
	        return this.destination.error(errorObject.e);
	      }
	    }

	    var result = false;

	    if (this.hasKey) {
	      result = tryCatch(this.compare)(this.key, key);

	      if (result === errorObject) {
	        return this.destination.error(errorObject.e);
	      }
	    } else {
	      this.hasKey = true;
	    }

	    if (Boolean(result) === false) {
	      this.key = key;
	      this.destination.next(value);
	    }
	  };

	  return DistinctUntilChangedSubscriber;
	}(Subscriber);
	/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


	function skip(count) {
	  return function (source) {
	    return source.lift(new SkipOperator(count));
	  };
	}

	var SkipOperator = /*@__PURE__*/function () {
	  function SkipOperator(total) {
	    this.total = total;
	  }

	  SkipOperator.prototype.call = function (subscriber, source) {
	    return source.subscribe(new SkipSubscriber(subscriber, this.total));
	  };

	  return SkipOperator;
	}();

	var SkipSubscriber = /*@__PURE__*/function (_super) {
	  __extends(SkipSubscriber, _super);

	  function SkipSubscriber(destination, total) {
	    var _this = _super.call(this, destination) || this;

	    _this.total = total;
	    _this.count = 0;
	    return _this;
	  }

	  SkipSubscriber.prototype._next = function (x) {
	    if (++this.count > this.total) {
	      this.destination.next(x);
	    }
	  };

	  return SkipSubscriber;
	}(Subscriber);
	/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

	/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

	/** PURE_IMPORTS_START  PURE_IMPORTS_END */


	var TrackableManager = /*#__PURE__*/function () {
	  function TrackableManager() {
	    _classCallCheck(this, TrackableManager);

	    // Used for checking for circular dependencies. Make sure originator of listening isn't in its own list of dependencies
	    this.listenerStack = [];
	    this.listenStack = [];
	  }

	  _createClass(TrackableManager, [{
	    key: "isListening",
	    get: function get() {
	      return this.listenStack.length > 0;
	    }
	  }, {
	    key: "trackableAccessed",
	    value: function trackableAccessed(subscribable) {
	      // This is detecting when a trackable is accessed twice in the same computed.
	      // if (this.listenStack.some(arr => arr.some(s => s === subscribable))) {
	      //     console.error("Trackable is its own dependency: ", subscribable);
	      //     throw new Error("Circular dependency detected");
	      // }
	      // if (this.listenerStack.some(t => t === subscribable)) {
	      //     console.error("Trackable is its own dependency: ", subscribable);
	      //     throw new Error("Circular dependency detected");
	      // }
	      if (this.isListening) {
	        var top = this.listenStack[this.listenStack.length - 1];
	        if (top.indexOf(subscribable) === -1) top.push(subscribable);
	      }
	    }
	  }, {
	    key: "startListening",
	    value: function startListening(listener) {
	      this.listenerStack.push(listener);
	      this.listenStack.push([]);
	    }
	  }, {
	    key: "stopListening",
	    value: function stopListening() {
	      this.listenerStack.pop();
	      var dependencies = this.listenStack.pop();
	      if (dependencies == null) throw new Error("Listening stack malformed, could not pop dependencies from stack");
	      return dependencies;
	    }
	  }]);

	  return TrackableManager;
	}();

	var trackableManager = new TrackableManager();

	var TrackedSubject = /*#__PURE__*/function () {
	  function TrackedSubject(initialValue, compare) {
	    _classCallCheck(this, TrackedSubject);

	    this.subject = new BehaviorSubject(initialValue);
	    this.observable = this.subject.pipe(distinctUntilChanged(compare)).pipe(skip(1));
	  }

	  _createClass(TrackedSubject, [{
	    key: "value",
	    get: function get() {
	      trackableManager.trackableAccessed(this);
	      return this.subject.value;
	    },
	    set: function set(value) {
	      this.subject.next(value);
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(observer) {
	      return this.observable.subscribe(observer);
	    }
	  }]);

	  return TrackedSubject;
	}();

	function shallowEqualArrays(a, b) {
	  if (a === b) {
	    return true;
	  }

	  var len = a.length;

	  if (b.length !== len) {
	    return false;
	  }

	  for (var i = 0; i < len; i++) {
	    if (a[i] !== b[i]) {
	      return false;
	    }
	  }

	  return true;
	}

	var TrackedArray = /*#__PURE__*/function () {
	  function TrackedArray(initialValue, compare) {
	    _classCallCheck(this, TrackedArray);

	    if (!Array.isArray(initialValue)) {
	      throw new Error("Trackable array must only be assigned an array as a value");
	    }

	    if (compare == null) compare = shallowEqualArrays;
	    this.subject = new TrackedSubject(initialValue, compare);
	  }

	  _createClass(TrackedArray, [{
	    key: "value",
	    get: function get() {
	      var arr = _toConsumableArray(this.subject.value);

	      Object.freeze(arr);
	      return arr;
	    },
	    set: function set(value) {
	      if (!Array.isArray(value)) {
	        throw new Error("Trackable array must only be assigned an array as a value");
	      }

	      this.subject.value = value;
	    }
	  }, {
	    key: "observable",
	    get: function get() {
	      return this.subject.observable;
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(observer) {
	      return this.observable.subscribe(observer); //?
	    }
	  }]);

	  return TrackedArray;
	}();

	var TrackedComputedSubject = /*#__PURE__*/function () {
	  function TrackedComputedSubject(getter) {
	    _classCallCheck(this, TrackedComputedSubject);

	    this._dependencies = [];
	    this.getter = getter;
	    this.subject = new BehaviorSubject(this.evaluateValue());
	    this.observable = this.subject.pipe(distinctUntilChanged()).pipe(skip(1));
	  }

	  _createClass(TrackedComputedSubject, [{
	    key: "evaluateValue",
	    value: function evaluateValue() {
	      trackableManager.trackableAccessed(this);
	      trackableManager.startListening(this);
	      var val = this.getter();
	      var dependencies = trackableManager.stopListening();
	      this.updateSubscriptions(dependencies);
	      return val;
	    }
	  }, {
	    key: "value",
	    get: function get() {
	      trackableManager.trackableAccessed(this);
	      return this.subject.value;
	    }
	  }, {
	    key: "updateSubscriptions",
	    value: function updateSubscriptions(dependencies) {
	      var _this2 = this;

	      var _iterator = _createForOfIteratorHelper(dependencies),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var subscribable = _step.value;

	          if (subscribable !== this && this._dependencies.indexOf(subscribable) === -1) {
	            subscribable.subscribe(function () {
	              _this2.subject.next(_this2.evaluateValue());
	            });

	            this._dependencies.push(subscribable);
	          }
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(observer) {
	      return this.observable.subscribe(observer);
	    }
	  }]);

	  return TrackedComputedSubject;
	}();

	var TrackableEntityKey = "_trackableEntity";
	/**
	 * Decorator for classes, allows them and their properties to be tracked using a TrackedEntity
	 * @param constructor
	 */

	function trackable(constructor) {
	  constructor.prototype[TrackableEntityKey] = true;
	}

	var isTrackableEntity = function isTrackableEntity(obj) {
	  return obj !== null && _typeof(obj) === "object" && obj[TrackableEntityKey] === true;
	};

	var TrackedPropertyDefinitionListKey = "_trackedPropertyDefinitions";

	var getTrackedPropertyDefinitionList = function getTrackedPropertyDefinitionList(obj) {
	  return obj[TrackedPropertyDefinitionListKey] = obj[TrackedPropertyDefinitionListKey] || {};
	};

	var registerTrackedPropertyDefinition = function registerTrackedPropertyDefinition(proto, name, computed
	/*, initialValue: T[K]*/
	) {
	  var list = getTrackedPropertyDefinitionList(proto);
	  list[name] = {
	    computed: computed
	  };
	};

	var ComputedPropertyListKey = "_computedProperties";

	var getComputedPropertyList = function getComputedPropertyList(obj) {
	  return obj[ComputedPropertyListKey] = obj[ComputedPropertyListKey] || {};
	};

	var getOrSetupComputedProperty = function getOrSetupComputedProperty(obj, name, getter) {
	  var list = getComputedPropertyList(obj);
	  var existing = list[name];

	  if (!existing) {
	    var subject = new TrackedComputedSubject(getter.bind(obj));
	    list[name] = {
	      subject: subject
	    };
	  }

	  return list[name].subject;
	};

	var getComputedProperty = function getComputedProperty(obj, name) {
	  var list = getComputedPropertyList(obj);

	  if (!list[name]) {
	    obj[name]; // Has not been initialized, so initialized it now
	    // Lazy initialization seems to be the correct step here? See the long comment in tracked-property.ts
	    //console.info("computed initialized lazily via getComputedProperty", obj, name, list);
	    //throw new Error("Property accessed before initialized: " + name);
	  }

	  return list[name].subject;
	};

	var TrackedPropertyListKey = "_trackedProperties";

	var getTrackedPropertyList = function getTrackedPropertyList(obj) {
	  return obj[TrackedPropertyListKey] = obj[TrackedPropertyListKey] || {};
	};

	var getTrackedProperty = function getTrackedProperty(obj, name, notFound) {
	  var list = getTrackedPropertyList(obj);
	  var existing = list[name];

	  if (!existing) {
	    if (notFound) return notFound(list, name);else throw new Error("Property accessed before initialized or property doesn't exist: " + name);
	  }

	  return existing.subject;
	};

	var getAllTrackedProperties = function getAllTrackedProperties(obj) {
	  var list = getTrackedPropertyDefinitionList(obj);
	  return Object.keys(list).map(function (key) {
	    return {
	      key: key,
	      definition: list[key]
	    };
	  }).map(function (_ref) {
	    var key = _ref.key,
	        definition = _ref.definition;
	    // // If someone tries to subscribe to a tracked entity without having read a computed,
	    // // The computed will not yet be initialized and the application will throw
	    // // Merely reading the property ensures getOrSetupComputed gets called and property is initialized
	    // // TODO: Write a test which subscribes to a tracked entity with a computed without having called or read the
	    // // computed in the constructor first (all existing tests read the computed in the constructor as part of the test)
	    // obj[key as keyof T];
	    // 4-18-2020 moved to getComputedProperty;
	    return definition.computed ? getComputedProperty(obj, key) : getTrackedProperty(obj, key);
	  });
	};

	var getAllObservables = function getAllObservables(obj) {
	  return getAllTrackedProperties(obj).map(function (tracked) {
	    return tracked.observable;
	  });
	};

	var subscribeAll = function subscribeAll(obj, observer) {
	  return merge.apply(void 0, _toConsumableArray(getAllObservables(obj))).subscribe(observer);
	}; // Tracks an object. If the object itself is changed, emit event, or if any of the objects children changes, emit event


	var TrackedEntity = /*#__PURE__*/function () {
	  function TrackedEntity(initialValue) {
	    var _this3 = this;

	    _classCallCheck(this, TrackedEntity);

	    this.subscription = null;
	    this.subject = new TrackedSubject(initialValue);
	    this.observable = new Observable(function (subscriber) {
	      _this3.next = function () {
	        return subscriber.next();
	      };
	    });

	    if (isTrackableEntity(initialValue)) {
	      // Setup subscription
	      this.subscription = subscribeAll(initialValue, function () {
	        return _this3.next();
	      });
	    }
	  }

	  _createClass(TrackedEntity, [{
	    key: "value",
	    get: function get() {
	      return this.subject.value;
	    },
	    set: function set(value) {
	      if (value !== this.subject.value) {
	        // If new value, then tear down old subscription
	        if (this.subscription && !this.subscription.closed) {
	          this.subscription.unsubscribe();
	          this.subscription = null;
	        }
	      }

	      if (isTrackableEntity(value)) {
	        // Setup subscription
	        this.subscription = subscribeAll(value, this.next);
	      }

	      this.subject.value = value;
	    }
	  }, {
	    key: "subscribe",
	    value: function subscribe(observer) {
	      return merge(this.observable, this.subject.observable).subscribe(observer);
	    }
	  }]);

	  return TrackedEntity;
	}();

	var createTracked = function createTracked(value) {
	  if (Array.isArray(value)) {
	    return new TrackedArray(value);
	  } else if (isTrackableEntity(value)) {
	    return new TrackedEntity(value);
	  } else {
	    return new TrackedSubject(value);
	  }
	}; // Moved here to avoid circular dependencies


	var getOrSetupTrackedProperty = function getOrSetupTrackedProperty(obj, name, value) {
	  return getTrackedProperty(obj, name, function (list) {
	    return (list[name] = {
	      subject: createTracked(value)
	    }).subject;
	  });
	};
	/**
	 * Wraps property in getters and setters for a TrackedSubject or TrackedArray;
	 */


	function tracked(prototype, propertyName) {
	  registerTrackedPropertyDefinition(prototype, propertyName, false); //, initialValue);

	  return {
	    set: function set(value) {
	      getOrSetupTrackedProperty(this, propertyName, value).value = value;
	    },
	    get: function get() {
	      return getTrackedProperty(this, propertyName).value;
	    },
	    enumerable: true,
	    configurable: true
	  };
	}

	function computed(proto, propertyName, descriptor) {
	  registerTrackedPropertyDefinition(proto, propertyName, true);
	  var getter = descriptor.get;

	  descriptor.get = function () {
	    return getOrSetupComputedProperty(this, propertyName, getter).value;
	  };

	  return descriptor;
	}

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;
	  array || (array = Array(length));

	  while (++index < length) {
	    array[index] = source[index];
	  }

	  return array;
	}

	var _copyArray = copyArray;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeFloor = Math.floor,
	    nativeRandom = Math.random;
	/**
	 * The base implementation of `_.random` without support for returning
	 * floating-point numbers.
	 *
	 * @private
	 * @param {number} lower The lower bound.
	 * @param {number} upper The upper bound.
	 * @returns {number} Returns the random number.
	 */

	function baseRandom(lower, upper) {
	  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	}

	var _baseRandom = baseRandom;

	/**
	 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	 *
	 * @private
	 * @param {Array} array The array to shuffle.
	 * @param {number} [size=array.length] The size of `array`.
	 * @returns {Array} Returns `array`.
	 */

	function shuffleSelf(array, size) {
	  var index = -1,
	      length = array.length,
	      lastIndex = length - 1;
	  size = size === undefined ? length : size;

	  while (++index < size) {
	    var rand = _baseRandom(index, lastIndex),
	        value = array[rand];
	    array[rand] = array[index];
	    array[index] = value;
	  }

	  array.length = size;
	  return array;
	}

	var _shuffleSelf = shuffleSelf;

	/**
	 * A specialized version of `_.shuffle` for arrays.
	 *
	 * @private
	 * @param {Array} array The array to shuffle.
	 * @returns {Array} Returns the new shuffled array.
	 */

	function arrayShuffle(array) {
	  return _shuffleSelf(_copyArray(array));
	}

	var _arrayShuffle = arrayShuffle;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }

	  return result;
	}

	var _arrayMap = arrayMap;

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */

	function baseValues(object, props) {
	  return _arrayMap(props, function (key) {
	    return object[key];
	  });
	}

	var _baseValues = baseValues;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }

	  return result;
	}

	var _baseTimes = baseTimes;

	/** Detect free variable `global` from Node.js. */

	var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */

	var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
	/** Used as a reference to the global object. */

	var root = _freeGlobal || freeSelf || Function('return this')();
	var _root = root;

	/** Built-in value references. */

	var _Symbol2 = _root.Symbol;
	var _Symbol = _Symbol2;

	/** Used for built-in method references. */

	var objectProto$b = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */

	var nativeObjectToString$1 = objectProto$b.toString;
	/** Built-in value references. */

	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */

	function getRawTag(value) {
	  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);

	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }

	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */

	var nativeObjectToString = objectProto$a.toString;
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */

	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	var _objectToString = objectToString;

	/** `Object#toString` result references. */

	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	/** Built-in value references. */

	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */

	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }

	  return symToStringTag && symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && _typeof(value) == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */

	var argsTag$2 = '[object Arguments]';
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */

	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */

	var objectProto$9 = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
	/** Built-in value references. */

	var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */

	var isArguments = _baseIsArguments(function () {
	  return arguments;
	}()) ? _baseIsArguments : function (value) {
	  return isObjectLike_1(value) && hasOwnProperty$7.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
	};
	var isArguments_1 = isArguments;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	var isArray_1 = isArray;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	var isBuffer_1 = createCommonjsModule(function (module, exports) {
	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;
	  /** Detect free variable `module`. */

	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
	  /** Detect the popular CommonJS extension `module.exports`. */

	  var moduleExports = freeModule && freeModule.exports === freeExports;
	  /** Built-in value references. */

	  var Buffer = moduleExports ? _root.Buffer : undefined;
	  /* Built-in method references for those with the same name as other `lodash` methods. */

	  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	  /**
	   * Checks if `value` is a buffer.
	   *
	   * @static
	   * @memberOf _
	   * @since 4.3.0
	   * @category Lang
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	   * @example
	   *
	   * _.isBuffer(new Buffer(2));
	   * // => true
	   *
	   * _.isBuffer(new Uint8Array(2));
	   * // => false
	   */

	  var isBuffer = nativeIsBuffer || stubFalse_1;
	  module.exports = isBuffer;
	});

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;
	/** Used to detect unsigned integer values. */

	var reIsUint = /^(?:0|[1-9]\d*)$/;
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */

	function isIndex(value, length) {
	  var type = _typeof(value);

	  length = length == null ? MAX_SAFE_INTEGER$1 : length;
	  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */

	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	var isLength_1 = isLength;

	/** `Object#toString` result references. */

	var argsTag$1 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    weakMapTag$1 = '[object WeakMap]';
	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	/** Used to identify `toStringTag` values of typed arrays. */

	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */

	function baseIsTypedArray(value) {
	  return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function (value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary;

	var _nodeUtil = createCommonjsModule(function (module, exports) {
	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;
	  /** Detect free variable `module`. */

	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
	  /** Detect the popular CommonJS extension `module.exports`. */

	  var moduleExports = freeModule && freeModule.exports === freeExports;
	  /** Detect free variable `process` from Node.js. */

	  var freeProcess = moduleExports && _freeGlobal.process;
	  /** Used to access faster Node.js helpers. */

	  var nodeUtil = function () {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;

	      if (types) {
	        return types;
	      } // Legacy `process.binding('util')` for Node.js < 10.


	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }();

	  module.exports = nodeUtil;
	});

	/* Node.js helper references. */

	var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */

	var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
	var isTypedArray_1 = isTypedArray;

	/** Used for built-in method references. */

	var objectProto$8 = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */

	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray_1(value),
	      isArg = !isArr && isArguments_1(value),
	      isBuff = !isArr && !isArg && isBuffer_1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? _baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
	    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
	    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
	    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
	    _isIndex(key, length)))) {
	      result.push(key);
	    }
	  }

	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */

	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$7;
	  return value === proto;
	}

	var _isPrototype = isPrototype;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */

	var nativeKeys = _overArg(Object.keys, Object);
	var _nativeKeys = nativeKeys;

	/** Used for built-in method references. */

	var objectProto$6 = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */

	function baseKeys(object) {
	  if (!_isPrototype(object)) {
	    return _nativeKeys(object);
	  }

	  var result = [];

	  for (var key in Object(object)) {
	    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }

	  return result;
	}

	var _baseKeys = baseKeys;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = _typeof(value);

	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject;

	/** `Object#toString` result references. */

	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */

	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  } // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.


	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */

	function isArrayLike(value) {
	  return value != null && isLength_1(value.length) && !isFunction_1(value);
	}

	var isArrayLike_1 = isArrayLike;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */

	function keys(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
	}

	var keys_1 = keys;

	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */

	function values(object) {
	  return object == null ? [] : _baseValues(object, keys_1(object));
	}

	var values_1 = values;

	/**
	 * The base implementation of `_.shuffle`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to shuffle.
	 * @returns {Array} Returns the new shuffled array.
	 */

	function baseShuffle(collection) {
	  return _shuffleSelf(values_1(collection));
	}

	var _baseShuffle = baseShuffle;

	/**
	 * Creates an array of shuffled values, using a version of the
	 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to shuffle.
	 * @returns {Array} Returns the new shuffled array.
	 * @example
	 *
	 * _.shuffle([1, 2, 3, 4]);
	 * // => [4, 1, 3, 2]
	 */

	function shuffle(collection) {
	  var func = isArray_1(collection) ? _arrayShuffle : _baseShuffle;
	  return func(collection);
	}

	var shuffle_1 = shuffle;

	var __decorate$q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var BodyElement = /*#__PURE__*/_createClass(function BodyElement(element) {
	  var _this = this;

	  _classCallCheck(this, BodyElement);

	  var _a;

	  this.element = element;
	  this.scrollLocked = new TrackedSubject(false);
	  this.reduceMotion = (_a = localStorage.getItem("oregon-gov-reducemotion") == "true") !== null && _a !== void 0 ? _a : false;
	  this.darkMode = localStorage.getItem("oregon-gov-darkmode") ? localStorage.getItem("oregon-gov-darkmode") == "true" : window.matchMedia('(prefers-color-scheme: dark)').matches;
	  this.scrollLocked.subscribe(function (val) {
	    if (val) {
	      element.classList.add("or-scroll-locked");
	    } else {
	      element.classList.remove("or-scroll-locked");
	    }
	  });

	  if (this.reduceMotion) {
	    document.documentElement.classList.add("or-reduce-motion");
	  }

	  if (this.darkMode) {
	    document.documentElement.classList.add("or-dark-mode");
	  }

	  getTrackedProperty(this, "darkMode").subscribe(function () {
	    if (_this.darkMode) {
	      localStorage.setItem("oregon-gov-darkmode", "true");
	      document.documentElement.classList.add("or-dark-mode");
	    } else {
	      localStorage.setItem("oregon-gov-darkmode", "false");
	      document.documentElement.classList.remove("or-dark-mode");
	    }
	  });
	  getTrackedProperty(this, "reduceMotion").subscribe(function () {
	    if (_this.reduceMotion) {
	      localStorage.setItem("oregon-gov-reducemotion", "true");
	      document.documentElement.classList.add("or-reduce-motion");
	    } else {
	      localStorage.removeItem("oregon-gov-reducemotion");
	      document.documentElement.classList.remove("or-reduce-motion");
	    }
	  }); //this.darkMode = true;
	});

	__decorate$q([tracked], BodyElement.prototype, "reduceMotion", void 0);

	__decorate$q([tracked], BodyElement.prototype, "darkMode", void 0);

	BodyElement = __decorate$q([trackable], BodyElement);
	var bodyElement = new BodyElement(document.body);

	var _templateObject$n, _templateObject2$i, _templateObject3$e, _templateObject4$9, _templateObject5$5;

	var __decorate$p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var isMobile = false;

	if (window.matchMedia("(min-device-width: 0px) and (max-device-width: 767.98px)").matches) {
	  isMobile = true;
	}

	var videos = shuffle_1(["painted-hills", "crater-lake", "mountain", "portland", "multnomah", "vineyard", "haystack", "portland-bridges", "mt-hood", "dome", "coast", "astoria-megler"]).slice(0, isMobile ? 5 : 12); // console.log(videos);

	var videoFormats = ["mp4" //"webm", // Webm appears to cause performance issues due to lack of hardware acceleration s
	];

	var Video = /*#__PURE__*/function () {
	  function Video(index, collection) {
	    var _this = this;

	    _classCallCheck(this, Video);

	    this.element = null;
	    this.loadedEnough = false;
	    this.index = index;
	    this.collection = collection;
	    var currentIndex = read(function () {
	      return _this.collection.currentIndex;
	    });
	    var duration = read(function () {
	      var _a, _b;

	      return (_b = (_a = _this.element) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : null;
	    });
	    var currentTime = read(function () {
	      var _a, _b;

	      return (_b = (_a = _this.element) === null || _a === void 0 ? void 0 : _a.currentTime) !== null && _b !== void 0 ? _b : null;
	    });
	    var buffered = read(function () {
	      if (_this.element == null) {
	        return null;
	      }

	      var buffered = _this.element.buffered;
	      var total = 0;

	      for (var i = 0; i < buffered.length; i++) {
	        var start = buffered.start(i);
	        var end = buffered.end(i);
	        total += end - start;
	      }

	      return total;
	    });
	    var bufferedPercentage = calc(function (b, d) {
	      if (!b || !d) return 0;
	      return Math.round(b / d * 100) / 100;
	    }, buffered, duration);
	    calc(function (p) {
	      if (p > 0.6) {
	        _this.loadedEnough = true;
	      }

	    }, bufferedPercentage);
	    calc(function (d, t, i) {
	      if (_this.index == i && t >= d - 2.5) {
	        _this.collection.increment();
	      }
	    }, duration, currentTime, currentIndex);
	  }

	  _createClass(Video, [{
	    key: "shouldDownload",
	    get: function get() {
	      return this.collection.currentIndex === this.index || this.index === 0 || this.collection.videos[this.index - 1].loadedEnough;
	    }
	  }]);

	  return Video;
	}();

	__decorate$p([tracked], Video.prototype, "loadedEnough", void 0);

	__decorate$p([computed], Video.prototype, "shouldDownload", null);

	Video = __decorate$p([trackable], Video);

	var VideoCollection = /*#__PURE__*/function () {
	  function VideoCollection() {
	    _classCallCheck(this, VideoCollection);

	    this.videos = [];
	    this.currentIndex = 0;
	    this.initialPlay = true; // Instantiate video objects

	    var _iterator = _createForOfIteratorHelper(videos),
	        _step;

	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var name = _step.value;
	        var video = new Video(videos.indexOf(name), this);
	        video.name = name;
	        this.videos.push(video);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  }

	  _createClass(VideoCollection, [{
	    key: "prevIndex",
	    get: function get() {
	      return this.currentIndex == 0 ? this.videos.length - 1 : this.currentIndex - 1;
	    }
	  }, {
	    key: "nextIndex",
	    get: function get() {
	      return this.currentIndex >= this.videos.length - 1 ? 0 : this.currentIndex + 1;
	    }
	  }, {
	    key: "increment",
	    value: function increment() {
	      if (this.currentIndex == this.videos.length - 1) this.currentIndex = 0;else this.currentIndex += 1;

	      if (this.currentIndex >= 1) {
	        this.initialPlay = false;
	      }

	      var el = this.videos[this.currentIndex].element;
	      el.currentTime = 0;
	      el.play();
	    }
	  }]);

	  return VideoCollection;
	}();

	__decorate$p([tracked], VideoCollection.prototype, "currentIndex", void 0);

	__decorate$p([computed], VideoCollection.prototype, "prevIndex", null);

	__decorate$p([computed], VideoCollection.prototype, "nextIndex", null);

	__decorate$p([tracked], VideoCollection.prototype, "initialPlay", void 0);

	VideoCollection = __decorate$p([trackable], VideoCollection);

	var VideoSlideshowElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(VideoSlideshowElement, _BaseElement);

	  var _super = _createSuper(VideoSlideshowElement);

	  function VideoSlideshowElement() {
	    var _this2;

	    _classCallCheck(this, VideoSlideshowElement);

	    _this2 = _super.call(this);
	    _this2.ready = false;
	    _this2.videoCollection = new VideoCollection();

	    if (window.matchMedia("(min-device-width: 0px) and (max-device-width: 767.98px)").matches) {
	      _this2.screenSize = "-sm";
	    } else if (window.matchMedia("(min-device-width: 768px) and (max-device-width: 1499.98px)").matches) {
	      _this2.screenSize = "-md";
	    } else {
	      _this2.screenSize = "-md";
	    }

	    return _this2;
	  }

	  _createClass(VideoSlideshowElement, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this3 = this;

	      _get(_getPrototypeOf(VideoSlideshowElement.prototype), "connectedCallback", this).call(this);

	      getTrackedProperty(bodyElement, "reduceMotion").subscribe(function () {
	        return _this3.requestUpdate();
	      });
	      subscribeAll(this.videoCollection, function () {
	        return _this3.requestUpdate();
	      });
	      this.videoCollection.videos.forEach(function (v) {
	        return subscribeAll(v, function () {
	          return _this3.requestUpdate();
	        });
	      });
	      setTimeout(function () {
	        return _this3.ready = true;
	      }, 1000);
	    }
	  }, {
	    key: "firstUpdated",
	    value: function firstUpdated(props) {
	      _get(_getPrototypeOf(VideoSlideshowElement.prototype), "updated", this).call(this, props);

	      this.querySelector("video:first-of-type"); //firstVideo.play();
	    }
	  }, {
	    key: "updated",
	    value: function updated(props) {
	      var _a;

	      _get(_getPrototypeOf(VideoSlideshowElement.prototype), "updated", this).call(this, props); // Assign HTMLVideoElements to each Video object, so we can keep track of video states


	      var elements = Array.from(this.getElementsByTagName("video"));

	      for (var _i = 0, _elements = elements; _i < _elements.length; _i++) {
	        var el = _elements[_i];
	        var index = parseInt((_a = el.getAttribute("data-index")) !== null && _a !== void 0 ? _a : "0");
	        var video = this.videoCollection.videos[index];

	        if (video.element == null) {
	          video.element = el;
	        }
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;

	      return html(_templateObject$n || (_templateObject$n = _taggedTemplateLiteral(["\n            ", "\n        "])), !bodyElement.reduceMotion && this.ready ? html(_templateObject2$i || (_templateObject2$i = _taggedTemplateLiteral(["\n                ", "\n            "])), this.videoCollection.videos.map(function (video) {
	        return html(_templateObject3$e || (_templateObject3$e = _taggedTemplateLiteral(["\n                    ", "\n                "])), video.shouldDownload ? html(_templateObject4$9 || (_templateObject4$9 = _taggedTemplateLiteral(["\n                        <video\n                            class=", "\n                            muted\n                            autoplay\n                            preload=\"auto\"\n                            playsinline\n                            aria-hidden=\"true\"\n                            data-index=", ">\n\n                            ", "\n                        </video>\n                    "])), classMap({
	          "or-video-initial": _this4.videoCollection.initialPlay,
	          "or-video-next": _this4.videoCollection.nextIndex === video.index,
	          "or-video-active": _this4.videoCollection.currentIndex === video.index,
	          "or-video-prev": _this4.videoCollection.prevIndex === video.index
	        }), video.index, videoFormats.map(function (format) {
	          return html(_templateObject5$5 || (_templateObject5$5 = _taggedTemplateLiteral(["\n                                <source\n                                    src=", "\n                                    type=", " />\n                            "])), "https://images.oregon.gov/Portal/Video/".concat(video.name).concat(_this4.screenSize, ".").concat(format), "video/".concat(format));
	        })) : null);
	      })) : null);
	    }
	  }]);

	  return VideoSlideshowElement;
	}(BaseElement);

	__decorate$p([state()], VideoSlideshowElement.prototype, "ready", void 0);

	VideoSlideshowElement = __decorate$p([customElement("or-video-slideshow")], VideoSlideshowElement);
	// export class VideoSlideshowElement extends BaseElement {
	//     videoId = 0;
	//     nextVideoId = 1;
	//     readonly videoUrls = [
	//         "painted-hills",
	//         "painted-hills"
	//         // "/Video Backgrounds/multnomah.mp4",
	//         // "/Video Backgrounds/mountain.mp4",
	//         // "/Video Backgrounds/haystack.mp4",
	//         // "/Video Backgrounds/crater-lake.mp4",
	//         // "/Video Backgrounds/mt-hood.mp4",
	//         // "/Video Backgrounds/vineyard.mp4",
	//         //"/Video Backgrounds/portland.mp4",     
	//         // "/Video Backgrounds/painted-hills.mp4",
	//         // "/Video Backgrounds/mt-hood.mp4",
	//         // "/Video Backgrounds/vineyard.mp4",
	//         //"/Video Backgrounds/portland-bridges.mp4",
	//         // "/Video Backgrounds/test.mp4",
	//         // "/Video Backgrounds/test2.mp4"
	//     ];
	//     getNextVideo() {
	//         const url = this.videoUrls[this.videoId];
	//         // Increment
	//         this.videoId = this.videoId >= this.videoUrls.length - 1 ? 0 : this.videoId + 1;
	//         return url;
	//     }
	//     prefetchedVideo: HTMLVideoElement | null;
	//     prefetchNext() {
	//         const prefetchUrl = this.videoUrls[this.videoId];
	//         fetch(prefetchUrl);
	//         // Not sure if this is effective at preloading, but it seems to work?
	//     }
	//     createVideo() {
	//         const el = document.createElement("video");
	//         el.setAttribute("autoplay", "");
	//         el.setAttribute("preload", "auto");
	//         el.setAttribute("muted", "");
	//         el.setAttribute("playsinline", "");
	//         el.setAttribute("aria-hidden", "true");
	//         el.src = this.getNextVideo();
	//         return el;
	//     }
	//     connectedCallback() {
	//         super.connectedCallback();
	//     }
	//     prevVideo: HTMLVideoElement;
	//     currentVideo: HTMLVideoElement;
	//     incrementVideos() {
	//         this.prevVideo = this.currentVideo;
	//         this.currentVideo = this.createVideo();
	//         this.attachVideoEvents(this.currentVideo);
	//         this.appendChild(this.currentVideo);
	//     }
	//     attachVideoEvents(video: HTMLVideoElement) {
	//         const callback = (event: Event) => {
	//             const { currentTime, duration } = video;
	//             if (!isNaN(duration) && currentTime > 0 && currentTime >= (duration - 2.5)) {
	//                 video.removeEventListener("timeupdate", callback);
	//                 this.incrementVideos();
	//             }
	//         }
	//         video.addEventListener("timeupdate", callback);
	//         video.addEventListener("ended", () => {
	//             video.remove();
	//         });
	//         const checkIfLoaded = () => {
	//             if (!video || !video.parentElement) {
	//                 return;
	//             }
	//             if (video &&
	//                 video.parentElement != null &&
	//                 video.buffered.length > 0 &&
	//                 (video.buffered.end(0) / video.duration) > 0.9) {
	//                 //console.log("Yes, prefetch");
	//                 this.prefetchNext();
	//             } else {
	//                 setTimeout(checkIfLoaded, 50);
	//             }
	//         }
	//         setTimeout(checkIfLoaded, 50);
	//     }
	//     firstUpdated(props) {
	//         super.firstUpdated(props);
	//         this.incrementVideos();
	//     }
	//     render() {
	//         return html``;
	//     }
	// }

	var _templateObject$m;

	var __decorate$o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$h = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var SecondaryNavigationElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(SecondaryNavigationElement, _BaseElement);

	  var _super = _createSuper(SecondaryNavigationElement);

	  function SecondaryNavigationElement() {
	    var _this;

	    _classCallCheck(this, SecondaryNavigationElement);

	    _this = _super.call(this);
	    _this.modalOpen = false;

	    _this.openModal = function (e) {
	      _this.modalOpen = true;
	      e.preventDefault();
	    };

	    _this.closeModal = function (e) {
	      _this.modalOpen = false;
	      e.preventDefault();
	    };

	    _this.modalWrapperElement = document.createElement("div");

	    _this.init();

	    return _this;
	  }

	  _createClass(SecondaryNavigationElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$h(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var _this2 = this;

	        var modalHtml, modalEl, modalBackdropEl, closeButtonEls;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return fetch('/Includes/secondary-navigation-modal.html').then(function (r) {
	                  if (r.status !== 200) {
	                    throw new Error("Unable to fetch modal template");
	                  }

	                  return r.text();
	                });

	              case 2:
	                modalHtml = _context.sent;
	                this.modalWrapperElement.innerHTML = modalHtml;
	                modalEl = this.modalWrapperElement.querySelector(".modal");
	                modalBackdropEl = this.modalWrapperElement.querySelector('.modal-backdrop');
	                closeButtonEls = Array.from(this.modalWrapperElement.querySelectorAll('.close, .modal-footer button'));
	                getTrackedProperty(this, "modalOpen").subscribe(function () {
	                  // modalOpen has changed
	                  if (_this2.modalOpen) {
	                    modalEl.classList.add("d-block");
	                    modalBackdropEl.classList.remove("d-none");
	                    modalEl.focus();
	                  } else {
	                    modalEl.classList.remove("d-block");
	                    modalBackdropEl.classList.add("d-none");
	                    document.querySelector(".or-official ~ a")?.focus();
	                  }
	                });
	                closeButtonEls.forEach(function (el) {
	                  return el.addEventListener("click", _this2.closeModal);
	                });
	                document.body.insertBefore(this.modalWrapperElement, null);

	              case 10:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$m || (_templateObject$m = _taggedTemplateLiteral(["\n            <div class=\"or-secondary-navigation-content\">\n                <div class=\"or-official\">\n                    <div class=\"d-block d-lg-none\">\n                        <img class=\"or-flag-icon\" src=\"https://images.oregon.gov/Portal/Images/Flags/oregon-flag.jpg\" alt=\"Oregon Flag\" /> \n                        <a class=\"or-link\" href=\"#_\" @click=", ">Official website of the State of Oregon <span class=\"far fa-chevron-right\" aria-hidden=\"true\"></span></a>\n                    </div>\n\n                    <div class=\"d-none d-lg-block\">\n                        <img class=\"or-flag-icon\" src=\"https://images.oregon.gov/Portal/Images/Flags/oregon-flag.jpg\" alt=\"Oregon Flag\" /> Official website of the State of Oregon \n                        <a class=\"or-link\" href=\"#_\" @click=", ">Here's&nbsp;how&nbsp;you&nbsp;know <span class=\"far fa-chevron-right\" aria-hidden=\"true\"></span></a>\n                    </div>\n                </div>\n                <div class=\"or-spacer\"></div>\n                <a class=\"d-none d-lg-block\" href=\"/Pages/agencies.aspx\"><span>Find an agency</span></a>\n                <a class=\"d-none d-lg-block\" href=\"/Pages/services.aspx\"><span>Find a service</span></a>\n                <or-translate></or-translate>\n                <or-accessibility-options></or-accessibility-options>\n            </div>\n        "])), this.openModal, this.openModal);
	    }
	  }]);

	  return SecondaryNavigationElement;
	}(BaseElement);

	__decorate$o([tracked], SecondaryNavigationElement.prototype, "modalOpen", void 0);

	SecondaryNavigationElement = __decorate$o([trackable, customElement("or-secondary-navigation")], SecondaryNavigationElement);

	/**
	 * @license
	 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	var previousValues$1 = new WeakMap();
	/**
	 * For AttributeParts, sets the attribute if the value is defined and removes
	 * the attribute if the value is undefined.
	 *
	 * For other part types, this directive is a no-op.
	 */

	var ifDefined = directive(function (value) {
	  return function (part) {
	    var previousValue = previousValues$1.get(part);

	    if (value === undefined && part instanceof AttributePart) {
	      // If the value is undefined, remove the attribute, but only if the value
	      // was previously defined.
	      if (previousValue !== undefined || !previousValues$1.has(part)) {
	        var name = part.committer.name;
	        part.committer.element.removeAttribute(name);
	      }
	    } else if (value !== previousValue) {
	      part.setValue(value);
	    }

	    previousValues$1.set(part, value);
	  };
	});

	function offsetTopRecursive(element) {
	  var top = element.offsetTop;

	  while (element = element.offsetParent) {
	    top += element.offsetTop;
	  }

	  return top + document.documentElement.offsetTop;
	}

	var spWorkspaceElement = document.querySelector("or-page-edit-wrapper");
	var getWindowWidth = spWorkspaceElement ? function () {
	  return spWorkspaceElement.clientWidth || 0;
	} : function () {
	  return window.innerWidth;
	};
	var getWindowHeight = spWorkspaceElement ? function () {
	  return spWorkspaceElement.clientHeight || 0;
	} : function () {
	  return document.documentElement.clientHeight;
	}; // Gets Y start of workspace element or roughly height of sharepoint ribbon

	var getWindowY = function getWindowY() {
	  return spWorkspaceElement ? offsetTopRecursive(spWorkspaceElement) : 0;
	}; // Always returns window height, even in edit mode

	var getViewportHeight = function getViewportHeight() {
	  return window.innerHeight;
	};
	var getScrollY = spWorkspaceElement ? function () {
	  return spWorkspaceElement.scrollTop;
	} : function () {
	  return window.scrollY || document.documentElement.scrollTop;
	};
	read(function () {
	  return getWindowWidth();
	});
	var windowHeight = read(function () {
	  return getWindowHeight();
	});
	var windowY = read(function () {
	  return getWindowY();
	});
	var viewportHeight = read(function () {
	  return getViewportHeight();
	});
	var scrollY = read(function () {
	  return Math.round(getScrollY());
	});

	var _templateObject$l, _templateObject2$h, _templateObject3$d, _templateObject4$8, _templateObject5$4, _templateObject6$2, _templateObject7$2, _templateObject8$1, _templateObject9$1, _templateObject10$1;

	var __decorate$n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var TopNavigationNode = /*#__PURE__*/function () {
	  function TopNavigationNode(data, collection, parentNode) {
	    _classCallCheck(this, TopNavigationNode);

	    this.id = Math.random();
	    this.name = data.name;
	    this.description = data.description;
	    this.icon = data.icon;
	    this.url = data.url;
	    this.parentNode = parentNode;
	    this.collection = collection;
	    this.viewMoreLinks = data.viewMoreLinks;

	    if (data.items) {
	      this.children = new TopNavigationNodeCollection(data.items, this);
	    }
	  }

	  _createClass(TopNavigationNode, [{
	    key: "isOpen",
	    get: function get() {
	      return this.collection.currentOpenNode == this.id;
	    }
	  }, {
	    key: "hasGrandchildren",
	    get: function get() {
	      return this.children && this.children.hasChildren;
	    }
	  }, {
	    key: "isVisible",
	    get: function get() {
	      var parent = this.parentNode;

	      while (parent) {
	        if (!parent.isOpen) return false;
	        parent = parent.parentNode;
	      }

	      return true;
	    }
	  }, {
	    key: "open",
	    value: function open() {
	      if (this.collection.alwaysOpenFirstChild && this.hasGrandchildren && this.children.currentOpenNode === -1) this.children.open(this.children.firstChild.id);
	      this.collection.open(this.id);
	    }
	  }, {
	    key: "close",
	    value: function close() {
	      if (this.hasGrandchildren) this.children.close();
	      this.collection.close();
	    }
	  }, {
	    key: "toggle",
	    value: function toggle() {
	      if (this.isOpen) {
	        this.close();
	      } else {
	        this.open();
	      }
	    }
	  }]);

	  return TopNavigationNode;
	}();

	__decorate$n([computed], TopNavigationNode.prototype, "isOpen", null);

	TopNavigationNode = __decorate$n([trackable], TopNavigationNode);

	var TopNavigationNodeCollection = /*#__PURE__*/function () {
	  function TopNavigationNodeCollection(data, parentNode) {
	    var _this = this;

	    _classCallCheck(this, TopNavigationNodeCollection);

	    this.currentOpenNode = -1;
	    this.alwaysOpenFirstChild = false;
	    this.parentNode = parentNode;
	    this.nodeArray = data.map(function (item) {
	      return new TopNavigationNode(item, _this, parentNode);
	    });
	  }

	  _createClass(TopNavigationNodeCollection, [{
	    key: "hasChildren",
	    get: function get() {
	      return this.nodeArray.length > 0 && this.nodeArray[0].children;
	    }
	  }, {
	    key: "childrenOpen",
	    get: function get() {
	      var _a, _b;

	      return this.currentOpenNode !== -1 && ((_b = (_a = this.get(this.currentOpenNode)) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.currentOpenNode) != -1;
	    }
	  }, {
	    key: "firstChild",
	    get: function get() {
	      return this.nodeArray.length > 0 ? this.nodeArray[0] : null;
	    }
	  }, {
	    key: "get",
	    value: function get(id) {
	      var _a;

	      return (_a = this.nodeArray.find(function (n) {
	        return n.id === id;
	      })) !== null && _a !== void 0 ? _a : null;
	    }
	  }, {
	    key: "open",
	    value: function open(id) {
	      this.currentOpenNode = id;
	    }
	  }, {
	    key: "close",
	    value: function close() {
	      this.currentOpenNode = -1;
	    }
	  }]);

	  return TopNavigationNodeCollection;
	}();

	__decorate$n([tracked], TopNavigationNodeCollection.prototype, "currentOpenNode", void 0);

	TopNavigationNodeCollection = __decorate$n([trackable], TopNavigationNodeCollection);

	var TopNavigationElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(TopNavigationElement, _BaseElement);

	  var _super = _createSuper(TopNavigationElement);

	  function TopNavigationElement() {
	    var _this2;

	    _classCallCheck(this, TopNavigationElement);

	    _this2 = _super.call(this);
	    _this2.mobileNavigationOpen = false;
	    _this2.isDesktop = false;
	    _this2.overlayElement = document.createElement("div");
	    _this2.overlayElement.className = "or-top-navigation-overlay";
	    var footerEl = document.querySelector("footer");
	    footerEl.parentElement.insertBefore(_this2.overlayElement, footerEl.nextSibling);
	    return _this2;
	  }

	  _createClass(TopNavigationElement, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this3 = this;

	      _get(_getPrototypeOf(TopNavigationElement.prototype), "connectedCallback", this).call(this);

	      var topNavDataEl = document.querySelector("#or-top-navigation-data");
	      var topNavData = JSON.parse(topNavDataEl.innerText);
	      this.navigationNodes = new TopNavigationNodeCollection(topNavData.items);
	      getTrackedProperty(this.navigationNodes, "currentOpenNode").subscribe(function () {
	        var open = _this3.navigationNodes.currentOpenNode != -1;
	        bodyElement.scrollLocked.value = open;

	        if (open) {
	          _this3.overlayElement.classList.add("or-top-navigation-open");

	          return;
	        }

	        _this3.overlayElement.classList.remove("or-top-navigation-open");
	      }); //console.log("Nav nodes", this.navigationNodes);
	      // const getCheckoutType = (spr: ISPRequest, webUrl: string, fileUrl: string) => {
	      //     return spr.get(`${ webUrl }/_api/web/getfilebyserverrelativeurl('${ fileUrl }')/CheckOutType`)
	      //             .then(response => response.body.d.CheckOutType)
	      //             .catch(err => {
	      //                 console.error("Unable to get checkout status for " + fileUrl);
	      //                 return err;
	      //             })
	      //             .catch(error)
	      // }
	      // getTrackedProperty(this, "navigationOpen")
	      //     .subscribe(() => bodyElement.scrollLocked.value = this.navigationOpen);

	      var isDesktop = read(function () {
	        return matchMedia("(min-width: 70rem)");
	      }); // Should match same value in CSS/Sass

	      calc(function (x) {
	        return _this3.isDesktop = x.matches;
	      }, isDesktop);
	      calc(function (x) {
	        return _this3.navigationNodes.alwaysOpenFirstChild = x.matches;
	      }, isDesktop);
	      this.requestUpdate();
	      document.addEventListener("click", function (event) {
	        if (event.target instanceof Element && !event.target.closest("or-top-navigation")) {
	          _this3.navigationNodes.close();
	        }
	      });

	      var traverse = function traverse(nodes) {
	        var _iterator = _createForOfIteratorHelper(nodes.nodeArray),
	            _step;

	        try {
	          for (_iterator.s(); !(_step = _iterator.n()).done;) {
	            var node = _step.value;
	            subscribeAll(node, function () {
	              return _this3.requestUpdate();
	            });
	            if (node.children) traverse(node.children);
	          }
	        } catch (err) {
	          _iterator.e(err);
	        } finally {
	          _iterator.f();
	        }
	      };

	      traverse(this.navigationNodes);
	      subscribeAll(this, function () {
	        return _this3.requestUpdate();
	      });
	    }
	  }, {
	    key: "firstUpdated",
	    value: function firstUpdated(props) {
	      var _this4 = this;

	      _get(_getPrototypeOf(TopNavigationElement.prototype), "firstUpdated", this).call(this, props);

	      var navTop = read(function () {
	        return offsetTopRecursive(_this4.navElement);
	      });
	      write(function (y, height) {
	        _this4.navElement.style.height = "".concat(height - y, "px");
	      }, navTop, viewportHeight);
	      var navHeight = read(function () {
	        return _this4.navElement.clientHeight;
	      });
	      write(function (h, y, s) {
	        return _this4.overlayElement.style.top = "".concat(Math.max(y, s) - s + h, "px");
	      }, navHeight, navTop, scrollY);
	      var submenuCategoryEls = Array.from(this.querySelectorAll(".or-submenu-categories"));
	      var submenuItemEls = submenuCategoryEls.map(function (categoryEl) {
	        return Array.from(categoryEl.querySelectorAll(".or-submenu-items"));
	      });
	      submenuItemEls.forEach(function (itemEls, i) {
	        var categoryEl = submenuCategoryEls[i];
	        var categoryListPaddingHeight = read(function () {
	          var style = getComputedStyle(categoryEl);
	          return parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
	        });
	        var openItemHeight = read(function () {
	          return itemEls.reduce(function (result, el, i) {
	            if (el.classList.contains("or-open")) return el.clientHeight;
	            return result;
	          }, 0);
	        });
	        var categoryListHeight = calc(function (paddingHeight) {
	          return Array.from(categoryEl.children).reduce(function (result, el, i) {
	            return result + el.clientHeight;
	          }, paddingHeight);
	        }, categoryListPaddingHeight);
	        var minHeight = calc(function (a, b) {
	          return Math.max(a, b);
	        }, categoryListHeight, openItemHeight);
	        write(function (h) {
	          return categoryEl.style.height = "".concat(h, "px");
	        }, minHeight);
	      });
	    }
	  }, {
	    key: "toggleNode",
	    value: function toggleNode(event, node) {
	      node.toggle();
	      event.preventDefault();
	    }
	  }, {
	    key: "openNode",
	    value: function openNode(event, node) {
	      node.open();
	      event.preventDefault();
	    }
	  }, {
	    key: "getNodeClickEvent",
	    value: function getNodeClickEvent(node) {
	      var _this5 = this;

	      if (node.url) {
	        return null;
	      } // if (!node.parentNode) {
	      //     return (e) => this.toggleNode(e, node);
	      // }


	      return function (e) {
	        if (!node.parentNode || !_this5.isDesktop) {
	          _this5.toggleNode(e, node);
	        } else {
	          _this5.openNode(e, node);
	        }
	      };
	    }
	  }, {
	    key: "getNodeHoverEvent",
	    value: function getNodeHoverEvent(item) {
	      var _this6 = this;

	      if (this.isDesktop && !item.url && item.parentNode && item.children) {
	        return function (e) {
	          return _this6.openNode(e, item);
	        };
	      }

	      return null;
	    }
	  }, {
	    key: "toggleButtonClicked",
	    value: function toggleButtonClicked(e) {
	      this.mobileNavigationOpen = !this.mobileNavigationOpen;
	      e.preventDefault();
	    }
	  }, {
	    key: "backButtonClicked",
	    value: function backButtonClicked(coll) {
	      //console.log("Attaching on click")
	      return function (event) {
	        var _a; //console.log("Running on click")


	        (_a = coll.parentNode) === null || _a === void 0 ? void 0 : _a.collection.close();
	        event.preventDefault();
	      };
	    }
	  }, {
	    key: "renderNodeRecursive",
	    value: function renderNodeRecursive(node, level) {
	      var name = node.name,
	          description = node.description,
	          icon = node.icon,
	          url = node.url,
	          children = node.children,
	          isOpen = node.isOpen,
	          isVisible = node.isVisible,
	          viewMoreLinks = node.viewMoreLinks;
	      return html(_templateObject$l || (_templateObject$l = _taggedTemplateLiteral(["\n            <li>\n                <a\n                    class=", "\n                    href=", "\n                    @click=", "\n                    @mouseover=", "\n                    title=", "\n                    tabindex=", ">\n\n                    ", "\n\n                    <span class=\"or-top-navigation-link-name\">", "</span>\n\n                    ", "\n\n                    ", "\n\n                    ", "\n                </a>\n\n                ", "\n\n                ", "\n            </li>\n        "])), classMap({
	        "or-open": isOpen
	      }), url !== null && url !== void 0 ? url : "#", this.getNodeClickEvent(node), this.getNodeHoverEvent(node), ifDefined(level < 2 ? description : undefined), isVisible ? 0 : -1, icon ? html(_templateObject2$h || (_templateObject2$h = _taggedTemplateLiteral(["\n                        <span class=", "></span>\n                    "])), icon + " or-top-navigation-category-icon") : null, name, level === 0 ? html(_templateObject3$d || (_templateObject3$d = _taggedTemplateLiteral(["\n                        <span class=\"or-top-navigation-underline\"></span>\n                    "]))) : null, level === 1 ? html(_templateObject4$8 || (_templateObject4$8 = _taggedTemplateLiteral(["\n                        <span class=\"fal fa-chevron-right\"></span>\n                    "]))) : null, level > 1 ? html(_templateObject5$4 || (_templateObject5$4 = _taggedTemplateLiteral(["\n                        <span class=\"or-top-navigation-link-description\">", "</span>\n                    "])), description) : null, children && level < 2 ? this.renderNodesRecursive(children, level + 1, viewMoreLinks != null) : null, viewMoreLinks ? html(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteral(["\n                    <div class=", ">\n                        ", "\n                    </div>\n                "])), classMap({
	        "or-viewmore": true,
	        "or-open": isOpen
	      }), viewMoreLinks.map(function (link) {
	        return html(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteral(["\n                            <a href=", "\n                            tabindex=", ">", "</a>\n                        "])), link.url, isOpen ? 0 : -1, link.label);
	      })) : null);
	    }
	  }, {
	    key: "renderNodesRecursive",
	    value: function renderNodesRecursive(collection) {
	      var _this7 = this;

	      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var parentHasViewMoreLinks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      var _a, _b, _c, _d, _e;

	      return html(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteral(["\n            ", "\n\n            <ul class=", ">\n                ", "\n            </ul>\n        "])), level > 1 ? html(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteral(["\n                <button\n                    class=", "\n                    @click=", ">\n                    <span class=\"far fa-chevron-left\" aria-hidden=\"true\"></span> Back to ", "\n                </button>\n            "])), classMap({
	        "or-top-navigation-back": true,
	        "or-open": (_b = (_a = collection.parentNode) === null || _a === void 0 ? void 0 : _a.isOpen) !== null && _b !== void 0 ? _b : false
	      }), this.backButtonClicked(collection), (_c = collection.parentNode) === null || _c === void 0 ? void 0 : _c.name) : null, classMap({
	        "or-menu": level === 0,
	        "or-submenu-categories": level === 1,
	        "or-submenu-items": level === 2,
	        "or-open": (_e = (_d = collection.parentNode) === null || _d === void 0 ? void 0 : _d.isOpen) !== null && _e !== void 0 ? _e : false,
	        "or-items-closed": collection.currentOpenNode === -1,
	        "or-children-open": collection.childrenOpen,
	        "or-parent-has-viewmore": parentHasViewMoreLinks
	      }), collection.nodeArray.map(function (node) {
	        return _this7.renderNodeRecursive(node, level);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject10$1 || (_templateObject10$1 = _taggedTemplateLiteral(["\n            <a class=\"or-top-navigation-logo\" href=\"/\">\n                <img src=\"/PublishingImages/oregon-logo-no-path.svg\" alt=\"Oregon.gov Logo\" />\n                <img class=\"or-top-navigation-logo-reverse\" aria-hidden=\"true\" src=\"/PublishingImages/oregon-logo-no-path-reverse.svg\" alt=\"Oregon.gov Logo with White Text\" />\n            </a>\n\n            <div class=\"or-top-navigation-spacer\">\n            </div>\n\n            <a class=\"or-top-navigation-search-toggle\" href=\"/Pages/search-results.aspx\">\n                <span class=\"far fa-search\" aria-hidden=\"true\"></span>\n                <span class=\"sr-only\">Search Oregon.gov</span>\n            </a>\n\n            <button class=\"or-top-navigation-toggle\"\n                @click=", ">\n                <span class=\"sr-only\">Toggle main navigation</span>\n                <span class=", "></span>\n            </button>\n\n            <nav class=", ">\n                ", "\n            </nav>\n        "])), this.toggleButtonClicked, this.mobileNavigationOpen ? "far fa-times" : "far fa-bars", classMap({
	        "or-navigation-open": this.mobileNavigationOpen
	      }), this.navigationNodes ? this.renderNodesRecursive(this.navigationNodes) : null);
	    }
	  }]);

	  return TopNavigationElement;
	}(BaseElement);

	__decorate$n([tracked], TopNavigationElement.prototype, "mobileNavigationOpen", void 0);

	__decorate$n([tracked], TopNavigationElement.prototype, "isDesktop", void 0);

	__decorate$n([query("nav")], TopNavigationElement.prototype, "navElement", void 0);

	TopNavigationElement = __decorate$n([trackable, customElement("or-top-navigation")], TopNavigationElement);

	var _templateObject$k;

	var __decorate$m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var TopBarElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(TopBarElement, _BaseElement);

	  var _super = _createSuper(TopBarElement);

	  function TopBarElement() {
	    _classCallCheck(this, TopBarElement);

	    return _super.call(this);
	  }

	  _createClass(TopBarElement, [{
	    key: "firstUpdated",
	    value: function firstUpdated(props) {
	      var _this = this;

	      _get(_getPrototypeOf(TopBarElement.prototype), "firstUpdated", this).call(this, props); // const headerEl = this.parentElement;
	      // if (!headerEl) {
	      //     throw new Error("Top bar has no parent");
	      // }


	      var translateBarHeight = read(function () {
	        var anonymous = document.body.classList.contains("or-anonymous");
	        if (!anonymous) return 0;
	        var el = document.querySelector('.goog-te-banner-frame');
	        if (!el) return 0;
	        return el.offsetHeight;
	      });
	      var topNavigationY = read(function () {
	        return offsetTopRecursive(_this.topNavPlaceholderEl);
	      });
	      var topNavigationHeight = read(function () {
	        return _this.topNavigationEl.clientHeight;
	      });
	      var targetY = calc(function (a, b, c) {
	        return a - b + c;
	      }, topNavigationY, windowY, translateBarHeight);
	      var isFixed = calc(function (y, t) {
	        return y >= t;
	      }, scrollY, targetY);
	      var isTransparent = calc(function (f) {
	        return !f;
	      }, isFixed);
	      calc(function (f, y) {
	        return f ? y : null;
	      }, isFixed, windowY); //write(y => this.style.top = y != null ? `${y}px` : "", topBarY);

	      write(function (f, h) {
	        return _this.topNavigationEl.style.top = f ? "".concat(h, "px") : "";
	      }, isFixed, windowY);
	      write(function (f, h) {
	        return _this.topNavPlaceholderEl.style.height = f ? "".concat(h, "px") : "";
	      }, isFixed, topNavigationHeight);
	      write(function (f) {
	        return f ? _this.classList.add("or-fixed") : _this.classList.remove("or-fixed");
	      }, isFixed);
	      write(function (t) {
	        return t ? _this.classList.add("or-transparent") : _this.classList.remove("or-transparent");
	      }, isTransparent); // const parentY = read(() => offsetTopRecursive(headerEl));
	      // write((y, h) => this.style.top = `${y + h}px`, parentY, translateBarHeight);
	      // scrollY.value === 0 ? this.classList.add("or-transparent") : this.classList.remove("or-transparent");
	      // write(y => y === 0 ? this.classList.add("or-transparent") : this.classList.remove("or-transparent"), scrollY);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$k || (_templateObject$k = _taggedTemplateLiteral(["\n            <a href=\"#main\" class=\"or-skip-to-main\">Skip to main content</a>\n            <or-alerts></or-alerts>\n            <or-secondary-navigation></or-secondary-navigation>\n            <div class=\"or-top-navigation-placeholder\"></div>\n            <or-top-navigation></or-top-navigation>\n        "])));
	    }
	  }]);

	  return TopBarElement;
	}(BaseElement);

	__decorate$m([query('or-top-navigation')], TopBarElement.prototype, "topNavigationEl", void 0);

	__decorate$m([query('.or-top-navigation-placeholder')], TopBarElement.prototype, "topNavPlaceholderEl", void 0);

	TopBarElement = __decorate$m([customElement("or-top-bar")], TopBarElement);

	var __awaiter$g = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var ListItemClient = /*#__PURE__*/function () {
	  function ListItemClient(webUrl) {
	    _classCallCheck(this, ListItemClient);

	    if (typeof webUrl === "undefined") {
	      webUrl = _spPageContextInfo.webServerRelativeUrl;
	    }

	    this.webUrl = webUrl;
	  }

	  _createClass(ListItemClient, [{
	    key: "convertToQueryStr",
	    value: function convertToQueryStr(queryParams) {
	      var queryStr = Object.keys(queryParams).reduce(function (result, key) {
	        return result + '&' + key + '=' + queryParams[key];
	      }, '');
	      if (queryStr) queryStr = '?' + queryStr;
	      return queryStr;
	    }
	  }, {
	    key: "getListItems",
	    value: function getListItems(listTitle) {
	      var selectFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	      var expandFields = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	      var top = arguments.length > 3 ? arguments[3] : undefined;
	      return __awaiter$g(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var queryParams, queryStr, fetchUrl, cacheKey, cachedBodyRaw, response;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                queryParams = {};

	                if (selectFields.length > 0) {
	                  queryParams.$select = selectFields.join(',');
	                }

	                if (expandFields.length > 0) {
	                  queryParams.$expand = expandFields.join(',');
	                }

	                if (top != null) {
	                  queryParams.$top = top.toString();
	                }

	                queryStr = this.convertToQueryStr(queryParams);
	                fetchUrl = "".concat(this.webUrl !== "/" ? this.webUrl : "", "/_api/web/lists/GetByTitle('").concat(listTitle, "')/items").concat(queryStr);
	                cacheKey = "oregon-gov-sprest-" + fetchUrl;
	                cachedBodyRaw = sessionStorage.getItem(cacheKey);

	                if (!cachedBodyRaw) {
	                  _context.next = 10;
	                  break;
	                }

	                return _context.abrupt("return", JSON.parse(cachedBodyRaw).d.results);

	              case 10:
	                _context.next = 12;
	                return fetch(fetchUrl, {
	                  headers: {
	                    Accept: "application/json;odata=verbose"
	                  }
	                }).then(function (r) {
	                  var _a;

	                  if (!r.ok) {
	                    console.error(r.status, r.statusText);

	                    if (r.status === 404) {
	                      console.error("Rest entity could not be found", fetchUrl);
	                    }
	                  }

	                  if (((_a = r.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.indexOf("json")) === -1) {
	                    throw new Error("Response is not JSON");
	                  } // Attempt to parse even if error, because response often has server side message


	                  // Attempt to parse even if error, because response often has server side message
	                  return r.json();
	                }).catch(function (err) {
	                  console.error(err);
	                  throw err;
	                });

	              case 12:
	                response = _context.sent;

	                /***
	                 * Fixing temporary bug with prod.oregon.gov
	                 */
	                response = JSON.parse(JSON.stringify(response).replace(/prod\.oregon\.gov/gi, "www.oregon.gov"));

	                if (!response.error) {
	                  _context.next = 17;
	                  break;
	                }

	                console.error("Server side error message", response.error.code, response.error.message.value);
	                throw new Error("Unable to fetch list items");

	              case 17:
	                sessionStorage.setItem(cacheKey, JSON.stringify(response));
	                return _context.abrupt("return", response.d.results);

	              case 19:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }]);

	  return ListItemClient;
	}();

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }

	  return array;
	}

	var _arrayPush = arrayPush;

	/** Built-in value references. */

	var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */

	function isFlattenable(value) {
	  return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	var _isFlattenable = isFlattenable;

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */

	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;
	  predicate || (predicate = _isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];

	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        _arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }

	  return result;
	}

	var _baseFlatten = baseFlatten;

	/** `Object#toString` result references. */

	var symbolTag$1 = '[object Symbol]';
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */

	function isSymbol(value) {
	  return _typeof(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1;
	}

	var isSymbol_1 = isSymbol;

	/** Used to match property names within property paths. */

	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */

	function isKey(value, object) {
	  if (isArray_1(value)) {
	    return false;
	  }

	  var type = _typeof(value);

	  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
	    return true;
	  }

	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
	}

	var _isKey = isKey;

	/** Used to detect overreaching core-js shims. */

	var coreJsData = _root['__core-js_shared__'];
	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */

	var maskSrcKey = function () {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? 'Symbol(src)_1.' + uid : '';
	}();
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */


	function isMasked(func) {
	  return !!maskSrcKey && maskSrcKey in func;
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype;
	/** Used to resolve the decompiled source of functions. */

	var funcToString$1 = funcProto$1.toString;
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */

	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString$1.call(func);
	    } catch (e) {}

	    try {
	      return func + '';
	    } catch (e) {}
	  }

	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */

	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	/** Used to detect host constructors (Safari). */

	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	/** Used for built-in method references. */

	var funcProto = Function.prototype,
	    objectProto$5 = Object.prototype;
	/** Used to resolve the decompiled source of functions. */

	var funcToString = funcProto.toString;
	/** Used to check objects for own properties. */

	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
	/** Used to detect if a method is native. */

	var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */

	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }

	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */

	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */

	var nativeCreate = _getNative(Object, 'create');
	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */

	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */

	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
	/** Used for built-in method references. */

	var objectProto$4 = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */

	function hashGet(key) {
	  var data = this.__data__;

	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$2 ? undefined : result;
	  }

	  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */

	var objectProto$3 = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? data[key] !== undefined : hasOwnProperty$2.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */

	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */

	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */

	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	  this.clear();

	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	} // Add methods to `Hash`.


	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;
	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || value !== value && other !== other;
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */

	function assocIndexOf(array, key) {
	  var length = array.length;

	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }

	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */

	var arrayProto = Array.prototype;
	/** Built-in value references. */

	var splice = arrayProto.splice;
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }

	  var lastIndex = data.length - 1;

	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }

	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */

	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);
	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */

	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }

	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */

	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	  this.clear();

	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	} // Add methods to `ListCache`.


	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;
	var _ListCache = ListCache;

	/* Built-in method references that are verified to be native. */

	var Map$1 = _getNative(_root, 'Map');
	var _Map = Map$1;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */

	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash(),
	    'map': new (_Map || _ListCache)(),
	    'string': new _Hash()
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = _typeof(value);

	  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */

	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */

	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */

	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;
	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */

	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;
	  this.clear();

	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	} // Add methods to `MapCache`.


	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;
	var _MapCache = MapCache;

	/** Error message constants. */

	var FUNC_ERROR_TEXT$1 = 'Expected a function';
	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */

	function memoize(func, resolver) {
	  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }

	  var memoized = function memoized() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }

	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };

	  memoized.cache = new (memoize.Cache || _MapCache)();
	  return memoized;
	} // Expose `MapCache`.


	memoize.Cache = _MapCache;
	var memoize_1 = memoize;

	/** Used as the maximum memoize cache size. */

	var MAX_MEMOIZE_SIZE = 500;
	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */

	function memoizeCapped(func) {
	  var result = memoize_1(func, function (key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }

	    return key;
	  });
	  var cache = result.cache;
	  return result;
	}

	var _memoizeCapped = memoizeCapped;

	/** Used to match property names within property paths. */

	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	/** Used to match backslashes in property paths. */

	var reEscapeChar = /\\(\\)?/g;
	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */

	var stringToPath = _memoizeCapped(function (string) {
	  var result = [];

	  if (string.charCodeAt(0) === 46
	  /* . */
	  ) {
	    result.push('');
	  }

	  string.replace(rePropName, function (match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
	  });
	  return result;
	});
	var _stringToPath = stringToPath;

	/** Used as references for various `Number` constants. */

	var INFINITY$2 = 1 / 0;
	/** Used to convert symbols to primitives and strings. */

	var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
	    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */

	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }

	  if (isArray_1(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return _arrayMap(value, baseToString) + '';
	  }

	  if (isSymbol_1(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }

	  var result = value + '';
	  return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
	}

	var _baseToString = baseToString;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */

	function toString$1(value) {
	  return value == null ? '' : _baseToString(value);
	}

	var toString_1 = toString$1;

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */

	function castPath(value, object) {
	  if (isArray_1(value)) {
	    return value;
	  }

	  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
	}

	var _castPath = castPath;

	/** Used as references for various `Number` constants. */

	var INFINITY$1 = 1 / 0;
	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */

	function toKey(value) {
	  if (typeof value == 'string' || isSymbol_1(value)) {
	    return value;
	  }

	  var result = value + '';
	  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
	}

	var _toKey = toKey;

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */

	function baseGet(object, path) {
	  path = _castPath(path, object);
	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[_toKey(path[index++])];
	  }

	  return index && index == length ? object : undefined;
	}

	var _baseGet = baseGet;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */

	function stackClear() {
	  this.__data__ = new _ListCache();
	  this.size = 0;
	}

	var _stackClear = stackClear;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);
	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas;

	/** Used as the size to enable large array optimizations. */

	var LARGE_ARRAY_SIZE$1 = 200;
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */

	function stackSet(key, value) {
	  var data = this.__data__;

	  if (data instanceof _ListCache) {
	    var pairs = data.__data__;

	    if (!_Map || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }

	    data = this.__data__ = new _MapCache(pairs);
	  }

	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */

	function Stack(entries) {
	  var data = this.__data__ = new _ListCache(entries);
	  this.size = data.size;
	} // Add methods to `Stack`.


	Stack.prototype.clear = _stackClear;
	Stack.prototype['delete'] = _stackDelete;
	Stack.prototype.get = _stackGet;
	Stack.prototype.has = _stackHas;
	Stack.prototype.set = _stackSet;
	var _Stack = Stack;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */

	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);

	  return this;
	}

	var _setCacheAdd = setCacheAdd;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */

	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;
	  this.__data__ = new _MapCache();

	  while (++index < length) {
	    this.add(values[index]);
	  }
	} // Add methods to `SetCache`.


	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
	SetCache.prototype.has = _setCacheHas;
	var _SetCache = SetCache;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }

	  return false;
	}

	var _arraySome = arraySome;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas;

	/** Used to compose bitmasks for value comparisons. */

	var COMPARE_PARTIAL_FLAG$5 = 1,
	    COMPARE_UNORDERED_FLAG$3 = 2;
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */

	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  } // Check that cyclic values are equal.


	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);

	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }

	  var index = -1,
	      result = true,
	      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new _SetCache() : undefined;
	  stack.set(array, other);
	  stack.set(other, array); // Ignore non-index properties.

	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
	    }

	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }

	      result = false;
	      break;
	    } // Recursively compare arrays (susceptible to call stack limits).


	    if (seen) {
	      if (!_arraySome(other, function (othValue, othIndex) {
	        if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	          return seen.push(othIndex);
	        }
	      })) {
	        result = false;
	        break;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	      result = false;
	      break;
	    }
	  }

	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	var _equalArrays = equalArrays;

	/** Built-in value references. */

	var Uint8Array = _root.Uint8Array;
	var _Uint8Array = Uint8Array;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	  map.forEach(function (value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	var _mapToArray = mapToArray;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);
	  set.forEach(function (value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray;

	/** Used to compose bitmasks for value comparisons. */

	var COMPARE_PARTIAL_FLAG$4 = 1,
	    COMPARE_UNORDERED_FLAG$2 = 2;
	/** `Object#toString` result references. */

	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag$1 = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag$1 = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]';
	/** Used to convert symbols to primitives and strings. */

	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */

	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$1:
	      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
	        return false;
	      }

	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
	        return false;
	      }

	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq_1(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == other + '';

	    case mapTag$1:
	      var convert = _mapToArray;

	    case setTag$1:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
	      convert || (convert = _setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      } // Assume cyclic values are equal.


	      var stacked = stack.get(object);

	      if (stacked) {
	        return stacked == other;
	      }

	      bitmask |= COMPARE_UNORDERED_FLAG$2; // Recursively compare objects (susceptible to call stack limits).

	      stack.set(object, other);
	      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }

	  }

	  return false;
	}

	var _equalByTag = equalByTag;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */

	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];

	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }

	  return result;
	}

	var _arrayFilter = arrayFilter;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	var stubArray_1 = stubArray;

	/** Used for built-in method references. */

	var objectProto$2 = Object.prototype;
	/** Built-in value references. */

	var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
	/* Built-in method references for those with the same name as other `lodash` methods. */

	var nativeGetSymbols = Object.getOwnPropertySymbols;
	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */

	var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
	  if (object == null) {
	    return [];
	  }

	  object = Object(object);
	  return _arrayFilter(nativeGetSymbols(object), function (symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};
	var _getSymbols = getSymbols;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */

	function getAllKeys(object) {
	  return _baseGetAllKeys(object, keys_1, _getSymbols);
	}

	var _getAllKeys = getAllKeys;

	/** Used to compose bitmasks for value comparisons. */

	var COMPARE_PARTIAL_FLAG$3 = 1;
	/** Used for built-in method references. */

	var objectProto$1 = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */

	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
	      objProps = _getAllKeys(object),
	      objLength = objProps.length,
	      othProps = _getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }

	  var index = objLength;

	  while (index--) {
	    var key = objProps[index];

	    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
	      return false;
	    }
	  } // Check that cyclic values are equal.


	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);

	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }

	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	  var skipCtor = isPartial;

	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
	    } // Recursively compare objects (susceptible to call stack limits).


	    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
	      result = false;
	      break;
	    }

	    skipCtor || (skipCtor = key == 'constructor');
	  }

	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

	    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }

	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	var _equalObjects = equalObjects;

	/* Built-in method references that are verified to be native. */

	var DataView$1 = _getNative(_root, 'DataView');
	var _DataView = DataView$1;

	/* Built-in method references that are verified to be native. */

	var Promise$1 = _getNative(_root, 'Promise');
	var _Promise = Promise$1;

	/* Built-in method references that are verified to be native. */

	var Set$1 = _getNative(_root, 'Set');
	var _Set = Set$1;

	/* Built-in method references that are verified to be native. */

	var WeakMap$1 = _getNative(_root, 'WeakMap');
	var _WeakMap = WeakMap$1;

	/** `Object#toString` result references. */

	var mapTag = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';
	var dataViewTag = '[object DataView]';
	/** Used to detect maps, sets, and weakmaps. */

	var dataViewCtorString = _toSource(_DataView),
	    mapCtorString = _toSource(_Map),
	    promiseCtorString = _toSource(_Promise),
	    setCtorString = _toSource(_Set),
	    weakMapCtorString = _toSource(_WeakMap);
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */

	var getTag = _baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

	if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag || _Map && getTag(new _Map()) != mapTag || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag || _WeakMap && getTag(new _WeakMap()) != weakMapTag) {
	  getTag = function getTag(value) {
	    var result = _baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? _toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString:
	          return dataViewTag;

	        case mapCtorString:
	          return mapTag;

	        case promiseCtorString:
	          return promiseTag;

	        case setCtorString:
	          return setTag;

	        case weakMapCtorString:
	          return weakMapTag;
	      }
	    }

	    return result;
	  };
	}

	var _getTag = getTag;

	/** Used to compose bitmasks for value comparisons. */

	var COMPARE_PARTIAL_FLAG$2 = 1;
	/** `Object#toString` result references. */

	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';
	/** Used for built-in method references. */

	var objectProto = Object.prototype;
	/** Used to check objects for own properties. */

	var hasOwnProperty = objectProto.hasOwnProperty;
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */

	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray_1(object),
	      othIsArr = isArray_1(other),
	      objTag = objIsArr ? arrayTag : _getTag(object),
	      othTag = othIsArr ? arrayTag : _getTag(other);
	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer_1(object)) {
	    if (!isBuffer_1(other)) {
	      return false;
	    }

	    objIsArr = true;
	    objIsObj = false;
	  }

	  if (isSameTag && !objIsObj) {
	    stack || (stack = new _Stack());
	    return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }

	  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;
	      stack || (stack = new _Stack());
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }

	  if (!isSameTag) {
	    return false;
	  }

	  stack || (stack = new _Stack());
	  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	var _baseIsEqualDeep = baseIsEqualDeep;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */

	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }

	  if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
	    return value !== value && other !== other;
	  }

	  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	var _baseIsEqual = baseIsEqual;

	/** Used to compose bitmasks for value comparisons. */

	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;
	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */

	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }

	  object = Object(object);

	  while (index--) {
	    var data = matchData[index];

	    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
	      return false;
	    }
	  }

	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new _Stack();

	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }

	      if (!(result === undefined ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
	        return false;
	      }
	    }
	  }

	  return true;
	}

	var _baseIsMatch = baseIsMatch;

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */

	function isStrictComparable(value) {
	  return value === value && !isObject_1(value);
	}

	var _isStrictComparable = isStrictComparable;

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */

	function getMatchData(object) {
	  var result = keys_1(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];
	    result[length] = [key, value, _isStrictComparable(value)];
	  }

	  return result;
	}

	var _getMatchData = getMatchData;

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function (object) {
	    if (object == null) {
	      return false;
	    }

	    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
	  };
	}

	var _matchesStrictComparable = matchesStrictComparable;

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */

	function baseMatches(source) {
	  var matchData = _getMatchData(source);

	  if (matchData.length == 1 && matchData[0][2]) {
	    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }

	  return function (object) {
	    return object === source || _baseIsMatch(object, source, matchData);
	  };
	}

	var _baseMatches = baseMatches;

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */

	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : _baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	var get_1 = get;

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	var _baseHasIn = baseHasIn;

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */

	function hasPath(object, path, hasFunc) {
	  path = _castPath(path, object);
	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = _toKey(path[index]);

	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }

	    object = object[key];
	  }

	  if (result || ++index != length) {
	    return result;
	  }

	  length = object == null ? 0 : object.length;
	  return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
	}

	var _hasPath = hasPath;

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */

	function hasIn(object, path) {
	  return object != null && _hasPath(object, path, _baseHasIn);
	}

	var hasIn_1 = hasIn;

	/** Used to compose bitmasks for value comparisons. */

	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;
	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */

	function baseMatchesProperty(path, srcValue) {
	  if (_isKey(path) && _isStrictComparable(srcValue)) {
	    return _matchesStrictComparable(_toKey(path), srcValue);
	  }

	  return function (object) {
	    var objValue = get_1(object, path);
	    return objValue === undefined && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	var _baseMatchesProperty = baseMatchesProperty;

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	var identity_1 = identity;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function (object) {
	    return object == null ? undefined : object[key];
	  };
	}

	var _baseProperty = baseProperty;

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */

	function basePropertyDeep(path) {
	  return function (object) {
	    return _baseGet(object, path);
	  };
	}

	var _basePropertyDeep = basePropertyDeep;

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */

	function property(path) {
	  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
	}

	var property_1 = property;

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */

	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }

	  if (value == null) {
	    return identity_1;
	  }

	  if (_typeof(value) == 'object') {
	    return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
	  }

	  return property_1(value);
	}

	var _baseIteratee = baseIteratee;

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function (object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];

	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }

	    return object;
	  };
	}

	var _createBaseFor = createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */

	var baseFor = _createBaseFor();
	var _baseFor = baseFor;

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */

	function baseForOwn(object, iteratee) {
	  return object && _baseFor(object, iteratee, keys_1);
	}

	var _baseForOwn = baseForOwn;

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */

	function createBaseEach(eachFunc, fromRight) {
	  return function (collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }

	    if (!isArrayLike_1(collection)) {
	      return eachFunc(collection, iteratee);
	    }

	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while (fromRight ? index-- : ++index < length) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }

	    return collection;
	  };
	}

	var _createBaseEach = createBaseEach;

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */

	var baseEach = _createBaseEach(_baseForOwn);
	var _baseEach = baseEach;

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */

	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike_1(collection) ? Array(collection.length) : [];
	  _baseEach(collection, function (value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	var _baseMap = baseMap;

	/**
	 * The base implementation of `_.sortBy` which uses `comparer` to define the
	 * sort order of `array` and replaces criteria objects with their corresponding
	 * values.
	 *
	 * @private
	 * @param {Array} array The array to sort.
	 * @param {Function} comparer The function to define sort order.
	 * @returns {Array} Returns `array`.
	 */
	function baseSortBy(array, comparer) {
	  var length = array.length;
	  array.sort(comparer);

	  while (length--) {
	    array[length] = array[length].value;
	  }

	  return array;
	}

	var _baseSortBy = baseSortBy;

	/**
	 * Compares values to sort them in ascending order.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {number} Returns the sort order indicator for `value`.
	 */

	function compareAscending(value, other) {
	  if (value !== other) {
	    var valIsDefined = value !== undefined,
	        valIsNull = value === null,
	        valIsReflexive = value === value,
	        valIsSymbol = isSymbol_1(value);
	    var othIsDefined = other !== undefined,
	        othIsNull = other === null,
	        othIsReflexive = other === other,
	        othIsSymbol = isSymbol_1(other);

	    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
	      return 1;
	    }

	    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
	      return -1;
	    }
	  }

	  return 0;
	}

	var _compareAscending = compareAscending;

	/**
	 * Used by `_.orderBy` to compare multiple properties of a value to another
	 * and stable sort them.
	 *
	 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	 * specify an order of "desc" for descending or "asc" for ascending sort order
	 * of corresponding values.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {boolean[]|string[]} orders The order to sort by for each property.
	 * @returns {number} Returns the sort order indicator for `object`.
	 */

	function compareMultiple(object, other, orders) {
	  var index = -1,
	      objCriteria = object.criteria,
	      othCriteria = other.criteria,
	      length = objCriteria.length,
	      ordersLength = orders.length;

	  while (++index < length) {
	    var result = _compareAscending(objCriteria[index], othCriteria[index]);

	    if (result) {
	      if (index >= ordersLength) {
	        return result;
	      }

	      var order = orders[index];
	      return result * (order == 'desc' ? -1 : 1);
	    }
	  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	  // that causes it, under certain circumstances, to provide the same value for
	  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	  // for more details.
	  //
	  // This also ensures a stable sort in V8 and other engines.
	  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


	  return object.index - other.index;
	}

	var _compareMultiple = compareMultiple;

	/**
	 * The base implementation of `_.orderBy` without param guards.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	 * @param {string[]} orders The sort orders of `iteratees`.
	 * @returns {Array} Returns the new sorted array.
	 */

	function baseOrderBy(collection, iteratees, orders) {
	  if (iteratees.length) {
	    iteratees = _arrayMap(iteratees, function (iteratee) {
	      if (isArray_1(iteratee)) {
	        return function (value) {
	          return _baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	        };
	      }

	      return iteratee;
	    });
	  } else {
	    iteratees = [identity_1];
	  }

	  var index = -1;
	  iteratees = _arrayMap(iteratees, _baseUnary(_baseIteratee));
	  var result = _baseMap(collection, function (value, key, collection) {
	    var criteria = _arrayMap(iteratees, function (iteratee) {
	      return iteratee(value);
	    });
	    return {
	      'criteria': criteria,
	      'index': ++index,
	      'value': value
	    };
	  });
	  return _baseSortBy(result, function (object, other) {
	    return _compareMultiple(object, other, orders);
	  });
	}

	var _baseOrderBy = baseOrderBy;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0:
	      return func.call(thisArg);

	    case 1:
	      return func.call(thisArg, args[0]);

	    case 2:
	      return func.call(thisArg, args[0], args[1]);

	    case 3:
	      return func.call(thisArg, args[0], args[1], args[2]);
	  }

	  return func.apply(thisArg, args);
	}

	var _apply = apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */

	var nativeMax$1 = Math.max;
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */

	function overRest(func, start, transform) {
	  start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
	  return function () {
	    var args = arguments,
	        index = -1,
	        length = nativeMax$1(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }

	    index = -1;
	    var otherArgs = Array(start + 1);

	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }

	    otherArgs[start] = transform(array);
	    return _apply(func, this, otherArgs);
	  };
	}

	var _overRest = overRest;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function () {
	    return value;
	  };
	}

	var constant_1 = constant;

	var defineProperty = function () {
	  try {
	    var func = _getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}();

	var _defineProperty = defineProperty;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */

	var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {
	  return _defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant_1(string),
	    'writable': true
	  });
	};
	var _baseSetToString = baseSetToString;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;
	/* Built-in method references for those with the same name as other `lodash` methods. */

	var nativeNow = Date.now;
	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */

	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;
	  return function () {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);
	    lastCalled = stamp;

	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }

	    return func.apply(undefined, arguments);
	  };
	}

	var _shortOut = shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */

	var setToString = _shortOut(_baseSetToString);
	var _setToString = setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */

	function baseRest(func, start) {
	  return _setToString(_overRest(func, start, identity_1), func + '');
	}

	var _baseRest = baseRest;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */

	function isIterateeCall(value, index, object) {
	  if (!isObject_1(object)) {
	    return false;
	  }

	  var type = _typeof(index);

	  if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
	    return eq_1(object[index], value);
	  }

	  return false;
	}

	var _isIterateeCall = isIterateeCall;

	/**
	 * Creates an array of elements, sorted in ascending order by the results of
	 * running each element in a collection thru each iteratee. This method
	 * performs a stable sort, that is, it preserves the original sort order of
	 * equal elements. The iteratees are invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {...(Function|Function[])} [iteratees=[_.identity]]
	 *  The iteratees to sort by.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'fred',   'age': 48 },
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 30 },
	 *   { 'user': 'barney', 'age': 34 }
	 * ];
	 *
	 * _.sortBy(users, [function(o) { return o.user; }]);
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
	 *
	 * _.sortBy(users, ['user', 'age']);
	 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
	 */

	var sortBy = _baseRest(function (collection, iteratees) {
	  if (collection == null) {
	    return [];
	  }

	  var length = iteratees.length;

	  if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
	    iteratees = [];
	  } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	    iteratees = [iteratees[0]];
	  }

	  return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
	});
	var sortBy_1 = sortBy;

	var _templateObject$j, _templateObject2$g, _templateObject3$c, _templateObject4$7, _templateObject5$3, _templateObject6$1, _templateObject7$1;

	var __decorate$l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$f = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var AlertLink = /*#__PURE__*/function () {
	  function AlertLink(url, description) {
	    _classCallCheck(this, AlertLink);

	    this.url = url;
	    this.description = description;
	  }

	  _createClass(AlertLink, null, [{
	    key: "fromListItem",
	    value: function fromListItem(listItem) {
	      var result = [];

	      var fromColumn = function fromColumn(column) {
	        if (column) result.push(new AlertLink(column.Url, column.Description));
	      };

	      fromColumn(listItem.Link_x0020_1);
	      fromColumn(listItem.Link_x0020_2);
	      fromColumn(listItem.Link_x0020_3);
	      fromColumn(listItem.Link_x0020_4);
	      return result;
	    }
	  }]);

	  return AlertLink;
	}();

	var Alert = /*#__PURE__*/_createClass(function Alert(listItem) {
	  _classCallCheck(this, Alert);

	  this.id = listItem.ID;
	  this.title = listItem.Title;
	  this.summary = listItem.Short_x0020_Summary;
	  this.expandDetails = listItem.Expandable_x0020_Details;
	  this.links = AlertLink.fromListItem(listItem);
	  this.alertClass = listItem.Background_x0020_color;
	  this.order = listItem.Order0;
	  this.active = listItem.Active;
	  this.customIconClass = listItem.Custom_x0020_Icon_x0020_Class;
	  this.dismissed = sessionStorage.getItem("oregon-gov-alert-" + this.id) != null;
	});

	var AlertsElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(AlertsElement, _BaseElement);

	  var _super = _createSuper(AlertsElement);

	  function AlertsElement() {
	    var _this;

	    _classCallCheck(this, AlertsElement);

	    _this = _super.call(this);
	    _this.alerts = [];

	    _this.closeClicked = function (alert) {
	      sessionStorage.setItem("oregon-gov-alert-" + alert.id, "true");
	      alert.dismissed = true;

	      _this.requestUpdate();
	    };

	    _this.init();

	    return _this;
	  }

	  _createClass(AlertsElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$f(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, items, alerts;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ListItemClient();
	                _context.next = 3;
	                return client.getListItems("Alerts");

	              case 3:
	                items = _context.sent;
	                alerts = items.map(function (i) {
	                  return new Alert(i);
	                });
	                this.alerts = sortBy_1(alerts.filter(function (a) {
	                  return a.active;
	                }), function (a) {
	                  return a.order;
	                });

	              case 6:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "renderTopLine",
	    value: function renderTopLine() {
	      return html(_templateObject$j || (_templateObject$j = _taggedTemplateLiteral(["\n\n        "])));
	    }
	  }, {
	    key: "renderLinks",
	    value: function renderLinks(alert) {
	      return html(_templateObject2$g || (_templateObject2$g = _taggedTemplateLiteral(["\n            ", "\n        "])), alert.links.map(function (link) {
	        return html(_templateObject3$c || (_templateObject3$c = _taggedTemplateLiteral(["\n                <a class=\"or-link\" href=", ">", " <span class=\"far fa-chevron-right\" aria-hidden=\"true\"></span></a>\n            "])), link.url, link.description);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this2 = this;

	      return html(_templateObject4$7 || (_templateObject4$7 = _taggedTemplateLiteral(["\n            ", "\n        "])), this.alerts.filter(function (alert) {
	        return !alert.dismissed;
	      }).map(function (alert) {
	        return html(_templateObject5$3 || (_templateObject5$3 = _taggedTemplateLiteral(["\n                <div role=\"alert\" class=", ">\n                    <span class=", " aria-hidden=\"true\"></span>\n\n                    <span class=\"or-alert-title\"><b>", ":</b></span>\n\n                    ", "\n                    \n                    ", "\n\n                    <button @click=", "><span class=\"sr-only\">Close</span>\n                    <span class=\"fal fa-times\" aria-hidden=\"true\"></span></button>\n                </div>\n            "])), "or-alert alert alert-" + alert.alertClass, alert.customIconClass || "far fa-bell", alert.title, alert.summary ? html(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteral(["\n                        <span class=\"or-alert-summary\">", "</span>\n                    "])), alert.summary) : null, alert.links.length > 0 ? html(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteral(["\n                        <span class=\"or-alert-links\">", "</span>\n                    "])), _this2.renderLinks(alert)) : null, function () {
	          return _this2.closeClicked(alert);
	        });
	      }));
	    }
	  }]);

	  return AlertsElement;
	}(BaseElement);

	__decorate$l([property$1({
	  type: Array
	})], AlertsElement.prototype, "alerts", void 0);

	AlertsElement = __decorate$l([customElement("or-alerts")], AlertsElement);

	var _templateObject$i;

	var __decorate$k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var AccessibilityOptionsElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(AccessibilityOptionsElement, _BaseElement);

	  var _super = _createSuper(AccessibilityOptionsElement);

	  function AccessibilityOptionsElement() {
	    var _this;

	    _classCallCheck(this, AccessibilityOptionsElement);

	    _this = _super.apply(this, arguments);
	    _this.buttonId = "id_" + Math.floor(Math.random() * 1000000000);
	    _this.showDropdown = false;

	    _this.buttonClicked = function (e) {
	      _this.showDropdown = !_this.showDropdown; //const translateEl = document.querySelector("or-translate");
	      // if (this.showDropdown && translateEl) {
	      //     (translateEl as any).showDropdown = false;
	      // }

	      e.preventDefault();
	    };

	    _this.reduceMotionClicked = function (e) {
	      bodyElement.reduceMotion = !bodyElement.reduceMotion;
	    };

	    _this.darkModeClicked = function (e) {
	      bodyElement.darkMode = !bodyElement.darkMode;
	    };

	    return _this;
	  }

	  _createClass(AccessibilityOptionsElement, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this2 = this;

	      _get(_getPrototypeOf(AccessibilityOptionsElement.prototype), "connectedCallback", this).call(this);

	      getTrackedProperty(bodyElement, "reduceMotion").subscribe(function () {
	        return _this2.requestUpdate();
	      });
	      getTrackedProperty(bodyElement, "darkMode").subscribe(function () {
	        return _this2.requestUpdate();
	      });
	      document.addEventListener("click", function (e) {
	        if (e.target instanceof Element) {
	          if (!e.target.closest("or-accessibility-options")) {
	            _this2.showDropdown = false;
	          }
	        }
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$i || (_templateObject$i = _taggedTemplateLiteral(["\n            <a href=\"https://www.oregon.gov\"\n                @click=", ">\n                <span class=\"fal fa-cog\" aria-hidden=\"true\"></span>\n                <span class=\"d-none d-lg-inline\"> <span class=\"sr-only\">Tweak how this site behaves using its </span>Options</span>\n            </a>\n\n\n            <div class=", " \n            aria-labelledby=", ">\n\n            <!-- <a class=\"dropdown-item\" href=\"#\">\n                Font size\n            </a> -->\n            <a class=\"dropdown-item\" href=\"#\"\n                @click=", ">\n                <div class=", ">\n                    <div class=\"or-switch-toggle-button\"></div>\n                </div>\n                Reduce motion\n            </a>\n            <a class=\"dropdown-item\" href=\"#\"\n                @click=", ">\n                <div class=", ">\n                    <div class=\"or-switch-toggle-button\"></div>\n                </div>\n                Dark mode\n            </a>\n\n            </div>\n        "])), this.buttonClicked, classMap({
	        "dropdown-menu": true,
	        "dropdown-menu-right": true,
	        "show": this.showDropdown
	      }), this.buttonId, this.reduceMotionClicked, classMap({
	        "or-switch-toggle": true,
	        "or-switch-toggle-on": bodyElement.reduceMotion
	      }), this.darkModeClicked, classMap({
	        "or-switch-toggle": true,
	        "or-switch-toggle-on": bodyElement.darkMode
	      }));
	    }
	  }]);

	  return AccessibilityOptionsElement;
	}(BaseElement);

	__decorate$k([property$1({
	  type: Boolean
	})], AccessibilityOptionsElement.prototype, "showDropdown", void 0);

	AccessibilityOptionsElement = __decorate$k([customElement("or-accessibility-options")], AccessibilityOptionsElement);
	//     "dropdown-menu": true,
	//     "dropdown-menu-right": true,
	//     "show": this.dropdownOpen
	// }) } 
	// aria-labelledby=${ this.buttonId }>
	// ${ this.options.map(o => html`
	//     <a class=${ classMap({
	//             "dropdown-item": true,
	//             active: this.value === o.value
	//         }) } 
	//         href="#"
	//         @click=${ (e) => this.optionClicked(e, o.value) }>
	//         ${ o.key }
	//     </a>
	// `) }
	// </div>

	function getTemplateSettings() {
	  return new Promise(function (resolve, reject) {
	    var siteUrl = _spPageContextInfo.siteServerRelativeUrl;
	    var cacheKey = "oregon-sharepoint-templatev4x-template-settings-" + siteUrl;

	    if (sessionStorage[cacheKey]) {
	      resolve(JSON.parse(sessionStorage[cacheKey]));
	    } else {
	      fetch(siteUrl + (siteUrl.charAt(siteUrl.length - 1) == '/' ? '' : '/') + '_vti_bin/OID.SharePoint.StarterTemplate/templatesettings.svc/compiled', {
	        credentials: 'include'
	      }).then(function (response) {
	        return response.json();
	      }).then(function (config) {
	        // console.log(config);
	        sessionStorage[cacheKey] = JSON.stringify(config);
	        resolve(config);
	      });
	    }
	  });
	}

	var _templateObject$h, _templateObject2$f, _templateObject3$b;

	var __decorate$j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$e = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var TranslateElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(TranslateElement, _BaseElement);

	  var _super = _createSuper(TranslateElement);

	  function TranslateElement() {
	    var _this;

	    _classCallCheck(this, TranslateElement);

	    _this = _super.apply(this, arguments);
	    _this.buttonId = "id_" + Math.floor(Math.random() * 1000000000);
	    _this.options = [];
	    _this.value = "en";
	    _this.dropdownOpen = false;

	    _this.init = function () {
	      return __awaiter$e(_assertThisInitialized(_this), void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var _this2 = this;

	        var _a, _b, _yield$Promise$all, _yield$Promise$all2, templateSettings, innerSelectEl, enabledLanguages;

	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                new google.translate.TranslateElement({
	                  pageLanguage: 'en',
	                  autoDisplay: false
	                }, "or-google-translate");
	                _context.next = 3;
	                return Promise.all([getTemplateSettings(), this.getGoogleSelectEl()]);

	              case 3:
	                _yield$Promise$all = _context.sent;
	                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
	                templateSettings = _yield$Promise$all2[0];
	                innerSelectEl = _yield$Promise$all2[1];
	                this.innerSelectEl = innerSelectEl;
	                enabledLanguages = (_b = (_a = templateSettings.enabledLanguagesCode) === null || _a === void 0 ? void 0 : _a.split("$")) !== null && _b !== void 0 ? _b : [];
	                this.options = Array.from(innerSelectEl.options).filter(function (optionEl) {
	                  return !optionEl.value || (enabledLanguages === null || enabledLanguages === void 0 ? void 0 : enabledLanguages.includes(optionEl.value));
	                }).map(function (optionEl) {
	                  if (optionEl.value === "") return {
	                    key: "English",
	                    value: "en"
	                  };
	                  return {
	                    key: optionEl.text,
	                    value: optionEl.value
	                  };
	                });
	                this.innerSelectEl.addEventListener("change", function () {
	                  _this2.value = _this2.innerSelectEl.value || "en";
	                });

	              case 11:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }; // selectChanged = (e: InputEvent) => {
	    //     const el = e.target as HTMLSelectElement;
	    //     this.innerSelectEl.value = el.value;
	    //     var event = new Event('change');
	    //     this.innerSelectEl.dispatchEvent(event);
	    // }


	    _this.toggleClicked = function (e) {
	      _this.dropdownOpen = !_this.dropdownOpen;
	      e.preventDefault();
	    };

	    _this.optionClicked = function (e, value) {
	      _this.value = value;
	      _this.innerSelectEl.value = value;
	      var event = new Event('change');

	      _this.innerSelectEl.dispatchEvent(event);

	      _this.dropdownOpen = false;
	      e.preventDefault();
	    };

	    return _this;
	  }

	  _createClass(TranslateElement, [{
	    key: "firstUpdated",
	    value: function firstUpdated(props) {
	      var _this3 = this;

	      _get(_getPrototypeOf(TranslateElement.prototype), "firstUpdated", this).call(this, props);

	      this.classList.add("notranslate");
	      window.oregonGoogleTranslateCallback = this.init;
	      var script = document.createElement("script");
	      script.async = true;
	      script.defer = true;
	      script.src = "https://translate.google.com/translate_a/element.js?cb=oregonGoogleTranslateCallback";
	      document.body.appendChild(script);
	      document.addEventListener("click", function (e) {
	        if (e.target instanceof Element) {
	          if (!e.target.closest("or-translate")) {
	            _this3.dropdownOpen = false;
	          }
	        }
	      });
	    }
	  }, {
	    key: "getGoogleSelectEl",
	    value: function getGoogleSelectEl() {
	      return new Promise(function (resolve) {
	        // Polling for when Google Translate has initialized
	        var loop = function loop() {
	          var innerSelectEl = document.querySelector(".goog-te-combo"); // Only poll until elements are found

	          if (!innerSelectEl || innerSelectEl.options.length === 0) {
	            setTimeout(loop, 17); // Roughly once a frame

	            return;
	          }

	          resolve(innerSelectEl);
	        };

	        loop();
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;

	      return html(_templateObject$h || (_templateObject$h = _taggedTemplateLiteral(["\n            <a id=", "\n                href=\"#\"\n                @click=", ">\n                <span class=\"fal fa-globe\" aria-hidden=\"true\"></span><span class=\"d-none d-lg-inline\"> <span class=\"sr-only\">Translate this site into other</span> Languages</span>\n            </a>\n            \n            <div style=\"display: none\" id=\"or-google-translate\" class=\"sr-only\" aria-hidden=\"true\"></div>\n\n            ", "\n\n\n        "])), this.buttonId, this.toggleClicked, this.options.length > 0 ? html(_templateObject2$f || (_templateObject2$f = _taggedTemplateLiteral(["\n                <div class=", " \n                    aria-labelledby=", ">\n\n                    ", "\n                </div>\n            "])), classMap({
	        "dropdown-menu": true,
	        "dropdown-menu-right": true,
	        "show": this.dropdownOpen
	      }), this.buttonId, this.options.map(function (o) {
	        return html(_templateObject3$b || (_templateObject3$b = _taggedTemplateLiteral(["\n                        <a class=", " \n                            href=\"#\"\n                            @click=", ">\n                            ", "\n                        </a>\n                    "])), classMap({
	          "dropdown-item": true,
	          active: _this4.value === o.value
	        }), function (e) {
	          return _this4.optionClicked(e, o.value);
	        }, o.key);
	      })) : null);
	    }
	  }]);

	  return TranslateElement;
	}(BaseElement);

	__decorate$j([property$1({
	  type: Array
	})], TranslateElement.prototype, "options", void 0);

	__decorate$j([property$1()], TranslateElement.prototype, "value", void 0);

	__decorate$j([property$1({
	  type: Boolean
	})], TranslateElement.prototype, "dropdownOpen", void 0);

	TranslateElement = __decorate$j([customElement("or-translate")], TranslateElement);
	// <select
	//     .value=${ this.value }
	//     @change=${ this.selectChanged }>
	//     ${ this.options.map(o => html`
	//         <option value=${ o.value }>${ o.key }</option>
	//     `) }
	// </select>
	// ` : null } -->

	var _templateObject$g;

	var __decorate$i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var ImageDeferredElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(ImageDeferredElement, _BaseElement);

	  var _super = _createSuper(ImageDeferredElement);

	  function ImageDeferredElement() {
	    _classCallCheck(this, ImageDeferredElement);

	    return _super.apply(this, arguments);
	  }

	  _createClass(ImageDeferredElement, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(ImageDeferredElement.prototype), "connectedCallback", this).call(this); //document.addEventListener("DOMContentLoaded", () => {
	      //console.log("running");
	      //});

	    }
	  }, {
	    key: "updated",
	    value: function updated() {
	      // DOMContentLoaded has already run by the time this executes
	      var img = document.createElement("img");
	      img.className = this.className;
	      img.src = this.src;
	      img.alt = this.alt;
	      this.parentElement.insertBefore(img, this);
	      this.remove();
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$g || (_templateObject$g = _taggedTemplateLiteral([""])));
	    }
	  }]);

	  return ImageDeferredElement;
	}(BaseElement);

	__decorate$i([property$1({
	  type: String
	})], ImageDeferredElement.prototype, "src", void 0);

	__decorate$i([property$1({
	  type: String
	})], ImageDeferredElement.prototype, "alt", void 0);

	ImageDeferredElement = __decorate$i([customElement("or-img-deferred")], ImageDeferredElement);

	/**
	 * @license
	 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
	 * This code may only be used under the BSD style license found at
	 * http://polymer.github.io/LICENSE.txt
	 * The complete set of authors may be found at
	 * http://polymer.github.io/AUTHORS.txt
	 * The complete set of contributors may be found at
	 * http://polymer.github.io/CONTRIBUTORS.txt
	 * Code distributed by Google as part of the polymer project is also
	 * subject to an additional IP rights grant found at
	 * http://polymer.github.io/PATENTS.txt
	 */
	// unsafeHTML directive, and the DocumentFragment that was last set as a value.
	// The DocumentFragment is used as a unique key to check if the last value
	// rendered to the part was with unsafeHTML. If not, we'll always re-render the
	// value passed to unsafeHTML.

	var previousValues = new WeakMap();
	/**
	 * Renders the result as HTML, rather than text.
	 *
	 * Note, this is unsafe to use with any user-provided input that hasn't been
	 * sanitized or escaped, as it may lead to cross-site-scripting
	 * vulnerabilities.
	 */

	var unsafeHTML = directive(function (value) {
	  return function (part) {
	    if (!(part instanceof NodePart)) {
	      throw new Error('unsafeHTML can only be used in text bindings');
	    }

	    var previousValue = previousValues.get(part);

	    if (previousValue !== undefined && isPrimitive(value) && value === previousValue.value && part.value === previousValue.fragment) {
	      return;
	    }

	    var template = document.createElement('template');
	    template.innerHTML = value; // innerHTML casts to string internally

	    var fragment = document.importNode(template.content, true);
	    part.setValue(fragment);
	    previousValues.set(part, {
	      value: value,
	      fragment: fragment
	    });
	  };
	});

	var _templateObject$f, _templateObject2$e, _templateObject3$a, _templateObject4$6;

	var __decorate$h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var EntityCardElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(EntityCardElement, _BaseElement);

	  var _super = _createSuper(EntityCardElement);

	  function EntityCardElement() {
	    _classCallCheck(this, EntityCardElement);

	    return _super.apply(this, arguments);
	  }

	  _createClass(EntityCardElement, [{
	    key: "render",
	    value: function render() {
	      return html(_templateObject$f || (_templateObject$f = _taggedTemplateLiteral(["\n            <a class=\"or-link-reset or-portal-entity-card\"\n                href=", "\n                style=", " >\n\n                ", "\n\n                <div class=\"or-portal-entity-card-content\">\n                    <h4 class=\"or-portal-entity-card-heading\">\n                        ", "\n                    </h4>\n\n                    ", "\n\n                    ", "\n                </div>\n            </a>\n        "])), this.entity.url, this.entity.primaryColor ? 'border-left: solid 10px ' + this.entity.primaryColor : 'border-left: solid 10px #4D874F', this.entity.logoUrl ? html(_templateObject2$e || (_templateObject2$e = _taggedTemplateLiteral(["\n                    <div class=\"or-portal-entity-card-image\">\n                        <!-- TODO: Add object fit contain which used to be KO binding -->\n                        <!-- <img src=", " alt=", " /> -->\n                        ", "\n                        <!-- <or-img src=", " alt=", " lazy=\"late\" fade=\"scroll\"></or-img> -->\n                    </div>\n                "])), this.entity.logoUrl, 'Logo for ' + this.entity.title, unsafeHTML("<or-img src=".concat(this.entity.logoUrl, " alt=").concat('Logo for ' + this.entity.title, " lazy=\"late\" fade=\"scroll\"></or-img>")), this.entity.logoUrl, 'Logo for ' + this.entity.title) : null, this.entity.title, this.entity.subtitle ? html(_templateObject3$a || (_templateObject3$a = _taggedTemplateLiteral(["\n                        <h5>", "</h5>\n                    "])), this.entity.subtitle) : null, this.entity.description ? html(_templateObject4$6 || (_templateObject4$6 = _taggedTemplateLiteral(["\n                        <p class=\"or-portal-entity-card-description\">", "</p>\n                    "])), this.entity.description) : null);
	    }
	  }]);

	  return EntityCardElement;
	}(BaseElement);

	__decorate$h([property$1({
	  attribute: false
	})], EntityCardElement.prototype, "entity", void 0);

	EntityCardElement = __decorate$h([customElement("or-entity-card")], EntityCardElement);

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */

	var now = function now() {
	  return _root.Date.now();
	};

	var now_1 = now;

	/** Used to match a single whitespace character. */
	var reWhitespace = /\s/;
	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	 * character of `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the index of the last non-whitespace character.
	 */

	function trimmedEndIndex(string) {
	  var index = string.length;

	  while (index-- && reWhitespace.test(string.charAt(index))) {}

	  return index;
	}

	var _trimmedEndIndex = trimmedEndIndex;

	/** Used to match leading whitespace. */

	var reTrimStart = /^\s+/;
	/**
	 * The base implementation of `_.trim`.
	 *
	 * @private
	 * @param {string} string The string to trim.
	 * @returns {string} Returns the trimmed string.
	 */

	function baseTrim(string) {
	  return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
	}

	var _baseTrim = baseTrim;

	/** Used as references for various `Number` constants. */

	var NAN = 0 / 0;
	/** Used to detect bad signed hexadecimal string values. */

	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	/** Used to detect binary string values. */

	var reIsBinary = /^0b[01]+$/i;
	/** Used to detect octal string values. */

	var reIsOctal = /^0o[0-7]+$/i;
	/** Built-in method references without a dependency on `root`. */

	var freeParseInt = parseInt;
	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */

	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }

	  if (isSymbol_1(value)) {
	    return NAN;
	  }

	  if (isObject_1(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject_1(other) ? other + '' : other;
	  }

	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }

	  value = _baseTrim(value);
	  var isBinary = reIsBinary.test(value);
	  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}

	var toNumber_1 = toNumber;

	/** Error message constants. */

	var FUNC_ERROR_TEXT = 'Expected a function';
	/* Built-in method references for those with the same name as other `lodash` methods. */

	var nativeMax = Math.max,
	    nativeMin = Math.min;
	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */

	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }

	  wait = toNumber_1(wait) || 0;

	  if (isObject_1(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;
	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time; // Start the timer for the trailing edge.

	    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;
	    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.

	    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	  }

	  function timerExpired() {
	    var time = now_1();

	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    } // Restart the timer.


	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.

	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }

	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }

	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now_1());
	  }

	  function debounced() {
	    var time = now_1(),
	        isInvoking = shouldInvoke(time);
	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }

	      if (maxing) {
	        // Handle invocations in a tight loop.
	        clearTimeout(timerId);
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }

	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }

	    return result;
	  }

	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	var debounce_1 = debounce;

	var _templateObject$e, _templateObject2$d, _templateObject3$9;

	var __decorate$g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$d = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var HeaderSearchElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(HeaderSearchElement, _BaseElement);

	  var _super = _createSuper(HeaderSearchElement);

	  function HeaderSearchElement() {
	    var _this;

	    _classCallCheck(this, HeaderSearchElement);

	    _this = _super.call(this);
	    _this.inputId = "id-" + Math.floor(Math.random() * 10000000);
	    _this.isMobile = false;
	    _this.searchTerms = [];
	    _this.inputText = "";
	    _this.autocompleteNeedsUpdate = false;
	    _this.autocompleteList = [];
	    _this.autocompleteSelectedIndex = -1;
	    _this.updateInputTextDebounced = debounce_1(function (input) {
	      _this.inputText = input.value;
	      _this.autocompleteNeedsUpdate = true;
	    }, 17);

	    _this.onKeyup = function (e) {
	      var input = e.target;

	      _this.updateInputTextDebounced(input);
	    };

	    _this.onKeydown = function (e) {
	      var input = e.target; //console.log(e.key);

	      switch (e.key) {
	        case "Enter":
	          _this.performSearch();

	          break;

	        case "ArrowUp":
	          _this.autocompleteSelectedIndex = Math.max(_this.autocompleteSelectedIndex - 1, -1);
	          input.value = _this.autocompleteSelectedIndex === -1 ? _this.inputText : _this.autocompleteList[_this.autocompleteSelectedIndex];
	          e.preventDefault();
	          break;

	        case "ArrowDown":
	          _this.autocompleteSelectedIndex = Math.min(_this.autocompleteSelectedIndex + 1, _this.autocompleteList.length - 1);
	          input.value = _this.autocompleteSelectedIndex === -1 ? _this.inputText : _this.autocompleteList[_this.autocompleteSelectedIndex];
	          e.preventDefault();
	          break;
	      }
	    };

	    _this.init();

	    subscribeAll(_assertThisInitialized(_this), function () {
	      return _this.requestUpdate();
	    });
	    return _this;
	  }

	  _createClass(HeaderSearchElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$d(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                //this.searchTerms = (await fetchJsonOrCache("/includes/search-analytics.txt")).items;
	                this.initiateAutocompleteWorker();

	              case 1:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "initiateAutocompleteWorker",
	    value: function initiateAutocompleteWorker() {
	      return __awaiter$d(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
	        var _this2 = this;

	        var staging;
	        return regeneratorRuntime.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                staging = window.location.hostname.includes("stage"); //console.warn("Creating worker");
	                // Create a worker

	                this.webWorker = new Worker("/Style Library/JS/autocomplete-worker.js");
	                getTrackedProperty(this, "autocompleteNeedsUpdate").subscribe(function () {
	                  if (_this2.autocompleteNeedsUpdate) _this2.webWorker.postMessage(_this2.inputText);
	                }); // Listen for messages from the worker

	                if (staging) {
	                  this.webWorker.addEventListener("message", function (event) {
	                    _this2.autocompleteNeedsUpdate = false;
	                    _this2.autocompleteList = event.data; // console.log(event.data, "from bg thread")
	                    // `event.data` contains the value or object sent from the worker
	                    // console.log("Message from worker:", event.data); // ["foo", "bar", "baz"]
	                  });
	                }

	                getTrackedProperty(this, "autocompleteList").subscribe(function () {
	                  _this2.querySelector("input");

	                  _this2.autocompleteSelectedIndex = -1;
	                }); // getTrackedProperty(this, "autocompleteSelectedIndex")
	                //     .subscribe(() => {
	                //         const input = this.querySelector("input")!;
	                //         if (this.autocompleteSelectedIndex === -1) {
	                //             input.value = this.inputText;
	                //         } else {
	                //             input.value = this.autocompleteList[this.autocompleteSelectedIndex];    
	                //         }
	                //     })

	              case 5:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	    }
	  }, {
	    key: "onAutocompleteHover",
	    value: function onAutocompleteHover(index) {
	      this.autocompleteSelectedIndex = index;
	    }
	  }, {
	    key: "onAutocompleteClick",
	    value: function onAutocompleteClick(index) {
	      var input = this.querySelector("input");
	      this.inputText = this.autocompleteList[index];
	      input.value = this.inputText;
	      this.autocompleteNeedsUpdate = false;
	      this.autocompleteList = [];
	      this.performSearch(); //const input = this.querySelector("input")!;
	      //this.commitSelectedAutocomplete(input);
	    }
	  }, {
	    key: "commitSelectedAutocomplete",
	    value: function commitSelectedAutocomplete(input) {// input.value = this.autocompleteList[this.autocompleteSelectedIndex];
	      // this.autocompleteSelectedIndex = -1;
	      // this.autocompleteList = [];
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this3 = this;

	      _get(_getPrototypeOf(HeaderSearchElement.prototype), "connectedCallback", this).call(this);

	      var matches = read(function () {
	        return window.matchMedia("(max-width: 480px)");
	      });
	      calc(function (w) {
	        _this3.isMobile = w.matches;
	      }, matches);
	    }
	  }, {
	    key: "performSearch",
	    value: function performSearch() {
	      var input = this.querySelector("input");
	      window.location.href = "/Pages/search-results.aspx?q=" + encodeURIComponent(input.value);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;

	      return html(_templateObject$e || (_templateObject$e = _taggedTemplateLiteral(["\n            <div class=\"or-header-search\">\n                <label class=\"sr-only\" for=", ">Search</label>\n                <span class=\"far fa-search\" aria-hidden=\"true\"></span>\n                <input\n                    id=", "\n                    class=", "\n                    type=\"search\"\n                    autocomplete=\"off\"\n                    aria-autocomplete=\"list\"\n                    role=\"combobox\"\n                    aria-owns=\"or-header-search-autocomplete-list\"\n                    aria-expanded=", "\n                    placeholder=", "\n                    @input=", "\n                    @keydown=", "/>\n\n                    ", "\n            </div>\n        "])), this.inputId, this.inputId, classMap({
	        "form-control": true,
	        "form-control-lg": true,
	        "or-header-autocomplete-open": this.autocompleteList.length > 0
	      }), this.autocompleteList.length > 0, this.isMobile ? "Search Oregon.gov" : "Search for topics, online services, & more", this.onKeyup, this.onKeydown, this.autocompleteList.length > 0 ? html(_templateObject2$d || (_templateObject2$d = _taggedTemplateLiteral(["\n                        <ul id=\"or-header-search-autocomplete-list\"\n                            class=\"list-unstyled or-header-search-autocomplete\"\n                            tabindex=\"0\"\n                            role=\"listbox\"\n                            aria-activedescendant=", ">\n                            ", "\n                        </ul>\n                    "])), "or-header-search-autocomplete-option-".concat(this.autocompleteSelectedIndex), this.autocompleteList.map(function (item, i) {
	        return html(_templateObject3$9 || (_templateObject3$9 = _taggedTemplateLiteral(["\n                                <li class=", "\n                                    id=", "\n                                    tabindex=\"-1\"\n                                    role=\"option\"\n                                    @mouseover=", "\n                                    @click=", ">\n                                    <span class=\"far fa-search\" aria-hidden=\"true\"></span>\n                                    ", "\n                                    <span class=\"fal fa-arrow-up\" aria-hidden=\"true\"></span>\n                                </li>\n                            "])), classMap({
	          "active": i === _this4.autocompleteSelectedIndex
	        }), "or-header-search-autocomplete-option-".concat(i), function () {
	          return _this4.onAutocompleteHover(i);
	        }, function () {
	          return _this4.onAutocompleteClick(i);
	        }, item);
	      })) : null);
	    }
	  }]);

	  return HeaderSearchElement;
	}(BaseElement);

	__decorate$g([property$1({
	  type: Boolean
	})], HeaderSearchElement.prototype, "isMobile", void 0);

	__decorate$g([tracked], HeaderSearchElement.prototype, "searchTerms", void 0);

	__decorate$g([tracked], HeaderSearchElement.prototype, "inputText", void 0);

	__decorate$g([tracked], HeaderSearchElement.prototype, "autocompleteNeedsUpdate", void 0);

	__decorate$g([tracked], HeaderSearchElement.prototype, "autocompleteList", void 0);

	__decorate$g([tracked], HeaderSearchElement.prototype, "autocompleteSelectedIndex", void 0);

	HeaderSearchElement = __decorate$g([trackable, customElement("or-header-search")], HeaderSearchElement);

	var _templateObject$d, _templateObject2$c;

	var __decorate$f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$c = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var PopularSearchTerm = /*#__PURE__*/_createClass(function PopularSearchTerm(listItem) {
	  _classCallCheck(this, PopularSearchTerm);

	  this.title = listItem.Title;
	});

	var PopularSearchesElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(PopularSearchesElement, _BaseElement);

	  var _super = _createSuper(PopularSearchesElement);

	  function PopularSearchesElement() {
	    var _this;

	    _classCallCheck(this, PopularSearchesElement);

	    _this = _super.call(this);
	    _this.searchTerms = [];

	    _this.init();

	    return _this;
	  }

	  _createClass(PopularSearchesElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$c(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var _yield$fetch$then, listItems;

	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return fetch("https://www.oregon.gov/_api/web/lists/GetByTitle('Popular Search Terms')/items?$select=Title", {
	                  headers: {
	                    Accept: "application/json;odata=verbose"
	                  }
	                }).then(function (d) {
	                  return d.json();
	                });

	              case 2:
	                _yield$fetch$then = _context.sent;
	                listItems = _yield$fetch$then.d.results;
	                this.searchTerms = listItems.map(function (item) {
	                  return new PopularSearchTerm(item);
	                });

	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$d || (_templateObject$d = _taggedTemplateLiteral(["\n            <p>Popular Search Terms</p>\n            <ul class=\"list-unstyled\">\n                ", "\n            </ul>\n        "])), this.searchTerms.map(function (term) {
	        return html(_templateObject2$c || (_templateObject2$c = _taggedTemplateLiteral(["\n                        <li>\n                            <a href=", ">\n                                ", "\n                            </a>\n                        </li>\n                    "])), "/Pages/search-results.aspx?q=" + encodeURIComponent(term.title), term.title);
	      }));
	    }
	  }]);

	  return PopularSearchesElement;
	}(BaseElement);

	__decorate$f([property$1({
	  type: Array
	})], PopularSearchesElement.prototype, "searchTerms", void 0);

	PopularSearchesElement = __decorate$f([customElement("or-popular-searches")], PopularSearchesElement);

	var _templateObject$c, _templateObject2$b, _templateObject3$8, _templateObject4$5, _templateObject5$2;

	var __decorate$e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$b = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var TopService = /*#__PURE__*/_createClass(function TopService(listItem) {
	  _classCallCheck(this, TopService);

	  this.title = listItem.Title;
	  this.description = listItem.Description;
	  this.url = listItem.Call_x0020_to_x0020_Action_x0020.Url;
	  this.active = listItem.Active;
	  this.imageId = listItem.Image_x0020_ID;
	  this.imageUrl = listItem.Image_x0020_URL;
	  this.imageAlt = listItem.Image_x0020_Alt_x0020_Text;
	  this.order = listItem.Order0;
	  // console.log(listItem, this.order);
	});

	var TopServicesElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(TopServicesElement, _BaseElement);

	  var _super = _createSuper(TopServicesElement);

	  function TopServicesElement() {
	    var _this;

	    _classCallCheck(this, TopServicesElement);

	    _this = _super.call(this);
	    _this.services = [];

	    _this.init();

	    return _this;
	  }

	  _createClass(TopServicesElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$b(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, topServicesColumns, listItems;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ListItemClient();
	                topServicesColumns = ["Title", "Description", "Call_x0020_to_x0020_Action_x0020", "Active", "Image_x0020_URL", "Image_x0020_ID", "Image_x0020_Alt_x0020_Text", "Order0"];
	                _context.next = 4;
	                return client.getListItems("Top Services", topServicesColumns);

	              case 4:
	                listItems = _context.sent;
	                this.services = sortBy_1(listItems.map(function (item) {
	                  return new TopService(item);
	                }).filter(function (item) {
	                  return item.active;
	                }), function (i) {
	                  return i.order;
	                });

	              case 6:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$c || (_templateObject$c = _taggedTemplateLiteral(["\n            ", "\n        "])), this.services.length > 0 ? html(_templateObject2$b || (_templateObject2$b = _taggedTemplateLiteral(["\n                <div class=\"or-top-service-grid\">\n                    ", "\n                </div>\n            "])), this.services.map(function (service) {
	        return html(_templateObject3$8 || (_templateObject3$8 = _taggedTemplateLiteral(["\n                        <a class=\"or-top-service\" href=", ">\n                            <div class=\"or-top-service-bg\">\n                                ", "\n                                \n                            </div>\n\n                            <div class=\"or-top-service-content\">\n                                <h3>", "</h3>\n                                <p class=\"d-none d-sm-block\">", "</p>\n                            </div>\n                        </a>\n                    "])), service.url, service.imageId ? html(_templateObject4$5 || (_templateObject4$5 = _taggedTemplateLiteral(["\n                                    <or-img imageid=", " include=\"4x3\" lazy=\"optimal\" fade=\"scroll\"></or-img>\n                                "])), service.imageId) : html(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteral(["\n                                    <img src=", " alt=", " />\n                                "])), service.imageUrl, service.imageAlt), service.title, service.description);
	      })) : null);
	    }
	  }]);

	  return TopServicesElement;
	}(BaseElement);

	__decorate$e([property$1({
	  type: Array
	})], TopServicesElement.prototype, "services", void 0);

	TopServicesElement = __decorate$e([customElement("or-top-services")], TopServicesElement);

	var Agency = /*#__PURE__*/function () {
	  function Agency(listItem) {
	    _classCallCheck(this, Agency);

	    //const fieldValues = oregon.sharePoint.models.fieldValues;
	    this.listItem = listItem;
	    this.listItemId = this.listItem.ID;
	    this.agencyId = this.listItem.Agency_x0020_ID;
	    this.active = this.listItem.Active === "Yes";
	    this.officialName = this.listItem.Official_x0020_Name;
	    this.abbreviation = this.listItem.Abbreviation;
	    this.description = this.listItem.Description;
	    this.categories = this.listItem.Categories.results; //new fieldValues.MultiChoiceFieldValue(this.listItem.Categories || "").values;

	    this.primaryColor = this.listItem.Primary_x0020_Color;
	    this.websiteUrl = this.listItem.Website.Url; //this.websiteUrl = this.listItem.Website ? new fieldValues.UrlFieldValue(this.listItem.Website).url : null;

	    this.homepageUrlPattern = this.listItem.Homepage_x0020_Pattern;
	    this.relatedUrlPattern = this.listItem.Related_x0020_Pattern;
	    this.entityType = this.listItem.Entity_x0020_Type;
	  }

	  _createClass(Agency, [{
	    key: "homepageRegex",
	    get: function get() {
	      if (!this._homepageRegex) {
	        this._homepageRegex = new RegExp(this.homepageUrlPattern, "i");
	      }

	      return this._homepageRegex;
	    }
	  }, {
	    key: "relatedRegex",
	    get: function get() {
	      if (!this._homepageRegex) {
	        this._homepageRegex = new RegExp(this.relatedUrlPattern, "i");
	      }

	      return this._homepageRegex;
	    }
	  }, {
	    key: "alphabeticalName",
	    get: function get() {
	      if (!this._alphabeticalName) {
	        // Reverses "department of" and similar phrases and moves them to the end-- good for alphabetical listings
	        // Written against these test cases:

	        /*
	        State of Oregon Law Library
	        State Medical Examiner
	        Oregon State Treasurer
	        State Library of Oregon
	        Oregon Youth Authority
	        Oregon State Board of Pharmacy
	        Oregon Plan for Salmon and Watersheds
	        Oregon Department of Veterans' Affairs
	        Oregon Commission on Black Affairs
	        Oregon Commission for the Blind
	        Oregon Commission for Women
	        Oregon Board of Tax Practioners
	        Office of the State Chief Information Officer
	        Office of the Chief Operating Officer
	        Office of State Fire Marshal
	        Office of Public Defense Services
	        Northwest Power and Conservation Council
	        Division of Financial Regulation
	        Council on Court Procedures
	        City of Salem
	        Bureau of Labor and Industries
	        Advisory Committee on Physician Credentialing Information
	        Advisory Council on Hearing Aids
	        Appraiser Certification and Licensure Board
	        Pacific States Marine Fisheries Commission
	        */
	        var regex = /(^((State of )?Oregon )?(State )?(Board of )?(Plan for )?(Department of )?(Bureau of )?((Advisory )?((Commission)|(Council)|(Committee)) ((on )|(for ))(the )?)?(Office of (the )?(State )?)?(Division of )?(Northwest )?(City of )?(Pacific States )?)(.*$)/i;
	        var name = this.listItem.Official_x0020_Name;
	        var match = name.match(regex);

	        if (match && match[1]) {
	          return match[match.length - 1] + ", " + match[1];
	        }

	        this._alphabeticalName = name;
	      }

	      return this._alphabeticalName;
	    }
	  }, {
	    key: "logoUrl",
	    get: function get() {
	      if (!this._logoUrl) {
	        if (!this.listItem.Logo || !this.listItem.Logo_x0020_Type) this._logoUrl = "/portalimages/logos/state-seal.png";else this._logoUrl = "/portalimages/logos/" + this.listItem.Logo + "." + this.listItem.Logo_x0020_Type;
	      }

	      return this._logoUrl;
	    }
	  }, {
	    key: "toEntity",
	    value: function toEntity(alphabetical) {
	      return {
	        description: this.description,
	        logoUrl: this.logoUrl,
	        primaryColor: this.primaryColor,
	        title: alphabetical ? this.alphabeticalName : this.officialName,
	        url: this.websiteUrl || ""
	      };
	    }
	  }]);

	  return Agency;
	}();

	var _templateObject$b, _templateObject2$a, _templateObject3$7;

	var __decorate$d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$a = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var AgencyListElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(AgencyListElement, _BaseElement);

	  var _super = _createSuper(AgencyListElement);

	  function AgencyListElement() {
	    var _this;

	    _classCallCheck(this, AgencyListElement);

	    _this = _super.call(this);
	    _this.search = false;
	    _this.category = "";
	    _this.types = "";
	    _this.agencies = [];
	    _this.searchText = "";

	    _this.init();

	    return _this;
	  }

	  _createClass(AgencyListElement, [{
	    key: "filteredAgencies",
	    get: function get() {
	      var _this2 = this;

	      var agencies = this.agencies;

	      if (this.types) {
	        var types = this.types.split(', ');
	        agencies = agencies.filter(function (a) {
	          return types.includes(a.entityType);
	        });
	      }

	      if (this.category) {
	        agencies = agencies.filter(function (a) {
	          return a.categories.includes(_this2.category);
	        });
	      }

	      if (this.searchText) {
	        var t = this.searchText.toLowerCase();
	        agencies = agencies.filter(function (a) {
	          return a.officialName.toLowerCase().includes(t) || a.alphabeticalName.toLowerCase().includes(t) || a.abbreviation.toLowerCase().includes(t) || a.description.toLowerCase().includes(t);
	        });
	      }

	      return agencies;
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this3 = this;

	      _get(_getPrototypeOf(AgencyListElement.prototype), "connectedCallback", this).call(this);

	      subscribeAll(this, function () {
	        return _this3.requestUpdate();
	      });
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      return __awaiter$a(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, items;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ListItemClient();
	                _context.next = 3;
	                return client.getListItems("Agencies and Entities", undefined, undefined, 1000);

	              case 3:
	                items = _context.sent;
	                this.agencies = items.map(function (i) {
	                  return new Agency(i);
	                });
	                this.agencies = sortBy_1(this.agencies, function (a) {
	                  return a.alphabeticalName;
	                });

	              case 6:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;

	      return html(_templateObject$b || (_templateObject$b = _taggedTemplateLiteral(["\n            ", "\n\n            ", "\n        "])), this.search ? html(_templateObject2$a || (_templateObject2$a = _taggedTemplateLiteral(["\n                <input\n                    placeholder=\"Search Agencies\"\n                    class=\"form-control form-control-lg\"\n                    type=\"text\"\n                    @keyup=", " /><br/><br/>\n            "])), function (e) {
	        _this4.searchText = e.target.value;
	      }) : null, this.filteredAgencies.map(function (agency) {
	        return html(_templateObject3$7 || (_templateObject3$7 = _taggedTemplateLiteral(["\n                <or-entity-card .entity=", "></or-entity-card>\n            "])), agency.toEntity(true));
	      }));
	    }
	  }]);

	  return AgencyListElement;
	}(BaseElement);

	__decorate$d([property$1({
	  type: Boolean
	})], AgencyListElement.prototype, "search", void 0);

	__decorate$d([property$1({
	  type: String
	})], AgencyListElement.prototype, "category", void 0);

	__decorate$d([property$1({
	  type: String
	})], AgencyListElement.prototype, "types", void 0);

	__decorate$d([tracked], AgencyListElement.prototype, "agencies", void 0);

	__decorate$d([tracked], AgencyListElement.prototype, "searchText", void 0);

	__decorate$d([computed], AgencyListElement.prototype, "filteredAgencies", null);

	AgencyListElement = __decorate$d([trackable, customElement("or-agency-list")], AgencyListElement);

	var ServiceClient = /*#__PURE__*/function () {
	  function ServiceClient(endpointUrl) {
	    _classCallCheck(this, ServiceClient);

	    this.endpointUrl = endpointUrl;
	  }

	  _createClass(ServiceClient, [{
	    key: "getAll",
	    value: function getAll() {
	      return fetch(this.endpointUrl).then(function (r) {
	        return r.json();
	      });
	    }
	  }]);

	  return ServiceClient;
	}();

	var Service = /*#__PURE__*/function () {
	  // fundingType: string;
	  // licensing: boolean;
	  // transitioned: boolean;
	  // deployed: Date;
	  // redesigned: Date;
	  function Service(row, agencies) {
	    _classCallCheck(this, Service);

	    var _a;

	    this.name = row.service_name;
	    this.type = row.service_type;
	    this.url = ((_a = row.url) === null || _a === void 0 ? void 0 : _a.url) || "";
	    this.urlDescription = row.url_description;
	    this.description = row.description || "";
	    this.retired = row.retired_yn;
	    this.agency = agencies.find(function (a) {
	      return a.agencyId === row.agency_id;
	    }) || null; // this.fundingType = this.row.funding_type;
	    // this.licensing = this.row.licensing;
	    // this.transitioned = this.row.transitioned;
	    // this.deployed = new Date(this.row.deployed);
	    // this.redesigned = new Date(this.row.redesigned);
	  }

	  _createClass(Service, [{
	    key: "toEntity",
	    value: function toEntity() {
	      var _a, _b, _c;

	      return {
	        description: this.description,
	        logoUrl: ((_a = this.agency) === null || _a === void 0 ? void 0 : _a.logoUrl) || "",
	        primaryColor: ((_b = this.agency) === null || _b === void 0 ? void 0 : _b.primaryColor) || "",
	        title: this.name,
	        subtitle: (_c = this.agency) === null || _c === void 0 ? void 0 : _c.officialName,
	        url: this.url
	      };
	    }
	  }]);

	  return Service;
	}();

	var _templateObject$a, _templateObject2$9, _templateObject3$6;

	var __decorate$c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$9 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var ServiceListElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(ServiceListElement, _BaseElement);

	  var _super = _createSuper(ServiceListElement);

	  function ServiceListElement() {
	    var _this;

	    _classCallCheck(this, ServiceListElement);

	    _this = _super.call(this);
	    _this.search = false;
	    _this.category = "";
	    _this.agencies = [];
	    _this.services = [];
	    _this.searchText = "";

	    _this.init();

	    return _this;
	  }

	  _createClass(ServiceListElement, [{
	    key: "filteredServices",
	    get: function get() {
	      var _this2 = this;

	      var services = this.services;

	      if (this.category) {
	        services = services.filter(function (s) {
	          return s.agency != null;
	        }).filter(function (a) {
	          return a.agency.categories.includes(_this2.category);
	        });
	      }

	      if (this.searchText) {
	        var t = this.searchText.toLowerCase();
	        services = services.filter(function (a) {
	          var _a;

	          return a.name.toLowerCase().includes(t) || (((_a = a.agency) === null || _a === void 0 ? void 0 : _a.officialName) || "").toLowerCase().includes(t) || a.description.toLowerCase().includes(t);
	        });
	      }

	      return services;
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this3 = this;

	      _get(_getPrototypeOf(ServiceListElement.prototype), "connectedCallback", this).call(this);

	      subscribeAll(this, function () {
	        return _this3.requestUpdate();
	      });
	    }
	  }, {
	    key: "getAgency",
	    value: function getAgency(id) {
	      this.agencies.find(function (a) {
	        return a.agencyId === id;
	      });
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      return __awaiter$9(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var _this4 = this;

	        var agencyClient, serviceClient, _yield$Promise$all, _yield$Promise$all2, serviceItems, agenyItems;

	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                agencyClient = new ListItemClient();
	                serviceClient = new ServiceClient("https://data.oregon.gov/resource/9g5a-r9zs.json");
	                _context.next = 4;
	                return Promise.all([serviceClient.getAll(), agencyClient.getListItems("Agencies and Entities", undefined, undefined, 1000)]);

	              case 4:
	                _yield$Promise$all = _context.sent;
	                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
	                serviceItems = _yield$Promise$all2[0];
	                agenyItems = _yield$Promise$all2[1];
	                this.agencies = agenyItems.map(function (a) {
	                  return new Agency(a);
	                });
	                this.services = serviceItems.map(function (s) {
	                  return new Service(s, _this4.agencies);
	                }).filter(function (s) {
	                  return s.type !== "Website" && s.retired !== true && s.type !== "Intranet";
	                });
	                this.services = sortBy_1(this.services, function (a) {
	                  return a.name;
	                });

	              case 11:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this5 = this;

	      return html(_templateObject$a || (_templateObject$a = _taggedTemplateLiteral(["\n            ", "\n\n            ", "\n        "])), this.search ? html(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteral(["\n                <input\n                    placeholder=\"Search Services\"\n                    class=\"form-control form-control-lg\"\n                    type=\"text\"\n                    @keyup=", " /><br/><br/>\n            "])), function (e) {
	        _this5.searchText = e.target.value;
	      }) : null, this.filteredServices.map(function (agency) {
	        return html(_templateObject3$6 || (_templateObject3$6 = _taggedTemplateLiteral(["\n                <or-entity-card .entity=", "></or-entity-card>\n            "])), agency.toEntity());
	      }));
	    }
	  }]);

	  return ServiceListElement;
	}(BaseElement);

	__decorate$c([property$1({
	  type: Boolean
	})], ServiceListElement.prototype, "search", void 0);

	__decorate$c([property$1({
	  type: String
	})], ServiceListElement.prototype, "category", void 0);

	__decorate$c([tracked], ServiceListElement.prototype, "agencies", void 0);

	__decorate$c([tracked], ServiceListElement.prototype, "services", void 0);

	__decorate$c([tracked], ServiceListElement.prototype, "searchText", void 0);

	__decorate$c([computed], ServiceListElement.prototype, "filteredServices", null);

	ServiceListElement = __decorate$c([trackable, customElement("or-service-list")], ServiceListElement);

	var __awaiter$8 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	function fetchJsonOrCache(url) {
	  return __awaiter$8(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	    var cacheKey, cachedRaw, _cachedFetch, oneHourAgo, response, text, cachedFetch;

	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            cacheKey = "oregon-gov-fetch-cache-" + url;
	            cachedRaw = localStorage.getItem(cacheKey);

	            if (!cachedRaw) {
	              _context.next = 8;
	              break;
	            }

	            _cachedFetch = JSON.parse(cachedRaw);
	            oneHourAgo = new Date();
	            oneHourAgo.setHours(oneHourAgo.getHours() - 1);

	            if (!(new Date(_cachedFetch.date) >= oneHourAgo)) {
	              _context.next = 8;
	              break;
	            }

	            return _context.abrupt("return", JSON.parse(_cachedFetch.body));

	          case 8:
	            _context.next = 10;
	            return fetch(url);

	          case 10:
	            response = _context.sent;
	            _context.next = 13;
	            return response.text();

	          case 13:
	            text = _context.sent;
	            cachedFetch = {
	              date: new Date(),
	              body: text
	            };
	            localStorage.setItem(cacheKey, JSON.stringify(cachedFetch));
	            return _context.abrupt("return", JSON.parse(text));

	          case 17:
	          case "end":
	            return _context.stop();
	        }
	      }
	    }, _callee);
	  }));
	}

	/**
	 * Interfaces with the OID.SharePoint.PortalSearch project's cached search web service
	 */

	var PortalSearchClient = /*#__PURE__*/function () {
	  function PortalSearchClient(endpointUrl) {
	    _classCallCheck(this, PortalSearchClient);

	    this.endpointUrl = endpointUrl;
	    this.requestInProgress = false;
	    this.rejectRequestInProgress = null;
	  }

	  _createClass(PortalSearchClient, [{
	    key: "getResults",
	    value: function getResults(query, start) {
	      var url = this.endpointUrl + "?q=" + encodeURIComponent(query) + "&start=" + start;
	      return fetchJsonOrCache(url);
	    }
	  }, {
	    key: "getResultsOrReject",
	    value: function getResultsOrReject(query, start) {
	      var _this = this;

	      // Handle Promise rejection if new search begins before old search finishes
	      // Cancel existing request
	      if (this.requestInProgress) {
	        this.rejectRequestInProgress();
	      }

	      return new Promise(function (resolve, reject) {
	        _this.rejectRequestInProgress = reject;
	        _this.requestInProgress = true;

	        _this.getResults(query, start).then(function (r) {
	          return resolve(r);
	        });
	      }).then(function (response) {
	        _this.requestInProgress = false; // console.log(query, response)

	        return response;
	      }, function () {
	        //console.log(query, 'promise rejected');
	        return null;
	      });
	    }
	  }]);

	  return PortalSearchClient;
	}();

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */

	function isEqual(value, other) {
	  return _baseIsEqual(value, other);
	}

	var isEqual_1 = isEqual;

	/**
	 * Check if we're required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */

	var requiresPort = function required(port, protocol) {
	  protocol = protocol.split(':')[0];
	  port = +port;
	  if (!port) return false;

	  switch (protocol) {
	    case 'http':
	    case 'ws':
	      return port !== 80;

	    case 'https':
	    case 'wss':
	      return port !== 443;

	    case 'ftp':
	      return port !== 21;

	    case 'gopher':
	      return port !== 70;

	    case 'file':
	      return false;
	  }

	  return port !== 0;
	};

	var has = Object.prototype.hasOwnProperty,
	    undef;
	/**
	 * Decode a URI encoded string.
	 *
	 * @param {String} input The URI encoded string.
	 * @returns {String|Null} The decoded string.
	 * @api private
	 */

	function decode(input) {
	  try {
	    return decodeURIComponent(input.replace(/\+/g, ' '));
	  } catch (e) {
	    return null;
	  }
	}
	/**
	 * Attempts to encode a given input.
	 *
	 * @param {String} input The string that needs to be encoded.
	 * @returns {String|Null} The encoded string.
	 * @api private
	 */


	function encode(input) {
	  try {
	    return encodeURIComponent(input);
	  } catch (e) {
	    return null;
	  }
	}
	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */


	function querystring(query) {
	  var parser = /([^=?#&]+)=?([^&]*)/g,
	      result = {},
	      part;

	  while (part = parser.exec(query)) {
	    var key = decode(part[1]),
	        value = decode(part[2]); //
	    // Prevent overriding of existing properties. This ensures that build-in
	    // methods like `toString` or __proto__ are not overriden by malicious
	    // querystrings.
	    //
	    // In the case if failed decoding, we want to omit the key/value pairs
	    // from the result.
	    //

	    if (key === null || value === null || key in result) continue;
	    result[key] = value;
	  }

	  return result;
	}
	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */


	function querystringify(obj, prefix) {
	  prefix = prefix || '';
	  var pairs = [],
	      value,
	      key; //
	  // Optionally prefix with a '?' if needed
	  //

	  if ('string' !== typeof prefix) prefix = '?';

	  for (key in obj) {
	    if (has.call(obj, key)) {
	      value = obj[key]; //
	      // Edge cases where we actually want to encode the value to an empty
	      // string instead of the stringified value.
	      //

	      if (!value && (value === null || value === undef || isNaN(value))) {
	        value = '';
	      }

	      key = encode(key);
	      value = encode(value); //
	      // If we failed to encode the strings, we should bail out as we don't
	      // want to add invalid strings to the query.
	      //

	      if (key === null || value === null) continue;
	      pairs.push(key + '=' + value);
	    }
	  }

	  return pairs.length ? prefix + pairs.join('&') : '';
	} //
	// Expose the module.
	//


	var stringify = querystringify;
	var parse = querystring;
	var querystringify_1 = {
	  stringify: stringify,
	  parse: parse
	};

	var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/,
	    CRHTLF = /[\n\r\t]/g,
	    slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//,
	    port = /:\d+$/,
	    protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i,
	    windowsDriveLetter = /^[a-zA-Z]:/;
	/**
	 * Remove control characters and whitespace from the beginning of a string.
	 *
	 * @param {Object|String} str String to trim.
	 * @returns {String} A new string representing `str` stripped of control
	 *     characters and whitespace from its beginning.
	 * @public
	 */

	function trimLeft(str) {
	  return (str ? str : '').toString().replace(controlOrWhitespace, '');
	}
	/**
	 * These are the parse rules for the URL parser, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it's a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it's backwards or forward parsing, when set as number it's
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */


	var rules = [['#', 'hash'], // Extract from the back.
	['?', 'query'], // Extract from the back.
	function sanitize(address, url) {
	  // Sanitize what is left of the address
	  return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
	}, ['/', 'pathname'], // Extract from the back.
	['@', 'auth', 1], // Extract from the front.
	[NaN, 'host', undefined, 1, 1], // Set left over value.
	[/:(\d*)$/, 'port', undefined, 1], // RegExp the back.
	[NaN, 'hostname', undefined, 1, 1] // Set left over.
	];
	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL's as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */

	var ignore = {
	  hash: 1,
	  query: 1
	};
	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good "default"
	 * location from it so we can generate proper relative URL's again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @public
	 */

	function lolcation(loc) {
	  var globalVar;
	  if (typeof window !== 'undefined') globalVar = window;else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;else if (typeof self !== 'undefined') globalVar = self;else globalVar = {};
	  var location = globalVar.location || {};
	  loc = loc || location;

	  var finaldestination = {},
	      type = _typeof(loc),
	      key;

	  if ('blob:' === loc.protocol) {
	    finaldestination = new Url(unescape(loc.pathname), {});
	  } else if ('string' === type) {
	    finaldestination = new Url(loc, {});

	    for (key in ignore) {
	      delete finaldestination[key];
	    }
	  } else if ('object' === type) {
	    for (key in loc) {
	      if (key in ignore) continue;
	      finaldestination[key] = loc[key];
	    }

	    if (finaldestination.slashes === undefined) {
	      finaldestination.slashes = slashes.test(loc.href);
	    }
	  }

	  return finaldestination;
	}
	/**
	 * Check whether a protocol scheme is special.
	 *
	 * @param {String} The protocol scheme of the URL
	 * @return {Boolean} `true` if the protocol scheme is special, else `false`
	 * @private
	 */


	function isSpecial(scheme) {
	  return scheme === 'file:' || scheme === 'ftp:' || scheme === 'http:' || scheme === 'https:' || scheme === 'ws:' || scheme === 'wss:';
	}
	/**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase.
	 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	 * @property {String} rest Rest of the URL that is not part of the protocol.
	 */

	/**
	 * Extract protocol information from a URL with/without double slash ("//").
	 *
	 * @param {String} address URL we want to extract from.
	 * @param {Object} location
	 * @return {ProtocolExtract} Extracted information.
	 * @private
	 */


	function extractProtocol(address, location) {
	  address = trimLeft(address);
	  address = address.replace(CRHTLF, '');
	  location = location || {};
	  var match = protocolre.exec(address);
	  var protocol = match[1] ? match[1].toLowerCase() : '';
	  var forwardSlashes = !!match[2];
	  var otherSlashes = !!match[3];
	  var slashesCount = 0;
	  var rest;

	  if (forwardSlashes) {
	    if (otherSlashes) {
	      rest = match[2] + match[3] + match[4];
	      slashesCount = match[2].length + match[3].length;
	    } else {
	      rest = match[2] + match[4];
	      slashesCount = match[2].length;
	    }
	  } else {
	    if (otherSlashes) {
	      rest = match[3] + match[4];
	      slashesCount = match[3].length;
	    } else {
	      rest = match[4];
	    }
	  }

	  if (protocol === 'file:') {
	    if (slashesCount >= 2) {
	      rest = rest.slice(2);
	    }
	  } else if (isSpecial(protocol)) {
	    rest = match[4];
	  } else if (protocol) {
	    if (forwardSlashes) {
	      rest = rest.slice(2);
	    }
	  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
	    rest = match[4];
	  }

	  return {
	    protocol: protocol,
	    slashes: forwardSlashes || isSpecial(protocol),
	    slashesCount: slashesCount,
	    rest: rest
	  };
	}
	/**
	 * Resolve a relative URL pathname against a base URL pathname.
	 *
	 * @param {String} relative Pathname of the relative URL.
	 * @param {String} base Pathname of the base URL.
	 * @return {String} Resolved pathname.
	 * @private
	 */


	function resolve(relative, base) {
	  if (relative === '') return base;
	  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),
	      i = path.length,
	      last = path[i - 1],
	      unshift = false,
	      up = 0;

	  while (i--) {
	    if (path[i] === '.') {
	      path.splice(i, 1);
	    } else if (path[i] === '..') {
	      path.splice(i, 1);
	      up++;
	    } else if (up) {
	      if (i === 0) unshift = true;
	      path.splice(i, 1);
	      up--;
	    }
	  }

	  if (unshift) path.unshift('');
	  if (last === '.' || last === '..') path.push('');
	  return path.join('/');
	}
	/**
	 * The actual URL instance. Instead of returning an object we've opted-in to
	 * create an actual constructor as it's much more memory efficient and
	 * faster and it pleases my OCD.
	 *
	 * It is worth noting that we should not use `URL` as class name to prevent
	 * clashes with the global URL instance that got introduced in browsers.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} [location] Location defaults for relative paths.
	 * @param {Boolean|Function} [parser] Parser for the query string.
	 * @private
	 */


	function Url(address, location, parser) {
	  address = trimLeft(address);
	  address = address.replace(CRHTLF, '');

	  if (!(this instanceof Url)) {
	    return new Url(address, location, parser);
	  }

	  var relative,
	      extracted,
	      parse,
	      instruction,
	      index,
	      key,
	      instructions = rules.slice(),
	      type = _typeof(location),
	      url = this,
	      i = 0; //
	  // The following if statements allows this module two have compatibility with
	  // 2 different API:
	  //
	  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
	  //    where the boolean indicates that the query string should also be parsed.
	  //
	  // 2. The `URL` interface of the browser which accepts a URL, object as
	  //    arguments. The supplied object will be used as default values / fall-back
	  //    for relative paths.
	  //


	  if ('object' !== type && 'string' !== type) {
	    parser = location;
	    location = null;
	  }

	  if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;
	  location = lolcation(location); //
	  // Extract protocol information before running the instructions.
	  //

	  extracted = extractProtocol(address || '', location);
	  relative = !extracted.protocol && !extracted.slashes;
	  url.slashes = extracted.slashes || relative && location.slashes;
	  url.protocol = extracted.protocol || location.protocol || '';
	  address = extracted.rest; //
	  // When the authority component is absent the URL starts with a path
	  // component.
	  //

	  if (extracted.protocol === 'file:' && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
	    instructions[3] = [/(.*)/, 'pathname'];
	  }

	  for (; i < instructions.length; i++) {
	    instruction = instructions[i];

	    if (typeof instruction === 'function') {
	      address = instruction(address, url);
	      continue;
	    }

	    parse = instruction[0];
	    key = instruction[1];

	    if (parse !== parse) {
	      url[key] = address;
	    } else if ('string' === typeof parse) {
	      index = parse === '@' ? address.lastIndexOf(parse) : address.indexOf(parse);

	      if (~index) {
	        if ('number' === typeof instruction[2]) {
	          url[key] = address.slice(0, index);
	          address = address.slice(index + instruction[2]);
	        } else {
	          url[key] = address.slice(index);
	          address = address.slice(0, index);
	        }
	      }
	    } else if (index = parse.exec(address)) {
	      url[key] = index[1];
	      address = address.slice(0, index.index);
	    }

	    url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : ''); //
	    // Hostname, host and protocol should be lowercased so they can be used to
	    // create a proper `origin`.
	    //

	    if (instruction[4]) url[key] = url[key].toLowerCase();
	  } //
	  // Also parse the supplied query string in to an object. If we're supplied
	  // with a custom parser as function use that instead of the default build-in
	  // parser.
	  //


	  if (parser) url.query = parser(url.query); //
	  // If the URL is relative, resolve the pathname against the base URL.
	  //

	  if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {
	    url.pathname = resolve(url.pathname, location.pathname);
	  } //
	  // Default to a / for pathname if none exists. This normalizes the URL
	  // to always have a /
	  //


	  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
	    url.pathname = '/' + url.pathname;
	  } //
	  // We should not add port numbers if they are already the default port number
	  // for a given protocol. As the host also contains the port number we're going
	  // override it with the hostname which contains no port number.
	  //


	  if (!requiresPort(url.port, url.protocol)) {
	    url.host = url.hostname;
	    url.port = '';
	  } //
	  // Parse down the `auth` for the username and password.
	  //


	  url.username = url.password = '';

	  if (url.auth) {
	    index = url.auth.indexOf(':');

	    if (~index) {
	      url.username = url.auth.slice(0, index);
	      url.username = encodeURIComponent(decodeURIComponent(url.username));
	      url.password = url.auth.slice(index + 1);
	      url.password = encodeURIComponent(decodeURIComponent(url.password));
	    } else {
	      url.username = encodeURIComponent(decodeURIComponent(url.auth));
	    }

	    url.auth = url.password ? url.username + ':' + url.password : url.username;
	  }

	  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null'; //
	  // The href is just the compiled result.
	  //

	  url.href = url.toString();
	}
	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} part          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function
	 *                               used to parse the query.
	 *                               When setting the protocol, double slash will be
	 *                               removed from the final url if it is true.
	 * @returns {URL} URL instance for chaining.
	 * @public
	 */


	function set(part, value, fn) {
	  var url = this;

	  switch (part) {
	    case 'query':
	      if ('string' === typeof value && value.length) {
	        value = (fn || querystringify_1.parse)(value);
	      }

	      url[part] = value;
	      break;

	    case 'port':
	      url[part] = value;

	      if (!requiresPort(value, url.protocol)) {
	        url.host = url.hostname;
	        url[part] = '';
	      } else if (value) {
	        url.host = url.hostname + ':' + value;
	      }

	      break;

	    case 'hostname':
	      url[part] = value;
	      if (url.port) value += ':' + url.port;
	      url.host = value;
	      break;

	    case 'host':
	      url[part] = value;

	      if (port.test(value)) {
	        value = value.split(':');
	        url.port = value.pop();
	        url.hostname = value.join(':');
	      } else {
	        url.hostname = value;
	        url.port = '';
	      }

	      break;

	    case 'protocol':
	      url.protocol = value.toLowerCase();
	      url.slashes = !fn;
	      break;

	    case 'pathname':
	    case 'hash':
	      if (value) {
	        var char = part === 'pathname' ? '/' : '#';
	        url[part] = value.charAt(0) !== char ? char + value : value;
	      } else {
	        url[part] = value;
	      }

	      break;

	    case 'username':
	    case 'password':
	      url[part] = encodeURIComponent(value);
	      break;

	    case 'auth':
	      var index = value.indexOf(':');

	      if (~index) {
	        url.username = value.slice(0, index);
	        url.username = encodeURIComponent(decodeURIComponent(url.username));
	        url.password = value.slice(index + 1);
	        url.password = encodeURIComponent(decodeURIComponent(url.password));
	      } else {
	        url.username = encodeURIComponent(decodeURIComponent(value));
	      }

	  }

	  for (var i = 0; i < rules.length; i++) {
	    var ins = rules[i];
	    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
	  }

	  url.auth = url.password ? url.username + ':' + url.password : url.username;
	  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host ? url.protocol + '//' + url.host : 'null';
	  url.href = url.toString();
	  return url;
	}
	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String} Compiled version of the URL.
	 * @public
	 */


	function toString(stringify) {
	  if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;
	  var query,
	      url = this,
	      host = url.host,
	      protocol = url.protocol;
	  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
	  var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? '//' : '');

	  if (url.username) {
	    result += url.username;
	    if (url.password) result += ':' + url.password;
	    result += '@';
	  } else if (url.password) {
	    result += ':' + url.password;
	    result += '@';
	  } else if (url.protocol !== 'file:' && isSpecial(url.protocol) && !host && url.pathname !== '/') {
	    //
	    // Add back the empty userinfo, otherwise the original invalid URL
	    // might be transformed into a valid one with `url.pathname` as host.
	    //
	    result += '@';
	  } //
	  // Trailing colon is removed from `url.host` when it is parsed. If it still
	  // ends with a colon, then add back the trailing colon that was removed. This
	  // prevents an invalid URL from being transformed into a valid one.
	  //


	  if (host[host.length - 1] === ':' || port.test(url.hostname) && !url.port) {
	    host += ':';
	  }

	  result += host + url.pathname;
	  query = 'object' === _typeof(url.query) ? stringify(url.query) : url.query;
	  if (query) result += '?' !== query.charAt(0) ? '?' + query : query;
	  if (url.hash) result += url.hash;
	  return result;
	}

	Url.prototype = {
	  set: set,
	  toString: toString
	}; //
	// Expose the URL parser and some additional properties that might be useful for
	// others or testing.
	//

	Url.extractProtocol = extractProtocol;
	Url.location = lolcation;
	Url.trimLeft = trimLeft;
	Url.qs = querystringify_1;
	var urlParse = Url;

	/**
	 * Helps shorten and format long URLs in a more mobile-friendly and human-readable way. Modeled after Google's mobile search app
	 */

	var FriendlyUrl = /*#__PURE__*/function () {
	  function FriendlyUrl(originalUrl) {
	    _classCallCheck(this, FriendlyUrl);

	    // --------------------------------------------------
	    // Routine to parse and format url into path segments
	    // --------------------------------------------------
	    // TODO: break into smaller functions for better readablity and maintainability
	    // TODO: break out core functionaility and separate from business rules specific to Oregon.gov and SharePoint/Pages library
	    this.originalUrl = originalUrl;
	    var parsedUrl = new urlParse(originalUrl);
	    var segmentArray = [];
	    // console.log(parsedUrl.protocol);
	    var hostnameSegment = parsedUrl.hostname.replace(/^www./, "");
	    if (hostnameSegment === "oregon.gov") hostnameSegment = "Oregon"; // Business rule-- switch out oregon.gov with the word Oregon

	    segmentArray.push(hostnameSegment);
	    var path = parsedUrl.pathname;
	    if (path.substring(0, 1) === "/") // Remove initial slash if there
	      path = path.substring(1);
	    var pathSegments = path.split("/");

	    if (pathSegments.length > 0) {
	      if (pathSegments[pathSegments.length - 1].indexOf(".") > -1) {
	        pathSegments.pop(); // remove page/file name from segments list
	      }

	      var _iterator = _createForOfIteratorHelper(pathSegments),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var segment = _step.value;

	          if (segment.match(/^[A-Z].*[a-z]$/) && !segment.match(/[A-Z][A-Z]/) && !segment.match(/(0-9)/)) {
	            // Quick and dirty Pascal Case test, excluding any string with consecutive capitals, or numbers
	            segment = segment.replace(/([a-z]).{0}([A-Z])/g, "$1 $2");
	          }

	          segment = segment.replace(/_|-|%20/g, " "); // Try to add spaces instead of hyphens, underscores, or %20

	          if (segment !== "" && segment.toLowerCase() !== "pages") // remove sharepoint pages folder from segments list, just to keep things tidy
	            segmentArray.push(segment);
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    } // Add ellipses / remove segments if too long


	    var segmentTotalCharacterLimit = 40;
	    var charsBetweenSegments = " > ";
	    var ellipsis = "...";
	    var addEllipsisSecondToLast = false;
	    var addEllipsisAtEnd = false;

	    function getCurrentCharacterLength() {
	      return segmentArray.join(charsBetweenSegments).length;
	    }

	    while (getCurrentCharacterLength() > segmentTotalCharacterLimit) {
	      if (segmentArray.length > 2) {
	        // remove second to last
	        segmentArray.splice(segmentArray.length - 2, 1); // add ellipsis second to last

	        addEllipsisSecondToLast = true;
	      } else if (segmentArray.length === 2) {
	        // if second can be truncated, truncate
	        if (segmentTotalCharacterLimit - getCurrentCharacterLength() - segmentArray[1].length >= 0) {
	          // truncate second item
	          segmentArray[1] = segmentArray[1].substr(0, segmentTotalCharacterLimit - getCurrentCharacterLength() - segmentArray[1].length);
	        } else {
	          // remove secondItem
	          segmentArray.pop();
	        }

	        addEllipsisAtEnd = true;
	      } else if (segmentArray.length === 1) {
	        addEllipsisAtEnd = true; // truncate

	        segmentArray[0] = segmentArray[0].substr(0, segmentTotalCharacterLimit);
	      } else {
	        break;
	      }
	    }

	    if (addEllipsisSecondToLast && segmentArray.length > 1) {
	      segmentArray.splice(segmentArray.length - 1, 0, ellipsis);
	    }

	    if (addEllipsisAtEnd && segmentArray.length > 0) {
	      segmentArray[segmentArray.length - 1] = segmentArray[segmentArray.length - 1] + ellipsis;
	    }

	    this.segments = segmentArray;
	  }

	  _createClass(FriendlyUrl, [{
	    key: "formattedUrl",
	    get: function get() {
	      return this.segments.join(" âº ");
	    }
	  }]);

	  return FriendlyUrl;
	}();

	var ItemFileType;

	(function (ItemFileType) {
	  ItemFileType[ItemFileType["None"] = 0] = "None";
	  ItemFileType[ItemFileType["Pdf"] = 1] = "Pdf";
	  ItemFileType[ItemFileType["Word"] = 2] = "Word";
	  ItemFileType[ItemFileType["Excel"] = 3] = "Excel";
	  ItemFileType[ItemFileType["PowerPoint"] = 4] = "PowerPoint";
	  ItemFileType[ItemFileType["Other"] = 5] = "Other";
	})(ItemFileType || (ItemFileType = {}));

	var WebResultItem = /*#__PURE__*/function () {
	  function WebResultItem() {
	    _classCallCheck(this, WebResultItem);

	    this.fileType = ItemFileType.None;
	    this.thumbnail = null;
	  }

	  _createClass(WebResultItem, null, [{
	    key: "parseItemFileType",
	    value: function parseItemFileType(fileFormat) {
	      var fileType = ItemFileType.None;

	      if (fileFormat != null) {
	        switch (fileFormat) {
	          case "PDF/Adobe Acrobat":
	            fileType = ItemFileType.Pdf;
	            break;

	          case "Microsoft Word":
	            fileType = ItemFileType.Word;
	            break;

	          case "Microsoft Excel":
	            fileType = ItemFileType.Excel;
	            break;

	          case "Microsoft Powerpoint":
	            fileType = ItemFileType.PowerPoint;
	            break;

	          default:
	            fileType = ItemFileType.Other;
	        }
	      }

	      return fileType;
	    }
	  }, {
	    key: "createFromItem",
	    value: function createFromItem(item) {
	      var _a, _b, _c, _d, _e;

	      var webResultItem = new WebResultItem();
	      webResultItem.title = ((_b = (_a = item.htmlTitle) !== null && _a !== void 0 ? _a : item.title) !== null && _b !== void 0 ? _b : item.displayLink).replace(/ \.\.\.$/, "&nbsp;&hellip;"), webResultItem.url = item.link; // console.log(item.link);

	      webResultItem.friendlyUrl = new FriendlyUrl(item.link);
	      webResultItem.description = ((_e = (_d = (_c = item.htmlSnippet) !== null && _c !== void 0 ? _c : item.htmlTitle) !== null && _d !== void 0 ? _d : item.title) !== null && _e !== void 0 ? _e : item.displayLink).replace(/<br>/gi, "");
	      webResultItem.fileType = this.parseItemFileType(item.fileFormat);

	      if (item.pagemap && item.pagemap.cse_thumbnail && item.pagemap.cse_thumbnail.length > 0) {
	        var thumbnail = item.pagemap.cse_thumbnail[0];
	        webResultItem.thumbnail = {
	          url: thumbnail.src,
	          width: parseInt(thumbnail.width, 10),
	          height: parseInt(thumbnail.height, 10)
	        };
	      }

	      return webResultItem;
	    }
	  }, {
	    key: "createFromPromotion",
	    value: function createFromPromotion(promotion) {
	      var webResultItem = new WebResultItem();

	      var replaceItalicTags = function replaceItalicTags(text) {
	        return text.replace(/(<\/?)em(>)/gi, "$1b$2");
	      };

	      webResultItem.title = replaceItalicTags(promotion.htmlTitle), webResultItem.url = promotion.link;
	      webResultItem.friendlyUrl = new FriendlyUrl(promotion.link);
	      var description = "";

	      if (promotion.bodyLines && promotion.bodyLines.length > 0) {
	        description = promotion.bodyLines[0].htmlTitle;
	        webResultItem.description = replaceItalicTags(description);
	      }

	      if (promotion.image != null) {
	        webResultItem.thumbnail = {
	          url: promotion.image.source.replace(/.*?url=([^&].*?)\&.*/gi, "$1"),
	          width: promotion.image.width,
	          height: promotion.image.height
	        };
	      }

	      return webResultItem;
	    }
	  }]);

	  return WebResultItem;
	}();

	var TopAgencyResultItem = /*#__PURE__*/_createClass(function TopAgencyResultItem(agency) {
	  _classCallCheck(this, TopAgencyResultItem);

	  this.agency = agency;
	});

	var RelatedAgenciesResultItem = /*#__PURE__*/_createClass(function RelatedAgenciesResultItem(agencies) {
	  _classCallCheck(this, RelatedAgenciesResultItem);

	  this.agencies = agencies;
	});

	var SpellingResultItem = /*#__PURE__*/_createClass(function SpellingResultItem(text, html) {
	  _classCallCheck(this, SpellingResultItem);

	  this.text = text;
	  this.html = html;
	});

	// import { Agency } from "../models/agency";
	var __decorate$b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	// 	public items: ResultItem[] = [];
	// 	public totalCount: number = 0;
	// 	public formattedTotalCount: string = "";
	// }

	var SearchResultsState = /*#__PURE__*/function () {
	  function SearchResultsState(searchAppState //private portalSearchClient: PortalSearchClient,
	  //private agencies: TrackedArray<Agency>
	  ) {
	    _classCallCheck(this, SearchResultsState);

	    // const searchParametersUpdate = () => {
	    // 	//console.log("Detected change, calling search client")
	    // 	this.portalSearchClient
	    // 		.getResults(appState.input.fullQuery, appState.input.startIndex)
	    // 		.then(r => SearchAppController.setResponse(r));
	    // };
	    this.searchAppState = searchAppState; // const throttledUpdate = debounce(searchParametersUpdate, 50);
	    // subscribeAll(appState.input, throttledUpdate);
	    // //this.start.subscribe(throttledUpdate);
	    // //this.query.subscribe(throttledUpdate);
	    // this.agencies.subscribe(throttledUpdate);
	  }

	  _createClass(SearchResultsState, [{
	    key: "includePromotions",
	    get: function get() {
	      return this.searchAppState.currentPage === 0;
	    }
	  }, {
	    key: "includeRelatedAgencies",
	    get: function get() {
	      return this.searchAppState.currentPage === 0;
	    } // @computed
	    // get totalCount() {
	    // 	const r = appState.results.response;
	    // 	return r ? parseInt(r.searchInformation.totalResults, 10) : 0;
	    // }
	    // @computed
	    // get formattedTotalCount() {
	    // 	const r = appState.results.response;
	    // 	return r ? r.searchInformation.formattedTotalResults : 0;
	    // }

	  }, {
	    key: "items",
	    get: function get() {
	      var response = this.searchAppState.searchResponse;
	      var items = [];
	      if (!response) return items;

	      if (response.promotions && this.includePromotions) {
	        // Create items from promotions, put in top of list
	        items = items.concat(response.promotions.map(function (p) {
	          return WebResultItem.createFromPromotion(p);
	        }));
	      }

	      if (response.items) {
	        // Factory create items from  items
	        items = items.concat(response.items.map(function (item) {
	          return WebResultItem.createFromItem(item);
	        }));
	      }

	      if (this.includeRelatedAgencies && this.searchAppState.agencies.length > 0) {
	        var matches = this.getAgencyMatches(this.searchAppState.agencies, this.getWebResultItems(items));
	        var topAgencyMatch = matches.strongMatches.length > 0 ? matches.strongMatches.shift() : null;

	        if (topAgencyMatch) {
	          items.splice(Math.floor(topAgencyMatch.index / 2), 0, new TopAgencyResultItem(topAgencyMatch.agency));
	        }

	        var remainingMatches = sortBy_1(matches.strongMatches.concat(matches.weakMatches), function (m) {
	          return m.index;
	        }).slice(0, 5);

	        if (remainingMatches.length > 0) {
	          var resultItem = new RelatedAgenciesResultItem(remainingMatches.map(function (m) {
	            return m.agency;
	          })); // Insert in 3rd place or at end

	          if (items.length > 3) {
	            items.splice(3, 0, resultItem);
	          } else {
	            items.push(resultItem);
	          }
	        }
	      } //console.log("agency matches", this.getAgenciesMatches(this.searchAppState.agencies, this.getWebResultItems(items)));
	      // if (this.includeRelatedAgencies && this.searchAppState.agencies.length > 0) {
	      // 	// Create items from agencies
	      // 	// top agency or empty array
	      // 	const topAgencyMatch = this.getTopAgencyMatch(this.getWebResultItems(items), this.searchAppState.agencies);
	      // 	if (topAgencyMatch) {
	      // 		items.splice(Math.floor(topAgencyMatch.matchIndex / 2), 0, new TopAgencyResultItem(topAgencyMatch.agency));
	      // 	}
	      // 	// Other related agencies (exclude top agency)
	      // 	const remainingAgencyMatches = this.getAgencyMatches(this.getWebResultItems(items), this.searchAppState.agencies)
	      // 		.filter(a => topAgencyMatch != null && topAgencyMatch.agency.listItemId !== a.listItemId); // Remove top agency if any
	      // 	if (remainingAgencyMatches.length > 0) {
	      // 		const resultItem = new RelatedAgenciesResultItem(remainingAgencyMatches);
	      // 		// Insert in 3rd place or at end
	      // 		if (items.length > 3) {
	      // 			items.splice(3, 0, resultItem);
	      // 		} else {
	      // 			items.push(resultItem);
	      // 		}
	      // 	}
	      // }


	      if (response.spelling) {
	        // Create item from spelling suggestion
	        items.unshift(new SpellingResultItem(response.spelling.correctedQuery, response.spelling.htmlCorrectedQuery));
	      }

	      return items;
	    } // An attempt to make the agency matching algorithm much more efficient and less cpu heavy
	    // By only iterating over agencies once, and not checking items that have already matched

	  }, {
	    key: "getAgencyMatches",
	    value: function getAgencyMatches(agencies, items) {
	      var itemsToCheck = items.slice();
	      var result = {
	        strongMatches: [],
	        weakMatches: []
	      };

	      var _iterator = _createForOfIteratorHelper(agencies),
	          _step;

	      try {
	        var _loop = function _loop() {
	          var agency = _step.value;

	          if (!agency.homepageUrlPattern && !agency.relatedUrlPattern) {
	            return "continue";
	          }

	          var weakMatchFound = false;

	          for (var i = 0; i < items.length; i++) {
	            var item = items[i];

	            if (item.url.match(agency.homepageRegex)) {
	              result.strongMatches.push({
	                agency: agency,
	                index: i
	              }); // If a weak match was found already, remove it from weakMatches,
	              // effectively "upgrading" it to strong match

	              var weakMatchIndex = result.weakMatches.findIndex(function (m) {
	                return m.agency == agency;
	              });

	              if (weakMatchIndex !== -1) {
	                result.weakMatches.splice(weakMatchIndex, 1);
	              } // Remove item from itemsToCheck


	              itemsToCheck.splice(i, 1); // Break from items loop
	              // Once a strong match is found, no need to keep searching for this agency
	              // Continue to next agency

	              break;
	            }

	            if (!weakMatchFound && item.url.match(agency.relatedRegex)) {
	              result.weakMatches.push({
	                agency: agency,
	                index: i
	              }); // Don't consider relatedUrlPattern in any more items in this items loop

	              weakMatchFound = true;
	            }
	          }
	        };

	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var _ret = _loop();

	          if (_ret === "continue") continue;
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }

	      result.strongMatches = sortBy_1(result.strongMatches, function (m) {
	        return m.index;
	      });
	      result.weakMatches = sortBy_1(result.weakMatches, function (m) {
	        return m.index;
	      });
	      return result;
	    }
	  }, {
	    key: "getWebResultItems",
	    value: function getWebResultItems(items) {
	      return items.filter(function (item) {
	        return item instanceof WebResultItem;
	      });
	    }
	  }]);

	  return SearchResultsState;
	}();

	__decorate$b([computed], SearchResultsState.prototype, "includePromotions", null);

	__decorate$b([computed], SearchResultsState.prototype, "includeRelatedAgencies", null);

	__decorate$b([computed], SearchResultsState.prototype, "items", null);

	SearchResultsState = __decorate$b([trackable], SearchResultsState);

	var __decorate$a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var SearchAppState = /*#__PURE__*/_createClass(function SearchAppState() {
	  _classCallCheck(this, SearchAppState);

	  // TODO: Somehow load agencies in background before user makes first search?
	  this.initialLoading = true; // Used to prevent user input until agencies list has loaded

	  this.loading = false; // For performing the actual searches

	  this.agencies = [];
	  this.currentSubset = "all";
	  this.currentPage = 0;
	  this.searchParameters = {
	    searchText: "",
	    subsetQuery: null,
	    start: 1
	  };
	  this.searchResponse = null;
	  this.results = new SearchResultsState(this);
	});

	__decorate$a([tracked], SearchAppState.prototype, "initialLoading", void 0);

	__decorate$a([tracked], SearchAppState.prototype, "loading", void 0);

	__decorate$a([tracked], SearchAppState.prototype, "agencies", void 0);

	__decorate$a([tracked], SearchAppState.prototype, "currentSubset", void 0);

	__decorate$a([tracked], SearchAppState.prototype, "currentPage", void 0);

	__decorate$a([tracked], SearchAppState.prototype, "searchParameters", void 0);

	__decorate$a([tracked], SearchAppState.prototype, "searchResponse", void 0);

	SearchAppState = __decorate$a([trackable], SearchAppState);
	var searchAppState = new SearchAppState();

	var subsets = {
	  "all": {
	    query: null,
	    iconText: "list",
	    name: "All Results"
	  },
	  "forms": {
	    query: "more:forms",
	    iconText: "description",
	    name: "Forms"
	  },
	  "services": {
	    query: "more:services",
	    iconText: "settings",
	    name: "Online Services"
	  }
	};

	var __awaiter$7 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	function assign(obj, obj2) {
	  return Object.assign(Object.assign({}, obj), obj2);
	}

	var searchClient = new PortalSearchClient("/_vti_bin/PortalSearch/Search.svc/Results");
	var SearchAppController = /*#__PURE__*/function () {
	  function SearchAppController() {
	    _classCallCheck(this, SearchAppController);
	  }

	  _createClass(SearchAppController, null, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$7(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var listItemClient, items, searchQueryString;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                listItemClient = new ListItemClient();
	                _context.next = 3;
	                return listItemClient.getListItems("Agencies and Entities", undefined, undefined, 1000);

	              case 3:
	                items = _context.sent;
	                searchAppState.agencies = items.map(function (i) {
	                  return new Agency(i);
	                });
	                searchQueryString = new URLSearchParams(window.location.search).get('q');

	                if (searchQueryString) {
	                  SearchAppController.setSearchText(searchQueryString);
	                }

	                searchAppState.initialLoading = false;

	              case 8:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee);
	      }));
	    }
	  }, {
	    key: "setSearchText",
	    value: function setSearchText(text) {
	      searchAppState.currentPage = 0;
	      SearchAppController.setSearchParameters(assign(searchAppState.searchParameters, {
	        searchText: text,
	        start: 1
	      }));
	    }
	  }, {
	    key: "setCurrentSubset",
	    value: function setCurrentSubset(key) {
	      searchAppState.currentSubset = key;
	      searchAppState.currentPage = 0;
	      SearchAppController.setSearchParameters(assign(searchAppState.searchParameters, {
	        subsetQuery: subsets[key].query,
	        start: 1
	      }));
	    }
	  }, {
	    key: "setCurrentPage",
	    value: function setCurrentPage(page) {
	      searchAppState.currentPage = page;
	      var start = 1 + page * 10;
	      SearchAppController.setSearchParameters(assign(searchAppState.searchParameters, {
	        start: start
	      }));
	    }
	  }, {
	    key: "previousPage",
	    value: function previousPage() {
	      SearchAppController.setCurrentPage(searchAppState.currentPage - 1);
	    }
	  }, {
	    key: "nextPage",
	    value: function nextPage() {
	      SearchAppController.setCurrentPage(searchAppState.currentPage + 1);
	    }
	  }, {
	    key: "setSearchParameters",
	    value: function setSearchParameters(params) {
	      // if params different
	      if (!isEqual_1(searchAppState.searchParameters, params)) {
	        searchAppState.searchParameters = params;
	        SearchAppController.searchParametersChanged();
	      }
	    }
	  }, {
	    key: "setSearchResponse",
	    value: function setSearchResponse(response) {
	      searchAppState.searchResponse = response;
	    }
	  }, {
	    key: "searchParametersChanged",
	    value: function searchParametersChanged() {
	      searchAppState.searchParameters.searchText;
	      searchAppState.loading = true;
	      var url = searchAppState.searchParameters.searchText;
	      if (searchAppState.searchParameters.subsetQuery) url += " " + searchAppState.searchParameters.subsetQuery;
	      searchClient.getResultsOrReject(url, searchAppState.searchParameters.start).then(function (response) {
	        //console.log(text, response);
	        // This then() gets called even if Promise was rejected.
	        // Not sure why, but we need to check for null here
	        if (response) {
	          SearchAppController.setSearchResponse(response);
	          searchAppState.loading = false;
	        }
	      });
	    }
	  }]);

	  return SearchAppController;
	}();

	var nprogress = createCommonjsModule(function (module, exports) {

	  (function (root, factory) {
	    {
	      module.exports = factory();
	    }
	  })(commonjsGlobal, function () {
	    var NProgress = {};
	    NProgress.version = '0.2.0';
	    var Settings = NProgress.settings = {
	      minimum: 0.08,
	      easing: 'ease',
	      positionUsing: '',
	      speed: 200,
	      trickle: true,
	      trickleRate: 0.02,
	      trickleSpeed: 800,
	      showSpinner: true,
	      barSelector: '[role="bar"]',
	      spinnerSelector: '[role="spinner"]',
	      parent: 'body',
	      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
	    };
	    /**
	     * Updates configuration.
	     *
	     *     NProgress.configure({
	     *       minimum: 0.1
	     *     });
	     */

	    NProgress.configure = function (options) {
	      var key, value;

	      for (key in options) {
	        value = options[key];
	        if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
	      }

	      return this;
	    };
	    /**
	     * Last number.
	     */


	    NProgress.status = null;
	    /**
	     * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
	     *
	     *     NProgress.set(0.4);
	     *     NProgress.set(1.0);
	     */

	    NProgress.set = function (n) {
	      var started = NProgress.isStarted();
	      n = clamp(n, Settings.minimum, 1);
	      NProgress.status = n === 1 ? null : n;
	      var progress = NProgress.render(!started),
	          bar = progress.querySelector(Settings.barSelector),
	          speed = Settings.speed,
	          ease = Settings.easing;
	      progress.offsetWidth;
	      /* Repaint */

	      queue(function (next) {
	        // Set positionUsing if it hasn't already been set
	        if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS(); // Add transition

	        css(bar, barPositionCSS(n, speed, ease));

	        if (n === 1) {
	          // Fade out
	          css(progress, {
	            transition: 'none',
	            opacity: 1
	          });
	          progress.offsetWidth;
	          /* Repaint */

	          setTimeout(function () {
	            css(progress, {
	              transition: 'all ' + speed + 'ms linear',
	              opacity: 0
	            });
	            setTimeout(function () {
	              NProgress.remove();
	              next();
	            }, speed);
	          }, speed);
	        } else {
	          setTimeout(next, speed);
	        }
	      });
	      return this;
	    };

	    NProgress.isStarted = function () {
	      return typeof NProgress.status === 'number';
	    };
	    /**
	     * Shows the progress bar.
	     * This is the same as setting the status to 0%, except that it doesn't go backwards.
	     *
	     *     NProgress.start();
	     *
	     */


	    NProgress.start = function () {
	      if (!NProgress.status) NProgress.set(0);

	      var work = function work() {
	        setTimeout(function () {
	          if (!NProgress.status) return;
	          NProgress.trickle();
	          work();
	        }, Settings.trickleSpeed);
	      };

	      if (Settings.trickle) work();
	      return this;
	    };
	    /**
	     * Hides the progress bar.
	     * This is the *sort of* the same as setting the status to 100%, with the
	     * difference being `done()` makes some placebo effect of some realistic motion.
	     *
	     *     NProgress.done();
	     *
	     * If `true` is passed, it will show the progress bar even if its hidden.
	     *
	     *     NProgress.done(true);
	     */


	    NProgress.done = function (force) {
	      if (!force && !NProgress.status) return this;
	      return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
	    };
	    /**
	     * Increments by a random amount.
	     */


	    NProgress.inc = function (amount) {
	      var n = NProgress.status;

	      if (!n) {
	        return NProgress.start();
	      } else {
	        if (typeof amount !== 'number') {
	          amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
	        }

	        n = clamp(n + amount, 0, 0.994);
	        return NProgress.set(n);
	      }
	    };

	    NProgress.trickle = function () {
	      return NProgress.inc(Math.random() * Settings.trickleRate);
	    };
	    /**
	     * Waits for all supplied jQuery promises and
	     * increases the progress as the promises resolve.
	     *
	     * @param $promise jQUery Promise
	     */


	    (function () {
	      var initial = 0,
	          current = 0;

	      NProgress.promise = function ($promise) {
	        if (!$promise || $promise.state() === "resolved") {
	          return this;
	        }

	        if (current === 0) {
	          NProgress.start();
	        }

	        initial++;
	        current++;
	        $promise.always(function () {
	          current--;

	          if (current === 0) {
	            initial = 0;
	            NProgress.done();
	          } else {
	            NProgress.set((initial - current) / initial);
	          }
	        });
	        return this;
	      };
	    })();
	    /**
	     * (Internal) renders the progress bar markup based on the `template`
	     * setting.
	     */


	    NProgress.render = function (fromStart) {
	      if (NProgress.isRendered()) return document.getElementById('nprogress');
	      addClass(document.documentElement, 'nprogress-busy');
	      var progress = document.createElement('div');
	      progress.id = 'nprogress';
	      progress.innerHTML = Settings.template;
	      var bar = progress.querySelector(Settings.barSelector),
	          perc = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
	          parent = document.querySelector(Settings.parent),
	          spinner;
	      css(bar, {
	        transition: 'all 0 linear',
	        transform: 'translate3d(' + perc + '%,0,0)'
	      });

	      if (!Settings.showSpinner) {
	        spinner = progress.querySelector(Settings.spinnerSelector);
	        spinner && removeElement(spinner);
	      }

	      if (parent != document.body) {
	        addClass(parent, 'nprogress-custom-parent');
	      }

	      parent.appendChild(progress);
	      return progress;
	    };
	    /**
	     * Removes the element. Opposite of render().
	     */


	    NProgress.remove = function () {
	      removeClass(document.documentElement, 'nprogress-busy');
	      removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
	      var progress = document.getElementById('nprogress');
	      progress && removeElement(progress);
	    };
	    /**
	     * Checks if the progress bar is rendered.
	     */


	    NProgress.isRendered = function () {
	      return !!document.getElementById('nprogress');
	    };
	    /**
	     * Determine which positioning CSS rule to use.
	     */


	    NProgress.getPositioningCSS = function () {
	      // Sniff on document.body.style
	      var bodyStyle = document.body.style; // Sniff prefixes

	      var vendorPrefix = 'WebkitTransform' in bodyStyle ? 'Webkit' : 'MozTransform' in bodyStyle ? 'Moz' : 'msTransform' in bodyStyle ? 'ms' : 'OTransform' in bodyStyle ? 'O' : '';

	      if (vendorPrefix + 'Perspective' in bodyStyle) {
	        // Modern browsers with 3D support, e.g. Webkit, IE10
	        return 'translate3d';
	      } else if (vendorPrefix + 'Transform' in bodyStyle) {
	        // Browsers without 3D support, e.g. IE9
	        return 'translate';
	      } else {
	        // Browsers without translate() support, e.g. IE7-8
	        return 'margin';
	      }
	    };
	    /**
	     * Helpers
	     */


	    function clamp(n, min, max) {
	      if (n < min) return min;
	      if (n > max) return max;
	      return n;
	    }
	    /**
	     * (Internal) converts a percentage (`0..1`) to a bar translateX
	     * percentage (`-100%..0%`).
	     */


	    function toBarPerc(n) {
	      return (-1 + n) * 100;
	    }
	    /**
	     * (Internal) returns the correct CSS for changing the bar's
	     * position given an n percentage, and speed and ease from Settings
	     */


	    function barPositionCSS(n, speed, ease) {
	      var barCSS;

	      if (Settings.positionUsing === 'translate3d') {
	        barCSS = {
	          transform: 'translate3d(' + toBarPerc(n) + '%,0,0)'
	        };
	      } else if (Settings.positionUsing === 'translate') {
	        barCSS = {
	          transform: 'translate(' + toBarPerc(n) + '%,0)'
	        };
	      } else {
	        barCSS = {
	          'margin-left': toBarPerc(n) + '%'
	        };
	      }

	      barCSS.transition = 'all ' + speed + 'ms ' + ease;
	      return barCSS;
	    }
	    /**
	     * (Internal) Queues a function to be executed.
	     */


	    var queue = function () {
	      var pending = [];

	      function next() {
	        var fn = pending.shift();

	        if (fn) {
	          fn(next);
	        }
	      }

	      return function (fn) {
	        pending.push(fn);
	        if (pending.length == 1) next();
	      };
	    }();
	    /**
	     * (Internal) Applies css properties to an element, similar to the jQuery 
	     * css method.
	     *
	     * While this helper does assist with vendor prefixed property names, it 
	     * does not perform any manipulation of values prior to setting styles.
	     */


	    var css = function () {
	      var cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'],
	          cssProps = {};

	      function camelCase(string) {
	        return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function (match, letter) {
	          return letter.toUpperCase();
	        });
	      }

	      function getVendorProp(name) {
	        var style = document.body.style;
	        if (name in style) return name;
	        var i = cssPrefixes.length,
	            capName = name.charAt(0).toUpperCase() + name.slice(1),
	            vendorName;

	        while (i--) {
	          vendorName = cssPrefixes[i] + capName;
	          if (vendorName in style) return vendorName;
	        }

	        return name;
	      }

	      function getStyleProp(name) {
	        name = camelCase(name);
	        return cssProps[name] || (cssProps[name] = getVendorProp(name));
	      }

	      function applyCss(element, prop, value) {
	        prop = getStyleProp(prop);
	        element.style[prop] = value;
	      }

	      return function (element, properties) {
	        var args = arguments,
	            prop,
	            value;

	        if (args.length == 2) {
	          for (prop in properties) {
	            value = properties[prop];
	            if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
	          }
	        } else {
	          applyCss(element, args[1], args[2]);
	        }
	      };
	    }();
	    /**
	     * (Internal) Determines if an element or space separated list of class names contains a class name.
	     */


	    function hasClass(element, name) {
	      var list = typeof element == 'string' ? element : classList(element);
	      return list.indexOf(' ' + name + ' ') >= 0;
	    }
	    /**
	     * (Internal) Adds a class to an element.
	     */


	    function addClass(element, name) {
	      var oldList = classList(element),
	          newList = oldList + name;
	      if (hasClass(oldList, name)) return; // Trim the opening space.

	      element.className = newList.substring(1);
	    }
	    /**
	     * (Internal) Removes a class from an element.
	     */


	    function removeClass(element, name) {
	      var oldList = classList(element),
	          newList;
	      if (!hasClass(element, name)) return; // Replace the class name.

	      newList = oldList.replace(' ' + name + ' ', ' '); // Trim the opening and closing spaces.

	      element.className = newList.substring(1, newList.length - 1);
	    }
	    /**
	     * (Internal) Gets a space separated list of the class names on the element. 
	     * The list is wrapped with a single space on each end to facilitate finding 
	     * matches within the list.
	     */


	    function classList(element) {
	      return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
	    }
	    /**
	     * (Internal) Removes an element from the DOM.
	     */


	    function removeElement(element) {
	      element && element.parentNode && element.parentNode.removeChild(element);
	    }

	    return NProgress;
	  });
	});

	var _templateObject$9, _templateObject2$8, _templateObject3$5, _templateObject4$4, _templateObject5$1, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11;

	var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$6 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};
	//     return Object.assign(Object.assign({}, obj), obj2);
	// }

	var SearchAppElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(SearchAppElement, _BaseElement);

	  var _super = _createSuper(SearchAppElement);

	  function SearchAppElement() {
	    var _this;

	    _classCallCheck(this, SearchAppElement);

	    _this = _super.call(this);

	    _this.inputKeydown = function (e) {
	      if (e.key === "Enter") {
	        _this.commitSearchText();

	        e.preventDefault();
	      }
	    };

	    _this.spellingSuggestionClicked = function (item) {
	      _this.inputElement.value = item.text;

	      _this.commitSearchText();
	    };

	    _this.subsetButtonClicked = function (key) {
	      SearchAppController.setCurrentSubset(key);
	    };

	    _this.prevPageClicked = function () {
	      SearchAppController.previousPage();
	      window.location.hash = "";
	      window.location.hash = "search-top";
	    };

	    _this.nextPageClicked = function () {
	      SearchAppController.nextPage();
	      window.location.hash = "";
	      window.location.hash = "search-top";
	    };

	    _this.submitButtonClicked = function () {
	      _this.commitSearchText();
	    };

	    _this.init();

	    return _this;
	  }

	  _createClass(SearchAppElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$6(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return SearchAppController.init();

	              case 2:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee);
	      }));
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this2 = this;

	      _get(_getPrototypeOf(SearchAppElement.prototype), "connectedCallback", this).call(this);

	      subscribeAll(searchAppState, function () {
	        return _this2.requestUpdate();
	      });
	      getTrackedProperty(searchAppState, "loading").subscribe(function () {
	        if (searchAppState.loading) {
	          nprogress.start();

	          _this2.classList.add("or-loading");
	        } else {
	          nprogress.done();

	          _this2.classList.remove("or-loading");
	        }
	      });
	    } // firstUpdated(props) {
	    //     super.firstUpdated(props);
	    //     // console.log("Nprogress", Nprogress);
	    //     // Nprogress.start();
	    // }

	  }, {
	    key: "updated",
	    value: function updated(props) {
	      _get(_getPrototypeOf(SearchAppElement.prototype), "updated", this).call(this, props);

	      if (this.nProgressElement) nprogress.configure({
	        parent: '#or-nprogress'
	      });
	    }
	  }, {
	    key: "commitSearchText",
	    value: function commitSearchText() {
	      SearchAppController.setSearchText(this.inputElement.value);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this3 = this;

	      var _a, _b;

	      return html(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteral(["\n            ", "\n        "])), searchAppState.initialLoading ? html(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteral(["\n                Loading...\n            "]))) : html(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteral(["\n                <a class=\"or-anchor\" name=\"search-top\"></a>\n\n                <div class=\"or-portal-search-input-wrapper\">\n                    <input\n                        class=\"or-portal-search-input\"\n                        type=\"search\"\n                        placeholder=\"Search Oregon.gov\"\n                        .value=", "\n                        @keydown=", " />\n\n                    <div class=\"or-portal-search-spinner\"></div>\n\n                    <button class=\"or-portal-search-submit btn-primary\"\n                        @click=", ">\n                        <span class=\"far fa-search\" aria-hidden=\"true\"></span>\n                        <span class=\"sr-only\">Submit</span>\n                    </button>\n                </div>\n                \n                \n\n                <!-- tabs -->\n                <div class=\"or-portal-search-toolbar clearfix\">\n                    <div id=\"or-nprogress\"></div>\n\n                    <div class=\"btn-group\">\n                        ", "\n                    </div>\n                </div>\n\n                <!-- results list -->\n                <div class=\"or-portal-search-results\">\n                    ", "\n                </div>\n\n\n\n                <!-- Next page, prev page links -->\n                <div class=\"or-portal-search-pages\">\n                    ", "\n\n                    <p>Page ", "</p>\n                    \n                    ", "\n                </div>\n\n                <div class=\"or-portal-search-powered-by-logo\">\n                    Powered by <img src=\"https://www.google.com/cse/static/images/1x/googlelogo_grey_46x15dp.png\" alt=\"Google\"> Custom Search\n                </div>\n            "])), searchAppState.searchParameters.searchText, this.inputKeydown, this.submitButtonClicked, Object.keys(subsets).map(function (subsetKey) {
	        return html(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteral(["\n                            <button\n                                class=", "\n                                @click=", " >\n                            ", "\n                        </button>\n                        "])), classMap({
	          btn: true,
	          "btn-primary": true,
	          active: searchAppState.currentSubset === subsetKey
	        }), function () {
	          return _this3.subsetButtonClicked(subsetKey);
	        }, subsets[subsetKey].name);
	      }), searchAppState.results.items.map(function (item) {
	        return html(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteral(["\n                        ", "\n                    "])), item instanceof WebResultItem ? html(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["\n                            <or-web-result .item=", "></or-web-result>\n                        "])), item) : item instanceof RelatedAgenciesResultItem ? html(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral(["\n                            <or-related-agencies-list .item=", "></or-related-agencies-list>\n                        "])), item) : item instanceof SpellingResultItem ? html(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["\n                            <p>Did you mean <a href=\"#_\" @click=", ">", "</a>?</p>\n                        "])), function () {
	          return _this3.spellingSuggestionClicked(item);
	        }, unsafeHTML(item.html)) : item instanceof TopAgencyResultItem ? html(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["\n                            <or-entity-card .entity=", "></or-entity-card>\n                        "])), item.agency.toEntity()) : null);
	      }), ((_a = searchAppState.searchResponse) === null || _a === void 0 ? void 0 : _a.queries.previousPage) ? html(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n                        <button class=\"btn btn-outline-primary\" @click=", ">Previous Page</button>\n                    "])), this.prevPageClicked) : null, searchAppState.currentPage + 1, ((_b = searchAppState.searchResponse) === null || _b === void 0 ? void 0 : _b.queries.nextPage) ? html(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral(["\n                        <button class=\"btn btn-outline-primary\" @click=", ">Next Page</button>\n                    "])), this.nextPageClicked) : null));
	    }
	  }]);

	  return SearchAppElement;
	}(BaseElement);

	__decorate$9([query("input[type=search")], SearchAppElement.prototype, "inputElement", void 0);

	__decorate$9([query("#or-nprogress")], SearchAppElement.prototype, "nProgressElement", void 0);

	SearchAppElement = __decorate$9([customElement("or-search")], SearchAppElement);

	var _templateObject$8, _templateObject2$7, _templateObject3$4, _templateObject4$3;

	var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var WebResultElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(WebResultElement, _BaseElement);

	  var _super = _createSuper(WebResultElement);

	  function WebResultElement() {
	    _classCallCheck(this, WebResultElement);

	    return _super.apply(this, arguments);
	  }

	  _createClass(WebResultElement, [{
	    key: "hasThumbnail",
	    get: function get() {
	      return this.item.thumbnail != null && this.item.thumbnail.url != null;
	    }
	  }, {
	    key: "thumbnailCss",
	    get: function get() {
	      return this.item.thumbnail ? "background-image: url('" + this.item.thumbnail.url + "'); width: 6rem; height: 6rem" : "";
	    }
	  }, {
	    key: "hasIcon",
	    get: function get() {
	      return this.item.fileType !== ItemFileType.None;
	    }
	  }, {
	    key: "iconClass",
	    get: function get() {
	      switch (this.item.fileType) {
	        case ItemFileType.Pdf:
	          return "or-portal-search-item-icon fal fa-file-pdf text-danger";

	        case ItemFileType.Word:
	          return "or-portal-search-item-icon fal fa-file-word text-primary";

	        case ItemFileType.Excel:
	          return "or-portal-search-item-icon fal fa-file-excel text-success";

	        case ItemFileType.PowerPoint:
	          return "or-portal-search-item-icon fal fa-file-powerpoint text-danger";

	        default:
	          return "or-portal-search-item-icon fal fa-file";
	      }
	    }
	  }, {
	    key: "hasMedia",
	    get: function get() {
	      return this.hasIcon || this.hasThumbnail;
	    } // TODO: Add analytics event back

	  }, {
	    key: "onClick",
	    get: function get() {
	      return ""; //return "oregon.analytics.sendEvent('Portal Search', 'Item Clicked in Facet', '" + appState.input.currentSubsetName + "')";
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this = this;

	      _get(_getPrototypeOf(WebResultElement.prototype), "connectedCallback", this).call(this);

	      subscribeAll(this, function () {
	        return _this.requestUpdate();
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteral(["\n\t\t\t<div class=\"or-portal-search-item\">\n\t\t\t\t<a href=", " onclick=", ">\n\t\t\t\t\t<h3 class=\"or-link or-portal-search-item-heading\">\n\t\t\t\t\t\t", "\n\t\t\t\t\t</h3>\n\t\t\t\t</a>\n\n\t\t\t\t<div class=\"or-portal-search-item-content\">\n\t\t\t\t\t", "\n\n\t\t\t\t\t<div class=\"or-portal-search-item-description\">\n\t\t\t\t\t\t<p class=\"text-success or-portal-search-display-url\">\n\t\t\t\t\t\t\t<a class=\"or-link-reset\" href=", " onclick=", ">\n\t\t\t\t\t\t\t\t", "\n\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t</p>\n\t\t\t\t\t\t<p class=\"or-portal-search-snippet\">\n\t\t\t\t\t\t\t", "\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t"])), this.item.url, this.onClick, unsafeHTML(this.item.title), this.hasMedia ? html(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteral(["\n\t\t\t\t\t\t<a class=\"or-portal-search-item-media\" href=", " onclick=", ">\n\t\t\t\t\t\t\t", "\n\t\t\t\t\t\t</a>\n\t\t\t\t\t"])), this.item.url, this.onClick, this.hasThumbnail ? html(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteral(["\n\t\t\t\t\t\t\t\t<div class=\"or-portal-search-item-thumbnail\" style=", "></div>\n\t\t\t\t\t\t\t"])), this.thumbnailCss) : this.hasIcon ? html(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteral(["\n\t\t\t\t\t\t\t\t<span class=", "></span>\n\t\t\t\t\t\t\t"])), this.iconClass) : null) : null, this.item.url, this.onClick, unsafeHTML(this.item.friendlyUrl.formattedUrl), unsafeHTML(this.item.description));
	    }
	  }]);

	  return WebResultElement;
	}(BaseElement);

	__decorate$8([tracked], WebResultElement.prototype, "item", void 0);

	__decorate$8([computed], WebResultElement.prototype, "hasThumbnail", null);

	__decorate$8([computed], WebResultElement.prototype, "thumbnailCss", null);

	__decorate$8([computed], WebResultElement.prototype, "hasIcon", null);

	__decorate$8([computed], WebResultElement.prototype, "iconClass", null);

	__decorate$8([computed], WebResultElement.prototype, "hasMedia", null);

	__decorate$8([computed], WebResultElement.prototype, "onClick", null);

	WebResultElement = __decorate$8([trackable, customElement("or-web-result")], WebResultElement);

	var _templateObject$7, _templateObject2$6;

	var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var RelatedAgencyListElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(RelatedAgencyListElement, _BaseElement);

	  var _super = _createSuper(RelatedAgencyListElement);

	  function RelatedAgencyListElement() {
	    _classCallCheck(this, RelatedAgencyListElement);

	    return _super.apply(this, arguments);
	  }

	  _createClass(RelatedAgencyListElement, [{
	    key: "render",
	    value: function render() {
	      return html(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral(["\n        <div class=\"card\">\n            <div class=\"card-header\">\n                Related Agencies and Entities\n            </div>\n            <div class=\"list-group list-group-flush\">\n                ", "\n            </div>\n        </div>\n\t\t"])), this.item.agencies.map(function (agency) {
	        return html(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteral(["\n                    <a href=", " class=\"list-group-item list-group-item-action\">", "</a>\n                "])), agency.websiteUrl, agency.officialName);
	      }));
	    }
	  }]);

	  return RelatedAgencyListElement;
	}(BaseElement);

	__decorate$7([property$1({
	  attribute: false
	})], RelatedAgencyListElement.prototype, "item", void 0);

	RelatedAgencyListElement = __decorate$7([customElement("or-related-agencies-list")], RelatedAgencyListElement);
	// <div class="or-portal-search-related-agencies">
	//     ${ this.item.agencies.map(agency => html`
	//         <or-entity-card .entity=${ agency.toEntity() }></or-entity-card>
	//     `) }
	// </div>
	// </div>

	var _templateObject$6;

	var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var EllipsisText = /*#__PURE__*/function (_BaseElement) {
	  _inherits(EllipsisText, _BaseElement);

	  var _super = _createSuper(EllipsisText);

	  function EllipsisText() {
	    _classCallCheck(this, EllipsisText);

	    return _super.apply(this, arguments);
	  }

	  _createClass(EllipsisText, [{
	    key: "firstUpdated",
	    value: function firstUpdated(props) {
	      _get(_getPrototypeOf(EllipsisText.prototype), "firstUpdated", this).call(this, props);

	      this.innerText = this.text.replace(/<\/?[^>]+(>|$)/g, "");
	      this.observeElement(this, this.getReferenceEl(this));
	    }
	  }, {
	    key: "observeElement",
	    value: function observeElement(element, referenceElement) {
	      var _this = this;

	      var width = read(function () {
	        return referenceElement.clientWidth;
	      });
	      var height = read(function () {
	        return referenceElement.clientHeight;
	      });
	      calc(function (w, h) {
	        _this.moveEllipsis();
	      }, width, height);
	    }
	  }, {
	    key: "moveEllipsis",
	    value: function moveEllipsis() {
	      var existingSpan = this.querySelector("span.or-ellipsis");

	      if (existingSpan) {
	        // This causes intentional layout thrashing
	        this.innerText = this.text.replace(/<\/?[^>]+(>|$)/g, "");

	      } // This causes intentional layout thrashing


	      var referenceRect = this.getReferenceEl(this).getBoundingClientRect(); // Assumes a single child text node after a comment (from lit html)

	      var textNode = this.childNodes[0];
	      var textContent = textNode.textContent;
	      var prevPrevEnd = -1;
	      var prevStart = -1;
	      var prevEnd = -1;
	      var start = -1;
	      var end = -1;

	      for (var i = 0; i < textContent.length; i++) {
	        var char = textContent[i];

	        if (char !== " " && start === -1) {
	          start = i;
	        } else if (start !== -1 && (char === " " || i === textContent.length - 1)) {
	          end = i === textContent.length - 1 ? i + 1 : i;
	          var success = this.checkWord(textNode, start, end, prevPrevEnd, prevStart, prevEnd, referenceRect);
	          if (success) return;
	          prevPrevEnd = prevEnd;
	          prevStart = start;
	          prevEnd = end;
	          start = -1;
	          end = -1;
	        }
	      }
	    }
	  }, {
	    key: "checkWord",
	    value: function checkWord(textNode, start, end, prevPrevEnd, prevStart, prevEnd, referenceRect) {
	      var range = document.createRange();
	      range.setStart(textNode, start);
	      range.setEnd(textNode, end);
	      var rect = range.getBoundingClientRect();

	      if (rect.bottom > referenceRect.bottom + 1) {
	        var prevRange = document.createRange();
	        prevRange.setStart(textNode, prevStart);
	        prevRange.setEnd(textNode, prevEnd);
	        var prevRect = prevRange.getBoundingClientRect();
	        var usePrevPrev = prevRect.right >= referenceRect.right - this.ellipsisWidth;
	        var splitPoint = usePrevPrev ? prevPrevEnd : prevEnd;
	        write(function () {
	          // insert ellipsis at prevEnd
	          var afterTextNode = textNode.splitText(splitPoint);
	          afterTextNode.remove();
	          var afterSpan = document.createElement("span");
	          afterSpan.className = "or-ellipsis-after";
	          afterSpan.appendChild(afterTextNode);
	          textNode.parentNode.appendChild(afterSpan);
	          var ellipsisEl = document.createElement("span");
	          ellipsisEl.className = "or-ellipsis";
	          ellipsisEl.innerHTML = "&hellip;";
	          textNode.parentNode.insertBefore(ellipsisEl, afterSpan);
	        });
	        return true;
	      }

	      return false; // console.log(range.toString(), rect.top, parent.getBoundingClientRect().top + parent.getBoundingClientRect().height);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral([""])));
	    }
	  }]);

	  return EllipsisText;
	}(BaseElement);

	__decorate$6([property$1({
	  type: String
	})], EllipsisText.prototype, "text", void 0);

	__decorate$6([property$1({
	  attribute: false
	})], EllipsisText.prototype, "getReferenceEl", void 0);

	__decorate$6([property$1({
	  type: Number
	})], EllipsisText.prototype, "ellipsisWidth", void 0);

	EllipsisText = __decorate$6([customElement("or-ellipsis-text")], EllipsisText);

	function createParallaxObservers(windowHeight, scrollY, element, multiplier) {
	  var origin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
	  var croppingElement = arguments.length > 5 ? arguments[5] : undefined;
	  var windowOverlapMargin = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 200;
	  var originMultiplier = origin === "top" ? 0 : origin === "bottom" ? 1 : origin === "center" ? 0.5 : origin;
	  var elementTop = read(function () {
	    return offsetTopRecursive(croppingElement || element);
	  });
	  var elementHeight = read(function () {
	    return (croppingElement || element).offsetHeight;
	  });
	  var elementOrigin = calc(function () {
	    return elementHeight.value * originMultiplier;
	  }, elementHeight);
	  var windowOrigin = calc(function () {
	    return windowHeight.value * originMultiplier;
	  }, windowHeight);
	  var withinWindow = calc(function () {
	    var x1 = scrollY.value - windowOverlapMargin;
	    var x2 = scrollY.value + windowHeight.value + windowOverlapMargin; // TODO: Make scrollBottom value on window observers

	    var y1 = elementTop.value;
	    var y2 = elementTop.value + elementHeight.value;

	    if (x1 <= y2 && y1 <= x2) {
	      return true;
	    }

	    return false;
	  }, scrollY, windowHeight, elementTop, elementHeight); // Return offset value

	  return {
	    offset: calc(function () {
	      return Math.round((elementTop.value + elementOrigin.value - (scrollY.value + windowOrigin.value)) * multiplier * 1 // * 2 for 0.5 rounding
	      ) / 1;
	    }, elementTop, elementOrigin, scrollY, windowOrigin),
	    withinWindow: withinWindow
	  };
	}
	function applyParallax(windowHeight, scrollY, element, multiplier) {
	  var origin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
	  var includeOriginalTransform = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
	  var scale = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
	  var croppingElement = arguments.length > 7 ? arguments[7] : undefined;
	  var windowOverlapMargin = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 300;

	  var _createParallaxObserv = createParallaxObservers(windowHeight, scrollY, element, multiplier, origin, croppingElement, windowOverlapMargin),
	      withinWindow = _createParallaxObserv.withinWindow,
	      offset = _createParallaxObserv.offset;

	  var apply = function apply(originalTransform) {
	    //document.addEventListener("DOMContentLoaded", () => {
	    write(function (w, o) {
	      if (w) {
	        element.style.transform = "".concat(originalTransform, "scale(").concat(scale, ") translate3d(0, ").concat(o, "px, 0)");
	      }
	    }, withinWindow, offset);
	    write(function (w) {
	      return element.style["willChange"] = w ? "transform" : "";
	    }, withinWindow); //});
	  };

	  if (includeOriginalTransform) {
	    main_1.read(function () {
	      //console.log("computedStyle", getComputedStyle(element), getComputedStyle(element).transform);
	      var originalTransform = getComputedStyle(element).transform;
	      apply((originalTransform === "none" ? "" : originalTransform) + " ");
	    });
	  } else {
	    apply("");
	  }
	}

	function initializeParallax(parallaxEls) {
	  parallaxEls.forEach(function (el) {
	    var multiplier = parseFloat(el.getAttribute("data-parallax") || "0");
	    var scale = el.hasAttribute("data-parallax-scale") ? parseFloat(el.getAttribute("data-parallax-scale") || "0") : 1;

	    var origin = function () {
	      if (!el.hasAttribute("data-parallax-origin")) return undefined;
	      var result = el.getAttribute("data-parallax-origin") || "center";
	      var float = parseFloat(result);
	      if (isNaN(float)) return result;
	      return float;
	    }(); //console.log("ORIGIN IS", origin);


	    applyParallax(windowHeight, scrollY, el, multiplier, origin, false, scale);
	  });
	}

	var _templateObject$5, _templateObject2$5, _templateObject3$3, _templateObject4$2, _templateObject5;

	var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var ImageSource = /*#__PURE__*/function () {
	  function ImageSource(orImg) {
	    _classCallCheck(this, ImageSource);

	    this.imageId = orImg.hasAttribute("imageId") ? orImg.getAttribute("imageId") : undefined;
	    this.url = orImg.hasAttribute("src") ? orImg.getAttribute("src") : undefined;
	    this.alt = orImg.hasAttribute("alt") ? orImg.getAttribute("alt") : undefined;
	  } // TODO: Add srcset filters
	  // TODO: Add manual srcset options, so user can add their own sources


	  _createClass(ImageSource, [{
	    key: "isSingleImage",
	    get: function get() {
	      return this.url && !this.imageId;
	    }
	  }]);

	  return ImageSource;
	}();

	var SingleImageDefinition = /*#__PURE__*/_createClass(function SingleImageDefinition(src, alt) {
	  _classCallCheck(this, SingleImageDefinition);

	  this.src = src;
	  this.alt = alt;
	});

	var ImageSourceDefinition = /*#__PURE__*/_createClass(function ImageSourceDefinition(format, url, minWidth) {
	  _classCallCheck(this, ImageSourceDefinition);

	  this.format = format;
	  this.url = url;
	  this.minWidth = minWidth;
	});

	var MultiImageDefinition = /*#__PURE__*/_createClass(function MultiImageDefinition() {
	  _classCallCheck(this, MultiImageDefinition);

	  this.sources = [];
	});

	var ImgElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(ImgElement, _BaseElement);

	  var _super = _createSuper(ImgElement);

	  function ImgElement() {
	    var _this;

	    _classCallCheck(this, ImgElement);

	    _this = _super.apply(this, arguments);
	    _this.imageFullyLoaded = false;
	    _this.imageDefinition = null;
	    _this.imageElementInitialized = false;
	    _this.trackedSubscriptions = [];
	    _this.loopObservers = [];
	    _this._scrolledPast = false;

	    _this.add = function (o) {
	      _this.loopObservers.push(o);

	      return o;
	    };

	    _this.imgLoaded = function (e) {
	      var img = e.target;

	      if (img.complete) {
	        _this.imageFullyLoaded = true;
	      }
	    };

	    return _this;
	  }

	  _createClass(ImgElement, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this2 = this;

	      _get(_getPrototypeOf(ImgElement.prototype), "connectedCallback", this).call(this);

	      var add = this.add;
	      this.elementY = add(read(function () {
	        return offsetTopRecursive(_this2);
	      }));
	      this.scrolledPast = add(calc(function (y, s, h) {
	        if (s > y - h && s < y) {
	          _this2._scrolledPast = true;
	        }

	        return _this2._scrolledPast;
	      }, this.elementY, scrollY, windowHeight));
	      this.trackedSubscriptions.push(getTrackedProperty(this, "imageDefinition").subscribe(function () {
	        return _this2.requestUpdate();
	      }));
	      this.init();
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      return __awaiter$5(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return this.waitToStartDownload();

	              case 2:
	                _context.next = 4;
	                return this.getImageDefinition();

	              case 4:
	                this.imageDefinition = _context.sent;
	                _context.next = 7;
	                return this.waitUntilReadyToShow();

	              case 7:
	                this.setAttribute("show", "");
	                this.dispose(); // Not necessary to have any subscriptions once loaded and displayed

	              case 9:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "waitUntilScrolledPast",
	    value: function waitUntilScrolledPast() {
	      var _this3 = this;

	      return new Promise(function (resolve) {
	        if (_this3.scrolledPast.value == true) {
	          return resolve();
	        }

	        var wait = calc(function (s) {
	          if (s) {
	            resolve();
	            wait.dispose();
	          }
	        }, _this3.scrolledPast);

	        _this3.add(wait);
	      });
	    }
	  }, {
	    key: "waitToStartDownload",
	    value: function waitToStartDownload() {
	      var _this4 = this;

	      return new Promise(function (resolve) {
	        if (_this4.lazy != "late") {
	          return resolve();
	        }

	        _this4.waitUntilScrolledPast().then(function () {
	          return resolve();
	        });
	      });
	    }
	  }, {
	    key: "buildUrl",
	    value: function buildUrl(domain, path) {
	      if (!domain.startsWith("h")) domain = "https://" + domain;
	      domain = domain.replace(/\/$/, '');
	      path = path.replace(/^\//, '');
	      return domain + "/" + path;
	    }
	  }, {
	    key: "getImageDefinition",
	    value: function getImageDefinition() {
	      return __awaiter$5(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
	        var _this5 = this;

	        var source, url, apiBaseUrl, apiKey, imageId, data, alt, sources, include, _url, imageDef;

	        return regeneratorRuntime.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                source = new ImageSource(this);

	                if (!source.isSingleImage) {
	                  _context2.next = 4;
	                  break;
	                }

	                url = source.url; // const response = await fetch(url);
	                // const alt = response.headers.get("x-amz-meta-alt-text") || source.alt || "No alt text provided";

	                return _context2.abrupt("return", new SingleImageDefinition(url, source.alt || "No alt text provided"));

	              case 4:
	                // Assume API Id for now
	                apiBaseUrl = "https://app.govstatus.site";
	                apiKey = "f2a134185c87e762ebcdf0b4973a7ca5a1843a8c";
	                imageId = source.imageId;
	                _context2.next = 9;
	                return fetch("".concat(apiBaseUrl, "/api/cdnfile/").concat(apiKey, "/").concat(imageId)).then(function (r) {
	                  return r.json();
	                }).catch(function (err) {
	                  console.error(err);
	                });

	              case 9:
	                data = _context2.sent;
	                // console.log(data);
	                alt = data.AltText;
	                sources = [];

	                if (data.Versions) {
	                  include = this.include ? this.include.split(',') : [];
	                  sources = data.Versions.filter(function (v) {
	                    return include.length === 0 || include.some(function (term) {
	                      return v.Name.includes('-' + term);
	                    });
	                  }).map(function (v) {
	                    var minWidth = v.Name.includes("-lg") ? 1000 : v.Name.includes("-md") ? 500 : v.Name.includes("-sm") ? 250 : v.Name.includes("-th") ? 100 : 100;

	                    var url = _this5.buildUrl(data.Domain, v.Path);

	                    return new ImageSourceDefinition(v.MimeType, url, minWidth);
	                  });
	                } else {
	                  _url = this.buildUrl(data.Domain, data.Path);
	                  sources.push(new ImageSourceDefinition("image/jpeg", _url, 0));
	                }

	                sources.sort(function (a, b) {
	                  return a.format > b.format ? -1 : a.format < b.format ? 1 : 0;
	                });
	                imageDef = new MultiImageDefinition();
	                imageDef.alt = alt;
	                imageDef.sources = sources;
	                imageDef.fallbackUrl = this.buildUrl(data.Domain, data.Path);
	                return _context2.abrupt("return", imageDef);

	              case 19:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	    }
	  }, {
	    key: "waitUntilReadyToShow",
	    value: function waitUntilReadyToShow() {
	      var _this6 = this;

	      return new Promise(function (resolve) {
	        if (_this6.fade != "scroll") {
	          _this6.waitUntilImageLoaded().then(function () {
	            return resolve();
	          });
	        } else {
	          Promise.all([_this6.waitUntilScrolledPast(), _this6.waitUntilImageLoaded()]).then(function () {
	            return resolve();
	          });
	        }
	      });
	    }
	  }, {
	    key: "waitUntilImageLoaded",
	    value: function waitUntilImageLoaded() {
	      var _this7 = this;

	      return new Promise(function (resolve) {
	        _this7.trackedSubscriptions.push(getTrackedProperty(_this7, "imageFullyLoaded").subscribe(function () {
	          if (_this7.imageFullyLoaded) resolve();
	        }));
	      });
	    }
	  }, {
	    key: "updated",
	    value: function updated(props) {
	      var _this8 = this;

	      _get(_getPrototypeOf(ImgElement.prototype), "updated", this).call(this, props); // or-img initializes parallax on img element when img element ready


	      if (this.imageElement && !this.imageElementInitialized) {
	        // Pass through data- attributes
	        Array.from(this.attributes).forEach(function (attr) {
	          if (attr.name.startsWith("data-")) {
	            _this8.imageElement.setAttribute(attr.name, attr.value);

	            _this8.removeAttribute(attr.name);
	          }
	        });

	        if (this.imageElement.hasAttribute("data-parallax")) {
	          initializeParallax([this.imageElement]);
	        }

	        this.imageElementInitialized = true;
	      }
	    }
	  }, {
	    key: "dispose",
	    value: function dispose() {
	      // Really important to dispose resources here!!
	      this.trackedSubscriptions.forEach(function (s) {
	        return s.unsubscribe();
	      }); //this.loopObservers.forEach(l => l.dispose());
	    }
	  }, {
	    key: "disconnectedCallback",
	    value: function disconnectedCallback() {
	      _get(_getPrototypeOf(ImgElement.prototype), "disconnectedCallback", this).call(this); // console.log('is disconnecting/disposing')
	      // Really important to dispose resources here!!


	      this.dispose();
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return html(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral(["\n            ", "\n        "])), this.imageDefinition ? html(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteral(["\n                ", "\n\n                ", "\n            "])), this.imageDefinition instanceof SingleImageDefinition ? html(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteral(["\n                    <img src=", " alt=", " @load=", "/>\n                "])), this.imageDefinition.src, this.imageDefinition.alt, this.imgLoaded) : null, this.imageDefinition instanceof MultiImageDefinition ? html(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteral(["\n                    <picture>\n                        ", "\n                        <img src=", "\n                            alt=", "\n                            @load=", "/>\n                    </picture>\n                "])), this.imageDefinition.sources.map(function (source) {
	        return html(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["\n                            <source srcset=", " media=", " type=", " />\n                        "])), source.url, "(min-width: ".concat(source.minWidth, "px)"), source.format);
	      }), this.imageDefinition.fallbackUrl, this.imageDefinition.alt, this.imgLoaded) : null) : null);
	    }
	  }]);

	  return ImgElement;
	}(BaseElement);

	__decorate$5([property$1({
	  type: String
	})], ImgElement.prototype, "lazy", void 0);

	__decorate$5([property$1({
	  type: String
	})], ImgElement.prototype, "fade", void 0);

	__decorate$5([property$1({
	  type: String
	})], ImgElement.prototype, "include", void 0);

	__decorate$5([tracked], ImgElement.prototype, "imageFullyLoaded", void 0);

	__decorate$5([tracked], ImgElement.prototype, "imageDefinition", void 0);

	__decorate$5([query('img')], ImgElement.prototype, "imageElement", void 0);

	ImgElement = __decorate$5([trackable, customElement("or-img")], ImgElement);

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while (fromRight ? index-- : ++index < length) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }

	  return -1;
	}

	var _baseFindIndex = baseFindIndex;

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	var _baseIsNaN = baseIsNaN;

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }

	  return -1;
	}

	var _strictIndexOf = strictIndexOf;

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */

	function baseIndexOf(array, value, fromIndex) {
	  return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
	}

	var _baseIndexOf = baseIndexOf;

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */

	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && _baseIndexOf(array, value, 0) > -1;
	}

	var _arrayIncludes = arrayIncludes;

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }

	  return false;
	}

	var _arrayIncludesWith = arrayIncludesWith;

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {// No operation performed.
	}

	var noop_1 = noop;

	/** Used as references for various `Number` constants. */

	var INFINITY = 1 / 0;
	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */

	var createSet = !(_Set && 1 / _setToArray(new _Set([, -0]))[1] == INFINITY) ? noop_1 : function (values) {
	  return new _Set(values);
	};
	var _createSet = createSet;

	/** Used as the size to enable large array optimizations. */

	var LARGE_ARRAY_SIZE = 200;
	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */

	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = _arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = _arrayIncludesWith;
	  } else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : _createSet(array);

	    if (set) {
	      return _setToArray(set);
	    }

	    isCommon = false;
	    includes = _cacheHas;
	    seen = new _SetCache();
	  } else {
	    seen = iteratee ? [] : result;
	  }

	  outer: while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;
	    value = comparator || value !== 0 ? value : 0;

	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;

	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }

	      if (iteratee) {
	        seen.push(computed);
	      }

	      result.push(value);
	    } else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }

	      result.push(value);
	    }
	  }

	  return result;
	}

	var _baseUniq = baseUniq;

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each element
	 * is kept. The order of result values is determined by the order they occur
	 * in the array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */

	function uniq(array) {
	  return array && array.length ? _baseUniq(array) : [];
	}

	var uniq_1 = uniq;

	var _templateObject$4, _templateObject2$4, _templateObject3$2, _templateObject4$1;

	var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var TopLink = /*#__PURE__*/_createClass(function TopLink(listItem) {
	  _classCallCheck(this, TopLink);

	  this.title = listItem.Title;
	  this.active = listItem.Active;
	  this.description = listItem.Description;
	  this.url = listItem.URL;
	  this.category = listItem.Category;
	});

	var TopLinks = /*#__PURE__*/function (_BaseElement) {
	  _inherits(TopLinks, _BaseElement);

	  var _super = _createSuper(TopLinks);

	  function TopLinks() {
	    var _this;

	    _classCallCheck(this, TopLinks);

	    _this = _super.call(this);
	    _this.links = [];

	    _this.init();

	    return _this;
	  }

	  _createClass(TopLinks, [{
	    key: "linkCategories",
	    get: function get() {
	      return uniq_1(this.links.map(function (link) {
	        return link.category;
	      }));
	    }
	  }, {
	    key: "getLinksForCategory",
	    value: function getLinksForCategory(category) {
	      return this.links.filter(function (link) {
	        return link.category === category;
	      });
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      return __awaiter$4(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, topLinksColumns, listItems;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ListItemClient();
	                topLinksColumns = ["Title", "Active", "Description", "Category", "URL"];
	                _context.next = 4;
	                return client.getListItems("Top Links", topLinksColumns);

	              case 4:
	                listItems = _context.sent;
	                this.links = listItems.map(function (item) {
	                  return new TopLink(item);
	                }).filter(function (link) {
	                  return link.active;
	                });

	              case 6:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this2 = this;

	      return html(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral(["\n            ", "\n        "])), this.links.length > 0 ? html(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteral([" \n                <div class=\"or-grid-2 or-grid-4-lg\">\n                    ", "\n                </div>\n            "])), this.linkCategories.map(function (category) {
	        return html(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral(["\n                        <div class=\"or-top-links-column\">\n                            <h3 class=\"h4\">", "</h3>\n                            <ul class=\"list-unstyled or-link-reset\">\n                                ", " \n                            </ul>\n                        </div>\n                    "])), category, _this2.getLinksForCategory(category).map(function (link) {
	          return html(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral(["\n                                    <li><a href=", " title=", " >", "</a></li>\n                                "])), link.url, link.description, link.title);
	        }));
	      })) : null);
	    }
	  }]);

	  return TopLinks;
	}(BaseElement);

	__decorate$4([property$1({
	  type: Array
	})], TopLinks.prototype, "links", void 0);

	TopLinks = __decorate$4([customElement("or-top-links")], TopLinks);

	var _templateObject$3, _templateObject2$3, _templateObject3$1, _templateObject4;

	var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var FeaturedItem = /*#__PURE__*/_createClass(function FeaturedItem(listItem) {
	  _classCallCheck(this, FeaturedItem);

	  this.title = listItem.Title;
	  this.order = listItem.Order0;
	  this.description = listItem.Description;
	  this.imageUrl = listItem.Image_x0020_URL;
	  this.imageAlt = listItem.Image_x0020_Alt_x0020_Text;
	  this.active = listItem.Active;
	  this.linkUrl = listItem.Call_x0020_to_x0020_Action_x0020.Url;
	  this.linkText = listItem.Call_x0020_to_x0020_Action_x0020.Description;
	  this.linkColor = listItem.Call_x0020_to_x0020_Action_x00200;
	  this.logoUrl = listItem.Logo_x0020_URL;
	  this.logoAlt = listItem.Logo_x0020_Alt_x0020_Text; // console.log(this, listItem);
	});

	var FeaturedElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(FeaturedElement, _BaseElement);

	  var _super = _createSuper(FeaturedElement);

	  function FeaturedElement() {
	    var _this;

	    _classCallCheck(this, FeaturedElement);

	    _this = _super.call(this);
	    _this.items = [];
	    _this.currentItemIndex = 0;

	    _this.next = function (e) {
	      if (_this.currentItemIndex >= _this.items.length - 1) {
	        _this.currentItemIndex = 0;
	      } else {
	        _this.currentItemIndex++;
	      }

	      e.preventDefault();
	    };

	    _this.previous = function (e) {
	      if (_this.currentItemIndex === 0) {
	        _this.currentItemIndex = _this.items.length - 1;
	      } else {
	        _this.currentItemIndex--;
	      }

	      e.preventDefault();
	    };

	    _this.init();

	    return _this;
	  }

	  _createClass(FeaturedElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$3(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, items;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ListItemClient();
	                _context.next = 3;
	                return client.getListItems("Featured Content").then(function (items) {
	                  return items.map(function (i) {
	                    return new FeaturedItem(i);
	                  });
	                });

	              case 3:
	                items = _context.sent;
	                this.items = sortBy_1(items.filter(function (item) {
	                  return item.active;
	                }), function (i) {
	                  return i.order;
	                }); // .reverse();

	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "firstUpdated",
	    value: function firstUpdated(props) {
	      var _this2 = this;

	      _get(_getPrototypeOf(FeaturedElement.prototype), "firstUpdated", this).call(this, props);

	      var activeItemHeight = read(function () {
	        var items = Array.from(document.querySelectorAll('.or-featured-item'));

	        if (items.length > 0) {
	          return items[_this2.currentItemIndex].clientHeight;
	        } else {
	          return 0;
	        }
	      });
	      write(function (h) {
	        return _this2.style.height = h + "px";
	      }, activeItemHeight);
	    }
	  }, {
	    key: "setIndex",
	    value: function setIndex(i) {
	      this.currentItemIndex = i;
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this3 = this;

	      return html(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["\n            <div role=\"region\" aria-roledescription=\"carousel\" aria-label=\"Featured Carousel\">\n <button class=\"or-featured-prev\" @click=", ">\n                <span class=\"fa fa-chevron-left\"></span>\n                <span class=\"sr-only\">Previous slide</span>\n            </button>\n\n            ", "\n\n            <button class=\"or-featured-next\" @click=", ">\n                <span class=\"fa fa-chevron-right\"></span>\n                <span class=\"sr-only\">Next slide</span>\n            </button>\n\n            <div class=\"or-featured-indicators\" role=\"group\" aria-label=\"Slide controls\">\n                ", "\n            </div>\n        "])), this.previous, this.items.map(function (item, i) {
	        return html(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral(["\n                <div\n                    class=", "\n                    aria-hidden=", " role=\"group\" aria-roledescription=\"slide\" aria-label=\"Slide ", " of ", "\" >\n\n                    <div class=\"or-featured-item-img\">\n                        <or-img src=", " alt=", " lazy=\"late\" fade=\"scroll\"></or-img>\n                    </div>\n\n                    <div class=\"or-featured-item-content\">\n                        ", " \n                        <h3><a href=", " tabindex=", " >", "</a></h3>\n                        <p>", "</p>\n                        <a style=", "\n                            class=\"btn btn-primary\"\n                            href=", " tabindex=", " >\n                            ", "\n                        </a>\n                    </div>\n                </div>\n            "])), classMap({
	          "or-unreverse": true,
	          "or-featured-item": true,
	          "or-active": i === _this3.currentItemIndex
	        }), i !== _this3.currentItemIndex, i + 1, _this3.items.length, item.imageUrl, item.imageAlt, item.logoUrl ? html(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral(["\n                            <or-img class=\"or-featured-item-logo\" src=", " alt=", " lazy=\"late\" fade=\"scroll\"></or-img>\n                        "])), item.logoUrl, item.logoAlt) : null, item.linkUrl, i !== _this3.currentItemIndex ? "-1" : "0", item.title, item.description, ifDefined(item.linkColor ? "background-color: ".concat(item.linkColor, "!important;") : undefined), item.linkUrl, i !== _this3.currentItemIndex ? "-1" : "0", item.linkText);
	      }), this.next, this.items.map(function (item, i) {
	        return html(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n                    <a href=\"#_\"\n                        class=", "\n                        @click=", "><span class=\"sr-only\">", "</span></a></div>\n                 </div>\n"])), classMap({
	          'or-active': i === _this3.currentItemIndex
	        }), function () {
	          return _this3.setIndex(i);
	        }, i === _this3.currentItemIndex ? 'You are currently on Slide ' + (i + 1) : "Jump to slide " + (i + 1));
	      }));
	    }
	  }]);

	  return FeaturedElement;
	}(BaseElement);

	__decorate$3([property$1({
	  type: Array
	})], FeaturedElement.prototype, "items", void 0);

	__decorate$3([property$1({
	  type: Number
	})], FeaturedElement.prototype, "currentItemIndex", void 0);

	FeaturedElement = __decorate$3([customElement('or-featured')], FeaturedElement);

	var _templateObject$2, _templateObject2$2;

	var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var Superlative = /*#__PURE__*/_createClass(function Superlative(listItem) {
	  _classCallCheck(this, Superlative);

	  this.pretext = listItem.Title;
	  this.text = listItem.Fact;
	  this.sourceUrl = listItem.Source.Url;
	  this.sourceName = listItem.Source.Description;
	  this.active = listItem.Active;
	  this.order = listItem.Order;
	  this.buttonText = listItem.Call_x0020_to_x0020_Action;
	  this.buttonUrl = listItem.Call_x0020_to_x0020_Action_x0020;
	  this.category = listItem.Category; // console.log(listItem.Category);
	});

	var SuperlativesElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(SuperlativesElement, _BaseElement);

	  var _super = _createSuper(SuperlativesElement);

	  function SuperlativesElement() {
	    var _this;

	    _classCallCheck(this, SuperlativesElement);

	    _this = _super.call(this);
	    _this.items = [];
	    _this.backgroundImageId = "";
	    _this.currentItem = Math.floor(Math.random() * 8);

	    _this.init();

	    return _this;
	  }

	  _createClass(SuperlativesElement, [{
	    key: "prevItem",
	    get: function get() {
	      return this.currentItem === 0 ? this.items.length - 1 : this.currentItem - 1;
	    }
	  }, {
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      var _this2 = this;

	      _get(_getPrototypeOf(SuperlativesElement.prototype), "connectedCallback", this).call(this);

	      subscribeAll(this, function () {
	        return _this2.requestUpdate();
	      });
	    }
	  }, {
	    key: "next",
	    value: function next(e) {
	      this.currentItem = this.currentItem >= this.items.length - 1 ? 0 : this.currentItem + 1;
	      e.preventDefault();
	    }
	  }, {
	    key: "prev",
	    value: function prev(e) {
	      this.currentItem = this.currentItem <= 0 ? this.items.length - 1 : this.currentItem - 1;
	      e.preventDefault();
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      return __awaiter$2(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, items;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ListItemClient();
	                _context.next = 3;
	                return client.getListItems("Superlatives");

	              case 3:
	                items = _context.sent;
	                this.items = items.map(function (i) {
	                  return new Superlative(i);
	                });

	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this3 = this;

	      return html(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral(["\n            <div role=\"region\" aria-roledescription=\"carousel\" aria-label=\"Superlatives Carousel\"><button class=\"or-superlatives-prev\" @click=", ">\n                <span class=\"fal fa-chevron-left\"></span>\n                <span class=\"sr-only\">Previous slide</span>\n            </button>\n\n            ", "\n\n            <button class=\"or-superlatives-next\" @click=", ">\n                <span class=\"fal fa-chevron-right\"></span>\n                <span class=\"sr-only\">Next slide</span>\n            </button>\n        "])), this.prev, this.items.map(function (item, i) {
	        return html(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral(["\n                <div class=", " aria-hidden=", " role=\"group\" aria-roledescription=\"slide\" aria-label=\"Slide ", " of ", "\" >\n                    <!-- <p class=\"h6\">", "</p> -->\n                    <p class=\"lead\">", "</p>\n                    <p>Source: <a href=", " tabindex=", " >", "</a></p>\n                    <a class=\"btn btn-primary\" href=", " tabindex=", " >", "</a>\n                </div></div>\n            "])), classMap({
	          "text-center": true,
	          "or-superlative": true,
	          "or-previous": _this3.prevItem === i,
	          "or-active": _this3.currentItem === i
	        }), _this3.currentItem !== i, i + 1, _this3.items.length, item.pretext, item.text, item.sourceUrl, _this3.currentItem !== i ? -1 : 0, item.sourceName, item.buttonUrl, _this3.currentItem !== i ? -1 : 0, item.buttonText);
	      }), this.next);
	    }
	  }]);

	  return SuperlativesElement;
	}(BaseElement);

	__decorate$2([property$1({
	  type: String
	})], SuperlativesElement.prototype, "category", void 0);

	__decorate$2([property$1({
	  type: Array
	})], SuperlativesElement.prototype, "items", void 0);

	__decorate$2([property$1({
	  type: String
	})], SuperlativesElement.prototype, "backgroundImageId", void 0);

	__decorate$2([tracked], SuperlativesElement.prototype, "currentItem", void 0);

	__decorate$2([computed], SuperlativesElement.prototype, "prevItem", null);

	SuperlativesElement = __decorate$2([trackable, customElement("or-superlatives")], SuperlativesElement);

	var _templateObject$1, _templateObject2$1;

	var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var InstagramPhoto = /*#__PURE__*/_createClass(function InstagramPhoto(listItem) {
	  _classCallCheck(this, InstagramPhoto);

	  this.active = listItem.Active;
	  this.order = listItem.Order0;
	  this.title = listItem.Title;
	  this.photoUrl = listItem.File.ServerRelativeUrl;
	  this.altText = listItem.Alt_x0020_Text;
	  this.profileName = listItem.Profile.Description;
	  this.profileUrl = listItem.Profile.Url;
	  this.instagramUrl = listItem.Source.Url;
	});

	var InstagramGridElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(InstagramGridElement, _BaseElement);

	  var _super = _createSuper(InstagramGridElement);

	  function InstagramGridElement() {
	    var _this;

	    _classCallCheck(this, InstagramGridElement);

	    _this = _super.call(this);
	    _this.photos = [];
	    _this.recentHover = -1;
	    _this.prevHover = -1;

	    _this.mouseOverItem = function (e, i) {
	      _this.prevHover = _this.recentHover;
	      _this.recentHover = i;
	    };

	    _this.init();

	    return _this;
	  }

	  _createClass(InstagramGridElement, [{
	    key: "init",
	    value: function init() {
	      return __awaiter$1(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, items;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ListItemClient();
	                _context.next = 3;
	                return client.getListItems("myOregon Feed", undefined, ["File"]);

	              case 3:
	                items = _context.sent;
	                //console.log("insta photos", items);
	                this.photos = sortBy_1(items.map(function (i) {
	                  return new InstagramPhoto(i);
	                }).filter(function (item) {
	                  return item.active;
	                }), function (i) {
	                  return i.order;
	                });

	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this2 = this;

	      return html(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral(["\n            <div class=\"or-instagram-item or-instagram-grid-header or-reverse\">\n                <h2 class=\"h3\">#MyOregon</h2>\n                <p>Add #MyOregon to your photos on Instagram for a chance to see them featured here!</p>\n            </div>\n            ", "\n        "])), this.photos.map(function (photo, i) {
	        return html(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral(["\n                <a\n                    class=\"or-instagram-item\"\n                    href=", "\n                    @mouseover=", "\n                    style=", ">\n                    <div class=\"or-instagram-item-img\">\n                        <or-img class=\"or-fit-cover\" src=", " alt=", " lazy=\"late\" fade=\"scroll\"></or-img>\n                    </div>\n                    \n                    <div class=\"or-instagram-item-content or-reverse\">\n                        <h3 class=\"h5\">", "</h3>\n                        <p>By ", "</p>\n                    </div>\n                </a>\n            "])), photo.instagramUrl, function (e) {
	          return _this2.mouseOverItem(e, i);
	        }, "z-index: " + (i === _this2.recentHover ? 2 : i === _this2.prevHover ? 1 : 0), photo.photoUrl, photo.altText, photo.title, photo.profileName);
	      }));
	    }
	  }]);

	  return InstagramGridElement;
	}(BaseElement);

	__decorate$1([property$1({
	  type: Array
	})], InstagramGridElement.prototype, "photos", void 0);

	__decorate$1([property$1({
	  type: Number
	})], InstagramGridElement.prototype, "recentHover", void 0);

	__decorate$1([property$1({
	  type: Number
	})], InstagramGridElement.prototype, "prevHover", void 0);

	InstagramGridElement = __decorate$1([customElement("or-instagram-grid")], InstagramGridElement);

	var ArticleSocrataClient = /*#__PURE__*/function () {
	  function ArticleSocrataClient() {
	    _classCallCheck(this, ArticleSocrataClient);
	  }

	  _createClass(ArticleSocrataClient, [{
	    key: "getArticleData",
	    value: // zeroPad(num: number) {
	    // 	if (num < 10) {
	    // 		return "0" + num;
	    // 	} else {
	    // 		return num.toString();
	    // 	}
	    // }
	    // formatDate(date: Date) {
	    // 	const year = date.getFullYear();
	    // 	const dayOfMonth = this.zeroPad(date.getDate());
	    // 	const month = this.zeroPad(date.getMonth() + 1);
	    // }
	    function getArticleData(limit, agency, category, excludeCategory) {
	      // var params = {
	      //   "$$exclude_system_fields": false,
	      //   "$limit": limit,
	      //   "$order": "publish_date DESC"
	      // };

		  var params = {};
	      if (agency) {
	        if (Array.isArray(agency) && agency.length > 0) {
	          let agenciesEncoded = agency.map(a => encodeURIComponent(a));
	          params.org = agenciesEncoded.join(',');
	        } else {
	          params.org = encodeURIComponent(agency);
	        }
	      }

	      // var now = new Date().toISOString().replace("Z", "");
	      // params.$where = "publish_date < '".concat(now, "'");

	      if (category) {
	        // category = encodeURIComponent(category);
	        // var categoryString = " AND (category_tag1 = \"".concat(category, "\" OR category_tag2 = \"").concat(category, "\" OR category_tag3 = \"").concat(category, "\" OR category_tag4 = \"").concat(category, "\" OR category_tag5 = \"").concat(category, "\")");
	        // params.$where += categoryString;
	        if (Array.isArray(category) && category.length > 0) {
	          let categoryEncoded = category.map(a => encodeURIComponent(a));
              params.cat = categoryEncoded.join(',');
            } else {
              params.cat = encodeURIComponent(category);
            }
	      }

	      if (excludeCategory) {
	        // var exclude = encodeURIComponent(excludeCategory);
	        // var str = " AND (category_tag1 != \"".concat(exclude, "\" AND category_tag2 != \"").concat(exclude, "\" AND category_tag3 != \"").concat(exclude, "\" AND category_tag4 != \"").concat(exclude, "\" AND category_tag5 != \"").concat(exclude, "\")");
	        // params.$where += str;
	        if (Array.isArray(excludeCategory) && excludeCategory.length > 0) {
	          let excludeCategoryEncoded = excludeCategory.map(a => encodeURIComponent(a));
              params.cat = '-' + excludeCategoryEncoded.join(',');
            } else {
              params.cat = '-' + encodeURIComponent(excludeCategory);
            }
	      }

	      if (limit) {
            params.maxPosts = limit;
          }

	      var url = Object.keys(params).reduce(function (url, key, i) {
	        if (i) url = url + "&";
	        return url + key + "=" + params[key];
	      }, "https://apps.oregon.gov/oregon-newsroom/OR/Posts/Search?json&"); //console.log(url);

	      return fetch(url).then(function (response) {
	        return response.json();
	      }).catch(function (error) {
	        console.error(error);
	        throw error;
	      });
	    }
	  }]);

	  return ArticleSocrataClient;
	}();

	var helperDiv = document.createElement('div');
	function htmlEncode(html) {
	  return html.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	}
	function htmlDecode(html) {
	  html = removeScriptTags(html);
	  html = removeHtmlTags(html);
	  helperDiv.innerHTML = html;
	  html = helperDiv.textContent || '';
	  helperDiv.textContent = '';
	  return html;
	}
	function removeScriptTags(html) {
	  return html.replace(/<script[^>]*>([\S\s]*?)<\/script>/gmi, '');
	}
	function removeHtmlTags(html) {
	  return html.replace(/<\/?\w(?:[^"'>]|"[^"]*"|'[^']*')*>/gmi, '');
	}
	function htmlTextContent(html) {
	  return htmlDecode(html);
	}

	var Article = /*#__PURE__*/function () {
	  function Article() {
	    _classCallCheck(this, Article);
	  }

	  _createClass(Article, [{
	    key: "textContent",
	    get: function get() {
	      if (this._textContent == null) {
	        this._textContent = htmlTextContent(this.contentSections.join(' '));
	      }

	      return this._textContent;
	    }
	  }, {
	    key: "excerpt",
	    get: function get() {
	      if (this._excerpt == null) this._excerpt = this.textContent.substr(0, 150) + '&hellip;';
	      return this._excerpt;
	    }
	  }, {
	    key: "url",
	    get: function get() {
	      if (this._url == null) this._url = 'https://apps.oregon.gov/oregon-newsroom/OR/' + this.agencyAlias + '/Posts/Post/' + this.postSlug;
	      return this._url;
	    }
	  }], [{
	    key: "replaceLinks",
	    value: function replaceLinks(content) {
	      // Mirrors the code from OID.Common.Newsroom that does the same thing on the server
	      var result;
	      var urlRegex = /(^|[\n ])((www|ftp)\.[^ ,"\s<]*)/gi;
	      result = content.replace(urlRegex, function (match, group0, group1, group2) {
	        return ' <a href="http://' + group2 + '" target="_blank">' + (group2.length > 50 ? group2.substr(0, 50) + '...' : group2) + '</a>';
	      });
	      var httpUrlRegex = /(^|[\n ])((http:\/\/www\.|http:\/\/|https:\/\/)[^ ,"\s<]*)/gi;
	      result = result.replace(httpUrlRegex, function (match, group0, group1, group2) {
	        return ' <a href="' + group2 + '" target="_blank">' + (group2.length > 50 ? group2.substr(0, 50) + '...' : group2) + '</a>';
	      });
	      var emailRegex = /\b([a-zA-Z_0-9.-]+\@[a-zA-Z_0-9.-]+\.\w+)\b/gi;
	      result = result.replace(emailRegex, '<a href="mailto:$1">$1</a>');
	      return result;
	    }
	  }, {
	    key: "replaceMarkdownLinks",
	    value: function replaceMarkdownLinks(content) {
	      // Mirrors the code from OID.Common.Newsroom that does the same thing on the server
	      // It's a markdown-style system of inserting links into the content without html
	      var result = content;
	      var urlRegex = /\[([^\]]+)\]\(([^)]+)\)/gi;
	      var httpRegex = /^https?/i;
	      var match;

	      while ((match = urlRegex.exec(result)) !== null) {
	        //console.log(match);
	        var linkText = match[1];
	        var urlText = match[2];
	        if (urlText.match(httpRegex) != null) urlText = "http://" + urlText;
	        if (linkText.length > 50) linkText = linkText.substr(0, 50) + '...';
	        result = result.replace(match[0], ' <a href="' + urlText + '" target="_blank">' + linkText + '</a>');
	      }

	      return result;
	    }
	  }, {
	    key: "parseContentString",
	    value: function parseContentString(content) {
	      if (!content) return '';
	      var result = htmlEncode(content).replace('\n', '<br />\n');
	      result = this.replaceLinks(result);
	      result = this.replaceMarkdownLinks(result);
	      result = result.replace('&amp;', '&');
	      result = result.replace('&rsquo;', "'");
	      return result;
	    }
	  }, {
	    key: "createFromArticleData",
	    value: function createFromArticleData(data) {
	      var article = new Article();
	      article.id = data[":id"];
	      article.publishDate = new Date(data.publish_date);
	      article.publishYear = parseInt(data.publish_year);
	      article.city = data.city.trim();
	      article.state = data.state;
	      article.categoryTags = data.category_tags ? data.category_tags.split(',') : [];
	      article.contentSections = [];
	      article.postSlug = data.postSlug;
          article.agencyAlias = data.agencyAlias;

	      for (var _i = 0, _arr = [data.content, data.content2, data.content3, data.content4, data.content5]; _i < _arr.length; _i++) {
	        var content = _arr[_i];

	        if (content) {
	          article.contentSections.push(this.parseContentString(content));
	        }
	      }

	      article.dateEntered = new Date(data.date_entered);
	      article.enteredBy = data.entered_by;
	      article.dateLastModified = new Date(data.date_last_modified);
	      article.lastModifiedBy = data.last_modified_by; // Parse attachments

		  if (data.footer_content) {
		  	article.attachments = [];
	        var decodedXmlString = htmlDecode(data.footer_content);
	        var footerContentData = JSON.parse(decodedXmlString);
	        article.attachments.concat(footerContentData.Audios.map(function (data) {
	          return {
	            type: "audio",
	            url: data.Url,
	            filename: data.Filename
	          };
	        }), footerContentData.Photos.map(function (data) {
	          return {
	            type: 'photo',
	            url: data.Url,
	            filename: data.Filename,
	            thumbUrl: data.ThumbUrl
	          };
	        }), footerContentData.Videos.map(function (data) {
	          return {
	            type: 'video',
	            url: data.Url
	          };
	        }));
		  }
	      article.title = data.headline.trim();
	      article.subtitle = (data.subheadline || '').trim();
	      article.agency = data.agency;
	      article.contacts = [];

	      for (var _i2 = 0, _arr2 = [data.contact1, data.contact2, data.contact3, data.contact4, data.contact5]; _i2 < _arr2.length; _i2++) {
	        var contact = _arr2[_i2];

	        if (contact) {
	          var split = contact.split('|');
	          article.contacts.push({
	            name: (split[0] || '').trim(),
	            position: (split[1] || '').trim(),
	            agency: (split[3] || '').trim(),
	            email: (split[4] || '').trim(),
	            phone: (split[5] || '').trim()
	          });
	        }
	      }

	      return article;
	    }
	  }]);

	  return Article;
	}();

	var _templateObject, _templateObject2, _templateObject3;

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var c = arguments.length,
	      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	      d;
	  if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
	    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  }
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};

	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  function adopt(value) {
	    return value instanceof P ? value : new P(function (resolve) {
	      resolve(value);
	    });
	  }

	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function rejected(value) {
	      try {
	        step(generator["throw"](value));
	      } catch (e) {
	        reject(e);
	      }
	    }

	    function step(result) {
	      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	    }

	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};

	var NewsroomElement = /*#__PURE__*/function (_BaseElement) {
	  _inherits(NewsroomElement, _BaseElement);

	  var _super = _createSuper(NewsroomElement);

	  function NewsroomElement() {
	    var _this;

	    _classCallCheck(this, NewsroomElement);

	    _this = _super.apply(this, arguments);
	    _this.articles = [];
	    _this.firstUpdate = false;
	    return _this;
	  }

	  _createClass(NewsroomElement, [{
	    key: "connectedCallback",
	    value: function connectedCallback() {
	      _get(_getPrototypeOf(NewsroomElement.prototype), "connectedCallback", this).call(this);

	      this.init();
	    }
	  }, {
	    key: "init",
	    value: function init() {
	      var _a;

	      return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
	        var client, data;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = new ArticleSocrataClient();
	                _context.next = 3;
	                return client.getArticleData(3, undefined, (_a = this.category) !== null && _a !== void 0 ? _a : undefined, "Media Advisory / Event");

	              case 3:
	                data = _context.sent;
	                //console.log(data);
	                this.articles = data.map(function (d) {
	                  return Article.createFromArticleData(d);
	                });

	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	  }, {
	    key: "updated",
	    value: function updated(props) {
	      _get(_getPrototypeOf(NewsroomElement.prototype), "updated", this).call(this, props); // if (!this.firstUpdate && this.articles.length > 0) {
	      //     this.firstUpdate = true;
	      //     const headings = Array.from(this.headers);
	      //     console.log('running first update');
	      //     headings.forEach(h => lineClamp(h.firstElementChild as HTMLElement, h));
	      // }

	    }
	  }, {
	    key: "renderDate",
	    value: function renderDate(date) {
	      //console.log(date);
	      var ye = new Intl.DateTimeFormat('en', {
	        month: 'long',
	        day: 'numeric',
	        year: 'numeric'
	      }).format(date);
	      return ye;
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this2 = this;

	      return html(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n            ", "\n        "])), this.articles.length > 0 ? html(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n                <div class=\"row\">\n                <!-- <or-slider class=\"or-slider-3\"> -->\n                    ", "\n                <!-- </or-slider> -->\n                </div>\n            "])), this.articles.map(function (article) {
	        return html(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n                        <!-- <div class=\"or-slide\"> -->\n                            <div class=\"col-md-4\">\n                                <div class=\"or-news-article\">\n                                    \n                                    <div class=\"or-news-article-content\">\n                                        <p class=\"or-news-article-date\">", "</p>\n                                        <h3 title=", ">\n                                            <a href=", ">\n                                                <or-ellipsis-text\n                                                    .text=", "\n                                                    .ellipsisWidth=", "\n                                                    .getReferenceEl=", ">\n                                                </or-ellipsis-text>\n                                            </a>\n                                        </h3>\n                                        <p class=\"or-news-article-excerpt\">\n                                            <or-ellipsis-text\n                                                .text=", "\n                                                .ellipsisWidth=", "\n                                                .getReferenceEl=", ">\n                                            </or-ellipsis-text>\n                                        </p>\n                                    </div>\n                                    <a class=\"btn btn-primary\" href=", ">Read more<span class=\"sr-only\"> about ", "</span></a>\n                                </div>\n                            </div>\n                        <!-- </div> -->\n                    "])), _this2.renderDate(article.publishDate), article.title, article.url, article.title, 28, function (self) {
	          return self.parentElement.parentElement;
	        }, article.textContent.replace(/\n/g, ' '), 16, function (self) {
	          return self.parentElement;
	        }, article.url, article.title);
	      })) : null);
	    }
	  }]);

	  return NewsroomElement;
	}(BaseElement);

	__decorate([property$1({
	  type: Array
	})], NewsroomElement.prototype, "articles", void 0);

	__decorate([property$1({
	  type: String
	})], NewsroomElement.prototype, "category", void 0);

	__decorate([queryAll("h3")], NewsroomElement.prototype, "headers", void 0);

	NewsroomElement = __decorate([customElement("or-newsroom")], NewsroomElement);

	function initializeObjectFit(element) {
	  var fitEls = Array.from(element.querySelectorAll(".or-fit-cover"));
	  fitEls.forEach(function (el) {
	    el.parentElement;

	    if (el instanceof HTMLImageElement) {
	      var naturalWidth = read(function () {
	        return el.naturalWidth;
	      });
	      var naturalHeight = read(function () {
	        return el.naturalHeight;
	      });
	      var parentWidth = read(function () {
	        var _a;

	        return (_a = el.parentElement) === null || _a === void 0 ? void 0 : _a.clientWidth;
	      });
	      var parentHeight = read(function () {
	        var _a;

	        return (_a = el.parentElement) === null || _a === void 0 ? void 0 : _a.clientHeight;
	      });
	      var aspectRatio = calc(function (w, h) {
	        return w / h;
	      }, naturalWidth, naturalHeight);
	      var parentAspectRatio = calc(function (w, h) {
	        return w / h;
	      }, parentWidth, parentHeight);
	      var wide = calc(function (a, p) {
	        return a > p;
	      }, aspectRatio, parentAspectRatio);
	      write(function (w) {
	        return w ? el.classList.add("or-fit-wide") : el.classList.remove("or-fit-wide");
	      }, wide);
	    }
	  });
	}

	var GoogleAnalyticsManager = /*#__PURE__*/function () {
	  // Singleton pattern
	  function GoogleAnalyticsManager() {
	    var _this = this;

	    _classCallCheck(this, GoogleAnalyticsManager);

	    // Constants
	    this.defaultStagingAccountId = 'UA-70385343-1';
	    this.defaultProductionAccountId = 'UA-3724630-2';
	    this.initialized = false; // For supporting multiple Google Analytics accounts

	    this.trackers = []; // Here for backwards-compatibility from back when there was only one account supported

	    this.accountID = undefined; // defaultAccountId
	    // Backwards-compatibility, probably unused

	    this.eventCallback = undefined;
	    this.eventQueue = []; // For anyone to send events through analytics. Abstracts out the implementation in case Google changes their analytics code yet again.

	    this.sendEvent = function (eventCategory, eventAction, eventLabel, eventValue, fieldsObject, trackerName) {
	      //console.log(GoogleAnalyticsManager.instance.trackers);
	      if (!_this.initialized) {
	        _this.eventQueue.push({
	          fn: _this.sendEvent,
	          args: [eventCategory, eventAction, eventLabel, eventValue, fieldsObject, trackerName]
	        });
	      } else {
	        if (trackerName) {
	          ga(trackerName + '.send', 'event', eventCategory, eventAction, eventLabel, eventValue);
	        } else {
	          _this.trackers.forEach(function (tracker) {
	            return ga(tracker.name + '.send', 'event', eventCategory, eventAction, eventLabel, eventValue);
	          });
	        }

	        if (_this.eventCallback != null) _this.eventCallback(eventCategory, eventAction, eventLabel, eventValue, fieldsObject, trackerName);
	      }
	    };

	    this.attachEventScriptsToAnchors();
	  }

	  _createClass(GoogleAnalyticsManager, [{
	    key: "initializeGoogleAnalytics",
	    value: // Attach async script and set up 'ga' object
	    function initializeGoogleAnalytics() {
	      // Google Analytics embed code unminified and labeled
	      (function (window, document, scriptTagName, scriptUrl, analyticsObjectName) {
	        var scriptElement, firstScriptElement;
	        window['GoogleAnalyticsObject'] = analyticsObjectName;

	        window[analyticsObjectName] = window[analyticsObjectName] || function () {
	          (window[analyticsObjectName].q = window[analyticsObjectName].q || []).push(arguments);
	        };

	        window[analyticsObjectName].l = new Date().valueOf();
	        scriptElement = document.createElement(scriptTagName);
	        firstScriptElement = document.getElementsByTagName(scriptTagName)[0];
	        scriptElement.async = true;
	        scriptElement.src = scriptUrl;
	        firstScriptElement.parentNode.insertBefore(scriptElement, firstScriptElement);
	      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

	      this.createTrackersAndSendPageview();
	      this.eventQueue.forEach(function (e) {
	        return e.fn.apply(e, _toConsumableArray(e.args));
	      });
	      this.eventQueue = [];
	      this.initialized = true;
	    }
	  }, {
	    key: "createTrackersAndSendPageview",
	    value: function createTrackersAndSendPageview() {
	      var _iterator = _createForOfIteratorHelper(this.trackers),
	          _step;

	      try {
	        for (_iterator.s(); !(_step = _iterator.n()).done;) {
	          var tracker = _step.value;
	          ga('create', tracker.id, 'auto', tracker.name);
	          ga(tracker.name + '.send', 'pageview');
	        }
	      } catch (err) {
	        _iterator.e(err);
	      } finally {
	        _iterator.f();
	      }
	    } // Add analytic events to track Mailto, Document downloads, and Outbound links

	  }, {
	    key: "attachEventScript",
	    value: function attachEventScript(anchorElement, title, description) {
	      var _this2 = this;

	      anchorElement.addEventListener('click', function () {
	        _this2.sendEvent(title, description); //console.log("SENDING EVENT");
	        //_gaq.push(['_trackEvent', title, description]);

	      });
	    }
	  }, {
	    key: "linkIsDocument",
	    value: function linkIsDocument(anchorElement) {
	      var path = anchorElement.pathname + anchorElement.search;
	      return path.match(/\.(?:doc|dot|docx|dotx|eps|jpg|png|svg|xls|xlt|xlsx|xlst|ppt|pps|pptx|ppsx|pot|potx|pdf|xls|zip|txt|vsd|vxd|js|css|rar|exe|wma|mov|avi|wmv|mpg|mpeg|mp3)($|\&|\?)/i);
	    }
	  }, {
	    key: "attachEvents",
	    value: function attachEvents(anchorElement) {
	      //console.log("attach events");
	      anchorElement.protocol;
	      var linkHostname = anchorElement.hostname;
	      var currentHostname = location.hostname;
	      var linkID = anchorElement.id;
	      var linkHref = anchorElement.href;
	      if (linkID == 'whoson_chat_link' || linkID == 'serfflink') return;

	      if (linkHostname == 'mailto:') {
	        this.attachEventScript(anchorElement, 'Mailto Links', linkHref);
	      } else if (linkHostname && linkHostname != currentHostname) {
	        this.attachEventScript(anchorElement, 'Outbound Links', linkHref);
	      } else {
	        if (this.linkIsDocument(anchorElement)) {
	          this.attachEventScript(anchorElement, 'Document Links', linkHref);
	        }
	      }
	    }
	  }, {
	    key: "attachEventScriptsToAnchors",
	    value: function attachEventScriptsToAnchors() {
	      var _this3 = this;

	      var loop = function loop() {
	        var anchors = Array.from(document.querySelectorAll("a"));
	        anchors.filter(function (a) {
	          return a.orAnalyticsEventAttached != true;
	        }).forEach(function (a) {
	          _this3.attachEvents(a);

	          a.orAnalyticsEventAttached = true;
	        });
	        setTimeout(loop, 750);
	      };

	      loop(); // Assuming this is instantiated in head, anchors haven't been created yet, so just catch all the new ones
	      // onAnchorCreated.push((element) => {	
	      // 	this.attachEvents(element);
	      // });
	    } // Allow the addition of other trackers for other analytics accounts
	    // private addTracker(tracker) {
	    // 	this.trackers.push({
	    // 		id: tracker.id,
	    // 		name: tracker.name
	    // 	});
	    // }
	    // Initialize

	  }, {
	    key: "initialize",
	    value: function initialize() {
	      var _this4 = this;

	      getTemplateSettings().then(function (settings) {
	        var defaultTrackerId = _this4.accountID; // If user supplied id through deprecated api
	        // Set accountID to default value if not set

	        if (defaultTrackerId === undefined) {
	          if (location.host.startsWith("stag")) {
	            defaultTrackerId = _this4.defaultStagingAccountId;
	          } else {
	            defaultTrackerId = _this4.defaultProductionAccountId;
	          }
	        }

	        _this4.trackers.push({
	          id: defaultTrackerId,
	          name: 'default'
	        });

	        if (settings.customGoogleAnalyticsId) {
	          _this4.trackers.push({
	            id: settings.customGoogleAnalyticsId,
	            name: 'site'
	          });
	        }

	        _this4.initializeGoogleAnalytics();
	      });
	    }
	  }], [{
	    key: "instance",
	    get: function get() {
	      if (typeof this._instance === 'undefined') this._instance = new GoogleAnalyticsManager();
	      return this._instance;
	    }
	  }]);

	  return GoogleAnalyticsManager;
	}();

	var _a;

	var container = document.querySelector(".helpfulPoll");
	var pathname = window.location.pathname;
	var cacheKey = "oregon-gov-helpful-poll-" + pathname;
	var cachedResultString = localStorage.getItem(cacheKey); //console.log(cachedResultString);

	var cachedResult = cachedResultString ? JSON.parse(cachedResultString || "{}") : null;

	if (cachedResult) {
	  cachedResult.date = new Date(cachedResult.date);
	} //console.log("cachedresult", cachedResult);
	var expireDate = new Date();
	expireDate.setDate(expireDate.getDate() - 30);

	if (!cachedResult || cachedResult.date < expireDate) {
	  container.innerHTML = "\n        <div class=\"well well-sm text-center\">\n            <div class=\"helpfulPollForm form-inline inline-block\">\n                <span class=\"fal fa-comment-lines\"></span>\n                <p class=\"helpfulPollQuestion inline-block\"><strong>Help us improve!</strong> Was this page helpful?</p>\n                \n                <div class=\"btn-group helpfulPollYesNo\" data-toggle=\"buttons-radio\">\n                    <button type=\"button\" class=\"btn btn-outline-light\" name=\"options\" id=\"helpfulPollYes\" aria-label=\"Was this page helpful? Yes\">Yes</button>\n                    <button type=\"button\" class=\"btn btn-outline-light\" name=\"options\" id=\"helpfulPollNo\" aria-label=\"Was this page helpful? No\">No</button>\n                </div>\n            </div>\n        </div>\n    ";
	  container.insertAdjacentHTML("afterend", "\n        <div id=\"helpfulPagePollModal\" class=\"text-left modal\" tabindex=\"-1\" role=\"dialog\">\n            <div class=\"modal-dialog\" role=\"document\">\n                <div class=\"modal-content\">\n                    <div class=\"modal-header bg-dark text-light\">\n                        <p class=\"modal-title\" id=\"helpfulPagePollTitle\">\n                            Help us blaze a better trail<br/>\n                            <span class=\"lead\">Let us know how we can improve this page</span>\n                        </p>\n                    </div>\n                    <div class=\"modal-body\" id=\"helpfulPagePollModalBody\">\n                        <div class=\"form-group required\" id=\"helpfulPagePollModalFeedbackType\">\n                            <label class=\"control-label\" for=\"helpfulPagePollModalFeedbackTypes\">I'd like to submit a/an </label>\n                            <select class=\"form-control form-control-lg\" id=\"helpfulPagePollModalFeedbackTypes\">\n                                <option value=\"Idea\" selected>Idea/Suggestion</option>\n                                <option value=\"Problem\">Problem</option>\n                                <option value=\"Comment\">Comment</option>\n                            </select>\n                        </div>\n                        <div class=\"form-group required\" id=\"helpfulPagePollModalQuestion\">\n                            <label class=\"control-label\" for=\"helpfulPagePollModalComment\">How can we make this page more helpful?</label>\n                            <textarea rows=\"4\" required data-max-length=\"250\" id=\"helpfulPagePollModalComment\" class=\"form-control\" aria-describedby=\"helpfulPagePollCommentCharLength\"></textarea>\n                            <p class=\"help-block\" id=\"helpfulPagePollCommentCharLength\" aria-live=\"polite\">\n                                <span id=\"helpfulPagePollCommentCharLengthCount\">250</span> characters remaining\n                            </p>\n                            <p>\n                                <b>Note: </b>Please do not provide personal information (e.g. address, social security numbers, etc.)</div>\n                            </p>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-dark\" data-dismiss=\"modal\" >No, Thanks</button>\n                            <button type=\"button\" class=\"btn btn-primary\" id=\"helpfulPagePollModalCommentSubmit\">Submit</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class=\"modal-backdrop show d-none\"></div>\n    ");
	  var modalComment = document.querySelector("#helpfulPagePollModalComment");
	  modalComment.addEventListener("keyup", function () {
	    var _a;

	    document.querySelector('#helpfulPagePollModalBody').classList.add("was-validated");
	    var maxLength = parseInt((_a = modalComment.getAttribute("data-max-length")) !== null && _a !== void 0 ? _a : "250");
	    var submit = document.querySelector('#helpfulPagePollModalCommentSubmit');
	    document.querySelector('#helpfulPagePollCommentCharLengthCount').innerHTML = (maxLength - modalComment.value.length).toString();
	    modalComment.setCustomValidity(modalComment.value.length > maxLength ? "Too many characters" : "");
	    submit.disabled = modalComment.value.length > maxLength;
	  });
	} else {
	  container.innerHTML = "\n        <div class=\"helpfulPolled\" style=\"display:none;\">You can respond again in 30 days.</div>\n    ";
	}

	Array.from(document.querySelectorAll('button[id^="helpfulPoll"]')).forEach(function (el) {
	  el.addEventListener('click', function (e) {
	    var button = e.target;
	    var yes = button.id == 'helpfulPollYes';
	    ga("send", "event", "Helpful Page Poll", "Vote", pathname, yes ? 1 : 0);
	    var form = document.querySelector('.helpfulPollForm');
	    form.style.display = "none";

	    if (yes) {
	      form.insertAdjacentHTML("afterend", "\n                <span class='helpfulPollThanks'>\n                    <span class='fal fa-check-circle'></span> Great! Thanks for letting us know! You can respond again in 30 days.\n                </span>\n            ");
	    }

	    localStorage.setItem(cacheKey, JSON.stringify({
	      date: new Date()
	    }));

	    if (!yes) {
	      openModal();
	    }
	  });
	});

	function openModal() {
	  var modal = document.querySelector('#helpfulPagePollModal');
	  var backdrop = document.querySelector('#helpfulPagePollModal + .modal-backdrop');
	  modal.classList.add('d-block');
	  backdrop.classList.remove('d-none');
	}

	function closeModal() {
	  var modal = document.querySelector('#helpfulPagePollModal');
	  var backdrop = document.querySelector('#helpfulPagePollModal + .modal-backdrop');
	  modal.classList.remove('d-block');
	  backdrop.classList.add('d-none');
	}

	(_a = document.querySelector('button[id^="helpfulPagePollModalCommentSubmit"]')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', function (e) {
	  var feedbackType = document.querySelector('#helpfulPagePollModalFeedbackTypes').value;
	  var feedbackComment = document.querySelector('#helpfulPagePollModalComment').value;
	  ga("send", "event", "Helpful Page Poll Feedback", feedbackType, feedbackComment, 0);
	  document.querySelector('#helpfulPagePollModal .modal-header').innerHTML = "\n            <h4 class=\"modal-title\">Thank you for your input!</h4>\n        ";
	  document.querySelector('#helpfulPagePollModalBody').innerHTML = "\n            <div class=\"lead\">\n                Your <b>".concat(feedbackType, "</b> has been submitted.\n            </div>\n            <div class=\"card bg-dark text-white\">\n                <div class=\"card-body\">\n                    ").concat(feedbackComment, "\n                </div>\n            </div>\n            <p class=\"lead\">A team member will review it soon!</p>\n        ");
	  document.querySelector('#helpfulPagePollModal .modal-footer button[data-dismiss=modal]').innerHTML = "Close";
	  document.querySelector('#helpfulPagePollModalCommentSubmit').style.display = "none";
	});
	Array.from(document.querySelectorAll("#helpfulPagePollModal [data-dismiss=modal]")).forEach(function (el) {
	  el.addEventListener("click", function () {
	    return closeModal();
	  });
	});

	polyfill(window); // polyfill closest

	initializeObjectFit(document.body);
	initializeParallax(Array.from(document.querySelectorAll(":not(or-img)[data-parallax]")) // or-img initializes parallax on its own
	);
	GoogleAnalyticsManager.instance.initialize();
	var n = 10;
	main_1.write(function () {
	  n += 6;
	});
	main_1.read(function () {
	  n /= 2;
	});
	requestAnimationFrame(function () {
	  console.warn(n);
	}); // import { PageViewModel } from "./ui/view-models/page-view-model";
	// // Register Knockout Components
	// import "./ui/components/agency-card";
	// import "./ui/components/agency-listing";
	// import "./ui/components/entity-card";
	// import "./ui/components/entity-listing";
	// import "./ui/components/related-news";
	// import "./ui/components/meganav";
	// import "./ui/components/meganav-topic";
	// import "./ui/components/meganav-subtopic";
	// import "./search/components/page-buttons";
	// import "./search/components/related-agencies-list";
	// import "./search/components/related-agency-item";
	// import "./search/components/search-app";
	// import "./search/components/search-results";
	// import "./search/components/top-agency-card";
	// import "./search/components/web-result";
	// // Register Binding Handlers
	// import "./ui/binding-handlers/animation-css";
	// import "./ui/binding-handlers/object-fit-binding-handler";
	// import "./ui/binding-handlers/parallax";
	// import "./ui/binding-handlers/safe-css";
	// import "./views/main-navigation-view"; // Contains binding handler
	// import "./views/meganav-view";
	// import "./views/search-view"; // Contains binding handler
	// import { shimCssGridElements } from "./ui/utilities/css-grid-shim";
	// export const page = new PageViewModel();
	// ko.applyBindings(page);
	// shimCssGridElements();
	// document.body.classList.remove("or-portal-unloaded");
	// // For debugging
	// window.pageViewModel = page;
	// declare global {
	// 	interface Window {
	// 		pageViewModel: PageViewModel;
	// 	}
	// }

})();

</script>

</body>
</html>
