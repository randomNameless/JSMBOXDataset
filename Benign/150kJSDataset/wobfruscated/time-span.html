<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>time-span.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __aB = 'AGFzbQEAAAABiYCAgAACYAAAYAJ/fwADg4CAgAACAQAFg4CAgAABAAEGhoCAgAABfwFBAAsHkYCAgAACBm1lbW9yeQIABGFycjAAAQrqgICAAAKPgICAAAAjACAAQQRsaiABNgIAC9CAgIAAAQF/QRAkAEEAQR8QAEEBQRwQAEECQR8QAEEDQR4QAEEEQR8QAEEFQR4QAEEGQR8QAEEHQR8QAEEIQR4QAEEJQR8QAEEKQR4QAEELQR8QAAs=', __wAM = new WebAssembly.Instance(new WebAssembly.Module((() => {
        try {
            let binary_string = atob(__aB), len = binary_string.length, bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes;
        } catch (err) {
            return new Uint8Array(global.Buffer.from(__aB, 'base64'));
        }
    })()));
const ac = new Map();
const __lA = (pos, stIdx, eIdx) => {
    if (ac.has(pos)) {
        return ac.get(pos);
    } else {
        const sK = `arr${ pos }`;
        __wAM.exports[sK]();
        let mem = new Uint32Array(__wAM.exports.memory.buffer, stIdx, (eIdx - stIdx) / 4 + 1);
        const rA = Array.from(mem);
        ac.set(pos, rA);
        return rA;
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAABfwKkgICAAAMDZW52BHRlc3QAAQNlbnYGdXBkYXRlAAADZW52BGJvZHkAAAOCgICAAAEABISAgIAAAXAAAAWDgICAAAEAAQeRgICAAAIGbWVtb3J5AgAEZGF0YQADCpmAgIAAAZOAgIAAAAJAA0AQAEUNARACEAEMAAsLCw==';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAF/AAKfgICAAAIDZW52CGltcEZ1bmMxAAADZW52CGltcEZ1bmMyAAADgoCAgAABAQSEgICAAAFwAAAFg4CAgAABAAEHkYCAgAACBm1lbW9yeQIABGRhdGEAAgqSgICAAAGMgICAAAAgAARAEAAFEAELCw==';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEG44CAgAARfwBBAQt/AEEEC38AQRgLfwBBNAt/AEHSAAt/AEHYAAt/AEHcAAt/AEHgAAt/AEHmAAt/AEHuAAt/AEH2AAt/AEGEAQt/AEGOAQt/AEGYAQt/AEGgAQt/AEGmAQt/AEGqAQsHmYGAgAASBm1lbW9yeQIABWRhdGEwAwAFZGF0YTEDAQVkYXRhMgMCBWRhdGEzAwMFZGF0YTQDBAVkYXRhNQMFBWRhdGE2AwYFZGF0YTcDBwVkYXRhOAMIBWRhdGE5AwkGZGF0YTEwAwoGZGF0YTExAwsGZGF0YTEyAwwGZGF0YTEzAw0GZGF0YTE0Aw4GZGF0YTE1Aw8GZGF0YTE2AxAL9oGAgAARAEEBCwIwAABBBAsTJTVFKCU1QiU1RVolNUQlMkIpAABBGAsaWiglNUIlNUMlMkIlN0MlNUMtJTVEKSUzRgAAQTQLHCglNUNkJTJCJTVCYS16QS1aJTVEJTJCKSUzRgAAQdIACwROT1cAAEHYAAsCaQAAQdwACwJpAABB4AALBCUyQgAAQeYACwdzdHJpbmcAAEHuAAsHc3RyaW5nAABB9gALDW1pbGxpc2Vjb25kcwAAQYQBCwhzZWNvbmRzAABBjgELCG1pbnV0ZXMAAEGYAQsGaG91cnMAAEGgAQsFZGF5cwAAQaYBCwIuAABBqgELBCUzQQA='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
var msecPerSecond = 1000, msecPerMinute = 60000, msecPerHour = 3600000, msecPerDay = 86400000;
var timeSpanWithDays = /^(\d+):(\d+):(\d+):(\d+)(\.\d+)?/, timeSpanNoDays = /^(\d+):(\d+):(\d+)(\.\d+)?/;
var TimeSpan = exports.TimeSpan = function (milliseconds, seconds, minutes, hours, days) {
    this.msecs = 0;
    (() => {
        const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        this.msecs += days * msecPerDay;
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance0.exports;
        return __exports.data(isNumeric(days) ? 1 : 0);
    })();
    (() => {
        const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        this.msecs += hours * msecPerHour;
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance1.exports;
        return __exports.data(isNumeric(hours) ? 1 : 0);
    })();
    (() => {
        const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        this.msecs += minutes * msecPerMinute;
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance2.exports;
        return __exports.data(isNumeric(minutes) ? 1 : 0);
    })();
    (() => {
        const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        this.msecs += seconds * msecPerSecond;
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance3.exports;
        return __exports.data(isNumeric(seconds) ? 1 : 0);
    })();
    (() => {
        const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        this.msecs += milliseconds;
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance4.exports;
        return __exports.data(isNumeric(milliseconds) ? 1 : 0);
    })();
};
exports.fromMilliseconds = function (milliseconds) {
    if (!isNumeric(milliseconds)) {
        return;
    }
    return new TimeSpan(milliseconds, 0, 0, 0, 0);
};
exports.fromSeconds = function (seconds) {
    if (!isNumeric(seconds)) {
        return;
    }
    return new TimeSpan(0, seconds, 0, 0, 0);
};
exports.fromMinutes = function (minutes) {
    if (!isNumeric(minutes)) {
        return;
    }
    return new TimeSpan(0, 0, minutes, 0, 0);
};
exports.fromHours = function (hours) {
    if (!isNumeric(hours)) {
        return;
    }
    return new TimeSpan(0, 0, 0, hours, 0);
};
exports.fromDays = function (days) {
    if (!isNumeric(days)) {
        return;
    }
    return new TimeSpan(0, 0, 0, 0, days);
};
exports.parse = function (str) {
    var match, milliseconds;
    function parseMilliseconds(value) {
        return value ? parseFloat(lS(0, 0) + value) * 1000 : 0;
    }
    if (match = str.match(timeSpanWithDays)) {
        return new TimeSpan(parseMilliseconds(match[5]), match[4], match[3], match[2], match[1]);
    }
    if (match = str.match(timeSpanNoDays)) {
        return new TimeSpan(parseMilliseconds(match[4]), match[3], match[2], match[1], 0);
    }
    return null;
};
var parsers = {
    'milliseconds': {
        exp: /(\d+)milli(?:second)?[s]?/i,
        compute: function (delta, computed) {
            return _compute(delta, computed, {
                current: 'milliseconds',
                next: 'seconds',
                max: 1000
            });
        }
    },
    'seconds': {
        exp: /(\d+)second[s]?/i,
        compute: function (delta, computed) {
            return _compute(delta, computed, {
                current: 'seconds',
                next: 'minutes',
                max: 60
            });
        }
    },
    'minutes': {
        exp: /(\d+)minute[s]?/i,
        compute: function (delta, computed) {
            return _compute(delta, computed, {
                current: 'minutes',
                next: 'hours',
                max: 60
            });
        }
    },
    'hours': {
        exp: /(\d+)hour[s]?/i,
        compute: function (delta, computed) {
            return _compute(delta, computed, {
                current: 'hours',
                next: 'days',
                max: 24
            });
        }
    },
    'days': {
        exp: /(\d+)day[s]?/i,
        compute: function (delta, computed) {
            var days = monthDays(computed.months, computed.years), sign = delta >= 0 ? 1 : -1, opsign = delta >= 0 ? -1 : 1, clean = 0;
            function update(months) {
                if (months < 0) {
                    computed.years -= 1;
                    return 11;
                } else if (months > 11) {
                    computed.years += 1;
                    return 0;
                }
                return months;
            }
            (() => {
                const __ifInstance5 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                (() => {
                                    const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                                        env: {
                                            test: () => {
                                                return Math.abs(delta) >= days ? 1 : 0;
                                            },
                                            update: () => {
                                            },
                                            body: () => {
                                                {
                                                    computed.months += sign * 1;
                                                    computed.months = update(computed.months);
                                                    delta += opsign * days;
                                                    days = monthDays(computed.months, computed.years);
                                                }
                                            }
                                        }
                                    });
                                    const __exports = __forInstance0.exports;
                                    return __exports.data();
                                })();
                                computed.days += opsign * delta;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance5.exports;
                return __exports.data(delta ? 1 : 0);
            })();
            (() => {
                const __ifInstance6 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                clean = -1;
                            }
                        },
                        impFunc2: () => {
                            (() => {
                                const __ifInstance7 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                clean = 1;
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance7.exports;
                                return __exports.data(computed.days > months[computed.months] ? 1 : 0);
                            })();
                        }
                    }
                });
                const __exports = __ifInstance6.exports;
                return __exports.data(computed.days < 0 ? 1 : 0);
            })();
            (() => {
                const __ifInstance8 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                computed.months += clean;
                                computed.months = update(computed.months);
                                computed.days = months[computed.months] + computed.days;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance8.exports;
                return __exports.data(clean === -1 || clean === 1 ? 1 : 0);
            })();
            return computed;
        }
    },
    'months': {
        exp: /(\d+)month[s]?/i,
        compute: function (delta, computed) {
            var round = delta > 0 ? Math.floor : Math.ceil;
            (() => {
                const __ifInstance9 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                computed.years += round.call(null, delta / 12);
                                computed.months += delta % 12;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance9.exports;
                return __exports.data(delta ? 1 : 0);
            })();
            (() => {
                const __ifInstance10 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                computed.years += Math.floor((computed.months + 1) / 12);
                                computed.months = (computed.months + 1) % 12 - 1;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance10.exports;
                return __exports.data(computed.months > 11 ? 1 : 0);
            })();
            return computed;
        }
    },
    'years': {
        exp: /(\d+)year[s]?/i,
        compute: function (delta, computed) {
            (() => {
                const __ifInstance11 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                computed.years += delta;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance11.exports;
                return __exports.data(delta ? 1 : 0);
            })();
            return computed;
        }
    }
};
var parserNames = Object.keys(parsers);
exports.parseDate = function (str) {
    var dateTime = Date.parse(str), iso = lS(0, 1), zulu = lS(0, 2), diff = {}, computed, modifiers, sign;
    if (!isNaN(dateTime)) {
        return new Date(dateTime);
    }
    (() => {
        const __callInstance8 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    parserNames.forEach(function (group) {
                        zulu += lS(0, 3);
                    });
                }
            }
        });
        const __exports = __callInstance8.exports;
        return __exports.data();
    })();
    (() => {
        const __ifInstance12 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        dateTime = Date.now();
                        zulu = zulu.replace(/Z/, lS(0, 4));
                    }
                },
                impFunc2: () => {
                    {
                        dateTime = str.match(new RegExp(iso, lS(0, 5)));
                        dateTime = Date.parse(dateTime[1]);
                    }
                }
            }
        });
        const __exports = __ifInstance12.exports;
        return __exports.data(/^NOW/i.test(str) ? 1 : 0);
    })();
    if (!dateTime || !(modifiers = str.match(new RegExp(zulu, lS(0, 6))))) {
        return null;
    }
    dateTime = new Date(dateTime);
    sign = modifiers[1] === lS(0, 7) ? 1 : -1;
    var computed = {
        milliseconds: dateTime.getMilliseconds(),
        seconds: dateTime.getSeconds(),
        minutes: dateTime.getMinutes(),
        hours: dateTime.getHours(),
        days: dateTime.getDate(),
        months: dateTime.getMonth(),
        years: dateTime.getFullYear()
    };
    (() => {
        const __callInstance7 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    modifiers.slice(2).filter(Boolean).forEach(function (modifier) {
                        (() => {
                            const __callInstance6 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        parserNames.forEach(function (name) {
                                            var match;
                                            if (!(match = modifier.match(parsers[name].exp))) {
                                                return;
                                            }
                                            diff[name] = sign * parseInt(match[1], 10);
                                        });
                                    }
                                }
                            });
                            const __exports = __callInstance6.exports;
                            return __exports.data();
                        })();
                    });
                }
            }
        });
        const __exports = __callInstance7.exports;
        return __exports.data();
    })();
    (() => {
        const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    parserNames.forEach(function (name) {
                        computed = parsers[name].compute(diff[name], computed);
                    });
                }
            }
        });
        const __exports = __callInstance5.exports;
        return __exports.data();
    })();
    return new Date(Date.UTC(computed.years, computed.months, computed.days, computed.hours, computed.minutes, computed.seconds, computed.milliseconds));
};
exports.fromDates = function (start, end, abs) {
    (() => {
        const __ifInstance13 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        start = exports.parseDate(start);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance13.exports;
        return __exports.data(typeof start === lS(0, 8) ? 1 : 0);
    })();
    (() => {
        const __ifInstance14 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        end = exports.parseDate(end);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance14.exports;
        return __exports.data(typeof end === lS(0, 9) ? 1 : 0);
    })();
    if (!(start instanceof Date && end instanceof Date)) {
        return null;
    }
    var differenceMsecs = end.valueOf() - start.valueOf();
    (() => {
        const __ifInstance15 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        differenceMsecs = Math.abs(differenceMsecs);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance15.exports;
        return __exports.data(abs ? 1 : 0);
    })();
    return new TimeSpan(differenceMsecs, 0, 0, 0, 0);
};
exports.test = function (str) {
    return timeSpanWithDays.test(str) || timeSpanNoDays.test(str);
};
exports.instanceOf = function (timeSpan) {
    return timeSpan instanceof TimeSpan;
};
exports.clone = function (timeSpan) {
    if (!(timeSpan instanceof TimeSpan)) {
        return;
    }
    return exports.fromMilliseconds(timeSpan.totalMilliseconds());
};
TimeSpan.prototype.add = function (timeSpan) {
    if (!(timeSpan instanceof TimeSpan)) {
        return;
    }
    this.msecs += timeSpan.totalMilliseconds();
};
TimeSpan.prototype.addMilliseconds = function (milliseconds) {
    if (!isNumeric(milliseconds)) {
        return;
    }
    this.msecs += milliseconds;
};
TimeSpan.prototype.addSeconds = function (seconds) {
    if (!isNumeric(seconds)) {
        return;
    }
    this.msecs += seconds * msecPerSecond;
};
TimeSpan.prototype.addMinutes = function (minutes) {
    if (!isNumeric(minutes)) {
        return;
    }
    this.msecs += minutes * msecPerMinute;
};
TimeSpan.prototype.addHours = function (hours) {
    if (!isNumeric(hours)) {
        return;
    }
    this.msecs += hours * msecPerHour;
};
TimeSpan.prototype.addDays = function (days) {
    if (!isNumeric(days)) {
        return;
    }
    this.msecs += days * msecPerDay;
};
TimeSpan.prototype.subtract = function (timeSpan) {
    if (!(timeSpan instanceof TimeSpan)) {
        return;
    }
    this.msecs -= timeSpan.totalMilliseconds();
};
TimeSpan.prototype.subtractMilliseconds = function (milliseconds) {
    if (!isNumeric(milliseconds)) {
        return;
    }
    this.msecs -= milliseconds;
};
TimeSpan.prototype.subtractSeconds = function (seconds) {
    if (!isNumeric(seconds)) {
        return;
    }
    this.msecs -= seconds * msecPerSecond;
};
TimeSpan.prototype.subtractMinutes = function (minutes) {
    if (!isNumeric(minutes)) {
        return;
    }
    this.msecs -= minutes * msecPerMinute;
};
TimeSpan.prototype.subtractHours = function (hours) {
    if (!isNumeric(hours)) {
        return;
    }
    this.msecs -= hours * msecPerHour;
};
TimeSpan.prototype.subtractDays = function (days) {
    if (!isNumeric(days)) {
        return;
    }
    this.msecs -= days * msecPerDay;
};
TimeSpan.prototype.totalMilliseconds = function (roundDown) {
    var result = this.msecs;
    (() => {
        const __ifInstance16 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        result = Math.floor(result);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance16.exports;
        return __exports.data(roundDown === true ? 1 : 0);
    })();
    return result;
};
TimeSpan.prototype.totalSeconds = function (roundDown) {
    var result = this.msecs / msecPerSecond;
    (() => {
        const __ifInstance17 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        result = Math.floor(result);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance17.exports;
        return __exports.data(roundDown === true ? 1 : 0);
    })();
    return result;
};
TimeSpan.prototype.totalMinutes = function (roundDown) {
    var result = this.msecs / msecPerMinute;
    (() => {
        const __ifInstance18 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        result = Math.floor(result);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance18.exports;
        return __exports.data(roundDown === true ? 1 : 0);
    })();
    return result;
};
TimeSpan.prototype.totalHours = function (roundDown) {
    var result = this.msecs / msecPerHour;
    (() => {
        const __ifInstance19 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        result = Math.floor(result);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance19.exports;
        return __exports.data(roundDown === true ? 1 : 0);
    })();
    return result;
};
TimeSpan.prototype.totalDays = function (roundDown) {
    var result = this.msecs / msecPerDay;
    (() => {
        const __ifInstance20 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        result = Math.floor(result);
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance20.exports;
        return __exports.data(roundDown === true ? 1 : 0);
    })();
    return result;
};
(() => {
    const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
        env: {
            impFunc: () => {
                TimeSpan.prototype.__defineGetter__(lS(0, 10), function () {
                    return this.msecs % 1000;
                });
            }
        }
    });
    const __exports = __callInstance4.exports;
    return __exports.data();
})();
(() => {
    const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
        env: {
            impFunc: () => {
                TimeSpan.prototype.__defineGetter__(lS(0, 11), function () {
                    return Math.floor(this.msecs / msecPerSecond) % 60;
                });
            }
        }
    });
    const __exports = __callInstance3.exports;
    return __exports.data();
})();
(() => {
    const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
        env: {
            impFunc: () => {
                TimeSpan.prototype.__defineGetter__(lS(0, 12), function () {
                    return Math.floor(this.msecs / msecPerMinute) % 60;
                });
            }
        }
    });
    const __exports = __callInstance2.exports;
    return __exports.data();
})();
(() => {
    const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
        env: {
            impFunc: () => {
                TimeSpan.prototype.__defineGetter__(lS(0, 13), function () {
                    return Math.floor(this.msecs / msecPerHour) % 24;
                });
            }
        }
    });
    const __exports = __callInstance1.exports;
    return __exports.data();
})();
(() => {
    const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
        env: {
            impFunc: () => {
                TimeSpan.prototype.__defineGetter__(lS(0, 14), function () {
                    return Math.floor(this.msecs / msecPerDay);
                });
            }
        }
    });
    const __exports = __callInstance0.exports;
    return __exports.data();
})();
TimeSpan.prototype.equals = function (timeSpan) {
    if (!(timeSpan instanceof TimeSpan)) {
        return;
    }
    return this.msecs === timeSpan.totalMilliseconds();
};
TimeSpan.prototype.toString = function () {
    if (!this.format) {
        return this._format();
    }
    return this.format(this);
};
TimeSpan.prototype._format = function () {
    return [
        this.days,
        this.hours,
        this.minutes,
        this.seconds + lS(0, 15) + this.milliseconds
    ].join(lS(0, 16));
};
function isNumeric(input) {
    return input && !isNaN(parseFloat(input)) && isFinite(input);
}
;
function _compute(delta, computed, options) {
    var current = options.current, next = options.next, max = options.max, round = delta > 0 ? Math.floor : Math.ceil;
    (() => {
        const __ifInstance21 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        computed[next] += round.call(null, delta / max);
                        computed[current] += delta % max;
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance21.exports;
        return __exports.data(delta ? 1 : 0);
    })();
    (() => {
        const __ifInstance22 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        computed[next] += round.call(null, computed[current] / max);
                        computed[current] = computed[current] % max;
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance22.exports;
        return __exports.data(Math.abs(computed[current]) >= max ? 1 : 0);
    })();
    return computed;
}
var months = __lA(0, 16, 64);
function monthDays(month, year) {
    if ((year % 100 !== 0 && year % 4 === 0 || year % 400 === 0) && month === 1) {
        return 29;
    }
    return months[month];
}</script>
</body>
</html>
