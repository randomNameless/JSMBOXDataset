<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>CCTGAlib.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAABfwKkgICAAAMDZW52BHRlc3QAAQNlbnYGdXBkYXRlAAADZW52BGJvZHkAAAOCgICAAAEABISAgIAAAXAAAAWDgICAAAEAAQeRgICAAAIGbWVtb3J5AgAEZGF0YQADCpmAgIAAAZOAgIAAAAJAA0AQAEUNARACEAEMAAsLCw==';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAF/AAKfgICAAAIDZW52CGltcEZ1bmMxAAADZW52CGltcEZ1bmMyAAADgoCAgAABAQSEgICAAAFwAAAFg4CAgAABAAEHkYCAgAACBm1lbW9yeQIABGRhdGEAAgqSgICAAAGMgICAAAAgAARAEAAFEAELCw==';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEGhoCAgAABfwBBAQsHkoCAgAACBm1lbW9yeQIABWRhdGEwAwALn4CAgAABAEEBCxlJbmRleCUyMG91dCUyMG9mJTIwYm91bmQA'].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function (status, type, pixelDepth, width, height, imageData, flipped) {
    this.status = status || 0;
    this.type = type || 0;
    this.pixelDepth = pixelDepth || 0;
    this.width = width || 0;
    this.height = height || 0;
    this.imageData = imageData || [];
    this.flipped = flipped || 0;
};
cc.tgaLoadHeader = function (buffer, bufSize, psInfo) {
    var step = 2;
    if (step + 1 > bufSize)
        return false;
    var binaryReader = new cc.BinaryStreamReader(buffer);
    (() => {
        const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    binaryReader.setOffset(step);
                }
            }
        });
        const __exports = __callInstance4.exports;
        return __exports.data();
    })();
    psInfo.type = binaryReader.readByte();
    step += 10;
    if (step + 4 + 1 > bufSize)
        return false;
    (() => {
        const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    binaryReader.setOffset(step);
                }
            }
        });
        const __exports = __callInstance3.exports;
        return __exports.data();
    })();
    psInfo.width = binaryReader.readUnsignedShort();
    psInfo.height = binaryReader.readUnsignedInteger();
    psInfo.pixelDepth = binaryReader.readByte();
    step += 5;
    if (step + 1 > bufSize)
        return false;
    var garbage = binaryReader.readByte();
    psInfo.flipped = 0;
    (() => {
        const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    psInfo.flipped = 1;
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance0.exports;
        return __exports.data(garbage & 32 ? 1 : 0);
    })();
    return true;
};
cc.tgaLoadImageData = function (buffer, bufSize, psInfo) {
    var mode, total, i, aux;
    var step = 18;
    mode = 0 | psInfo.pixelDepth / 2;
    total = psInfo.height * psInfo.width * mode;
    if (step + total > bufSize)
        return false;
    psInfo.imageData = cc.__getSubArray(buffer, step, step + total);
    (() => {
        const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        (() => {
                            i = 0;
                            const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                                env: {
                                    test: () => {
                                        return i < total ? 1 : 0;
                                    },
                                    update: () => {
                                        i += mode;
                                    },
                                    body: () => {
                                        {
                                            aux = psInfo.imageData[i];
                                            psInfo.imageData[i] = psInfo.imageData[i + 2];
                                            psInfo.imageData[i + 2] = aux;
                                        }
                                    }
                                }
                            });
                            const __exports = __forInstance0.exports;
                            return __exports.data();
                        })();
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance1.exports;
        return __exports.data(mode >= 3 ? 1 : 0);
    })();
    return true;
};
cc.tgaRGBtogreyscale = function (psInfo) {
    var i, j;
    if (psInfo.pixelDepth === 8)
        return;
    var mode = psInfo.pixelDepth / 8;
    var newImageData = new Uint8Array(psInfo.height * psInfo.width);
    if (newImageData === null)
        return;
    (() => {
        i = 0, j = 0;
        const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return j < psInfo.width * psInfo.height ? 1 : 0;
                },
                update: () => {
                    i += mode, j++;
                },
                body: () => {
                    newImageData[j] = 0.3 * psInfo.imageData[i] + 0.59 * psInfo.imageData[i + 1] + 0.11 * psInfo.imageData[i + 2];
                }
            }
        });
        const __exports = __forInstance1.exports;
        return __exports.data();
    })();
    psInfo.pixelDepth = 8;
    psInfo.type = 3;
    psInfo.imageData = newImageData;
};
cc.tgaDestroy = function (psInfo) {
    if (!psInfo)
        return;
    psInfo.imageData = null;
    psInfo = null;
};
cc.tgaLoadRLEImageData = function (buffer, bufSize, psInfo) {
    var mode, total, i, index = 0, skip = 0, flag = 0;
    var aux = [], runlength = 0;
    var step = 18;
    mode = psInfo.pixelDepth / 8;
    total = psInfo.height * psInfo.width;
    for (i = 0; i < total; i++) {
        if (runlength != 0) {
            runlength--;
            skip = flag != 0;
        } else {
            if (step + 1 > bufSize)
                break;
            runlength = buffer[step];
            step += 1;
            flag = runlength & 128;
            (() => {
                const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            runlength -= 128;
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance2.exports;
                return __exports.data(flag ? 1 : 0);
            })();
            skip = 0;
        }
        if (!skip) {
            if (step + mode > bufSize)
                break;
            aux = cc.__getSubArray(buffer, step, step + mode);
            step += mode;
            (() => {
                const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
                    env: {
                        impFunc1: () => {
                            {
                                var tmp = aux[0];
                                aux[0] = aux[2];
                                aux[2] = tmp;
                            }
                        },
                        impFunc2: () => {
                        }
                    }
                });
                const __exports = __ifInstance3.exports;
                return __exports.data(mode >= 3 ? 1 : 0);
            })();
        }
        (() => {
            var j = 0;
            const __forInstance2 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return j < mode ? 1 : 0;
                    },
                    update: () => {
                        j++;
                    },
                    body: () => {
                        psInfo.imageData[index + j] = aux[j];
                    }
                }
            });
            const __exports = __forInstance2.exports;
            return __exports.data();
        })();
        index += mode;
    }
    return true;
};
cc.tgaFlipImage = function (psInfo) {
    var mode = psInfo.pixelDepth / 8;
    var rowbytes = psInfo.width * mode;
    (() => {
        var y = 0;
        const __forInstance3 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return y < psInfo.height / 2 ? 1 : 0;
                },
                update: () => {
                    y++;
                },
                body: () => {
                    {
                        var row = cc.__getSubArray(psInfo.imageData, y * rowbytes, y * rowbytes + rowbytes);
                        (() => {
                            const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        cc.__setDataToArray(cc.__getSubArray(psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes, rowbytes), psInfo.imageData, y * rowbytes);
                                    }
                                }
                            });
                            const __exports = __callInstance2.exports;
                            return __exports.data();
                        })();
                        (() => {
                            const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        cc.__setDataToArray(row, psInfo.imageData, (psInfo.height - (y + 1)) * rowbytes);
                                    }
                                }
                            });
                            const __exports = __callInstance1.exports;
                            return __exports.data();
                        })();
                    }
                }
            }
        });
        const __exports = __forInstance3.exports;
        return __exports.data();
    })();
    psInfo.flipped = 0;
};
cc.__getSubArray = function (array, start, end) {
    if (array instanceof Array)
        return array.slice(start, end);
    else
        return array.subarray(start, end);
};
cc.__setDataToArray = function (sourceData, destArray, startIndex) {
    (() => {
        var i = 0;
        const __forInstance4 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return i < sourceData.length ? 1 : 0;
                },
                update: () => {
                    i++;
                },
                body: () => {
                    destArray[startIndex + i] = sourceData[i];
                }
            }
        });
        const __exports = __forInstance4.exports;
        return __exports.data();
    })();
};
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function (binaryData) {
        this._binaryData = binaryData;
    },
    setBinaryData: function (binaryData) {
        this._binaryData = binaryData;
        this._offset = 0;
    },
    getBinaryData: function () {
        return this._binaryData;
    },
    _checkSize: function (neededBits) {
        if (!(this._offset + Math.ceil(neededBits / 8) < this._data.length))
            throw new Error(lS(0, 0));
    },
    _decodeFloat: function (precisionBits, exponentBits) {
        var length = precisionBits + exponentBits + 1;
        var size = length >> 3;
        (() => {
            const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        this._checkSize(length);
                    }
                }
            });
            const __exports = __callInstance0.exports;
            return __exports.data();
        })();
        var bias = Math.pow(2, exponentBits - 1) - 1;
        var signal = this._readBits(precisionBits + exponentBits, 1, size);
        var exponent = this._readBits(precisionBits, exponentBits, size);
        var significand = 0;
        var divisor = 2;
        var curByte = 0;
        do {
            var byteValue = this._readByte(++curByte, size);
            var startBit = precisionBits % 8 || 8;
            var mask = 1 << startBit;
            (() => {
                const __forInstance6 = new WebAssembly.Instance(__forWasmModule, {
                    env: {
                        test: () => {
                            return (mask >>= 1) ? 1 : 0;
                        },
                        update: () => {
                        },
                        body: () => {
                            {
                                (() => {
                                    const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
                                        env: {
                                            impFunc1: () => {
                                                significand += 1 / divisor;
                                            },
                                            impFunc2: () => {
                                            }
                                        }
                                    });
                                    const __exports = __ifInstance4.exports;
                                    return __exports.data(byteValue & mask ? 1 : 0);
                                })();
                                divisor *= 2;
                            }
                        }
                    }
                });
                const __exports = __forInstance6.exports;
                return __exports.data();
            })();
        } while (precisionBits -= startBit);
        this._offset += size;
        return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
    },
    _readByte: function (i, size) {
        return this._data[this._offset + size - i - 1];
    },
    _decodeInt: function (bits, signed) {
        var x = this._readBits(0, bits, bits / 8), max = Math.pow(2, bits);
        var result = signed && x >= max / 2 ? x - max : x;
        this._offset += bits / 8;
        return result;
    },
    _shl: function (a, b) {
        (() => {
            ++b;
            const __forInstance5 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return --b ? 1 : 0;
                    },
                    update: () => {
                        a = ((a %= 2147483647 + 1) & 1073741824) == 1073741824 ? a * 2 : (a - 1073741824) * 2 + 2147483647 + 1;
                    },
                    body: () => {
                        {
                        }
                    }
                }
            });
            const __exports = __forInstance5.exports;
            return __exports.data();
        })();
        ;
        return a;
    },
    _readBits: function (start, length, size) {
        var offsetLeft = (start + length) % 8;
        var offsetRight = start % 8;
        var curByte = size - (start >> 3) - 1;
        var lastByte = size + (-(start + length) >> 3);
        var diff = curByte - lastByte;
        var sum = this._readByte(curByte, size) >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1;
        (() => {
            const __ifInstance5 = new WebAssembly.Instance(__ifWasmModule, {
                env: {
                    impFunc1: () => {
                        sum += (this._readByte(lastByte++, size) & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight;
                    },
                    impFunc2: () => {
                    }
                }
            });
            const __exports = __ifInstance5.exports;
            return __exports.data(diff && offsetLeft ? 1 : 0);
        })();
        (() => {
            const __forInstance7 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return diff ? 1 : 0;
                    },
                    update: () => {
                    },
                    body: () => {
                        sum += this._shl(this._readByte(lastByte++, size), (diff-- << 3) - offsetRight);
                    }
                }
            });
            const __exports = __forInstance7.exports;
            return __exports.data();
        })();
        return sum;
    },
    readInteger: function () {
        return this._decodeInt(32, true);
    },
    readUnsignedInteger: function () {
        return this._decodeInt(32, false);
    },
    readSingle: function () {
        return this._decodeFloat(23, 8);
    },
    readShort: function () {
        return this._decodeInt(16, true);
    },
    readUnsignedShort: function () {
        return this._decodeInt(16, false);
    },
    readByte: function () {
        var readByte = this._data[this._offset];
        this._offset += 1;
        return readByte;
    },
    readData: function (start, end) {
        if (this._binaryData instanceof Array) {
            return this._binaryData.slice(start, end);
        } else {
            return this._binaryData.subarray(start, end);
        }
    },
    setOffset: function (offset) {
        this._offset = offset;
    },
    getOffset: function () {
        return this._offset;
    }
});</script>
</body>
</html>
