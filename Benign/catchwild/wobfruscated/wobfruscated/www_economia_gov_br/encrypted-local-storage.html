<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>encrypted-local-storage.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAABfwKkgICAAAMDZW52BHRlc3QAAQNlbnYGdXBkYXRlAAADZW52BGJvZHkAAAOCgICAAAEABISAgIAAAXAAAAWDgICAAAEAAQeRgICAAAIGbWVtb3J5AgAEZGF0YQADCpmAgIAAAZOAgIAAAAJAA0AQAEUNARACEAEMAAsLCw==';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEGtYCAgAAJfwBBAQt/AEEKC38AQcYBC38AQc4BC38AQd4CC38AQeYCC38AQfgVC38AQfoVC38AQfwVCwfSgICAAAoGbWVtb3J5AgAFZGF0YTADAAVkYXRhMQMBBWRhdGEyAwIFZGF0YTMDAwVkYXRhNAMEBWRhdGE1AwUFZGF0YTYDBgVkYXRhNwMHBWRhdGE4AwgLr5aAgAAJAEEBCwdiYXNlNjQAAEEKC7sBQUdGemJRRUFBQUFCaUlDQWdBQUNZQUFBWUFGJTJGQUFLZmdJQ0FBQUlEWlc1MkNHbHRjRVoxYm1NeEFBQURaVzUyQ0dsdGNFWjFibU15QUFBRGdvQ0FnQUFCQVFTRWdJQ0FBQUZ3QUFBRmc0Q0FnQUFCQUFFSGtZQ0FnQUFDQm0xbGJXOXllUUlBQkdSaGRHRUFBZ3FTZ0lDQUFBR01nSUNBQUFBZ0FBUkFFQUFGRUFFTEN3JTNEJTNEAABBxgELB2Jhc2U2NAAAQc4BC48BQUdGemJRRUFBQUFCaElDQWdBQUJZQUFBQW8lMkJBZ0lBQUFRTmxibllIYVcxd1JuVnVZd0FBQTRLQWdJQUFBUUFFaElDQWdBQUJjQUFBQllPQWdJQUFBUUFCQjVHQWdJQUFBZ1p0WlcxdmNua0NBQVJrWVhSaEFBRUtpb0NBZ0FBQmhJQ0FnQUFBRUFBTAAAQd4CCwdiYXNlNjQAAEHmAguRE0FHRnpiUUVBQUFBRmc0Q0FnQUFCQUFFR2lJR0FnQUFYZndCQkFRdCUyRkFFRWVDMzhBUVNJTGZ3QkJxQUVMZndCQnBBSUxmd0JCcUFNTGZ3QkJwZ1FMZndCQmxBVUxmd0JCbUFVTGZ3QkIlMkZBVUxmd0JCZ2dZTGZ3QkJqQVlMZndCQmxnWUxmd0JCb0FZTGZ3QkJtQWNMZndCQm9nY0xmd0JCbWdnTGZ3QkJrQWtMZndCQiUyQmdrTGZ3QkIlMkZBa0xmd0JCZ2dvTGZ3QkJ0Z29MZndCQnZBb0xCOCUyQkJnSUFBR0FadFpXMXZjbmtDQUFWa1lYUmhNQU1BQldSaGRHRXhBd0VGWkdGMFlUSURBZ1ZrWVhSaE13TURCV1JoZEdFMEF3UUZaR0YwWVRVREJRVmtZWFJoTmdNR0JXUmhkR0UzQXdjRlpHRjBZVGdEQ0FWa1lYUmhPUU1KQm1SaGRHRXhNQU1LQm1SaGRHRXhNUU1MQm1SaGRHRXhNZ01NQm1SaGRHRXhNd01OQm1SaGRHRXhOQU1PQm1SaGRHRXhOUU1QQm1SaGRHRXhOZ01RQm1SaGRHRXhOd01SQm1SaGRHRXhPQU1TQm1SaGRHRXhPUU1UQm1SaGRHRXlNQU1VQm1SaGRHRXlNUU1WQm1SaGRHRXlNZ01XQzZXTGdJQUFGd0JCQVFzY1JXNWpjbmx3ZEdWa0xVeHZZMkZzTFZOMGIzSmhaMlV0UzJWNUFBQkJIZ3NDTGdBQVFTSUxoQUZsYm1OeWVYQjBaV1F0Ykc5allXd3RjM1J2Y21GblpTNXFjeVV5TUVWdVkzSjVjSFJsWkV4dlkyRnNVM1J2Y21GblpTVXlNR2RsZEVsMFpXMG9LU1V5TUd0bGVTVXpRU1V5TUhaaGJIVmxKVEl3YVc0bE1qQnpkRzl5WVdkbEpUSXdZMkZ1Ym05MEpUSXdhWE1sTWpCdWIzUWxNakIzWld4c0pUSXdabTl5YldWa0xnQUFRYWdCQzNwbGJtTnllWEIwWldRdGJHOWpZV3d0YzNSdmNtRm5aUzVxY3lVeU1FVnVZM0o1Y0hSbFpFeHZZMkZzVTNSdmNtRm5aU1V5TUdkbGRFbDBaVzBvS1NVeU1HdGxlU1V6UVNVeU1IWmhiSFZsSlRJd2FXNGxNakJ6ZEc5eVlXZGxKVEl3WTJGdWJtOTBKVEl3WW1VbE1qQmtaV055ZVhCMFpXUXVBQUJCcEFJTGd3RmxibU55ZVhCMFpXUXRiRzlqWVd3dGMzUnZjbUZuWlM1cWN5VXlNRVZ1WTNKNWNIUmxaRXh2WTJGc1UzUnZjbUZuWlNVeU1HZGxkRWwwWlcwb0tTVXlNR3RsZVNVelFTVXlNSFpoYkhWbEpUSXdhVzRsTWpCemRHOXlZV2RsSlRJd1kyRnVibTkwSlRJd1ltVWxNakJ3WVhKelpXUWxNakJoY3lVeU1FcFRUMDR1QUFCQnFBTUxmR1Z1WTNKNWNIUmxaQzFzYjJOaGJDMXpkRzl5WVdkbExtcHpKVEl3Ulc1amNubHdkR1ZrVEc5allXeFRkRzl5WVdkbEpUSXdjMlYwU1hSbGJTZ3BKVEl3ZG1Gc2RXVWxNMEVsTWpCMllXeDFaU1V5TUdOaGJtNXZkQ1V5TUdKbEpUSXdiV0Z5YzJoaGJHeGxaQ1V5TUdsdWRHOGxNakJLVTA5T0xnQUFRYVlFQzIxbGJtTnllWEIwWldRdGJHOWpZV3d0YzNSdmNtRm5aUzVxY3lVeU1FVnVZM0o1Y0hSbFpFeHZZMkZzVTNSdmNtRm5aU1V5TUhObGRFbDBaVzBvS1NVeU1IWmhiSFZsSlROQkpUSXdkbUZzZFdVbE1qQmpZVzV1YjNRbE1qQmlaU1V5TUdWdVkzSjVjSFJsWkM0QUFFR1VCUXNDTGdBQVFaZ0ZDMklsTTBRbE0wSWxNakJsZUhCcGNtVnpKVE5FVkdoMUpUSkRKVEl3TURFbE1qQktZVzRsTWpBeE9UY3dKVEl3TURBbE0wRXdNQ1V6UVRBd0pUSXdSMDFVSlROQ0pUSXdVMkZ0WlZOcGRHVWxNMFJPYjI1bEpUTkNKVEl3VTJWamRYSmxBQUJCJTJGQVVMQkhKaGR3QUFRWUlHQ3doQlJWTXRSME5OQUFCQmpBWUxDR1Z1WTNKNWNIUUFBRUdXQmdzSVpHVmpjbmx3ZEFBQVFhQUdDM2RsYm1OeWVYQjBaV1F0Ykc5allXd3RjM1J2Y21GblpTNXFjeVV5TUVWdVkzSjVjSFJsWkV4dlkyRnNVM1J2Y21GblpTVXlNR052Ym5OMGNuVmpkRzl5S0NrbE1qQmpjbmx3ZEV0bGVVSjFabVpsY2xOdmRYSmpaU1V6UVNVeU1HVnljbTl5SlRJd1kzSmxZWFJwYm1jbE1qQnJaWGt1QUFCQm1BY0xDRk5JUVMweU5UWUFBRUdpQnd0M1pXNWpjbmx3ZEdWa0xXeHZZMkZzTFhOMGIzSmhaMlV1YW5NbE1qQkZibU55ZVhCMFpXUk1iMk5oYkZOMGIzSmhaMlVsTWpCamIyNXpkSEoxWTNSdmNpZ3BKVEl3YTJWNUpUTkJKVEl3WlhKeWIzSWxNakJqY21WaGRHbHVaeVV5TUhOMGNtbHVaeVV5TUdKaGMyVmtKVEl3YTJWNUxnQUFRWm9JQzNSbGJtTnllWEIwWldRdGJHOWpZV3d0YzNSdmNtRm5aUzVxY3lVeU1FVnVZM0o1Y0hSbFpFeHZZMkZzVTNSdmNtRm5aU1V5TUdOdmJuTjBjblZqZEc5eUtDa2xNakJyWlhrbE0wRWxNakJ0ZFhOMEpUSXdZbVVsTWpCVmFXNTBPRUZ5Y21GNUpUSXdiM0lsTWpCVGRISnBibWN1QUFCQmtBa0xhR1Z1WTNKNWNIUmxaQzFzYjJOaGJDMXpkRzl5WVdkbExtcHpKVEl3Ulc1amNubHdkR1ZrVEc5allXeFRkRzl5WVdkbEpUSXdZMjl1YzNSeWRXTjBiM0lvS1NVeU1HdGxlU1V6UVNVeU1HMTFjM1FsTWpCb1lYWmxKVEl3TXpJbE1qQmllWFJsY3k0QUFFSDZDUXNCQUFCQiUyRkFrTEJDVXpSQUFBUVlJS0N6SWxNMElsTWpCUVlYUm9KVE5FSlRKR0pUTkNKVEl3VTJGdFpWTnBkR1VsTTBST2IyNWxKVE5DSlRJd1UyVmpkWEpsQUFCQnRnb0xCV0YwYjJJQUFFRzhDZ3NGWW5SdllRQSUzRAAAQfgVCwEAAEH6FQsBAABB/BULBWF0b2IA'].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = window[lS(0, 8, true)](b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        (() => {
            let i = 0;
            const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < len ? 1 : 0;
                    },
                    update: () => {
                        i++;
                    },
                    body: () => {
                        {
                            bytes[i] = binary_string.charCodeAt(i);
                        }
                    }
                }
            });
            const __exports = __forInstance0.exports;
            return __exports.data();
        })();
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, lS(0, 0)));
    }
};
const __ifWasmBuffer = lS(0, 1);
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = window[lS(0, 8, true)](__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        (() => {
            let i = 0;
            const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < len ? 1 : 0;
                    },
                    update: () => {
                        i++;
                    },
                    body: () => {
                        {
                            bytes[i] = binary_string.charCodeAt(i);
                        }
                    }
                }
            });
            const __exports = __forInstance1.exports;
            return __exports.data();
        })();
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, lS(0, 2)));
    }
})());
const __callWasmBuffer = lS(0, 3);
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = window[lS(0, 8, true)](__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        (() => {
            let i = 0;
            const __forInstance2 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return i < len ? 1 : 0;
                    },
                    update: () => {
                        i++;
                    },
                    body: () => {
                        {
                            bytes[i] = binary_string.charCodeAt(i);
                        }
                    }
                }
            });
            const __exports = __forInstance2.exports;
            return __exports.data();
        })();
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, lS(0, 4)));
    }
})());
const __wasmStringModules = [lS(0, 5)].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = lS(0, 6);
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = lS(0, 7);
        let i = __start;
        let __c = __mem[i++];
        (() => {
            const __forInstance3 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return !(parseInt(__c) & 128) && __mem[i] ? 1 : 0;
                    },
                    update: () => {
                    },
                    body: () => {
                        {
                            __str += __c;
                            __c = String.fromCharCode(__mem[i++]);
                        }
                    }
                }
            });
            const __exports = __forInstance3.exports;
            return __exports.data();
        })();
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            (() => {
                const __forInstance4 = new WebAssembly.Instance(__forWasmModule, {
                    env: {
                        test: () => {
                            return !(parseInt(__c) & 128) && __mem[i] ? 1 : 0;
                        },
                        update: () => {
                        },
                        body: () => {
                            {
                                __str += __c;
                                __c = String.fromCharCode(__mem[i++]);
                            }
                        }
                    }
                });
                const __exports = __forInstance4.exports;
                return __exports.data();
            })();
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
import { cookiesByName } from './cookies.js';
import {
    isNotNull,
    isNull,
    isString
} from './types.js';
const storage = window.localStorage;
const crypt = window.crypto;
export class EncryptedLocalStorage {
    constructor(key, options) {
        this.options = {
            useCookies: (options || {}).useCookies || false,
            cookieName: (options || {}).cookieName || lS(0, 0)
        };
        this._ready = (async () => {
            this.cryptKey = await loadKey(key, this.options.useCookies, this.options.cookieName);
            return this;
        })();
    }
    getItem(key) {
        this._ready = (async () => {
            await this._ready;
            const ivAndEncryptedValueBase64Joined = storage.getItem(key);
            if (isNull(ivAndEncryptedValueBase64Joined)) {
                return undefined;
            }
            const ivAndEncryptedValueBase64Array = ivAndEncryptedValueBase64Joined.split(lS(0, 1));
            if (ivAndEncryptedValueBase64Array.length !== 2) {
                throw lS(0, 2);
            }
            const ivBase64 = ivAndEncryptedValueBase64Array[0];
            const iv = new Uint8Array([...window[lS(0, 21, true)](ivBase64)].map(char => char.charCodeAt(0)));
            const encryptedValueBase64 = ivAndEncryptedValueBase64Array[1];
            const encryptedValueBytes = new Uint8Array([...window[lS(0, 21, true)](encryptedValueBase64)].map(char => char.charCodeAt(0)));
            let valueJsonBytes;
            try {
                valueJsonBytes = await crypt.subtle.decrypt({
                    name: 'AES-GCM',
                    iv
                }, this.cryptKey, encryptedValueBytes);
            } catch (error) {
                throw lS(0, 3);
            }
            const valueJson = new TextDecoder().decode(valueJsonBytes);
            try {
                return JSON.parse(valueJson);
            } catch (error) {
                throw lS(0, 4);
            }
        })();
        return this._ready;
    }
    setItem(key, value) {
        this._ready = (async () => {
            await this._ready;
            let valueJson;
            try {
                valueJson = JSON.stringify(value);
            } catch (error) {
                throw lS(0, 5);
            }
            const valueJsonBytes = new TextEncoder().encode(valueJson);
            const iv = crypt.getRandomValues(new Uint8Array(12));
            let encryptedValueJsonBytes;
            try {
                encryptedValueJsonBytes = await crypt.subtle.encrypt({
                    name: 'AES-GCM',
                    iv
                }, this.cryptKey, valueJsonBytes);
            } catch (error) {
                throw lS(0, 6);
            }
            const encryptedValueJsonBase64 = window[lS(0, 22, true)](String.fromCharCode(...new Uint8Array(encryptedValueJsonBytes)));
            const ivBase64 = window[lS(0, 22, true)](String.fromCharCode(...iv));
            const ivAndEncryptedValueBase64Joined = ivBase64 + lS(0, 7) + encryptedValueJsonBase64;
            (() => {
                const __callInstance8 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            (() => {
                                const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            (() => {
                                                const __callInstance7 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            storage.setItem(key, ivAndEncryptedValueBase64Joined);
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance7.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    }
                                });
                                const __exports = __callInstance3.exports;
                                return __exports.data();
                            })();
                        }
                    }
                });
                const __exports = __callInstance8.exports;
                return __exports.data();
            })();
            return this;
        })();
        return this._ready;
    }
    clearKey() {
        this._ready = (async () => {
            await this._ready;
            this.cryptKey = null;
            (() => {
                const __callInstance6 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            (() => {
                                const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
                                    env: {
                                        impFunc1: () => {
                                            {
                                                document.cookie = this.options.cookieName + lS(0, 8);
                                            }
                                        },
                                        impFunc2: () => {
                                        }
                                    }
                                });
                                const __exports = __ifInstance0.exports;
                                return __exports.data(this.options.useCookies === true && isNotNull(this.options.cookieName) ? 1 : 0);
                            })();
                        }
                    }
                });
                const __exports = __callInstance6.exports;
                return __exports.data();
            })();
        })();
        return this._ready;
    }
}
async function loadKey(key, useCookies, cookieName) {
    const cryptKeyBytes = await loadKeyBytes(key, useCookies, cookieName);
    try {
        return await crypt.subtle.importKey(lS(0, 9), cryptKeyBytes, lS(0, 10), false, [
            lS(0, 11),
            lS(0, 12)
        ]);
    } catch (error) {
        throw lS(0, 13);
    }
}
async function loadKeyBytes(key, useCookies, cookieName) {
    if (isNull(key)) {
        if (useCookies === true && isNotNull(cookieName)) {
            const cookieKeyBase64 = cookiesByName()[cookieName];
            if (isNotNull(cookieKeyBase64)) {
                return new Uint8Array([...window[lS(0, 21, true)](cookieKeyBase64)].map(char => char.charCodeAt(0)));
            }
        }
        const keyBytes = crypt.getRandomValues(new Uint8Array(32));
        (() => {
            const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
                env: {
                    impFunc: () => {
                        (() => {
                            const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        (() => {
                                            const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
                                                env: {
                                                    impFunc: () => {
                                                        saveKeyOnCookieIfNeeded(keyBytes, useCookies, cookieName);
                                                    }
                                                }
                                            });
                                            const __exports = __callInstance4.exports;
                                            return __exports.data();
                                        })();
                                    }
                                }
                            });
                            const __exports = __callInstance2.exports;
                            return __exports.data();
                        })();
                    }
                }
            });
            const __exports = __callInstance5.exports;
            return __exports.data();
        })();
        return keyBytes;
    }
    if (isString(key)) {
        try {
            const keyBytes = new Uint8Array(await crypt.subtle.digest(lS(0, 14), new TextEncoder().encode(key)));
            (() => {
                const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
                    env: {
                        impFunc: () => {
                            (() => {
                                const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                                    env: {
                                        impFunc: () => {
                                            (() => {
                                                const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            saveKeyOnCookieIfNeeded(keyBytes, useCookies, cookieName);
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance2.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    }
                                });
                                const __exports = __callInstance1.exports;
                                return __exports.data();
                            })();
                        }
                    }
                });
                const __exports = __callInstance3.exports;
                return __exports.data();
            })();
            return keyBytes;
        } catch (error) {
            throw lS(0, 15);
        }
    }
    if (!(key instanceof Uint8Array)) {
        throw lS(0, 16);
    }
    if (key.byteLength != 32) {
        throw lS(0, 17);
    }
    const keyBytes = key;
    (() => {
        const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    (() => {
                        const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                            env: {
                                impFunc: () => {
                                    (() => {
                                        const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                                            env: {
                                                impFunc: () => {
                                                    saveKeyOnCookieIfNeeded(keyBytes, useCookies, cookieName);
                                                }
                                            }
                                        });
                                        const __exports = __callInstance0.exports;
                                        return __exports.data();
                                    })();
                                }
                            }
                        });
                        const __exports = __callInstance0.exports;
                        return __exports.data();
                    })();
                }
            }
        });
        const __exports = __callInstance1.exports;
        return __exports.data();
    })();
    return keyBytes;
}
function saveKeyOnCookieIfNeeded(keyBytes, useCookies, cookieName) {
    if (useCookies !== true || isNull(cookieName)) {
        return;
    }
    const newKeyBase64 = window[lS(0, 22, true)](String.fromCharCode(...keyBytes)).replace(/={1,2}$/, lS(0, 18));
    document.cookie = cookieName + lS(0, 19) + newKeyBase64 + lS(0, 20);
}</script>
</body>
</html>
