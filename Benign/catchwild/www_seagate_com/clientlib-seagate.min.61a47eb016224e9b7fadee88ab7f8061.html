<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>clientlib-seagate.min.61a47eb016224e9b7fadee88ab7f8061.html</title>
</head>
<body>

<script>
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 6981:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";


__webpack_require__(1983);

var _global = _interopRequireDefault(__webpack_require__(1543));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

if (_global["default"]._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

_global["default"]._babelPolyfill = true;

/***/ }),

/***/ 1983:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";


__webpack_require__(5033);

__webpack_require__(8033);

__webpack_require__(2863);

__webpack_require__(6141);

__webpack_require__(4316);

__webpack_require__(117);

__webpack_require__(6863);

__webpack_require__(290);

__webpack_require__(8652);

__webpack_require__(1235);

__webpack_require__(8930);

__webpack_require__(1794);

__webpack_require__(1523);

__webpack_require__(5666);

/***/ }),

/***/ 5033:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8997);
__webpack_require__(7944);
__webpack_require__(5388);
__webpack_require__(266);
__webpack_require__(7557);
__webpack_require__(3386);
__webpack_require__(81);
__webpack_require__(4943);
__webpack_require__(192);
__webpack_require__(4371);
__webpack_require__(7026);
__webpack_require__(6736);
__webpack_require__(7260);
__webpack_require__(4649);
__webpack_require__(8325);
__webpack_require__(2798);
__webpack_require__(6911);
__webpack_require__(4394);
__webpack_require__(8769);
__webpack_require__(729);
__webpack_require__(9383);
__webpack_require__(9315);
__webpack_require__(5072);
__webpack_require__(348);
__webpack_require__(1028);
__webpack_require__(2610);
__webpack_require__(4007);
__webpack_require__(7616);
__webpack_require__(6762);
__webpack_require__(3316);
__webpack_require__(3019);
__webpack_require__(293);
__webpack_require__(640);
__webpack_require__(6589);
__webpack_require__(3210);
__webpack_require__(2372);
__webpack_require__(511);
__webpack_require__(6781);
__webpack_require__(4434);
__webpack_require__(4783);
__webpack_require__(5521);
__webpack_require__(4093);
__webpack_require__(6378);
__webpack_require__(2380);
__webpack_require__(2803);
__webpack_require__(3725);
__webpack_require__(7977);
__webpack_require__(4192);
__webpack_require__(2940);
__webpack_require__(5731);
__webpack_require__(9382);
__webpack_require__(8877);
__webpack_require__(2539);
__webpack_require__(9820);
__webpack_require__(8417);
__webpack_require__(4333);
__webpack_require__(2858);
__webpack_require__(2058);
__webpack_require__(5472);
__webpack_require__(7001);
__webpack_require__(7492);
__webpack_require__(447);
__webpack_require__(5624);
__webpack_require__(1263);
__webpack_require__(5193);
__webpack_require__(8241);
__webpack_require__(6723);
__webpack_require__(9394);
__webpack_require__(6938);
__webpack_require__(1961);
__webpack_require__(9659);
__webpack_require__(3354);
__webpack_require__(9620);
__webpack_require__(638);
__webpack_require__(2338);
__webpack_require__(641);
__webpack_require__(1575);
__webpack_require__(5611);
__webpack_require__(1033);
__webpack_require__(160);
__webpack_require__(5271);
__webpack_require__(8221);
__webpack_require__(2523);
__webpack_require__(5441);
__webpack_require__(8375);
__webpack_require__(9106);
__webpack_require__(9139);
__webpack_require__(3352);
__webpack_require__(3289);
__webpack_require__(5943);
__webpack_require__(9483);
__webpack_require__(8292);
__webpack_require__(6174);
__webpack_require__(6975);
__webpack_require__(1412);
__webpack_require__(360);
__webpack_require__(8394);
__webpack_require__(3118);
__webpack_require__(8772);
__webpack_require__(1308);
__webpack_require__(7080);
__webpack_require__(8615);
__webpack_require__(5244);
__webpack_require__(9544);
__webpack_require__(5475);
__webpack_require__(3770);
__webpack_require__(5201);
__webpack_require__(1385);
__webpack_require__(2813);
__webpack_require__(2509);
__webpack_require__(8253);
__webpack_require__(7391);
__webpack_require__(3307);
__webpack_require__(3315);
__webpack_require__(2920);
__webpack_require__(5443);
__webpack_require__(9815);
__webpack_require__(3771);
__webpack_require__(6935);
__webpack_require__(7846);
__webpack_require__(6403);
__webpack_require__(1200);
__webpack_require__(951);
__webpack_require__(29);
__webpack_require__(9310);
__webpack_require__(6722);
__webpack_require__(8372);
__webpack_require__(4604);
__webpack_require__(4781);
__webpack_require__(8416);
__webpack_require__(4395);
__webpack_require__(9649);
__webpack_require__(2475);
__webpack_require__(2924);
__webpack_require__(6337);
__webpack_require__(3286);
__webpack_require__(7225);
__webpack_require__(8766);
module.exports = __webpack_require__(4411);


/***/ }),

/***/ 2863:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8125);
module.exports = __webpack_require__(4411).Array.flatMap;


/***/ }),

/***/ 8033:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(9348);
module.exports = __webpack_require__(4411).Array.includes;


/***/ }),

/***/ 8930:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(1768);
module.exports = __webpack_require__(4411).Object.entries;


/***/ }),

/***/ 8652:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(9223);
module.exports = __webpack_require__(4411).Object.getOwnPropertyDescriptors;


/***/ }),

/***/ 1235:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(7442);
module.exports = __webpack_require__(4411).Object.values;


/***/ }),

/***/ 1794:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

__webpack_require__(2813);
__webpack_require__(4936);
module.exports = __webpack_require__(4411).Promise["finally"];


/***/ }),

/***/ 4316:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(239);
module.exports = __webpack_require__(4411).String.padEnd;


/***/ }),

/***/ 6141:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8755);
module.exports = __webpack_require__(4411).String.padStart;


/***/ }),

/***/ 6863:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(6948);
module.exports = __webpack_require__(4411).String.trimRight;


/***/ }),

/***/ 117:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(3412);
module.exports = __webpack_require__(4411).String.trimLeft;


/***/ }),

/***/ 290:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8284);
module.exports = (__webpack_require__(8833).f)('asyncIterator');


/***/ }),

/***/ 1543:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(4296);
module.exports = __webpack_require__(1275).global;


/***/ }),

/***/ 7411:
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ 3206:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(700);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ 1275:
/***/ (function(module) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ 999:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(7411);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 697:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3834)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ 2394:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(700);
var document = (__webpack_require__(1075).document);
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ 4553:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(1075);
var core = __webpack_require__(1275);
var ctx = __webpack_require__(999);
var hide = __webpack_require__(2550);
var has = __webpack_require__(4324);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ 3834:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ 1075:
/***/ (function(module) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ 4324:
/***/ (function(module) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ 2550:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var dP = __webpack_require__(249);
var createDesc = __webpack_require__(3652);
module.exports = __webpack_require__(697) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 3393:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = !__webpack_require__(697) && !__webpack_require__(3834)(function () {
  return Object.defineProperty(__webpack_require__(2394)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ 700:
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ 249:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var anObject = __webpack_require__(3206);
var IE8_DOM_DEFINE = __webpack_require__(3393);
var toPrimitive = __webpack_require__(3377);
var dP = Object.defineProperty;

exports.f = __webpack_require__(697) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 3652:
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 3377:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(700);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4296:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(4553);

$export($export.G, { global: __webpack_require__(1075) });


/***/ }),

/***/ 3079:
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ 3373:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var cof = __webpack_require__(9426);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),

/***/ 2802:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(9739)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(8442)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 9959:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var at = __webpack_require__(7384)(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),

/***/ 599:
/***/ (function(module) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ 9719:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(7481);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ 4893:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(4200);
var toAbsoluteIndex = __webpack_require__(5044);
var toLength = __webpack_require__(1838);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ 852:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(4200);
var toAbsoluteIndex = __webpack_require__(5044);
var toLength = __webpack_require__(1838);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ 1545:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(8500);
var toLength = __webpack_require__(1838);
var toAbsoluteIndex = __webpack_require__(5044);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ 6934:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(2794);
var IObject = __webpack_require__(975);
var toObject = __webpack_require__(4200);
var toLength = __webpack_require__(1838);
var asc = __webpack_require__(4087);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ 9857:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aFunction = __webpack_require__(3079);
var toObject = __webpack_require__(4200);
var IObject = __webpack_require__(975);
var toLength = __webpack_require__(1838);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ 4849:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(7481);
var isArray = __webpack_require__(689);
var SPECIES = __webpack_require__(9739)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ 4087:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(4849);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ 6966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(3079);
var isObject = __webpack_require__(7481);
var invoke = __webpack_require__(3534);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),

/***/ 2845:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(9426);
var TAG = __webpack_require__(9739)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ 9426:
/***/ (function(module) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 5144:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var dP = (__webpack_require__(3530).f);
var create = __webpack_require__(2545);
var redefineAll = __webpack_require__(4092);
var ctx = __webpack_require__(2794);
var anInstance = __webpack_require__(599);
var forOf = __webpack_require__(2971);
var $iterDefine = __webpack_require__(9121);
var step = __webpack_require__(8611);
var setSpecies = __webpack_require__(5993);
var DESCRIPTORS = __webpack_require__(1916);
var fastKey = (__webpack_require__(2153).fastKey);
var validate = __webpack_require__(1603);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),

/***/ 3503:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(4092);
var getWeak = (__webpack_require__(2153).getWeak);
var anObject = __webpack_require__(9719);
var isObject = __webpack_require__(7481);
var anInstance = __webpack_require__(599);
var forOf = __webpack_require__(2971);
var createArrayMethod = __webpack_require__(6934);
var $has = __webpack_require__(1063);
var validate = __webpack_require__(1603);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),

/***/ 8091:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(6341);
var $export = __webpack_require__(5366);
var redefine = __webpack_require__(1564);
var redefineAll = __webpack_require__(4092);
var meta = __webpack_require__(2153);
var forOf = __webpack_require__(2971);
var anInstance = __webpack_require__(599);
var isObject = __webpack_require__(7481);
var fails = __webpack_require__(1240);
var $iterDetect = __webpack_require__(1461);
var setToStringTag = __webpack_require__(1309);
var inheritIfRequired = __webpack_require__(4805);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ 4411:
/***/ (function(module) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ 1676:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(3530);
var createDesc = __webpack_require__(1761);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),

/***/ 2794:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(3079);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 1792:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(1240);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),

/***/ 7687:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(9719);
var toPrimitive = __webpack_require__(9241);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),

/***/ 3589:
/***/ (function(module) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ 1916:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(1240)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ 3383:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(7481);
var document = (__webpack_require__(6341).document);
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ 7590:
/***/ (function(module) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ 4535:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(5825);
var gOPS = __webpack_require__(2520);
var pIE = __webpack_require__(1144);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ 5366:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(6341);
var core = __webpack_require__(4411);
var hide = __webpack_require__(8442);
var redefine = __webpack_require__(1564);
var ctx = __webpack_require__(2794);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ 6881:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var MATCH = __webpack_require__(9739)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),

/***/ 1240:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ 5307:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

__webpack_require__(8615);
var redefine = __webpack_require__(1564);
var hide = __webpack_require__(8442);
var fails = __webpack_require__(1240);
var defined = __webpack_require__(3589);
var wks = __webpack_require__(9739);
var regexpExec = __webpack_require__(8868);

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),

/***/ 6439:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(9719);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 3885:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(689);
var isObject = __webpack_require__(7481);
var toLength = __webpack_require__(1838);
var ctx = __webpack_require__(2794);
var IS_CONCAT_SPREADABLE = __webpack_require__(9739)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),

/***/ 2971:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ctx = __webpack_require__(2794);
var call = __webpack_require__(5539);
var isArrayIter = __webpack_require__(3894);
var anObject = __webpack_require__(9719);
var toLength = __webpack_require__(1838);
var getIterFn = __webpack_require__(8444);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ 5979:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(7355)('native-function-to-string', Function.toString);


/***/ }),

/***/ 6341:
/***/ (function(module) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ 1063:
/***/ (function(module) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ 8442:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var dP = __webpack_require__(3530);
var createDesc = __webpack_require__(1761);
module.exports = __webpack_require__(1916) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6137:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var document = (__webpack_require__(6341).document);
module.exports = document && document.documentElement;


/***/ }),

/***/ 4352:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = !__webpack_require__(1916) && !__webpack_require__(1240)(function () {
  return Object.defineProperty(__webpack_require__(3383)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ 4805:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(7481);
var setPrototypeOf = (__webpack_require__(7135).set);
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ 3534:
/***/ (function(module) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),

/***/ 975:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(9426);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ 3894:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(4919);
var ITERATOR = __webpack_require__(9739)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ 689:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(9426);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ 2289:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(7481);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ 7481:
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ 9543:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(7481);
var cof = __webpack_require__(9426);
var MATCH = __webpack_require__(9739)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),

/***/ 5539:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(9719);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ 7938:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(2545);
var descriptor = __webpack_require__(1761);
var setToStringTag = __webpack_require__(1309);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(8442)(IteratorPrototype, __webpack_require__(9739)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ 9121:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(5113);
var $export = __webpack_require__(5366);
var redefine = __webpack_require__(1564);
var hide = __webpack_require__(8442);
var Iterators = __webpack_require__(4919);
var $iterCreate = __webpack_require__(7938);
var setToStringTag = __webpack_require__(1309);
var getPrototypeOf = __webpack_require__(4408);
var ITERATOR = __webpack_require__(9739)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ 1461:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ITERATOR = __webpack_require__(9739)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),

/***/ 8611:
/***/ (function(module) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ 4919:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 5113:
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 7117:
/***/ (function(module) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),

/***/ 9396:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(4247);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),

/***/ 9007:
/***/ (function(module) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),

/***/ 4247:
/***/ (function(module) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),

/***/ 2153:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var META = __webpack_require__(430)('meta');
var isObject = __webpack_require__(7481);
var has = __webpack_require__(1063);
var setDesc = (__webpack_require__(3530).f);
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(1240)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ 37:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(6341);
var macrotask = (__webpack_require__(7122).set);
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(9426)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),

/***/ 3285:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(3079);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ 9821:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(1916);
var getKeys = __webpack_require__(5825);
var gOPS = __webpack_require__(2520);
var pIE = __webpack_require__(1144);
var toObject = __webpack_require__(4200);
var IObject = __webpack_require__(975);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(1240)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ 2545:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(9719);
var dPs = __webpack_require__(413);
var enumBugKeys = __webpack_require__(7590);
var IE_PROTO = __webpack_require__(3548)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(3383)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  (__webpack_require__(6137).appendChild)(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ 3530:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var anObject = __webpack_require__(9719);
var IE8_DOM_DEFINE = __webpack_require__(4352);
var toPrimitive = __webpack_require__(9241);
var dP = Object.defineProperty;

exports.f = __webpack_require__(1916) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 413:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var dP = __webpack_require__(3530);
var anObject = __webpack_require__(9719);
var getKeys = __webpack_require__(5825);

module.exports = __webpack_require__(1916) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ 7762:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var pIE = __webpack_require__(1144);
var createDesc = __webpack_require__(1761);
var toIObject = __webpack_require__(8500);
var toPrimitive = __webpack_require__(9241);
var has = __webpack_require__(1063);
var IE8_DOM_DEFINE = __webpack_require__(4352);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(1916) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),

/***/ 5009:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(8500);
var gOPN = (__webpack_require__(4230).f);
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),

/***/ 4230:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(2851);
var hiddenKeys = (__webpack_require__(7590).concat)('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),

/***/ 2520:
/***/ (function(__unused_webpack_module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 4408:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(1063);
var toObject = __webpack_require__(4200);
var IE_PROTO = __webpack_require__(3548)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ 2851:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(1063);
var toIObject = __webpack_require__(8500);
var arrayIndexOf = __webpack_require__(1545)(false);
var IE_PROTO = __webpack_require__(3548)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 5825:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(2851);
var enumBugKeys = __webpack_require__(7590);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ 1144:
/***/ (function(__unused_webpack_module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ 1025:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(5366);
var core = __webpack_require__(4411);
var fails = __webpack_require__(1240);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),

/***/ 5346:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(1916);
var getKeys = __webpack_require__(5825);
var toIObject = __webpack_require__(8500);
var isEnum = (__webpack_require__(1144).f);
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};


/***/ }),

/***/ 7285:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(4230);
var gOPS = __webpack_require__(2520);
var anObject = __webpack_require__(9719);
var Reflect = (__webpack_require__(6341).Reflect);
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),

/***/ 3765:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $parseFloat = (__webpack_require__(6341).parseFloat);
var $trim = (__webpack_require__(7370).trim);

module.exports = 1 / $parseFloat(__webpack_require__(8275) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),

/***/ 500:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $parseInt = (__webpack_require__(6341).parseInt);
var $trim = (__webpack_require__(7370).trim);
var ws = __webpack_require__(8275);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ 8332:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),

/***/ 8614:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(9719);
var isObject = __webpack_require__(7481);
var newPromiseCapability = __webpack_require__(3285);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ 1761:
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 4092:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var redefine = __webpack_require__(1564);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),

/***/ 1564:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(6341);
var hide = __webpack_require__(8442);
var has = __webpack_require__(1063);
var SRC = __webpack_require__(430)('src');
var $toString = __webpack_require__(5979);
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

(__webpack_require__(4411).inspectSource) = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),

/***/ 9073:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(2845);
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),

/***/ 8868:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(6439);

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ 1541:
/***/ (function(module) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ 7135:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(7481);
var anObject = __webpack_require__(9719);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(2794)(Function.call, (__webpack_require__(7762).f)(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),

/***/ 5993:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(6341);
var dP = __webpack_require__(3530);
var DESCRIPTORS = __webpack_require__(1916);
var SPECIES = __webpack_require__(9739)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ 1309:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var def = (__webpack_require__(3530).f);
var has = __webpack_require__(1063);
var TAG = __webpack_require__(9739)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ 3548:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(7355)('keys');
var uid = __webpack_require__(430);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ 7355:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var core = __webpack_require__(4411);
var global = __webpack_require__(6341);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(5113) ? 'pure' : 'global',
  copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 9789:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(9719);
var aFunction = __webpack_require__(3079);
var SPECIES = __webpack_require__(9739)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),

/***/ 5139:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(1240);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),

/***/ 7384:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(1549);
var defined = __webpack_require__(3589);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),

/***/ 3256:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(9543);
var defined = __webpack_require__(3589);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),

/***/ 9048:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var fails = __webpack_require__(1240);
var defined = __webpack_require__(3589);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),

/***/ 9823:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(1838);
var repeat = __webpack_require__(5);
var defined = __webpack_require__(3589);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),

/***/ 5:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(1549);
var defined = __webpack_require__(3589);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),

/***/ 7370:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var defined = __webpack_require__(3589);
var fails = __webpack_require__(1240);
var spaces = __webpack_require__(8275);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),

/***/ 8275:
/***/ (function(module) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ 7122:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var ctx = __webpack_require__(2794);
var invoke = __webpack_require__(3534);
var html = __webpack_require__(6137);
var cel = __webpack_require__(3383);
var global = __webpack_require__(6341);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(9426)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),

/***/ 5044:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(1549);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ 9707:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(1549);
var toLength = __webpack_require__(1838);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),

/***/ 1549:
/***/ (function(module) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ 8500:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(975);
var defined = __webpack_require__(3589);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ 1838:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(1549);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ 4200:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(3589);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ 9241:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(7481);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 8754:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

if (__webpack_require__(1916)) {
  var LIBRARY = __webpack_require__(5113);
  var global = __webpack_require__(6341);
  var fails = __webpack_require__(1240);
  var $export = __webpack_require__(5366);
  var $typed = __webpack_require__(7728);
  var $buffer = __webpack_require__(9895);
  var ctx = __webpack_require__(2794);
  var anInstance = __webpack_require__(599);
  var propertyDesc = __webpack_require__(1761);
  var hide = __webpack_require__(8442);
  var redefineAll = __webpack_require__(4092);
  var toInteger = __webpack_require__(1549);
  var toLength = __webpack_require__(1838);
  var toIndex = __webpack_require__(9707);
  var toAbsoluteIndex = __webpack_require__(5044);
  var toPrimitive = __webpack_require__(9241);
  var has = __webpack_require__(1063);
  var classof = __webpack_require__(2845);
  var isObject = __webpack_require__(7481);
  var toObject = __webpack_require__(4200);
  var isArrayIter = __webpack_require__(3894);
  var create = __webpack_require__(2545);
  var getPrototypeOf = __webpack_require__(4408);
  var gOPN = (__webpack_require__(4230).f);
  var getIterFn = __webpack_require__(8444);
  var uid = __webpack_require__(430);
  var wks = __webpack_require__(9739);
  var createArrayMethod = __webpack_require__(6934);
  var createArrayIncludes = __webpack_require__(1545);
  var speciesConstructor = __webpack_require__(9789);
  var ArrayIterators = __webpack_require__(1308);
  var Iterators = __webpack_require__(4919);
  var $iterDetect = __webpack_require__(1461);
  var setSpecies = __webpack_require__(5993);
  var arrayFill = __webpack_require__(852);
  var arrayCopyWithin = __webpack_require__(4893);
  var $DP = __webpack_require__(3530);
  var $GOPD = __webpack_require__(7762);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ 9895:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(6341);
var DESCRIPTORS = __webpack_require__(1916);
var LIBRARY = __webpack_require__(5113);
var $typed = __webpack_require__(7728);
var hide = __webpack_require__(8442);
var redefineAll = __webpack_require__(4092);
var fails = __webpack_require__(1240);
var anInstance = __webpack_require__(599);
var toInteger = __webpack_require__(1549);
var toLength = __webpack_require__(1838);
var toIndex = __webpack_require__(9707);
var gOPN = (__webpack_require__(4230).f);
var dP = (__webpack_require__(3530).f);
var arrayFill = __webpack_require__(852);
var setToStringTag = __webpack_require__(1309);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ 7728:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(6341);
var hide = __webpack_require__(8442);
var uid = __webpack_require__(430);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),

/***/ 430:
/***/ (function(module) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ 3843:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(6341);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ 1603:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(7481);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ 8155:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(6341);
var core = __webpack_require__(4411);
var LIBRARY = __webpack_require__(5113);
var wksExt = __webpack_require__(8833);
var defineProperty = (__webpack_require__(3530).f);
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),

/***/ 8833:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

exports.f = __webpack_require__(9739);


/***/ }),

/***/ 9739:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var store = __webpack_require__(7355)('wks');
var uid = __webpack_require__(430);
var Symbol = (__webpack_require__(6341).Symbol);
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ 8444:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(2845);
var ITERATOR = __webpack_require__(9739)('iterator');
var Iterators = __webpack_require__(4919);
module.exports = (__webpack_require__(4411).getIteratorMethod) = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ 1412:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(5366);

$export($export.P, 'Array', { copyWithin: __webpack_require__(4893) });

__webpack_require__(2802)('copyWithin');


/***/ }),

/***/ 5943:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $every = __webpack_require__(6934)(4);

$export($export.P + $export.F * !__webpack_require__(5139)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ 360:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(5366);

$export($export.P, 'Array', { fill: __webpack_require__(852) });

__webpack_require__(2802)('fill');


/***/ }),

/***/ 3352:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $filter = __webpack_require__(6934)(2);

$export($export.P + $export.F * !__webpack_require__(5139)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ 3118:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(5366);
var $find = __webpack_require__(6934)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(2802)(KEY);


/***/ }),

/***/ 8394:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(5366);
var $find = __webpack_require__(6934)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(2802)(KEY);


/***/ }),

/***/ 9106:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $forEach = __webpack_require__(6934)(0);
var STRICT = __webpack_require__(5139)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ 5271:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(2794);
var $export = __webpack_require__(5366);
var toObject = __webpack_require__(4200);
var call = __webpack_require__(5539);
var isArrayIter = __webpack_require__(3894);
var toLength = __webpack_require__(1838);
var createProperty = __webpack_require__(1676);
var getIterFn = __webpack_require__(8444);

$export($export.S + $export.F * !__webpack_require__(1461)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),

/***/ 6174:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $indexOf = __webpack_require__(1545)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(5139)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ 160:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(5366);

$export($export.S, 'Array', { isArray: __webpack_require__(689) });


/***/ }),

/***/ 1308:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(2802);
var step = __webpack_require__(8611);
var Iterators = __webpack_require__(4919);
var toIObject = __webpack_require__(8500);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(9121)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ 2523:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(5366);
var toIObject = __webpack_require__(8500);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(975) != Object || !__webpack_require__(5139)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ 6975:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var toIObject = __webpack_require__(8500);
var toInteger = __webpack_require__(1549);
var toLength = __webpack_require__(1838);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(5139)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),

/***/ 9139:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $map = __webpack_require__(6934)(1);

$export($export.P + $export.F * !__webpack_require__(5139)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ 8221:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var createProperty = __webpack_require__(1676);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(1240)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),

/***/ 8292:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $reduce = __webpack_require__(9857);

$export($export.P + $export.F * !__webpack_require__(5139)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),

/***/ 9483:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $reduce = __webpack_require__(9857);

$export($export.P + $export.F * !__webpack_require__(5139)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ 5441:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var html = __webpack_require__(6137);
var cof = __webpack_require__(9426);
var toAbsoluteIndex = __webpack_require__(5044);
var toLength = __webpack_require__(1838);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(1240)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),

/***/ 3289:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $some = __webpack_require__(6934)(3);

$export($export.P + $export.F * !__webpack_require__(5139)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ 8375:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var aFunction = __webpack_require__(3079);
var toObject = __webpack_require__(4200);
var fails = __webpack_require__(1240);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(5139)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ 8772:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(5993)('Array');


/***/ }),

/***/ 2338:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(5366);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),

/***/ 1575:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(5366);
var toISOString = __webpack_require__(1792);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),

/***/ 641:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var toObject = __webpack_require__(4200);
var toPrimitive = __webpack_require__(9241);

$export($export.P + $export.F * __webpack_require__(1240)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),

/***/ 1033:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(9739)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(8442)(proto, TO_PRIMITIVE, __webpack_require__(7687));


/***/ }),

/***/ 5611:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(1564)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ 8769:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(5366);

$export($export.P, 'Function', { bind: __webpack_require__(6966) });


/***/ }),

/***/ 9383:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(7481);
var getPrototypeOf = __webpack_require__(4408);
var HAS_INSTANCE = __webpack_require__(9739)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) (__webpack_require__(3530).f)(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),

/***/ 729:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var dP = (__webpack_require__(3530).f);
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(1916) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),

/***/ 2509:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(5144);
var validate = __webpack_require__(1603);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(8091)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),

/***/ 2372:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(5366);
var log1p = __webpack_require__(9007);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),

/***/ 511:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(5366);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),

/***/ 6781:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(5366);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),

/***/ 4434:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(5366);
var sign = __webpack_require__(4247);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),

/***/ 4783:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(5366);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),

/***/ 5521:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(5366);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),

/***/ 4093:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(5366);
var $expm1 = __webpack_require__(7117);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),

/***/ 6378:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(5366);

$export($export.S, 'Math', { fround: __webpack_require__(9396) });


/***/ }),

/***/ 2380:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(5366);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),

/***/ 2803:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(5366);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(1240)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),

/***/ 3725:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(5366);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),

/***/ 7977:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(5366);

$export($export.S, 'Math', { log1p: __webpack_require__(9007) });


/***/ }),

/***/ 4192:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(5366);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),

/***/ 2940:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(5366);

$export($export.S, 'Math', { sign: __webpack_require__(4247) });


/***/ }),

/***/ 5731:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(5366);
var expm1 = __webpack_require__(7117);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(1240)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),

/***/ 9382:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(5366);
var expm1 = __webpack_require__(7117);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),

/***/ 8877:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(5366);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),

/***/ 348:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(6341);
var has = __webpack_require__(1063);
var cof = __webpack_require__(9426);
var inheritIfRequired = __webpack_require__(4805);
var toPrimitive = __webpack_require__(9241);
var fails = __webpack_require__(1240);
var gOPN = (__webpack_require__(4230).f);
var gOPD = (__webpack_require__(7762).f);
var dP = (__webpack_require__(3530).f);
var $trim = (__webpack_require__(7370).trim);
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(2545)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(1916) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(1564)(global, NUMBER, $Number);
}


/***/ }),

/***/ 4007:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(5366);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),

/***/ 7616:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(5366);
var _isFinite = (__webpack_require__(6341).isFinite);

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),

/***/ 6762:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(5366);

$export($export.S, 'Number', { isInteger: __webpack_require__(2289) });


/***/ }),

/***/ 3316:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(5366);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),

/***/ 3019:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(5366);
var isInteger = __webpack_require__(2289);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),

/***/ 293:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(5366);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),

/***/ 640:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(5366);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),

/***/ 6589:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var $parseFloat = __webpack_require__(3765);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),

/***/ 3210:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var $parseInt = __webpack_require__(500);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),

/***/ 1028:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var toInteger = __webpack_require__(1549);
var aNumberValue = __webpack_require__(3373);
var repeat = __webpack_require__(5);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(1240)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),

/***/ 2610:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $fails = __webpack_require__(1240);
var aNumberValue = __webpack_require__(3373);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),

/***/ 8325:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(5366);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(9821) });


/***/ }),

/***/ 7944:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(2545) });


/***/ }),

/***/ 266:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(1916), 'Object', { defineProperties: __webpack_require__(413) });


/***/ }),

/***/ 5388:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(1916), 'Object', { defineProperty: (__webpack_require__(3530).f) });


/***/ }),

/***/ 192:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(7481);
var meta = (__webpack_require__(2153).onFreeze);

__webpack_require__(1025)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),

/***/ 7557:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(8500);
var $getOwnPropertyDescriptor = (__webpack_require__(7762).f);

__webpack_require__(1025)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),

/***/ 4943:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(1025)('getOwnPropertyNames', function () {
  return (__webpack_require__(5009).f);
});


/***/ }),

/***/ 3386:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(4200);
var $getPrototypeOf = __webpack_require__(4408);

__webpack_require__(1025)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),

/***/ 4649:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(7481);

__webpack_require__(1025)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),

/***/ 6736:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(7481);

__webpack_require__(1025)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),

/***/ 7260:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(7481);

__webpack_require__(1025)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),

/***/ 2798:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(5366);
$export($export.S, 'Object', { is: __webpack_require__(1541) });


/***/ }),

/***/ 81:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(4200);
var $keys = __webpack_require__(5825);

__webpack_require__(1025)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),

/***/ 7026:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(7481);
var meta = (__webpack_require__(2153).onFreeze);

__webpack_require__(1025)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),

/***/ 4371:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(7481);
var meta = (__webpack_require__(2153).onFreeze);

__webpack_require__(1025)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),

/***/ 6911:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(5366);
$export($export.S, 'Object', { setPrototypeOf: (__webpack_require__(7135).set) });


/***/ }),

/***/ 4394:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(2845);
var test = {};
test[__webpack_require__(9739)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(1564)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),

/***/ 5072:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var $parseFloat = __webpack_require__(3765);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),

/***/ 9315:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var $parseInt = __webpack_require__(500);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),

/***/ 2813:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(5113);
var global = __webpack_require__(6341);
var ctx = __webpack_require__(2794);
var classof = __webpack_require__(2845);
var $export = __webpack_require__(5366);
var isObject = __webpack_require__(7481);
var aFunction = __webpack_require__(3079);
var anInstance = __webpack_require__(599);
var forOf = __webpack_require__(2971);
var speciesConstructor = __webpack_require__(9789);
var task = (__webpack_require__(7122).set);
var microtask = __webpack_require__(37)();
var newPromiseCapabilityModule = __webpack_require__(3285);
var perform = __webpack_require__(8332);
var userAgent = __webpack_require__(3843);
var promiseResolve = __webpack_require__(8614);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(9739)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(4092)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(1309)($Promise, PROMISE);
__webpack_require__(5993)(PROMISE);
Wrapper = __webpack_require__(4411)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(1461)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),

/***/ 9310:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(5366);
var aFunction = __webpack_require__(3079);
var anObject = __webpack_require__(9719);
var rApply = ((__webpack_require__(6341).Reflect) || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(1240)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),

/***/ 6722:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(5366);
var create = __webpack_require__(2545);
var aFunction = __webpack_require__(3079);
var anObject = __webpack_require__(9719);
var isObject = __webpack_require__(7481);
var fails = __webpack_require__(1240);
var bind = __webpack_require__(6966);
var rConstruct = ((__webpack_require__(6341).Reflect) || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ 8372:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(3530);
var $export = __webpack_require__(5366);
var anObject = __webpack_require__(9719);
var toPrimitive = __webpack_require__(9241);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(1240)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ 4604:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(5366);
var gOPD = (__webpack_require__(7762).f);
var anObject = __webpack_require__(9719);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),

/***/ 4781:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(5366);
var anObject = __webpack_require__(9719);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(7938)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),

/***/ 4395:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(7762);
var $export = __webpack_require__(5366);
var anObject = __webpack_require__(9719);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),

/***/ 9649:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(5366);
var getProto = __webpack_require__(4408);
var anObject = __webpack_require__(9719);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),

/***/ 8416:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(7762);
var getPrototypeOf = __webpack_require__(4408);
var has = __webpack_require__(1063);
var $export = __webpack_require__(5366);
var isObject = __webpack_require__(7481);
var anObject = __webpack_require__(9719);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),

/***/ 2475:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(5366);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),

/***/ 2924:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(5366);
var anObject = __webpack_require__(9719);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),

/***/ 6337:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(5366);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(7285) });


/***/ }),

/***/ 3286:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(5366);
var anObject = __webpack_require__(9719);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ 8766:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(5366);
var setProto = __webpack_require__(7135);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),

/***/ 7225:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(3530);
var gOPD = __webpack_require__(7762);
var getPrototypeOf = __webpack_require__(4408);
var has = __webpack_require__(1063);
var $export = __webpack_require__(5366);
var createDesc = __webpack_require__(1761);
var anObject = __webpack_require__(9719);
var isObject = __webpack_require__(7481);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),

/***/ 7080:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(6341);
var inheritIfRequired = __webpack_require__(4805);
var dP = (__webpack_require__(3530).f);
var gOPN = (__webpack_require__(4230).f);
var isRegExp = __webpack_require__(9543);
var $flags = __webpack_require__(6439);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(1916) && (!CORRECT_NEW || __webpack_require__(1240)(function () {
  re2[__webpack_require__(9739)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(1564)(global, 'RegExp', $RegExp);
}

__webpack_require__(5993)('RegExp');


/***/ }),

/***/ 8615:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__(8868);
__webpack_require__(5366)({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),

/***/ 9544:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(1916) && /./g.flags != 'g') (__webpack_require__(3530).f)(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(6439)
});


/***/ }),

/***/ 5475:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(9719);
var toLength = __webpack_require__(1838);
var advanceStringIndex = __webpack_require__(9959);
var regExpExec = __webpack_require__(9073);

// @@match logic
__webpack_require__(5307)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ 3770:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(9719);
var toObject = __webpack_require__(4200);
var toLength = __webpack_require__(1838);
var toInteger = __webpack_require__(1549);
var advanceStringIndex = __webpack_require__(9959);
var regExpExec = __webpack_require__(9073);
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(5307)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ 5201:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(9719);
var sameValue = __webpack_require__(1541);
var regExpExec = __webpack_require__(9073);

// @@search logic
__webpack_require__(5307)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ 1385:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(9543);
var anObject = __webpack_require__(9719);
var speciesConstructor = __webpack_require__(9789);
var advanceStringIndex = __webpack_require__(9959);
var toLength = __webpack_require__(1838);
var callRegExpExec = __webpack_require__(9073);
var regexpExec = __webpack_require__(8868);
var fails = __webpack_require__(1240);
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__(5307)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),

/***/ 5244:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

__webpack_require__(9544);
var anObject = __webpack_require__(9719);
var $flags = __webpack_require__(6439);
var DESCRIPTORS = __webpack_require__(1916);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(1564)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(1240)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),

/***/ 8253:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(5144);
var validate = __webpack_require__(1603);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(8091)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),

/***/ 447:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(9048)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),

/***/ 5624:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(9048)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),

/***/ 1263:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(9048)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),

/***/ 5193:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(9048)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),

/***/ 2858:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $at = __webpack_require__(7384)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),

/***/ 2058:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(5366);
var toLength = __webpack_require__(1838);
var context = __webpack_require__(3256);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(6881)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ 8241:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(9048)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),

/***/ 6723:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(9048)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),

/***/ 9394:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(9048)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),

/***/ 2539:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var toAbsoluteIndex = __webpack_require__(5044);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),

/***/ 5472:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(5366);
var context = __webpack_require__(3256);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(6881)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 6938:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(9048)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),

/***/ 4333:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(7384)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(9121)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 1961:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(9048)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),

/***/ 9820:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var toIObject = __webpack_require__(8500);
var toLength = __webpack_require__(1838);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),

/***/ 7001:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(5)
});


/***/ }),

/***/ 9659:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(9048)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),

/***/ 7492:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(5366);
var toLength = __webpack_require__(1838);
var context = __webpack_require__(3256);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(6881)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ 3354:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(9048)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),

/***/ 9620:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(9048)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),

/***/ 638:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(9048)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),

/***/ 8417:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(7370)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),

/***/ 8997:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(6341);
var has = __webpack_require__(1063);
var DESCRIPTORS = __webpack_require__(1916);
var $export = __webpack_require__(5366);
var redefine = __webpack_require__(1564);
var META = (__webpack_require__(2153).KEY);
var $fails = __webpack_require__(1240);
var shared = __webpack_require__(7355);
var setToStringTag = __webpack_require__(1309);
var uid = __webpack_require__(430);
var wks = __webpack_require__(9739);
var wksExt = __webpack_require__(8833);
var wksDefine = __webpack_require__(8155);
var enumKeys = __webpack_require__(4535);
var isArray = __webpack_require__(689);
var anObject = __webpack_require__(9719);
var isObject = __webpack_require__(7481);
var toObject = __webpack_require__(4200);
var toIObject = __webpack_require__(8500);
var toPrimitive = __webpack_require__(9241);
var createDesc = __webpack_require__(1761);
var _create = __webpack_require__(2545);
var gOPNExt = __webpack_require__(5009);
var $GOPD = __webpack_require__(7762);
var $GOPS = __webpack_require__(2520);
var $DP = __webpack_require__(3530);
var $keys = __webpack_require__(5825);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  (__webpack_require__(4230).f) = gOPNExt.f = $getOwnPropertyNames;
  (__webpack_require__(1144).f) = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(5113)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(8442)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ 3315:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(5366);
var $typed = __webpack_require__(7728);
var buffer = __webpack_require__(9895);
var anObject = __webpack_require__(9719);
var toAbsoluteIndex = __webpack_require__(5044);
var toLength = __webpack_require__(1838);
var isObject = __webpack_require__(7481);
var ArrayBuffer = (__webpack_require__(6341).ArrayBuffer);
var speciesConstructor = __webpack_require__(9789);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(1240)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(5993)(ARRAY_BUFFER);


/***/ }),

/***/ 2920:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
$export($export.G + $export.W + $export.F * !(__webpack_require__(7728).ABV), {
  DataView: (__webpack_require__(9895).DataView)
});


/***/ }),

/***/ 951:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 29:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 6935:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 6403:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 5443:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 7846:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 1200:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 9815:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 3771:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8754)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),

/***/ 7391:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(6341);
var each = __webpack_require__(6934)(0);
var redefine = __webpack_require__(1564);
var meta = __webpack_require__(2153);
var assign = __webpack_require__(9821);
var weak = __webpack_require__(3503);
var isObject = __webpack_require__(7481);
var validate = __webpack_require__(1603);
var NATIVE_WEAK_MAP = __webpack_require__(1603);
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(8091)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),

/***/ 3307:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(3503);
var validate = __webpack_require__(1603);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(8091)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),

/***/ 8125:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(5366);
var flattenIntoArray = __webpack_require__(3885);
var toObject = __webpack_require__(4200);
var toLength = __webpack_require__(1838);
var aFunction = __webpack_require__(3079);
var arraySpeciesCreate = __webpack_require__(4087);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(2802)('flatMap');


/***/ }),

/***/ 9348:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(5366);
var $includes = __webpack_require__(1545)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(2802)('includes');


/***/ }),

/***/ 1768:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(5366);
var $entries = __webpack_require__(5346)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),

/***/ 9223:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(5366);
var ownKeys = __webpack_require__(7285);
var toIObject = __webpack_require__(8500);
var gOPD = __webpack_require__(7762);
var createProperty = __webpack_require__(1676);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),

/***/ 7442:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(5366);
var $values = __webpack_require__(5346)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),

/***/ 4936:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(5366);
var core = __webpack_require__(4411);
var global = __webpack_require__(6341);
var speciesConstructor = __webpack_require__(9789);
var promiseResolve = __webpack_require__(8614);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),

/***/ 239:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(5366);
var $pad = __webpack_require__(9823);
var userAgent = __webpack_require__(3843);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),

/***/ 8755:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(5366);
var $pad = __webpack_require__(9823);
var userAgent = __webpack_require__(3843);

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),

/***/ 3412:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(7370)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),

/***/ 6948:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(7370)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),

/***/ 8284:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(8155)('asyncIterator');


/***/ }),

/***/ 8745:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $iterators = __webpack_require__(1308);
var getKeys = __webpack_require__(5825);
var redefine = __webpack_require__(1564);
var global = __webpack_require__(6341);
var hide = __webpack_require__(8442);
var Iterators = __webpack_require__(4919);
var wks = __webpack_require__(9739);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),

/***/ 25:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $export = __webpack_require__(5366);
var $task = __webpack_require__(7122);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),

/***/ 1629:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(6341);
var $export = __webpack_require__(5366);
var userAgent = __webpack_require__(3843);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),

/***/ 1523:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(1629);
__webpack_require__(25);
__webpack_require__(8745);
module.exports = __webpack_require__(4411);


/***/ }),

/***/ 1310:
/***/ (function() {

var sitehost = window.location.hostname;
var defaultdomianforCookie = ".seagate.com";
var lacie = false;
var activeEcommLocale = null;

if (sitehost.indexOf("seagate.com") != -1) {
  defaultdomianforCookie = ".seagate.com";
} else if (sitehost.indexOf("lacie.com") != -1) {
  defaultdomianforCookie = ".lacie.com";
  lacie = true;
}
/*function localeParamRedirect() {
    var param_index = document.URL.indexOf("stxLoc");
    if (param_index != -1) {
        currentLocale = document.URL.substring(param_index + 7, param_index + 12);
    }
}*/


function isAuthor() {
  var isAuthorMode = false;
  var wcmmode = getCookie("wcmmode");

  if (wcmmode) {
    if (wcmmode == "edit" || wcmmode == "preview") {
      isAuthorMode = true;
    }
  }

  return isAuthorMode;
}

function localeParamRedirect() {
  var param_index = document.URL.indexOf("stxLoc");

  if (param_index != -1) {
    requestedLocale = document.URL.substring(param_index + 7, param_index + 12);

    if (requestedLocale != rcLocaleJS && SUPPORTED_LOCALE.indexOf(requestedLocale) != -1) {
      setSessionCookie(LOCALE_COOKIE_NAME_TEMP, requestedLocale);
      localeRedirect(window.location.href, requestedLocale);
    }
  }
}

var SUPPORTED_ECOMM_LOCALE = [""];
var SUPPORTED_PS_LOCALE = ["en-us", "en-ca", "de-de", "en-gb", "fr-fr", "fr-ca"];

if (lacie) {
  var SUPPORTED_COUNTRY_For_getCountryForLocale = ["us", "gb", "as", "cn", "jp", "la", "es", "it", "fr", "de", "ca", "nl", "ca", "ch", "ch", "be", "be"];
} else {
  var SUPPORTED_COUNTRY_For_getCountryForLocale = ["us", "gb", "as", "cn", "tw", "jp", "kr", "la", "es", "it", "fr", "tr", "pl", "ru", "de", "br", "in", "sg", "au", "em", "id", "ar", "ca", "nl", "be", "be", "ie", "se", "ca", "ch", "ch", "at", "pt"];
}

var SUPPORTED_COUNTRY = ["us", "gb", "as", "cn", "tw", "jp", "kr", "la", "es", "it", "fr", "tr", "pl", "ru", "de", "br", "in", "sg", "au", "em", "id", "ar", "ca", "nl", "be", "be", "ie", "se", "ca", "ch", "ch", "at", "pt"];
var COUNTRY_KEYS = ["country.unitedStates", "country.unitedKingdom", "country.asean", "country.china", "country.taiwan", "country.japan", "country.republicofKorea", "country.americaLatina", "country.spain", "country.italy", "country.france", "country.turkey", "country.poland", "country.russia", "country.germany", "country.brazil", "country.india", "country.singapore", "country.australia", "country.menaEnglish", "country.indonesia", "country.menaArabic", "country.canada", "country.netherlands", "country.belgiumf", "country.belgiumn", "country.eurozone", "country.sweden", "country.canadaf", "country.switzerlandg", "country.switzerlandf", "country.austria", "country.portugal"];

if (lacie) {
  var SUPPORTED_LOCALE = ["en-us", "en-gb", "en-as", "zh-cn", "ja-jp", "es-la", "es-es", "it-it", "fr-fr", "de-de", "en-ca", "nl-nl", "fr-ca", "de-ch", "fr-ch", "nl-be", "fr-be"];
} else {
  var SUPPORTED_LOCALE = ["en-us", "en-gb", "en-as", "zh-cn", "zh-tw", "ja-jp", "ko-kr", "es-la", "es-es", "it-it", "fr-fr", "tr-tr", "pl-pl", "ru-ru", "de-de", "pt-br", "en-in", "en-sg", "en-au", "en-em", "id-id", "en-ca", "nl-nl", "fr-ca", "nl-be", "fr-be", "pt-pt"];
}

var SUPPORTED_LOCALE_STR = "/us/en,/gb/en,/as/en,/cn/zh,/tw/zh,/jp/ja,/kr/ko,/la/es,/es/es,/it/it,/fr/fr,/tr/tr,/pl/pl,/ru/ru,/de/de,/br/pt,/in/en,/sg/en,/au/en,/em/en,/id/id,/ca/en,/em/ar,/nl/nl,/be/fr,/be/nl,/ca/fr,/ch/de,/ch/fr,/pt/pt";
var DOMAIN_LOCALE_ARR = ["en-us", "en-us", "zh-cn", "ja-jp", "fr-fr"];
var DOMAIN_ARR = ["/www", ".com", ".cn", ".co.jp", ".fr"];
var DOMAIN_LANG_ARR = ["en", "en", "zh", "ja", "fr"];
var DOMAIN_COUNTRY_ARR = ["us", "us", "cn", "jp", "fr"];
var DEFAULT_LOCALE = "en-us";
var DEFAULT_COUNTRY = "us";
var DEFAULT_LANGUAGE = "English";
var DEFAULT_DOMAIN = ".com";
var LOCALE_COOKIE_NAME_TEMP = "userSelectedLocaleCookie";
var LOCALE_COOKIE_NAME_PERMANENT = "permanentLocaleCookie";
var LOCALE_COOKIE_NAME_ECOMM_TEMP = "ecommSessionCookie";
var LOCALE_COOKIE_NAME_ECOMM_PERMANENT = "ecommLocaleCookie";
/*if (!getCookie(LOCALE_COOKIE_NAME_TEMP)) {
  setSessionCookie(LOCALE_COOKIE_NAME_TEMP, "en-us");
}*/

if (!getCookie(LOCALE_COOKIE_NAME_PERMANENT)) {
  setPermanentCookie(LOCALE_COOKIE_NAME_PERMANENT, "en-us", 60);
}

var cookieLocale = getCookie(LOCALE_COOKIE_NAME_TEMP) || getCookie(LOCALE_COOKIE_NAME_PERMANENT) || "en-us";
var currentUrl = window.location;
var currentUrlStr = currentUrl.toString();
var pageLocale = currentUrlStr.match(/\/\w{2,2}\/\w{2,2}\//) ? currentUrlStr.match(/\/\w{2,2}\/\w{2,2}\//)[0] : "/us/en/";
var domainCountry = pageLocale.substring(1, 3);
var domainLang = pageLocale.substring(4, 6);
var cookieLocaleCountry = cookieLocale.split("-")[1];
var cookieLocaleLang = cookieLocale.split("-")[0];
var cookieLocaleString = "/" + cookieLocaleCountry + "/" + cookieLocaleLang + "/";
var pageLocaleString = "/" + domainCountry + "/" + domainLang + "/";
var param = document.location.search;

if (param.length > 0) {
  param = param.replace(/[?&]stxLoc=[^&]*/, "");

  if (param.length > 0 && param[0] == "&") {
    param = "?" + param.substring(1);
  }
}

if (cookieLocaleString != pageLocaleString && window.location.href.indexOf("/language-masters/") == -1 && !isAuthor() && !/^.*(shop|store|myportal|seagategov)(.*)\.(seagate|lacie)\.com$/.test(document.location.host) && !window.location.pathname.startsWith("/ww/")) {
  if (currentUrlStr.match(/\/\w{2,2}\/\w{2,2}\//)) {
    window.location = currentUrlStr.replace(/\/\w{2,2}\/\w{2,2}\//, cookieLocaleString);
  } else {
    window.location = document.location.origin + cookieLocaleString.slice(0, -1) + document.location.pathname + param + document.location.hash;
  }
}

var localeElement = document.querySelector(".dropdown-menu [data-locale='" + cookieLocale + "'");

if (localeElement) {
  localeElement.parentNode.classList.add("active");
  var currentCountryText = localeElement.innerText;
  document.getElementById("currentCountryText").innerText = currentCountryText;
}

function getCookie(c_name) {
  var i,
      x,
      y,
      ARRcookies = document.cookie.split(";");

  for (i = 0; i < ARRcookies.length; i++) {
    x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="));
    y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1);
    x = x.replace(/^\s+|\s+$/g, "");

    if (x == c_name) {
      return unescape(y);
    }
  }
}

function deleteCookie(name, path, domain) {
  if (getCookie(name)) {
    document.cookie = name + "=" + (path ? "; path=" + path : "") + (domain ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
  }
}

function setPermanentCookie(c_name, value, exdays) {
  var exdate = new Date();
  exdate.setDate(exdate.getDate() + exdays);
  var c_value = escape(value) + (exdays == null ? "" : "; expires=" + exdate.toUTCString());
  document.cookie = c_name + "=" + c_value + "; path=/ ; domain=" + defaultdomianforCookie;
}

function setSessionCookie(c_name, value) {
  document.cookie = c_name + "=" + escape(value) + "; path=/ ;domain=" + defaultdomianforCookie;
}

function removeCookie(c_name) {
  document.cookie = c_name + "=;path=/;expires=Thu, 01-Jan-1970 00:00:01 GMT;domain=" + defaultdomianforCookie;
}

function setLocaleOnLoadEdit() {
  domain = DEFAULT_DOMAIN;
  domainLang = "en";
  domainCountry = "us";
  localeUrl = DEFAULT_LOCALE;

  for (var i = 0; i < DOMAIN_ARR.length; i++) {
    localeUrl = getLocaleFromURL(DOMAIN_ARR[i] + "/", DOMAIN_LOCALE_ARR[i]);

    if (localeUrl != 0) {
      domain = DOMAIN_ARR[i];
      domainLang = DOMAIN_LANG_ARR[i];
      domainCountry = DOMAIN_COUNTRY_ARR[i];
      break;
    }
  }

  currentLocale = localeUrl;
  currentCountry = getCountryForLocale(currentLocale);
  chkForwardLocale(localeUrl, domain, domainLang, domainCountry);
}

function updateLocale(this_locale) {
  setNewLocale(this_locale);
}

function setNewLocale(value, cookieFlag) {
  var cookieExists = getCookie(LOCALE_COOKIE_NAME_ECOMM_PERMANENT) != null || getCookie(LOCALE_COOKIE_NAME_ECOMM_TEMP) != null;
  var ecommValue = "";
  var revisedValue = value;

  if (!/^[a-zA-Z]{2,2}-[a-zA-Z]{2,2}$/.test(value)) {
    value = "en-us";
  }

  if (cookieFlag == undefined) {
    var rememberMe = true;

    if (document.getElementById("nav-footer-remember") != null) {
      rememberMe = document.getElementById("nav-footer-remember").checked;
    }

    if (rememberMe) {
      removeCookie(LOCALE_COOKIE_NAME_ECOMM_PERMANENT);
      setPermanentCookie(LOCALE_COOKIE_NAME_PERMANENT, value, 60);
      setSessionCookie(LOCALE_COOKIE_NAME_TEMP, value);

      if (ecommValue != "") {
        setPermanentCookie(LOCALE_COOKIE_NAME_ECOMM_PERMANENT, ecommValue, 60);
        setSessionCookie(LOCALE_COOKIE_NAME_ECOMM_TEMP, ecommValue);
      }
    } else {
      removeCookie(LOCALE_COOKIE_NAME_ECOMM_TEMP);
      setSessionCookie(LOCALE_COOKIE_NAME_TEMP, value);

      if (ecommValue != "") {
        setSessionCookie(LOCALE_COOKIE_NAME_ECOMM_TEMP, ecommValue);
      }
    }
  }
  /*for (var i = 0; i < DOMAIN_ARR.length; i++) {
        localeUrl = getLocaleFromURL(DOMAIN_ARR[i] + "/", DOMAIN_LOCALE_ARR[i]);
        if (localeUrl != 0) {
            domain = DOMAIN_ARR[i];
            domainLang = DOMAIN_LANG_ARR[i];
            domainCountry = DOMAIN_COUNTRY_ARR[i];
            break;
        }
    }*/


  chkForwardLocale(value);
}

function chkForwardLocale(value) {
  if (/^(origin-www|www).*\.(seagate|lacie)\.com$/.test(document.location.host) || /^.*(seagate|lacie|localhost)/.test(document.location.host)) {
    var newLangShort = value.substr(0, 2);
    var newCountry = value.substr(3, 2);

    if (domainCountry != newCountry || domainLang != newLangShort) {
      domainString = "/" + newCountry + "/" + newLangShort + "/";
    }

    currentUrlStr = currentUrlStr.replace(/\/\w{2,2}\/\w{2,2}\//, domainString);
    currentUrlStr = currentUrlStr.replace(/[?&]stxLoc=(\w{2,2}[-_]\w{2,2})?/, "");

    if (currentUrlStr.indexOf("?") == -1) {
      currentUrlStr = currentUrlStr.replace("&", "?");
    }

    window.location = currentUrlStr;
    /*if (currentUrlLength == currentUrlStr.indexOf(domain) + domainLength && (newLangShort != lang || newCountry != country)) {
            window.location = currentUrlStr + domainString;
        } else {
            if (currentUrlStr.indexOf(domain + "/") > 0) {
                var comIndex = currentUrlStr.indexOf(domain + "/");
                if (domain == "/www") {
                    domain = "";
                }
                if ((currentUrlLength < comIndex + 10 || (currentUrlLength >= comIndex + 10 && SUPPORTED_LOCALE_STR.indexOf(currentUrlStr.substr(comIndex + domainLength, 6).toLowerCase()) < 0)) && (newLangShort != lang || newCountry != country)) {
                    window.location = currentUrlStr.replace(currentUrlStr.substr(comIndex, 5), domain + domainString);
                } else {
                    if (currentUrlLength >= comIndex + 10 && SUPPORTED_LOCALE_STR.indexOf(currentUrlStr.substr(comIndex + domainLength, 6).toLowerCase()) >= 0 && currentUrlStr.substr(comIndex + domainLength, 6).toLowerCase() != "/" + newCountry + "/" + newLangShort) {
                        domainString = domainString.substr(0, domainString.length - 1);
                        currentUrlStr = currentUrlStr.replace(currentUrlStr.substr(comIndex, 10), domain + domainString);
                        currentUrlStr = currentUrlStr.replace(/[?&]stxLoc=(\w{2,2}[-_]\w{2,2})?/, "");
                        if (currentUrlStr.indexOf("?") == -1) {
                            currentUrlStr = currentUrlStr.replace("&", "?");
                        }
                        window.location = currentUrlStr;
                    }
                }
            }
        } */
  }
}

function getCountryForLocale(locale) {
  if (locale != null) {
    var passedLocale = locale.toLowerCase();

    for (var i = 0; i < SUPPORTED_LOCALE.length; i++) {
      var slocale = SUPPORTED_LOCALE[i].toLowerCase();

      if (slocale == passedLocale) {
        return SUPPORTED_COUNTRY_For_getCountryForLocale[i];
      }
    }

    return DEFAULT_COUNTRY;
  }
}

function getLocaleForCountry(country) {
  var passedCountry = country.toLowerCase();

  if ("nz" == passedCountry.toLowerCase()) {
    passedCountry = "au";
  } else {
    if ("th" == passedCountry.toLowerCase()) {
      passedCountry = "as";
    }
  }

  for (var i = 0; i < SUPPORTED_COUNTRY.length; i++) {
    var sCountry = SUPPORTED_COUNTRY[i].toLowerCase();

    if (sCountry == passedCountry) {
      return SUPPORTED_LOCALE[i];
    }
  }

  return DEFAULT_LOCALE;
}

function setGlobeLocaleCountry() {
  var selectorCountry = null;
  var selectorLanguage = null;
  var ecommTempCookie = getCookie(LOCALE_COOKIE_NAME_ECOMM_TEMP);
  var ecommPermCookie = getCookie(LOCALE_COOKIE_NAME_ECOMM_PERMANENT);
  var localeTempCookie = getCookie(LOCALE_COOKIE_NAME_TEMP);
  var localePermCookie = getCookie(LOCALE_COOKIE_NAME_PERMANENT);

  if (ecommTempCookie != null && isSupportedEcommLocale(ecommTempCookie)) {
    selectorLanguage = ecommTempCookie.substr(0, 2);
    selectorCountry = ecommTempCookie.substr(3, 5);
  } else {
    if (localeTempCookie != null) {
      selectorLanguage = localeTempCookie.substr(0, 2);
      selectorCountry = localeTempCookie.substr(3, 5);
    } else {
      if (ecommPermCookie != null && isSupportedEcommLocale(ecommPermCookie)) {
        selectorLanguage = ecommPermCookie.substr(0, 2);
        selectorCountry = ecommPermCookie.substr(3, 5);
      } else {
        if (localePermCookie != null) {
          selectorLanguage = localePermCookie.substr(0, 2);
          selectorCountry = localePermCookie.substr(3, 5);
        } else {
          selectorCountry = currentCountry;
        }
      }
    }
  }

  var countryKey = "country.unitedStates";
  var languageKey = "country.unitedStates.lang";

  if (selectorCountry == "be") {
    if (selectorLanguage == "fr") {
      countryKey = "country.belgiumf";
      languageKey = "country.belgiumf.lang";
    } else {
      if (selectorLanguage == "nl") {
        countryKey = "country.belgium";
        languageKey = "country.belgium.lang";
      } else {
        countryKey = "country.belgiumn";
        languageKey = "country.belgiumn.lang";
      }
    }
  } else {
    if (selectorCountry == "em") {
      if (selectorLanguage == "en") {
        countryKey = "country.menaEnglish";
        languageKey = "country.menaEnglish.lang";
      } else {
        countryKey = "country.menaArabic";
        languageKey = "country.menaArabic.lang";
      }
    } else {
      if (selectorCountry == "ca") {
        if (selectorLanguage == "en") {
          countryKey = "country.canada";
          languageKey = "country.canada.lang";
        } else {
          countryKey = "country.canadaf";
          languageKey = "country.canadaf.lang";
        }
      } else {
        if (selectorCountry == "ch") {
          if (selectorLanguage == "fr") {
            countryKey = "country.switzerlandf";
            languageKey = "country.switzerlandf.lang";
          } else {
            countryKey = "country.switzerlandg";
            languageKey = "country.switzerlandg.lang";
          }
        } else {
          for (var i = 0; i < SUPPORTED_COUNTRY.length; i++) {
            var country = SUPPORTED_COUNTRY[i].toLowerCase();

            if (country == selectorCountry) {
              countryKey = COUNTRY_KEYS[i];
              languageKey = countryKey + ".lang";
            }
          }
        }
      }
    }
  }

  if (document.getElementById("currentCountryText") != undefined) {
    if (document.getElementById(countryKey) == null) {
      document.getElementById("currentCountryText").innerHTML = document.getElementById("country.unitedStates").innerHTML + " " + document.getElementById("country.unitedStates.lang").innerHTML;
    } else {
      document.getElementById("currentCountryText").innerHTML = document.getElementById(countryKey).innerHTML + " " + document.getElementById(languageKey).innerHTML;
    }
  } else {
    if (document.getElementById("currentCountry") != undefined) {
      if (document.getElementById(countryKey) == null) {
        document.getElementById("currentCountry").innerHTML = document.getElementById("country.unitedStates").innerHTML + " " + document.getElementById("country.unitedStates.lang").innerHTML;
      } else {
        document.getElementById("currentCountry").innerHTML = document.getElementById(countryKey).innerHTML + " " + document.getElementById(languageKey).innerHTML;
      }
    }
  }
}

function isSupportedEcommLocale(locale) {
  return false;
}

function isSupportedCountry(country) {
  var passedCountry = country.toLowerCase();

  if ("nz" == passedCountry.toLowerCase()) {
    passedCountry = "au";
  } else {
    if ("th" == passedCountry.toLowerCase()) {
      passedCountry = "as";
    }
  }

  for (var i = 0; i < SUPPORTED_COUNTRY.length; i++) {
    var sCountry = SUPPORTED_COUNTRY[i].toLowerCase();

    if (sCountry == passedCountry) {
      return true;
    }
  }

  return false;
}

function getLocaleFromURL(domain, defaultLocale) {
  var currentUrl = window.location;
  var currentUrlStr = currentUrl.toString();

  if (currentUrlStr.indexOf(domain) > 0) {
    var currentIndex = currentUrlStr.indexOf(domain);
    var subString = currentUrlStr.substring(currentIndex + domain.length, currentIndex + domain.length + 5);

    if (subString != "" && SUPPORTED_LOCALE_STR.indexOf(subString) > -1) {
      var localeArr = subString.split("/");
      return localeArr[1] + "-" + localeArr[0];
    } else {
      return defaultLocale;
    }
  } else {
    return 0;
  }
}

function localeRedirect(url, locale) {
  var newURL = url;
  var localeInURL = "";

  if (locale.indexOf("-") != -1 && locale != "en-us") {
    localeInURL = "/" + locale.split("-")[1] + "/" + locale.split("-")[0];
  }

  var replaced = false;
  var supportLocales = SUPPORTED_LOCALE_STR.split(",");

  for (var i = 0; i < supportLocales.length; i++) {
    var supportLocale = supportLocales[i];

    if (newURL.indexOf(".com" + supportLocale) != -1) {
      newURL = newURL.replace(".com" + supportLocale, ".com" + localeInURL);
      replaced = true;
      break;
    }
  }

  if (!replaced) {
    newURL = newURL.replace(".com", ".com" + localeInURL);
  }

  if (newURL != url) {
    window.location = newURL;
  }
}

function setLocaleOnLoad() {
  var selectedLocaleCookie = getCookie(LOCALE_COOKIE_NAME_TEMP);

  if ("th-th" == selectedLocaleCookie || "vi-vn" == selectedLocaleCookie) {
    selectedLocaleCookie = "en-as";
    setSessionCookie(LOCALE_COOKIE_NAME_TEMP, selectedLocaleCookie);
  }

  var permanentLocaleCookie = getCookie(LOCALE_COOKIE_NAME_PERMANENT);
  var cookieFlag = false;
  localeParamRedirect();

  if (selectedLocaleCookie != null && selectedLocaleCookie != "null" && selectedLocaleCookie != "") {
    currentLocale = selectedLocaleCookie;
    currentCountry = getCountryForLocale(currentLocale);
  } else {
    if (permanentLocaleCookie != null && permanentLocaleCookie != "" && /^[a-z]{2,2}-[a-z]{2,2}$/.test(permanentLocaleCookie)) {
      currentLocale = permanentLocaleCookie;
      currentCountry = getCountryForLocale(currentLocale);
    } else {
      for (var i = 0; i < DOMAIN_ARR.length; i++) {
        localeUrl = getLocaleFromURL(DOMAIN_ARR[i] + "/", DOMAIN_LOCALE_ARR[i]);

        if (localeUrl != 0) {
          break;
        }
      }

      currentLocale = localeUrl;
      currentCountry = getCountryForLocale(currentLocale);
    }
  }

  setNewLocale(currentLocale, cookieFlag);
}

function getKeyValueFromCookie(cookieName, key) {
  if (cookieName == "") {
    return "";
  } else {
    if (key == "") {
      return "";
    } else {
      if (getCookie(cookieName) === null || getCookie("stxEdgescape") == undefined) {
        return "";
      }

      var cookieValue = getCookie(cookieName);

      if (cookieValue != "") {
        var i,
            x,
            y,
            ARRcookies = cookieValue.split(",");

        for (i = 0; i < ARRcookies.length; i++) {
          x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="));
          y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1);
          x = x.replace(/^\s+|\s+$/g, "");

          if (x == key) {
            return unescape(y);
          }
        }
      }

      return "";
    }
  }
}

function setSegmentCookie() {
  var cookieVals = ["external", "external", "internal", "enterprise"];
  var segments = ["consumer", "services-software", "internal-hard-drives", "enterprise-storage"];
  var seagateReferrer = document.referrer.indexOf("www.seagate.com") != -1;
  var segment = window.location.pathname;

  if (segment.match(/^\/..\/..\//) != null) {
    segment = segment.replace(/^\/..\/../, "");
  }

  segment = segment.slice("1");
  segment = segment.substr(0, segment.indexOf("/"));

  if (segment == "" && seagateReferrer) {
    setPermanentCookie("prodSegment", "none", 60);
  } else {
    if (segment == "") {
      segmentRedirect();
    } else {
      for (i = 0; i < segments.length; i++) {
        if (segments[i] == segment) {
          setPermanentCookie("prodSegment", cookieVals[i], 60);
          break;
        }
      }
    }
  }
}

function segmentRedirect() {
  var segmentCookie = getCookie("prodSegment");
  var segmentTarget = {
    external: "/consumer/",
    internal: "/internal-hard-drives/",
    enterprise: "/enterprise-storage/"
  };

  if (window.location.hostname.indexOf("www.seagate.com") != -1 && segmentCookie != null && segmentCookie != "none") {
    window.location = "//" + window.location.hostname + segmentTarget[segmentCookie];
  }
}

var pmLinks = document.querySelectorAll(".pm-top-header .dropdown-menu a");
pmLinks.forEach(function (link) {
  link.addEventListener('click', function (e) {
    e.preventDefault();
    updateLocale(e.currentTarget.dataset.locale);
  });
});

/***/ }),

/***/ 4433:
/***/ (function() {

if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}

if (!Element.prototype.closest) {
  Element.prototype.closest = function (s) {
    var el = this;

    do {
      if (Element.prototype.matches.call(el, s)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);

    return null;
  };
}

/***/ }),

/***/ 78:
/***/ (function() {

/* eslint-disable */
// NOTE: Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent
(function () {
  if (typeof window.CustomEvent === 'function') return false;

  function CustomEvent(event, params) {
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: null
    };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }

  window.CustomEvent = CustomEvent;
})();

/***/ }),

/***/ 7215:
/***/ (function() {

/* eslint-disable */
(function () {
  if ('HTMLCollection' in window && !HTMLCollection.prototype.forEach) {
    console.info('polyfill HTMLCollection for IE11');

    HTMLCollection.prototype.forEach = function (callback, thisArg) {
      thisArg = thisArg || window;

      for (var i = 0; i < this.length; i++) {
        callback.call(thisArg, this[i], i, this);
      }
    };
  }

  if ('NodeList' in window && !NodeList.prototype.forEach) {
    console.info('polyfill for IE11');

    NodeList.prototype.forEach = function (callback, thisArg) {
      thisArg = thisArg || window;

      for (var i = 0; i < this.length; i++) {
        callback.call(thisArg, this[i], i, this);
      }
    };
  }
})();

/***/ }),

/***/ 5198:
/***/ (function() {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */
(function () {
  'use strict'; // Exit early if we're not running in a browser.

  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object') {
    return;
  } // Exit early if all IntersectionObserver and IntersectionObserverEntry
  // features are natively supported.


  if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {
    // Minimal polyfill for Edge 15's lack of `isIntersecting`
    // See: https://github.com/w3c/IntersectionObserver/issues/211
    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
      Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', {
        get: function get() {
          return this.intersectionRatio > 0;
        }
      });
    }

    return;
  }
  /**
   * Returns the embedding frame element, if any.
   * @param {!Document} doc
   * @return {!Element}
   */


  function getFrameElement(doc) {
    try {
      return doc.defaultView && doc.defaultView.frameElement || null;
    } catch (e) {
      // Ignore the error.
      return null;
    }
  }
  /**
   * A local reference to the root document.
   */


  var document = function (startDoc) {
    var doc = startDoc;
    var frame = getFrameElement(doc);

    while (frame) {
      doc = frame.ownerDocument;
      frame = getFrameElement(doc);
    }

    return doc;
  }(window.document);
  /**
   * An IntersectionObserver registry. This registry exists to hold a strong
   * reference to IntersectionObserver instances currently observing a target
   * element. Without this registry, instances without another reference may be
   * garbage collected.
   */


  var registry = [];
  /**
   * The signal updater for cross-origin intersection. When not null, it means
   * that the polyfill is configured to work in a cross-origin mode.
   * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}
   */

  var crossOriginUpdater = null;
  /**
   * The current cross-origin intersection. Only used in the cross-origin mode.
   * @type {DOMRect|ClientRect}
   */

  var crossOriginRect = null;
  /**
   * Creates the global IntersectionObserverEntry constructor.
   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
   * @param {Object} entry A dictionary of instance properties.
   * @constructor
   */

  function IntersectionObserverEntry(entry) {
    this.time = entry.time;
    this.target = entry.target;
    this.rootBounds = ensureDOMRect(entry.rootBounds);
    this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
    this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
    this.isIntersecting = !!entry.intersectionRect; // Calculates the intersection ratio.

    var targetRect = this.boundingClientRect;
    var targetArea = targetRect.width * targetRect.height;
    var intersectionRect = this.intersectionRect;
    var intersectionArea = intersectionRect.width * intersectionRect.height; // Sets intersection ratio.

    if (targetArea) {
      // Round the intersection ratio to avoid floating point math issues:
      // https://github.com/w3c/IntersectionObserver/issues/324
      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
    } else {
      // If area is zero and is intersecting, sets to 1, otherwise to 0
      this.intersectionRatio = this.isIntersecting ? 1 : 0;
    }
  }
  /**
   * Creates the global IntersectionObserver constructor.
   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
   * @param {Function} callback The function to be invoked after intersection
   *     changes have queued. The function is not invoked if the queue has
   *     been emptied by calling the `takeRecords` method.
   * @param {Object=} opt_options Optional configuration options.
   * @constructor
   */


  function IntersectionObserver(callback, opt_options) {
    var options = opt_options || {};

    if (typeof callback != 'function') {
      throw new Error('callback must be a function');
    }

    if (options.root && options.root.nodeType != 1) {
      throw new Error('root must be an Element');
    } // Binds and throttles `this._checkForIntersections`.


    this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT); // Private properties.

    this._callback = callback;
    this._observationTargets = [];
    this._queuedEntries = [];
    this._rootMarginValues = this._parseRootMargin(options.rootMargin); // Public properties.

    this.thresholds = this._initThresholds(options.threshold);
    this.root = options.root || null;
    this.rootMargin = this._rootMarginValues.map(function (margin) {
      return margin.value + margin.unit;
    }).join(' ');
    /** @private @const {!Array<!Document>} */

    this._monitoringDocuments = [];
    /** @private @const {!Array<function()>} */

    this._monitoringUnsubscribes = [];
  }
  /**
   * The minimum interval within which the document will be checked for
   * intersection changes.
   */


  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;
  /**
   * The frequency in which the polyfill polls for intersection changes.
   * this can be updated on a per instance basis and must be set prior to
   * calling `observe` on the first target.
   */

  IntersectionObserver.prototype.POLL_INTERVAL = null;
  /**
   * Use a mutation observer on the root element
   * to detect intersection changes.
   */

  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;
  /**
   * Sets up the polyfill in the cross-origin mode. The result is the
   * updater function that accepts two arguments: `boundingClientRect` and
   * `intersectionRect` - just as these fields would be available to the
   * parent via `IntersectionObserverEntry`. This function should be called
   * each time the iframe receives intersection information from the parent
   * window, e.g. via messaging.
   * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}
   */

  IntersectionObserver._setupCrossOriginUpdater = function () {
    if (!crossOriginUpdater) {
      /**
       * @param {DOMRect|ClientRect} boundingClientRect
       * @param {DOMRect|ClientRect} intersectionRect
       */
      crossOriginUpdater = function crossOriginUpdater(boundingClientRect, intersectionRect) {
        if (!boundingClientRect || !intersectionRect) {
          crossOriginRect = getEmptyRect();
        } else {
          crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
        }

        registry.forEach(function (observer) {
          observer._checkForIntersections();
        });
      };
    }

    return crossOriginUpdater;
  };
  /**
   * Resets the cross-origin mode.
   */


  IntersectionObserver._resetCrossOriginUpdater = function () {
    crossOriginUpdater = null;
    crossOriginRect = null;
  };
  /**
   * Starts observing a target element for intersection changes based on
   * the thresholds values.
   * @param {Element} target The DOM element to observe.
   */


  IntersectionObserver.prototype.observe = function (target) {
    var isTargetAlreadyObserved = this._observationTargets.some(function (item) {
      return item.element == target;
    });

    if (isTargetAlreadyObserved) {
      return;
    }

    if (!(target && target.nodeType == 1)) {
      throw new Error('target must be an Element');
    }

    this._registerInstance();

    this._observationTargets.push({
      element: target,
      entry: null
    });

    this._monitorIntersections(target.ownerDocument);

    this._checkForIntersections();
  };
  /**
   * Stops observing a target element for intersection changes.
   * @param {Element} target The DOM element to observe.
   */


  IntersectionObserver.prototype.unobserve = function (target) {
    this._observationTargets = this._observationTargets.filter(function (item) {
      return item.element != target;
    });

    this._unmonitorIntersections(target.ownerDocument);

    if (this._observationTargets.length == 0) {
      this._unregisterInstance();
    }
  };
  /**
   * Stops observing all target elements for intersection changes.
   */


  IntersectionObserver.prototype.disconnect = function () {
    this._observationTargets = [];

    this._unmonitorAllIntersections();

    this._unregisterInstance();
  };
  /**
   * Returns any queue entries that have not yet been reported to the
   * callback and clears the queue. This can be used in conjunction with the
   * callback to obtain the absolute most up-to-date intersection information.
   * @return {Array} The currently queued entries.
   */


  IntersectionObserver.prototype.takeRecords = function () {
    var records = this._queuedEntries.slice();

    this._queuedEntries = [];
    return records;
  };
  /**
   * Accepts the threshold value from the user configuration object and
   * returns a sorted array of unique threshold values. If a value is not
   * between 0 and 1 and error is thrown.
   * @private
   * @param {Array|number=} opt_threshold An optional threshold value or
   *     a list of threshold values, defaulting to [0].
   * @return {Array} A sorted list of unique and valid threshold values.
   */


  IntersectionObserver.prototype._initThresholds = function (opt_threshold) {
    var threshold = opt_threshold || [0];
    if (!Array.isArray(threshold)) threshold = [threshold];
    return threshold.sort().filter(function (t, i, a) {
      if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
        throw new Error('threshold must be a number between 0 and 1 inclusively');
      }

      return t !== a[i - 1];
    });
  };
  /**
   * Accepts the rootMargin value from the user configuration object
   * and returns an array of the four margin values as an object containing
   * the value and unit properties. If any of the values are not properly
   * formatted or use a unit other than px or %, and error is thrown.
   * @private
   * @param {string=} opt_rootMargin An optional rootMargin value,
   *     defaulting to '0px'.
   * @return {Array<Object>} An array of margin objects with the keys
   *     value and unit.
   */


  IntersectionObserver.prototype._parseRootMargin = function (opt_rootMargin) {
    var marginString = opt_rootMargin || '0px';
    var margins = marginString.split(/\s+/).map(function (margin) {
      var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);

      if (!parts) {
        throw new Error('rootMargin must be specified in pixels or percent');
      }

      return {
        value: parseFloat(parts[1]),
        unit: parts[2]
      };
    }); // Handles shorthand.

    margins[1] = margins[1] || margins[0];
    margins[2] = margins[2] || margins[0];
    margins[3] = margins[3] || margins[1];
    return margins;
  };
  /**
   * Starts polling for intersection changes if the polling is not already
   * happening, and if the page's visibility state is visible.
   * @param {!Document} doc
   * @private
   */


  IntersectionObserver.prototype._monitorIntersections = function (doc) {
    var win = doc.defaultView;

    if (!win) {
      // Already destroyed.
      return;
    }

    if (this._monitoringDocuments.indexOf(doc) != -1) {
      // Already monitoring.
      return;
    } // Private state for monitoring.


    var callback = this._checkForIntersections;
    var monitoringInterval = null;
    var domObserver = null; // If a poll interval is set, use polling instead of listening to
    // resize and scroll events or DOM mutations.

    if (this.POLL_INTERVAL) {
      monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
    } else {
      addEvent(win, 'resize', callback, true);
      addEvent(doc, 'scroll', callback, true);

      if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {
        domObserver = new win.MutationObserver(callback);
        domObserver.observe(doc, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }

    this._monitoringDocuments.push(doc);

    this._monitoringUnsubscribes.push(function () {
      // Get the window object again. When a friendly iframe is destroyed, it
      // will be null.
      var win = doc.defaultView;

      if (win) {
        if (monitoringInterval) {
          win.clearInterval(monitoringInterval);
        }

        removeEvent(win, 'resize', callback, true);
      }

      removeEvent(doc, 'scroll', callback, true);

      if (domObserver) {
        domObserver.disconnect();
      }
    }); // Also monitor the parent.


    if (doc != (this.root && this.root.ownerDocument || document)) {
      var frame = getFrameElement(doc);

      if (frame) {
        this._monitorIntersections(frame.ownerDocument);
      }
    }
  };
  /**
   * Stops polling for intersection changes.
   * @param {!Document} doc
   * @private
   */


  IntersectionObserver.prototype._unmonitorIntersections = function (doc) {
    var index = this._monitoringDocuments.indexOf(doc);

    if (index == -1) {
      return;
    }

    var rootDoc = this.root && this.root.ownerDocument || document; // Check if any dependent targets are still remaining.

    var hasDependentTargets = this._observationTargets.some(function (item) {
      var itemDoc = item.element.ownerDocument; // Target is in this context.

      if (itemDoc == doc) {
        return true;
      } // Target is nested in this context.


      while (itemDoc && itemDoc != rootDoc) {
        var frame = getFrameElement(itemDoc);
        itemDoc = frame && frame.ownerDocument;

        if (itemDoc == doc) {
          return true;
        }
      }

      return false;
    });

    if (hasDependentTargets) {
      return;
    } // Unsubscribe.


    var unsubscribe = this._monitoringUnsubscribes[index];

    this._monitoringDocuments.splice(index, 1);

    this._monitoringUnsubscribes.splice(index, 1);

    unsubscribe(); // Also unmonitor the parent.

    if (doc != rootDoc) {
      var frame = getFrameElement(doc);

      if (frame) {
        this._unmonitorIntersections(frame.ownerDocument);
      }
    }
  };
  /**
   * Stops polling for intersection changes.
   * @param {!Document} doc
   * @private
   */


  IntersectionObserver.prototype._unmonitorAllIntersections = function () {
    var unsubscribes = this._monitoringUnsubscribes.slice(0);

    this._monitoringDocuments.length = 0;
    this._monitoringUnsubscribes.length = 0;

    for (var i = 0; i < unsubscribes.length; i++) {
      unsubscribes[i]();
    }
  };
  /**
   * Scans each observation target for intersection changes and adds them
   * to the internal entries queue. If new entries are found, it
   * schedules the callback to be invoked.
   * @private
   */


  IntersectionObserver.prototype._checkForIntersections = function () {
    if (!this.root && crossOriginUpdater && !crossOriginRect) {
      // Cross origin monitoring, but no initial data available yet.
      return;
    }

    var rootIsInDom = this._rootIsInDom();

    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

    this._observationTargets.forEach(function (item) {
      var target = item.element;
      var targetRect = getBoundingClientRect(target);

      var rootContainsTarget = this._rootContainsTarget(target);

      var oldEntry = item.entry;

      var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, targetRect, rootRect);

      var newEntry = item.entry = new IntersectionObserverEntry({
        time: now(),
        target: target,
        boundingClientRect: targetRect,
        rootBounds: crossOriginUpdater && !this.root ? null : rootRect,
        intersectionRect: intersectionRect
      });

      if (!oldEntry) {
        this._queuedEntries.push(newEntry);
      } else if (rootIsInDom && rootContainsTarget) {
        // If the new entry intersection ratio has crossed any of the
        // thresholds, add a new entry.
        if (this._hasCrossedThreshold(oldEntry, newEntry)) {
          this._queuedEntries.push(newEntry);
        }
      } else {
        // If the root is not in the DOM or target is not contained within
        // root but the previous entry for this target had an intersection,
        // add a new record indicating removal.
        if (oldEntry && oldEntry.isIntersecting) {
          this._queuedEntries.push(newEntry);
        }
      }
    }, this);

    if (this._queuedEntries.length) {
      this._callback(this.takeRecords(), this);
    }
  };
  /**
   * Accepts a target and root rect computes the intersection between then
   * following the algorithm in the spec.
   * TODO(philipwalton): at this time clip-path is not considered.
   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
   * @param {Element} target The target DOM element
   * @param {Object} targetRect The bounding rect of the target.
   * @param {Object} rootRect The bounding rect of the root after being
   *     expanded by the rootMargin value.
   * @return {?Object} The final intersection rect object or undefined if no
   *     intersection is found.
   * @private
   */


  IntersectionObserver.prototype._computeTargetAndRootIntersection = function (target, targetRect, rootRect) {
    // If the element isn't displayed, an intersection can't happen.
    if (window.getComputedStyle(target).display == 'none') return;
    var intersectionRect = targetRect;
    var parent = getParentNode(target);
    var atRoot = false;

    while (!atRoot && parent) {
      var parentRect = null;
      var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {}; // If the parent isn't displayed, an intersection can't happen.

      if (parentComputedStyle.display == 'none') return null;

      if (parent == this.root || parent.nodeType ==
      /* DOCUMENT */
      9) {
        atRoot = true;

        if (parent == this.root || parent == document) {
          if (crossOriginUpdater && !this.root) {
            if (!crossOriginRect || crossOriginRect.width == 0 && crossOriginRect.height == 0) {
              // A 0-size cross-origin intersection means no-intersection.
              parent = null;
              parentRect = null;
              intersectionRect = null;
            } else {
              parentRect = crossOriginRect;
            }
          } else {
            parentRect = rootRect;
          }
        } else {
          // Check if there's a frame that can be navigated to.
          var frame = getParentNode(parent);
          var frameRect = frame && getBoundingClientRect(frame);

          var frameIntersect = frame && this._computeTargetAndRootIntersection(frame, frameRect, rootRect);

          if (frameRect && frameIntersect) {
            parent = frame;
            parentRect = convertFromParentRect(frameRect, frameIntersect);
          } else {
            parent = null;
            intersectionRect = null;
          }
        }
      } else {
        // If the element has a non-visible overflow, and it's not the <body>
        // or <html> element, update the intersection rect.
        // Note: <body> and <html> cannot be clipped to a rect that's not also
        // the document rect, so no need to compute a new intersection.
        var doc = parent.ownerDocument;

        if (parent != doc.body && parent != doc.documentElement && parentComputedStyle.overflow != 'visible') {
          parentRect = getBoundingClientRect(parent);
        }
      } // If either of the above conditionals set a new parentRect,
      // calculate new intersection data.


      if (parentRect) {
        intersectionRect = computeRectIntersection(parentRect, intersectionRect);
      }

      if (!intersectionRect) break;
      parent = parent && getParentNode(parent);
    }

    return intersectionRect;
  };
  /**
   * Returns the root rect after being expanded by the rootMargin value.
   * @return {ClientRect} The expanded root rect.
   * @private
   */


  IntersectionObserver.prototype._getRootRect = function () {
    var rootRect;

    if (this.root) {
      rootRect = getBoundingClientRect(this.root);
    } else {
      // Use <html>/<body> instead of window since scroll bars affect size.
      var html = document.documentElement;
      var body = document.body;
      rootRect = {
        top: 0,
        left: 0,
        right: html.clientWidth || body.clientWidth,
        width: html.clientWidth || body.clientWidth,
        bottom: html.clientHeight || body.clientHeight,
        height: html.clientHeight || body.clientHeight
      };
    }

    return this._expandRectByRootMargin(rootRect);
  };
  /**
   * Accepts a rect and expands it by the rootMargin value.
   * @param {DOMRect|ClientRect} rect The rect object to expand.
   * @return {ClientRect} The expanded rect.
   * @private
   */


  IntersectionObserver.prototype._expandRectByRootMargin = function (rect) {
    var margins = this._rootMarginValues.map(function (margin, i) {
      return margin.unit == 'px' ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100;
    });

    var newRect = {
      top: rect.top - margins[0],
      right: rect.right + margins[1],
      bottom: rect.bottom + margins[2],
      left: rect.left - margins[3]
    };
    newRect.width = newRect.right - newRect.left;
    newRect.height = newRect.bottom - newRect.top;
    return newRect;
  };
  /**
   * Accepts an old and new entry and returns true if at least one of the
   * threshold values has been crossed.
   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
   *    particular target element or null if no previous entry exists.
   * @param {IntersectionObserverEntry} newEntry The current entry for a
   *    particular target element.
   * @return {boolean} Returns true if a any threshold has been crossed.
   * @private
   */


  IntersectionObserver.prototype._hasCrossedThreshold = function (oldEntry, newEntry) {
    // To make comparing easier, an entry that has a ratio of 0
    // but does not actually intersect is given a value of -1
    var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
    var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1; // Ignore unchanged ratios

    if (oldRatio === newRatio) return;

    for (var i = 0; i < this.thresholds.length; i++) {
      var threshold = this.thresholds[i]; // Return true if an entry matches a threshold or if the new ratio
      // and the old ratio are on the opposite sides of a threshold.

      if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
        return true;
      }
    }
  };
  /**
   * Returns whether or not the root element is an element and is in the DOM.
   * @return {boolean} True if the root element is an element and is in the DOM.
   * @private
   */


  IntersectionObserver.prototype._rootIsInDom = function () {
    return !this.root || containsDeep(document, this.root);
  };
  /**
   * Returns whether or not the target element is a child of root.
   * @param {Element} target The target element to check.
   * @return {boolean} True if the target element is a child of root.
   * @private
   */


  IntersectionObserver.prototype._rootContainsTarget = function (target) {
    return containsDeep(this.root || document, target) && (!this.root || this.root.ownerDocument == target.ownerDocument);
  };
  /**
   * Adds the instance to the global IntersectionObserver registry if it isn't
   * already present.
   * @private
   */


  IntersectionObserver.prototype._registerInstance = function () {
    if (registry.indexOf(this) < 0) {
      registry.push(this);
    }
  };
  /**
   * Removes the instance from the global IntersectionObserver registry.
   * @private
   */


  IntersectionObserver.prototype._unregisterInstance = function () {
    var index = registry.indexOf(this);
    if (index != -1) registry.splice(index, 1);
  };
  /**
   * Returns the result of the performance.now() method or null in browsers
   * that don't support the API.
   * @return {number} The elapsed time since the page was requested.
   */


  function now() {
    return window.performance && performance.now && performance.now();
  }
  /**
   * Throttles a function and delays its execution, so it's only called at most
   * once within a given time period.
   * @param {Function} fn The function to throttle.
   * @param {number} timeout The amount of time that must pass before the
   *     function can be called again.
   * @return {Function} The throttled function.
   */


  function throttle(fn, timeout) {
    var timer = null;
    return function () {
      if (!timer) {
        timer = setTimeout(function () {
          fn();
          timer = null;
        }, timeout);
      }
    };
  }
  /**
   * Adds an event handler to a DOM node ensuring cross-browser compatibility.
   * @param {Node} node The DOM node to add the event handler to.
   * @param {string} event The event name.
   * @param {Function} fn The event handler to add.
   * @param {boolean} opt_useCapture Optionally adds the even to the capture
   *     phase. Note: this only works in modern browsers.
   */


  function addEvent(node, event, fn, opt_useCapture) {
    if (typeof node.addEventListener == 'function') {
      node.addEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node.attachEvent == 'function') {
      node.attachEvent('on' + event, fn);
    }
  }
  /**
   * Removes a previously added event handler from a DOM node.
   * @param {Node} node The DOM node to remove the event handler from.
   * @param {string} event The event name.
   * @param {Function} fn The event handler to remove.
   * @param {boolean} opt_useCapture If the event handler was added with this
   *     flag set to true, it should be set to true here in order to remove it.
   */


  function removeEvent(node, event, fn, opt_useCapture) {
    if (typeof node.removeEventListener == 'function') {
      node.removeEventListener(event, fn, opt_useCapture || false);
    } else if (typeof node.detatchEvent == 'function') {
      node.detatchEvent('on' + event, fn);
    }
  }
  /**
   * Returns the intersection between two rect objects.
   * @param {Object} rect1 The first rect.
   * @param {Object} rect2 The second rect.
   * @return {?Object|?ClientRect} The intersection rect or undefined if no
   *     intersection is found.
   */


  function computeRectIntersection(rect1, rect2) {
    var top = Math.max(rect1.top, rect2.top);
    var bottom = Math.min(rect1.bottom, rect2.bottom);
    var left = Math.max(rect1.left, rect2.left);
    var right = Math.min(rect1.right, rect2.right);
    var width = right - left;
    var height = bottom - top;
    return width >= 0 && height >= 0 && {
      top: top,
      bottom: bottom,
      left: left,
      right: right,
      width: width,
      height: height
    } || null;
  }
  /**
   * Shims the native getBoundingClientRect for compatibility with older IE.
   * @param {Element} el The element whose bounding rect to get.
   * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.
   */


  function getBoundingClientRect(el) {
    var rect;

    try {
      rect = el.getBoundingClientRect();
    } catch (err) {// Ignore Windows 7 IE11 "Unspecified error"
      // https://github.com/w3c/IntersectionObserver/pull/205
    }

    if (!rect) return getEmptyRect(); // Older IE

    if (!(rect.width && rect.height)) {
      rect = {
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        width: rect.right - rect.left,
        height: rect.bottom - rect.top
      };
    }

    return rect;
  }
  /**
   * Returns an empty rect object. An empty rect is returned when an element
   * is not in the DOM.
   * @return {ClientRect} The empty rect.
   */


  function getEmptyRect() {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  /**
   * Ensure that the result has all of the necessary fields of the DOMRect.
   * Specifically this ensures that `x` and `y` fields are set.
   *
   * @param {?DOMRect|?ClientRect} rect
   * @return {?DOMRect}
   */


  function ensureDOMRect(rect) {
    // A `DOMRect` object has `x` and `y` fields.
    if (!rect || 'x' in rect) {
      return rect;
    } // A IE's `ClientRect` type does not have `x` and `y`. The same is the case
    // for internally calculated Rect objects. For the purposes of
    // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`
    // for these fields.


    return {
      top: rect.top,
      y: rect.top,
      bottom: rect.bottom,
      left: rect.left,
      x: rect.left,
      right: rect.right,
      width: rect.width,
      height: rect.height
    };
  }
  /**
   * Inverts the intersection and bounding rect from the parent (frame) BCR to
   * the local BCR space.
   * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.
   * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.
   * @return {ClientRect} The local root bounding rect for the parent's children.
   */


  function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
    var top = parentIntersectionRect.top - parentBoundingRect.top;
    var left = parentIntersectionRect.left - parentBoundingRect.left;
    return {
      top: top,
      left: left,
      height: parentIntersectionRect.height,
      width: parentIntersectionRect.width,
      bottom: top + parentIntersectionRect.height,
      right: left + parentIntersectionRect.width
    };
  }
  /**
   * Checks to see if a parent element contains a child element (including inside
   * shadow DOM).
   * @param {Node} parent The parent element.
   * @param {Node} child The child element.
   * @return {boolean} True if the parent node contains the child node.
   */


  function containsDeep(parent, child) {
    var node = child;

    while (node) {
      if (node == parent) return true;
      node = getParentNode(node);
    }

    return false;
  }
  /**
   * Gets the parent node of an element or its host element if the parent node
   * is a shadow root.
   * @param {Node} node The node whose parent to get.
   * @return {Node|null} The parent node or null if no parent exists.
   */


  function getParentNode(node) {
    var parent = node.parentNode;

    if (node.nodeType ==
    /* DOCUMENT */
    9 && node != document) {
      // If this node is a document node, look for the embedding frame.
      return getFrameElement(node);
    }

    if (parent && parent.nodeType == 11 && parent.host) {
      // If the parent is a shadow root, return the host element.
      return parent.host;
    }

    if (parent && parent.assignedSlot) {
      // If the parent is distributed in a <slot>, return the parent of a slot.
      return parent.assignedSlot.parentNode;
    }

    return parent;
  } // Exposes the constructors globally.


  window.IntersectionObserver = IntersectionObserver;
  window.IntersectionObserverEntry = IntersectionObserverEntry;
})();

/***/ }),

/***/ 1924:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(210);

var callBind = __webpack_require__(5559);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ 5559:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(8612);
var GetIntrinsic = __webpack_require__(210);
var setFunctionLength = __webpack_require__(7771);

var $TypeError = __webpack_require__(4453);
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $defineProperty = __webpack_require__(4429);
var $max = GetIntrinsic('%Math.max%');

module.exports = function callBind(originalFunction) {
	if (typeof originalFunction !== 'function') {
		throw new $TypeError('a function is required');
	}
	var func = $reflectApply(bind, $call, arguments);
	return setFunctionLength(
		func,
		1 + $max(0, originalFunction.length - (arguments.length - 1)),
		true
	);
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ 4529:
/***/ (function(module) {

/*! choices.js v9.1.0 |  2021 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 282:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_607__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.clearChoices = exports.activateChoices = exports.filterChoices = exports.addChoice = void 0;

var constants_1 = __nested_webpack_require_607__(883);

var addChoice = function (_a) {
  var value = _a.value,
      label = _a.label,
      id = _a.id,
      groupId = _a.groupId,
      disabled = _a.disabled,
      elementId = _a.elementId,
      customProperties = _a.customProperties,
      placeholder = _a.placeholder,
      keyCode = _a.keyCode;
  return {
    type: constants_1.ACTION_TYPES.ADD_CHOICE,
    value: value,
    label: label,
    id: id,
    groupId: groupId,
    disabled: disabled,
    elementId: elementId,
    customProperties: customProperties,
    placeholder: placeholder,
    keyCode: keyCode
  };
};

exports.addChoice = addChoice;

var filterChoices = function (results) {
  return {
    type: constants_1.ACTION_TYPES.FILTER_CHOICES,
    results: results
  };
};

exports.filterChoices = filterChoices;

var activateChoices = function (active) {
  if (active === void 0) {
    active = true;
  }

  return {
    type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
    active: active
  };
};

exports.activateChoices = activateChoices;

var clearChoices = function () {
  return {
    type: constants_1.ACTION_TYPES.CLEAR_CHOICES
  };
};

exports.clearChoices = clearChoices;

/***/ }),

/***/ 783:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_2083__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addGroup = void 0;

var constants_1 = __nested_webpack_require_2083__(883);

var addGroup = function (_a) {
  var value = _a.value,
      id = _a.id,
      active = _a.active,
      disabled = _a.disabled;
  return {
    type: constants_1.ACTION_TYPES.ADD_GROUP,
    value: value,
    id: id,
    active: active,
    disabled: disabled
  };
};

exports.addGroup = addGroup;

/***/ }),

/***/ 464:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_2633__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.highlightItem = exports.removeItem = exports.addItem = void 0;

var constants_1 = __nested_webpack_require_2633__(883);

var addItem = function (_a) {
  var value = _a.value,
      label = _a.label,
      id = _a.id,
      choiceId = _a.choiceId,
      groupId = _a.groupId,
      customProperties = _a.customProperties,
      placeholder = _a.placeholder,
      keyCode = _a.keyCode;
  return {
    type: constants_1.ACTION_TYPES.ADD_ITEM,
    value: value,
    label: label,
    id: id,
    choiceId: choiceId,
    groupId: groupId,
    customProperties: customProperties,
    placeholder: placeholder,
    keyCode: keyCode
  };
};

exports.addItem = addItem;

var removeItem = function (id, choiceId) {
  return {
    type: constants_1.ACTION_TYPES.REMOVE_ITEM,
    id: id,
    choiceId: choiceId
  };
};

exports.removeItem = removeItem;

var highlightItem = function (id, highlighted) {
  return {
    type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
    id: id,
    highlighted: highlighted
  };
};

exports.highlightItem = highlightItem;

/***/ }),

/***/ 137:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_3852__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setIsLoading = exports.resetTo = exports.clearAll = void 0;

var constants_1 = __nested_webpack_require_3852__(883);

var clearAll = function () {
  return {
    type: constants_1.ACTION_TYPES.CLEAR_ALL
  };
};

exports.clearAll = clearAll;

var resetTo = function (state) {
  return {
    type: constants_1.ACTION_TYPES.RESET_TO,
    state: state
  };
};

exports.resetTo = resetTo;

var setIsLoading = function (isLoading) {
  return {
    type: constants_1.ACTION_TYPES.SET_IS_LOADING,
    isLoading: isLoading
  };
};

exports.setIsLoading = setIsLoading;

/***/ }),

/***/ 373:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_4588__) {

"use strict";


var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var deepmerge_1 = __importDefault(__nested_webpack_require_4588__(996));
/* eslint-disable @typescript-eslint/no-explicit-any */


var fuse_js_1 = __importDefault(__nested_webpack_require_4588__(70));

var choices_1 = __nested_webpack_require_4588__(282);

var groups_1 = __nested_webpack_require_4588__(783);

var items_1 = __nested_webpack_require_4588__(464);

var misc_1 = __nested_webpack_require_4588__(137);

var components_1 = __nested_webpack_require_4588__(520);

var constants_1 = __nested_webpack_require_4588__(883);

var defaults_1 = __nested_webpack_require_4588__(789);

var utils_1 = __nested_webpack_require_4588__(799);

var reducers_1 = __nested_webpack_require_4588__(655);

var store_1 = __importDefault(__nested_webpack_require_4588__(744));

var templates_1 = __importDefault(__nested_webpack_require_4588__(686));
/** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */


var IS_IE11 = '-ms-scroll-limit' in document.documentElement.style && '-ms-ime-align' in document.documentElement.style;
var USER_DEFAULTS = {};
/**
 * Choices
 * @author Josh Johnson<josh@joshuajohnson.co.uk>
 */

var Choices =
/** @class */
function () {
  function Choices(element, userConfig) {
    var _this = this;

    if (element === void 0) {
      element = '[data-choice]';
    }

    if (userConfig === void 0) {
      userConfig = {};
    }

    this.config = deepmerge_1.default.all([defaults_1.DEFAULT_CONFIG, Choices.defaults.options, userConfig], // When merging array configs, replace with a copy of the userConfig array,
    // instead of concatenating with the default array
    {
      arrayMerge: function (_, sourceArray) {
        return __spreadArray([], sourceArray, true);
      }
    });
    var invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);

    if (invalidConfigOptions.length) {
      console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
    }

    var passedElement = typeof element === 'string' ? document.querySelector(element) : element;

    if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
      throw TypeError('Expected one of the following types text|select-one|select-multiple');
    }

    this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
    this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
    this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
    this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
    this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;

    if (!['auto', 'always'].includes("".concat(this.config.renderSelectedChoices))) {
      this.config.renderSelectedChoices = 'auto';
    }

    if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== 'function') {
      var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
      this.config.addItemFilter = re.test.bind(re);
    }

    if (this._isTextElement) {
      this.passedElement = new components_1.WrappedInput({
        element: passedElement,
        classNames: this.config.classNames,
        delimiter: this.config.delimiter
      });
    } else {
      this.passedElement = new components_1.WrappedSelect({
        element: passedElement,
        classNames: this.config.classNames,
        template: function (data) {
          return _this._templates.option(data);
        }
      });
    }

    this.initialised = false;
    this._store = new store_1.default();
    this._initialState = reducers_1.defaultState;
    this._currentState = reducers_1.defaultState;
    this._prevState = reducers_1.defaultState;
    this._currentValue = '';
    this._canSearch = !!this.config.searchEnabled;
    this._isScrollingOnIe = false;
    this._highlightPosition = 0;
    this._wasTap = true;
    this._placeholderValue = this._generatePlaceholderValue();
    this._baseId = (0, utils_1.generateId)(this.passedElement.element, 'choices-');
    /**
     * setting direction in cases where it's explicitly set on passedElement
     * or when calculated direction is different from the document
     */

    this._direction = this.passedElement.dir;

    if (!this._direction) {
      var elementDirection = window.getComputedStyle(this.passedElement.element).direction;
      var documentDirection = window.getComputedStyle(document.documentElement).direction;

      if (elementDirection !== documentDirection) {
        this._direction = elementDirection;
      }
    }

    this._idNames = {
      itemChoice: 'item-choice'
    };

    if (this._isSelectElement) {
      // Assign preset groups from passed element
      this._presetGroups = this.passedElement.optionGroups; // Assign preset options from passed element

      this._presetOptions = this.passedElement.options;
    } // Assign preset choices from passed object


    this._presetChoices = this.config.choices; // Assign preset items from passed object first

    this._presetItems = this.config.items; // Add any values passed from attribute

    if (this.passedElement.value && this._isTextElement) {
      var splitValues = this.passedElement.value.split(this.config.delimiter);
      this._presetItems = this._presetItems.concat(splitValues);
    } // Create array of choices from option elements


    if (this.passedElement.options) {
      this.passedElement.options.forEach(function (option) {
        _this._presetChoices.push({
          value: option.value,
          label: option.innerHTML,
          selected: !!option.selected,
          disabled: option.disabled || option.parentNode.disabled,
          placeholder: option.value === '' || option.hasAttribute('placeholder'),
          customProperties: option.dataset['custom-properties']
        });
      });
    }

    this._render = this._render.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
    this._onKeyUp = this._onKeyUp.bind(this);
    this._onKeyDown = this._onKeyDown.bind(this);
    this._onClick = this._onClick.bind(this);
    this._onTouchMove = this._onTouchMove.bind(this);
    this._onTouchEnd = this._onTouchEnd.bind(this);
    this._onMouseDown = this._onMouseDown.bind(this);
    this._onMouseOver = this._onMouseOver.bind(this);
    this._onFormReset = this._onFormReset.bind(this);
    this._onSelectKey = this._onSelectKey.bind(this);
    this._onEnterKey = this._onEnterKey.bind(this);
    this._onEscapeKey = this._onEscapeKey.bind(this);
    this._onDirectionKey = this._onDirectionKey.bind(this);
    this._onDeleteKey = this._onDeleteKey.bind(this); // If element has already been initialised with Choices, fail silently

    if (this.passedElement.isActive) {
      if (!this.config.silent) {
        console.warn('Trying to initialise Choices on element already initialised', {
          element: element
        });
      }

      this.initialised = true;
      return;
    } // Let's go


    this.init();
  }

  Object.defineProperty(Choices, "defaults", {
    get: function () {
      return Object.preventExtensions({
        get options() {
          return USER_DEFAULTS;
        },

        get templates() {
          return templates_1.default;
        }

      });
    },
    enumerable: false,
    configurable: true
  });

  Choices.prototype.init = function () {
    if (this.initialised) {
      return;
    }

    this._createTemplates();

    this._createElements();

    this._createStructure();

    this._store.subscribe(this._render);

    this._render();

    this._addEventListeners();

    var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute('disabled');

    if (shouldDisable) {
      this.disable();
    }

    this.initialised = true;
    var callbackOnInit = this.config.callbackOnInit; // Run callback if it is a function

    if (callbackOnInit && typeof callbackOnInit === 'function') {
      callbackOnInit.call(this);
    }
  };

  Choices.prototype.destroy = function () {
    if (!this.initialised) {
      return;
    }

    this._removeEventListeners();

    this.passedElement.reveal();
    this.containerOuter.unwrap(this.passedElement.element);
    this.clearStore();

    if (this._isSelectElement) {
      this.passedElement.options = this._presetOptions;
    }

    this._templates = templates_1.default;
    this.initialised = false;
  };

  Choices.prototype.enable = function () {
    if (this.passedElement.isDisabled) {
      this.passedElement.enable();
    }

    if (this.containerOuter.isDisabled) {
      this._addEventListeners();

      this.input.enable();
      this.containerOuter.enable();
    }

    return this;
  };

  Choices.prototype.disable = function () {
    if (!this.passedElement.isDisabled) {
      this.passedElement.disable();
    }

    if (!this.containerOuter.isDisabled) {
      this._removeEventListeners();

      this.input.disable();
      this.containerOuter.disable();
    }

    return this;
  };

  Choices.prototype.highlightItem = function (item, runEvent) {
    if (runEvent === void 0) {
      runEvent = true;
    }

    if (!item || !item.id) {
      return this;
    }

    var id = item.id,
        _a = item.groupId,
        groupId = _a === void 0 ? -1 : _a,
        _b = item.value,
        value = _b === void 0 ? '' : _b,
        _c = item.label,
        label = _c === void 0 ? '' : _c;
    var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;

    this._store.dispatch((0, items_1.highlightItem)(id, true));

    if (runEvent) {
      this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
        id: id,
        value: value,
        label: label,
        groupValue: group && group.value ? group.value : null
      });
    }

    return this;
  };

  Choices.prototype.unhighlightItem = function (item) {
    if (!item || !item.id) {
      return this;
    }

    var id = item.id,
        _a = item.groupId,
        groupId = _a === void 0 ? -1 : _a,
        _b = item.value,
        value = _b === void 0 ? '' : _b,
        _c = item.label,
        label = _c === void 0 ? '' : _c;
    var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;

    this._store.dispatch((0, items_1.highlightItem)(id, false));

    this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
      id: id,
      value: value,
      label: label,
      groupValue: group && group.value ? group.value : null
    });
    return this;
  };

  Choices.prototype.highlightAll = function () {
    var _this = this;

    this._store.items.forEach(function (item) {
      return _this.highlightItem(item);
    });

    return this;
  };

  Choices.prototype.unhighlightAll = function () {
    var _this = this;

    this._store.items.forEach(function (item) {
      return _this.unhighlightItem(item);
    });

    return this;
  };

  Choices.prototype.removeActiveItemsByValue = function (value) {
    var _this = this;

    this._store.activeItems.filter(function (item) {
      return item.value === value;
    }).forEach(function (item) {
      return _this._removeItem(item);
    });

    return this;
  };

  Choices.prototype.removeActiveItems = function (excludedId) {
    var _this = this;

    this._store.activeItems.filter(function (_a) {
      var id = _a.id;
      return id !== excludedId;
    }).forEach(function (item) {
      return _this._removeItem(item);
    });

    return this;
  };

  Choices.prototype.removeHighlightedItems = function (runEvent) {
    var _this = this;

    if (runEvent === void 0) {
      runEvent = false;
    }

    this._store.highlightedActiveItems.forEach(function (item) {
      _this._removeItem(item); // If this action was performed by the user
      // trigger the event


      if (runEvent) {
        _this._triggerChange(item.value);
      }
    });

    return this;
  };

  Choices.prototype.showDropdown = function (preventInputFocus) {
    var _this = this;

    if (this.dropdown.isActive) {
      return this;
    }

    requestAnimationFrame(function () {
      _this.dropdown.show();

      _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);

      if (!preventInputFocus && _this._canSearch) {
        _this.input.focus();
      }

      _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
    });
    return this;
  };

  Choices.prototype.hideDropdown = function (preventInputBlur) {
    var _this = this;

    if (!this.dropdown.isActive) {
      return this;
    }

    requestAnimationFrame(function () {
      _this.dropdown.hide();

      _this.containerOuter.close();

      if (!preventInputBlur && _this._canSearch) {
        _this.input.removeActiveDescendant();

        _this.input.blur();
      }

      _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
    });
    return this;
  };

  Choices.prototype.getValue = function (valueOnly) {
    if (valueOnly === void 0) {
      valueOnly = false;
    }

    var values = this._store.activeItems.reduce(function (selectedItems, item) {
      var itemValue = valueOnly ? item.value : item;
      selectedItems.push(itemValue);
      return selectedItems;
    }, []);

    return this._isSelectOneElement ? values[0] : values;
  };

  Choices.prototype.setValue = function (items) {
    var _this = this;

    if (!this.initialised) {
      return this;
    }

    items.forEach(function (value) {
      return _this._setChoiceOrItem(value);
    });
    return this;
  };

  Choices.prototype.setChoiceByValue = function (value) {
    var _this = this;

    if (!this.initialised || this._isTextElement) {
      return this;
    } // If only one value has been passed, convert to array


    var choiceValue = Array.isArray(value) ? value : [value]; // Loop through each value and

    choiceValue.forEach(function (val) {
      return _this._findAndSelectChoiceByValue(val);
    });
    return this;
  };
  /**
   * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
   * a value field name and a label field name.
   * This behaves the same as passing items via the choices option but can be called after initialising Choices.
   * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
   * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
   *
   * **Input types affected:** select-one, select-multiple
   *
   * @example
   * ```js
   * const example = new Choices(element);
   *
   * example.setChoices([
   *   {value: 'One', label: 'Label One', disabled: true},
   *   {value: 'Two', label: 'Label Two', selected: true},
   *   {value: 'Three', label: 'Label Three'},
   * ], 'value', 'label', false);
   * ```
   *
   * @example
   * ```js
   * const example = new Choices(element);
   *
   * example.setChoices(async () => {
   *   try {
   *      const items = await fetch('/items');
   *      return items.json()
   *   } catch(err) {
   *      console.error(err)
   *   }
   * });
   * ```
   *
   * @example
   * ```js
   * const example = new Choices(element);
   *
   * example.setChoices([{
   *   label: 'Group one',
   *   id: 1,
   *   disabled: false,
   *   choices: [
   *     {value: 'Child One', label: 'Child One', selected: true},
   *     {value: 'Child Two', label: 'Child Two',  disabled: true},
   *     {value: 'Child Three', label: 'Child Three'},
   *   ]
   * },
   * {
   *   label: 'Group two',
   *   id: 2,
   *   disabled: false,
   *   choices: [
   *     {value: 'Child Four', label: 'Child Four', disabled: true},
   *     {value: 'Child Five', label: 'Child Five'},
   *     {value: 'Child Six', label: 'Child Six', customProperties: {
   *       description: 'Custom description about child six',
   *       random: 'Another random custom property'
   *     }},
   *   ]
   * }], 'value', 'label', false);
   * ```
   */


  Choices.prototype.setChoices = function (choicesArrayOrFetcher, value, label, replaceChoices) {
    var _this = this;

    if (choicesArrayOrFetcher === void 0) {
      choicesArrayOrFetcher = [];
    }

    if (value === void 0) {
      value = 'value';
    }

    if (label === void 0) {
      label = 'label';
    }

    if (replaceChoices === void 0) {
      replaceChoices = false;
    }

    if (!this.initialised) {
      throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
    }

    if (!this._isSelectElement) {
      throw new TypeError("setChoices can't be used with INPUT based Choices");
    }

    if (typeof value !== 'string' || !value) {
      throw new TypeError("value parameter must be a name of 'value' field in passed objects");
    } // Clear choices if needed


    if (replaceChoices) {
      this.clearChoices();
    }

    if (typeof choicesArrayOrFetcher === 'function') {
      // it's a choices fetcher function
      var fetcher_1 = choicesArrayOrFetcher(this);

      if (typeof Promise === 'function' && fetcher_1 instanceof Promise) {
        // that's a promise
        // eslint-disable-next-line no-promise-executor-return
        return new Promise(function (resolve) {
          return requestAnimationFrame(resolve);
        }).then(function () {
          return _this._handleLoadingState(true);
        }).then(function () {
          return fetcher_1;
        }).then(function (data) {
          return _this.setChoices(data, value, label, replaceChoices);
        }).catch(function (err) {
          if (!_this.config.silent) {
            console.error(err);
          }
        }).then(function () {
          return _this._handleLoadingState(false);
        }).then(function () {
          return _this;
        });
      } // function returned something else than promise, let's check if it's an array of choices


      if (!Array.isArray(fetcher_1)) {
        throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
      } // recursion with results, it's sync and choices were cleared already


      return this.setChoices(fetcher_1, value, label, false);
    }

    if (!Array.isArray(choicesArrayOrFetcher)) {
      throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
    }

    this.containerOuter.removeLoadingState();

    this._startLoading();

    choicesArrayOrFetcher.forEach(function (groupOrChoice) {
      if (groupOrChoice.choices) {
        _this._addGroup({
          id: groupOrChoice.id ? parseInt("".concat(groupOrChoice.id), 10) : null,
          group: groupOrChoice,
          valueKey: value,
          labelKey: label
        });
      } else {
        var choice = groupOrChoice;

        _this._addChoice({
          value: choice[value],
          label: choice[label],
          isSelected: !!choice.selected,
          isDisabled: !!choice.disabled,
          placeholder: !!choice.placeholder,
          customProperties: choice.customProperties
        });
      }
    });

    this._stopLoading();

    return this;
  };

  Choices.prototype.clearChoices = function () {
    this._store.dispatch((0, choices_1.clearChoices)());

    return this;
  };

  Choices.prototype.clearStore = function () {
    this._store.dispatch((0, misc_1.clearAll)());

    return this;
  };

  Choices.prototype.clearInput = function () {
    var shouldSetInputWidth = !this._isSelectOneElement;
    this.input.clear(shouldSetInputWidth);

    if (!this._isTextElement && this._canSearch) {
      this._isSearching = false;

      this._store.dispatch((0, choices_1.activateChoices)(true));
    }

    return this;
  };

  Choices.prototype._render = function () {
    if (this._store.isLoading()) {
      return;
    }

    this._currentState = this._store.state;
    var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
    var shouldRenderChoices = this._isSelectElement;
    var shouldRenderItems = this._currentState.items !== this._prevState.items;

    if (!stateChanged) {
      return;
    }

    if (shouldRenderChoices) {
      this._renderChoices();
    }

    if (shouldRenderItems) {
      this._renderItems();
    }

    this._prevState = this._currentState;
  };

  Choices.prototype._renderChoices = function () {
    var _this = this;

    var _a = this._store,
        activeGroups = _a.activeGroups,
        activeChoices = _a.activeChoices;
    var choiceListFragment = document.createDocumentFragment();
    this.choiceList.clear();

    if (this.config.resetScrollPosition) {
      requestAnimationFrame(function () {
        return _this.choiceList.scrollToTop();
      });
    } // If we have grouped options


    if (activeGroups.length >= 1 && !this._isSearching) {
      // If we have a placeholder choice along with groups
      var activePlaceholders = activeChoices.filter(function (activeChoice) {
        return activeChoice.placeholder === true && activeChoice.groupId === -1;
      });

      if (activePlaceholders.length >= 1) {
        choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
      }

      choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
    } else if (activeChoices.length >= 1) {
      choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
    } // If we have choices to show


    if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
      var activeItems = this._store.activeItems;

      var canAddItem = this._canAddItem(activeItems, this.input.value); // ...and we can select them


      if (canAddItem.response) {
        // ...append them and highlight the first choice
        this.choiceList.append(choiceListFragment);

        this._highlightChoice();
      } else {
        var notice = this._getTemplate('notice', canAddItem.notice);

        this.choiceList.append(notice);
      }
    } else {
      // Otherwise show a notice
      var dropdownItem = void 0;
      var notice = void 0;

      if (this._isSearching) {
        notice = typeof this.config.noResultsText === 'function' ? this.config.noResultsText() : this.config.noResultsText;
        dropdownItem = this._getTemplate('notice', notice, 'no-results');
      } else {
        notice = typeof this.config.noChoicesText === 'function' ? this.config.noChoicesText() : this.config.noChoicesText;
        dropdownItem = this._getTemplate('notice', notice, 'no-choices');
      }

      this.choiceList.append(dropdownItem);
    }
  };

  Choices.prototype._renderItems = function () {
    var activeItems = this._store.activeItems || [];
    this.itemList.clear(); // Create a fragment to store our list items
    // (so we don't have to update the DOM for each item)

    var itemListFragment = this._createItemsFragment(activeItems); // If we have items to add, append them


    if (itemListFragment.childNodes) {
      this.itemList.append(itemListFragment);
    }
  };

  Choices.prototype._createGroupsFragment = function (groups, choices, fragment) {
    var _this = this;

    if (fragment === void 0) {
      fragment = document.createDocumentFragment();
    }

    var getGroupChoices = function (group) {
      return choices.filter(function (choice) {
        if (_this._isSelectOneElement) {
          return choice.groupId === group.id;
        }

        return choice.groupId === group.id && (_this.config.renderSelectedChoices === 'always' || !choice.selected);
      });
    }; // If sorting is enabled, filter groups


    if (this.config.shouldSort) {
      groups.sort(this.config.sorter);
    }

    groups.forEach(function (group) {
      var groupChoices = getGroupChoices(group);

      if (groupChoices.length >= 1) {
        var dropdownGroup = _this._getTemplate('choiceGroup', group);

        fragment.appendChild(dropdownGroup);

        _this._createChoicesFragment(groupChoices, fragment, true);
      }
    });
    return fragment;
  };

  Choices.prototype._createChoicesFragment = function (choices, fragment, withinGroup) {
    var _this = this;

    if (fragment === void 0) {
      fragment = document.createDocumentFragment();
    }

    if (withinGroup === void 0) {
      withinGroup = false;
    } // Create a fragment to store our list items (so we don't have to update the DOM for each item)


    var _a = this.config,
        renderSelectedChoices = _a.renderSelectedChoices,
        searchResultLimit = _a.searchResultLimit,
        renderChoiceLimit = _a.renderChoiceLimit;
    var filter = this._isSearching ? utils_1.sortByScore : this.config.sorter;

    var appendChoice = function (choice) {
      var shouldRender = renderSelectedChoices === 'auto' ? _this._isSelectOneElement || !choice.selected : true;

      if (shouldRender) {
        var dropdownItem = _this._getTemplate('choice', choice, _this.config.itemSelectText);

        fragment.appendChild(dropdownItem);
      }
    };

    var rendererableChoices = choices;

    if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {
      rendererableChoices = choices.filter(function (choice) {
        return !choice.selected;
      });
    } // Split array into placeholders and "normal" choices


    var _b = rendererableChoices.reduce(function (acc, choice) {
      if (choice.placeholder) {
        acc.placeholderChoices.push(choice);
      } else {
        acc.normalChoices.push(choice);
      }

      return acc;
    }, {
      placeholderChoices: [],
      normalChoices: []
    }),
        placeholderChoices = _b.placeholderChoices,
        normalChoices = _b.normalChoices; // If sorting is enabled or the user is searching, filter choices


    if (this.config.shouldSort || this._isSearching) {
      normalChoices.sort(filter);
    }

    var choiceLimit = rendererableChoices.length; // Prepend placeholeder

    var sortedChoices = this._isSelectOneElement ? __spreadArray(__spreadArray([], placeholderChoices, true), normalChoices, true) : normalChoices;

    if (this._isSearching) {
      choiceLimit = searchResultLimit;
    } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
      choiceLimit = renderChoiceLimit;
    } // Add each choice to dropdown within range


    for (var i = 0; i < choiceLimit; i += 1) {
      if (sortedChoices[i]) {
        appendChoice(sortedChoices[i]);
      }
    }

    return fragment;
  };

  Choices.prototype._createItemsFragment = function (items, fragment) {
    var _this = this;

    if (fragment === void 0) {
      fragment = document.createDocumentFragment();
    } // Create fragment to add elements to


    var _a = this.config,
        shouldSortItems = _a.shouldSortItems,
        sorter = _a.sorter,
        removeItemButton = _a.removeItemButton; // If sorting is enabled, filter items

    if (shouldSortItems && !this._isSelectOneElement) {
      items.sort(sorter);
    }

    if (this._isTextElement) {
      // Update the value of the hidden input
      this.passedElement.value = items.map(function (_a) {
        var value = _a.value;
        return value;
      }).join(this.config.delimiter);
    } else {
      // Update the options of the hidden input
      this.passedElement.options = items;
    }

    var addItemToFragment = function (item) {
      // Create new list element
      var listItem = _this._getTemplate('item', item, removeItemButton); // Append it to list


      fragment.appendChild(listItem);
    }; // Add each list item to list


    items.forEach(addItemToFragment);
    return fragment;
  };

  Choices.prototype._triggerChange = function (value) {
    if (value === undefined || value === null) {
      return;
    }

    this.passedElement.triggerEvent(constants_1.EVENTS.change, {
      value: value
    });
  };

  Choices.prototype._selectPlaceholderChoice = function (placeholderChoice) {
    this._addItem({
      value: placeholderChoice.value,
      label: placeholderChoice.label,
      choiceId: placeholderChoice.id,
      groupId: placeholderChoice.groupId,
      placeholder: placeholderChoice.placeholder
    });

    this._triggerChange(placeholderChoice.value);
  };

  Choices.prototype._handleButtonAction = function (activeItems, element) {
    if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
      return;
    }

    var itemId = element.parentNode && element.parentNode.dataset.id;
    var itemToRemove = itemId && activeItems.find(function (item) {
      return item.id === parseInt(itemId, 10);
    });

    if (!itemToRemove) {
      return;
    } // Remove item associated with button


    this._removeItem(itemToRemove);

    this._triggerChange(itemToRemove.value);

    if (this._isSelectOneElement && this._store.placeholderChoice) {
      this._selectPlaceholderChoice(this._store.placeholderChoice);
    }
  };

  Choices.prototype._handleItemAction = function (activeItems, element, hasShiftKey) {
    var _this = this;

    if (hasShiftKey === void 0) {
      hasShiftKey = false;
    }

    if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
      return;
    }

    var passedId = element.dataset.id; // We only want to select one item with a click
    // so we deselect any items that aren't the target
    // unless shift is being pressed

    activeItems.forEach(function (item) {
      if (item.id === parseInt("".concat(passedId), 10) && !item.highlighted) {
        _this.highlightItem(item);
      } else if (!hasShiftKey && item.highlighted) {
        _this.unhighlightItem(item);
      }
    }); // Focus input as without focus, a user cannot do anything with a
    // highlighted item

    this.input.focus();
  };

  Choices.prototype._handleChoiceAction = function (activeItems, element) {
    if (!activeItems || !element) {
      return;
    } // If we are clicking on an option


    var id = element.dataset.id;

    var choice = id && this._store.getChoiceById(id);

    if (!choice) {
      return;
    }

    var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : undefined;
    var hasActiveDropdown = this.dropdown.isActive; // Update choice keyCode

    choice.keyCode = passedKeyCode;
    this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
      choice: choice
    });

    if (!choice.selected && !choice.disabled) {
      var canAddItem = this._canAddItem(activeItems, choice.value);

      if (canAddItem.response) {
        this._addItem({
          value: choice.value,
          label: choice.label,
          choiceId: choice.id,
          groupId: choice.groupId,
          customProperties: choice.customProperties,
          placeholder: choice.placeholder,
          keyCode: choice.keyCode
        });

        this._triggerChange(choice.value);
      }
    }

    this.clearInput(); // We want to close the dropdown if we are dealing with a single select box

    if (hasActiveDropdown && this._isSelectOneElement) {
      this.hideDropdown(true);
      this.containerOuter.focus();
    }
  };

  Choices.prototype._handleBackspace = function (activeItems) {
    if (!this.config.removeItems || !activeItems) {
      return;
    }

    var lastItem = activeItems[activeItems.length - 1];
    var hasHighlightedItems = activeItems.some(function (item) {
      return item.highlighted;
    }); // If editing the last item is allowed and there are not other selected items,
    // we can edit the item value. Otherwise if we can remove items, remove all selected items

    if (this.config.editItems && !hasHighlightedItems && lastItem) {
      this.input.value = lastItem.value;
      this.input.setWidth();

      this._removeItem(lastItem);

      this._triggerChange(lastItem.value);
    } else {
      if (!hasHighlightedItems) {
        // Highlight last item if none already highlighted
        this.highlightItem(lastItem, false);
      }

      this.removeHighlightedItems(true);
    }
  };

  Choices.prototype._startLoading = function () {
    this._store.dispatch((0, misc_1.setIsLoading)(true));
  };

  Choices.prototype._stopLoading = function () {
    this._store.dispatch((0, misc_1.setIsLoading)(false));
  };

  Choices.prototype._handleLoadingState = function (setLoading) {
    if (setLoading === void 0) {
      setLoading = true;
    }

    var placeholderItem = this.itemList.getChild(".".concat(this.config.classNames.placeholder));

    if (setLoading) {
      this.disable();
      this.containerOuter.addLoadingState();

      if (this._isSelectOneElement) {
        if (!placeholderItem) {
          placeholderItem = this._getTemplate('placeholder', this.config.loadingText);

          if (placeholderItem) {
            this.itemList.append(placeholderItem);
          }
        } else {
          placeholderItem.innerHTML = this.config.loadingText;
        }
      } else {
        this.input.placeholder = this.config.loadingText;
      }
    } else {
      this.enable();
      this.containerOuter.removeLoadingState();

      if (this._isSelectOneElement) {
        if (placeholderItem) {
          placeholderItem.innerHTML = this._placeholderValue || '';
        }
      } else {
        this.input.placeholder = this._placeholderValue || '';
      }
    }
  };

  Choices.prototype._handleSearch = function (value) {
    if (!value || !this.input.isFocussed) {
      return;
    }

    var choices = this._store.choices;
    var _a = this.config,
        searchFloor = _a.searchFloor,
        searchChoices = _a.searchChoices;
    var hasUnactiveChoices = choices.some(function (option) {
      return !option.active;
    }); // Check that we have a value to search and the input was an alphanumeric character

    if (value && value.length >= searchFloor) {
      var resultCount = searchChoices ? this._searchChoices(value) : 0; // Trigger search event

      this.passedElement.triggerEvent(constants_1.EVENTS.search, {
        value: value,
        resultCount: resultCount
      });
    } else if (hasUnactiveChoices) {
      // Otherwise reset choices to active
      this._isSearching = false;

      this._store.dispatch((0, choices_1.activateChoices)(true));
    }
  };

  Choices.prototype._canAddItem = function (activeItems, value) {
    var canAddItem = true;
    var notice = typeof this.config.addItemText === 'function' ? this.config.addItemText(value) : this.config.addItemText;

    if (!this._isSelectOneElement) {
      var isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value);

      if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
        // If there is a max entry limit and we have reached that limit
        // don't update
        canAddItem = false;
        notice = typeof this.config.maxItemText === 'function' ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
      }

      if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
        canAddItem = false;
        notice = typeof this.config.uniqueItemText === 'function' ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
      }

      if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === 'function' && !this.config.addItemFilter(value)) {
        canAddItem = false;
        notice = typeof this.config.customAddItemText === 'function' ? this.config.customAddItemText(value) : this.config.customAddItemText;
      }
    }

    return {
      response: canAddItem,
      notice: notice
    };
  };

  Choices.prototype._searchChoices = function (value) {
    var newValue = typeof value === 'string' ? value.trim() : value;
    var currentValue = typeof this._currentValue === 'string' ? this._currentValue.trim() : this._currentValue;

    if (newValue.length < 1 && newValue === "".concat(currentValue, " ")) {
      return 0;
    } // If new value matches the desired length and is not the same as the current value with a space


    var haystack = this._store.searchableChoices;
    var needle = newValue;

    var keys = __spreadArray([], this.config.searchFields, true);

    var options = Object.assign(this.config.fuseOptions, {
      keys: keys,
      includeMatches: true
    });
    var fuse = new fuse_js_1.default(haystack, options);
    var results = fuse.search(needle); // see https://github.com/krisk/Fuse/issues/303

    this._currentValue = newValue;
    this._highlightPosition = 0;
    this._isSearching = true;

    this._store.dispatch((0, choices_1.filterChoices)(results));

    return results.length;
  };

  Choices.prototype._addEventListeners = function () {
    var documentElement = document.documentElement; // capture events - can cancel event processing or propagation

    documentElement.addEventListener('touchend', this._onTouchEnd, true);
    this.containerOuter.element.addEventListener('keydown', this._onKeyDown, true);
    this.containerOuter.element.addEventListener('mousedown', this._onMouseDown, true); // passive events - doesn't call `preventDefault` or `stopPropagation`

    documentElement.addEventListener('click', this._onClick, {
      passive: true
    });
    documentElement.addEventListener('touchmove', this._onTouchMove, {
      passive: true
    });
    this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
      passive: true
    });

    if (this._isSelectOneElement) {
      this.containerOuter.element.addEventListener('focus', this._onFocus, {
        passive: true
      });
      this.containerOuter.element.addEventListener('blur', this._onBlur, {
        passive: true
      });
    }

    this.input.element.addEventListener('keyup', this._onKeyUp, {
      passive: true
    });
    this.input.element.addEventListener('focus', this._onFocus, {
      passive: true
    });
    this.input.element.addEventListener('blur', this._onBlur, {
      passive: true
    });

    if (this.input.element.form) {
      this.input.element.form.addEventListener('reset', this._onFormReset, {
        passive: true
      });
    }

    this.input.addEventListeners();
  };

  Choices.prototype._removeEventListeners = function () {
    var documentElement = document.documentElement;
    documentElement.removeEventListener('touchend', this._onTouchEnd, true);
    this.containerOuter.element.removeEventListener('keydown', this._onKeyDown, true);
    this.containerOuter.element.removeEventListener('mousedown', this._onMouseDown, true);
    documentElement.removeEventListener('click', this._onClick);
    documentElement.removeEventListener('touchmove', this._onTouchMove);
    this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);

    if (this._isSelectOneElement) {
      this.containerOuter.element.removeEventListener('focus', this._onFocus);
      this.containerOuter.element.removeEventListener('blur', this._onBlur);
    }

    this.input.element.removeEventListener('keyup', this._onKeyUp);
    this.input.element.removeEventListener('focus', this._onFocus);
    this.input.element.removeEventListener('blur', this._onBlur);

    if (this.input.element.form) {
      this.input.element.form.removeEventListener('reset', this._onFormReset);
    }

    this.input.removeEventListeners();
  };

  Choices.prototype._onKeyDown = function (event) {
    var keyCode = event.keyCode;
    var activeItems = this._store.activeItems;
    var hasFocusedInput = this.input.isFocussed;
    var hasActiveDropdown = this.dropdown.isActive;
    var hasItems = this.itemList.hasChildren();
    var keyString = String.fromCharCode(keyCode);
    var wasAlphaNumericChar = /[a-zA-Z0-9-_ ]/.test(keyString);
    var BACK_KEY = constants_1.KEY_CODES.BACK_KEY,
        DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY,
        ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY,
        A_KEY = constants_1.KEY_CODES.A_KEY,
        ESC_KEY = constants_1.KEY_CODES.ESC_KEY,
        UP_KEY = constants_1.KEY_CODES.UP_KEY,
        DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY,
        PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY,
        PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;

    if (!this._isTextElement && !hasActiveDropdown && wasAlphaNumericChar) {
      this.showDropdown();

      if (!this.input.isFocussed) {
        /*
          We update the input value with the pressed key as
          the input was not focussed at the time of key press
          therefore does not have the value of the key.
        */
        this.input.value += keyString.toLowerCase();
      }
    }

    switch (keyCode) {
      case A_KEY:
        return this._onSelectKey(event, hasItems);

      case ENTER_KEY:
        return this._onEnterKey(event, activeItems, hasActiveDropdown);

      case ESC_KEY:
        return this._onEscapeKey(hasActiveDropdown);

      case UP_KEY:
      case PAGE_UP_KEY:
      case DOWN_KEY:
      case PAGE_DOWN_KEY:
        return this._onDirectionKey(event, hasActiveDropdown);

      case DELETE_KEY:
      case BACK_KEY:
        return this._onDeleteKey(event, activeItems, hasFocusedInput);

      default:
    }
  };

  Choices.prototype._onKeyUp = function (_a) {
    var target = _a.target,
        keyCode = _a.keyCode;
    var value = this.input.value;
    var activeItems = this._store.activeItems;

    var canAddItem = this._canAddItem(activeItems, value);

    var backKey = constants_1.KEY_CODES.BACK_KEY,
        deleteKey = constants_1.KEY_CODES.DELETE_KEY; // We are typing into a text input and have a value, we want to show a dropdown
    // notice. Otherwise hide the dropdown

    if (this._isTextElement) {
      var canShowDropdownNotice = canAddItem.notice && value;

      if (canShowDropdownNotice) {
        var dropdownItem = this._getTemplate('notice', canAddItem.notice);

        this.dropdown.element.innerHTML = dropdownItem.outerHTML;
        this.showDropdown(true);
      } else {
        this.hideDropdown(true);
      }
    } else {
      var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
      var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
      var canReactivateChoices = !this._isTextElement && this._isSearching;
      var canSearch = this._canSearch && canAddItem.response;

      if (userHasRemovedValue && canReactivateChoices) {
        this._isSearching = false;

        this._store.dispatch((0, choices_1.activateChoices)(true));
      } else if (canSearch) {
        this._handleSearch(this.input.value);
      }
    }

    this._canSearch = this.config.searchEnabled;
  };

  Choices.prototype._onSelectKey = function (event, hasItems) {
    var ctrlKey = event.ctrlKey,
        metaKey = event.metaKey;
    var hasCtrlDownKeyPressed = ctrlKey || metaKey; // If CTRL + A or CMD + A have been pressed and there are items to select

    if (hasCtrlDownKeyPressed && hasItems) {
      this._canSearch = false;
      var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;

      if (shouldHightlightAll) {
        this.highlightAll();
      }
    }
  };

  Choices.prototype._onEnterKey = function (event, activeItems, hasActiveDropdown) {
    var target = event.target;
    var enterKey = constants_1.KEY_CODES.ENTER_KEY;
    var targetWasButton = target && target.hasAttribute('data-button');

    if (this._isTextElement && target && target.value) {
      var value = this.input.value;

      var canAddItem = this._canAddItem(activeItems, value);

      if (canAddItem.response) {
        this.hideDropdown(true);

        this._addItem({
          value: value
        });

        this._triggerChange(value);

        this.clearInput();
      }
    }

    if (targetWasButton) {
      this._handleButtonAction(activeItems, target);

      event.preventDefault();
    }

    if (hasActiveDropdown) {
      var highlightedChoice = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));

      if (highlightedChoice) {
        // add enter keyCode value
        if (activeItems[0]) {
          activeItems[0].keyCode = enterKey; // eslint-disable-line no-param-reassign
        }

        this._handleChoiceAction(activeItems, highlightedChoice);
      }

      event.preventDefault();
    } else if (this._isSelectOneElement) {
      this.showDropdown();
      event.preventDefault();
    }
  };

  Choices.prototype._onEscapeKey = function (hasActiveDropdown) {
    if (hasActiveDropdown) {
      this.hideDropdown(true);
      this.containerOuter.focus();
    }
  };

  Choices.prototype._onDirectionKey = function (event, hasActiveDropdown) {
    var keyCode = event.keyCode,
        metaKey = event.metaKey;
    var downKey = constants_1.KEY_CODES.DOWN_KEY,
        pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY,
        pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY; // If up or down key is pressed, traverse through options

    if (hasActiveDropdown || this._isSelectOneElement) {
      this.showDropdown();
      this._canSearch = false;
      var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
      var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
      var selectableChoiceIdentifier = '[data-choice-selectable]';
      var nextEl = void 0;

      if (skipKey) {
        if (directionInt > 0) {
          nextEl = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
        } else {
          nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
        }
      } else {
        var currentEl = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));

        if (currentEl) {
          nextEl = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);
        } else {
          nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
        }
      }

      if (nextEl) {
        // We prevent default to stop the cursor moving
        // when pressing the arrow
        if (!(0, utils_1.isScrolledIntoView)(nextEl, this.choiceList.element, directionInt)) {
          this.choiceList.scrollToChildElement(nextEl, directionInt);
        }

        this._highlightChoice(nextEl);
      } // Prevent default to maintain cursor position whilst
      // traversing dropdown options


      event.preventDefault();
    }
  };

  Choices.prototype._onDeleteKey = function (event, activeItems, hasFocusedInput) {
    var target = event.target; // If backspace or delete key is pressed and the input has no value

    if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
      this._handleBackspace(activeItems);

      event.preventDefault();
    }
  };

  Choices.prototype._onTouchMove = function () {
    if (this._wasTap) {
      this._wasTap = false;
    }
  };

  Choices.prototype._onTouchEnd = function (event) {
    var target = (event || event.touches[0]).target;
    var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);

    if (touchWasWithinContainer) {
      var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;

      if (containerWasExactTarget) {
        if (this._isTextElement) {
          this.input.focus();
        } else if (this._isSelectMultipleElement) {
          this.showDropdown();
        }
      } // Prevents focus event firing


      event.stopPropagation();
    }

    this._wasTap = true;
  };
  /**
   * Handles mousedown event in capture mode for containetOuter.element
   */


  Choices.prototype._onMouseDown = function (event) {
    var target = event.target;

    if (!(target instanceof HTMLElement)) {
      return;
    } // If we have our mouse down on the scrollbar and are on IE11...


    if (IS_IE11 && this.choiceList.element.contains(target)) {
      // check if click was on a scrollbar area
      var firstChoice = this.choiceList.element.firstElementChild;
      var isOnScrollbar = this._direction === 'ltr' ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
      this._isScrollingOnIe = isOnScrollbar;
    }

    if (target === this.input.element) {
      return;
    }

    var item = target.closest('[data-button],[data-item],[data-choice]');

    if (item instanceof HTMLElement) {
      var hasShiftKey = event.shiftKey;
      var activeItems = this._store.activeItems;
      var dataset = item.dataset;

      if ('button' in dataset) {
        this._handleButtonAction(activeItems, item);
      } else if ('item' in dataset) {
        this._handleItemAction(activeItems, item, hasShiftKey);
      } else if ('choice' in dataset) {
        this._handleChoiceAction(activeItems, item);
      }
    }

    event.preventDefault();
  };
  /**
   * Handles mouseover event over this.dropdown
   * @param {MouseEvent} event
   */


  Choices.prototype._onMouseOver = function (_a) {
    var target = _a.target;

    if (target instanceof HTMLElement && 'choice' in target.dataset) {
      this._highlightChoice(target);
    }
  };

  Choices.prototype._onClick = function (_a) {
    var target = _a.target;
    var clickWasWithinContainer = this.containerOuter.element.contains(target);

    if (clickWasWithinContainer) {
      if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
        if (this._isTextElement) {
          if (document.activeElement !== this.input.element) {
            this.input.focus();
          }
        } else {
          this.showDropdown();
          this.containerOuter.focus();
        }
      } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
        this.hideDropdown();
      }
    } else {
      var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;

      if (hasHighlightedItems) {
        this.unhighlightAll();
      }

      this.containerOuter.removeFocusState();
      this.hideDropdown(true);
    }
  };

  Choices.prototype._onFocus = function (_a) {
    var _b;

    var _this = this;

    var target = _a.target;
    var focusWasWithinContainer = target && this.containerOuter.element.contains(target);

    if (!focusWasWithinContainer) {
      return;
    }

    var focusActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function () {
      if (target === _this.input.element) {
        _this.containerOuter.addFocusState();
      }
    }, _b[constants_1.SELECT_ONE_TYPE] = function () {
      _this.containerOuter.addFocusState();

      if (target === _this.input.element) {
        _this.showDropdown(true);
      }
    }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
      if (target === _this.input.element) {
        _this.showDropdown(true); // If element is a select box, the focused element is the container and the dropdown
        // isn't already open, focus and show dropdown


        _this.containerOuter.addFocusState();
      }
    }, _b);
    focusActions[this.passedElement.element.type]();
  };

  Choices.prototype._onBlur = function (_a) {
    var _b;

    var _this = this;

    var target = _a.target;
    var blurWasWithinContainer = target && this.containerOuter.element.contains(target);

    if (blurWasWithinContainer && !this._isScrollingOnIe) {
      var activeItems = this._store.activeItems;
      var hasHighlightedItems_1 = activeItems.some(function (item) {
        return item.highlighted;
      });
      var blurActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function () {
        if (target === _this.input.element) {
          _this.containerOuter.removeFocusState();

          if (hasHighlightedItems_1) {
            _this.unhighlightAll();
          }

          _this.hideDropdown(true);
        }
      }, _b[constants_1.SELECT_ONE_TYPE] = function () {
        _this.containerOuter.removeFocusState();

        if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {
          _this.hideDropdown(true);
        }
      }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
        if (target === _this.input.element) {
          _this.containerOuter.removeFocusState();

          _this.hideDropdown(true);

          if (hasHighlightedItems_1) {
            _this.unhighlightAll();
          }
        }
      }, _b);
      blurActions[this.passedElement.element.type]();
    } else {
      // On IE11, clicking the scollbar blurs our input and thus
      // closes the dropdown. To stop this, we refocus our input
      // if we know we are on IE *and* are scrolling.
      this._isScrollingOnIe = false;
      this.input.element.focus();
    }
  };

  Choices.prototype._onFormReset = function () {
    this._store.dispatch((0, misc_1.resetTo)(this._initialState));
  };

  Choices.prototype._highlightChoice = function (el) {
    var _this = this;

    if (el === void 0) {
      el = null;
    }

    var choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));

    if (!choices.length) {
      return;
    }

    var passedEl = el;
    var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState))); // Remove any highlighted choices

    highlightedChoices.forEach(function (choice) {
      choice.classList.remove(_this.config.classNames.highlightedState);
      choice.setAttribute('aria-selected', 'false');
    });

    if (passedEl) {
      this._highlightPosition = choices.indexOf(passedEl);
    } else {
      // Highlight choice based on last known highlight location
      if (choices.length > this._highlightPosition) {
        // If we have an option to highlight
        passedEl = choices[this._highlightPosition];
      } else {
        // Otherwise highlight the option before
        passedEl = choices[choices.length - 1];
      }

      if (!passedEl) {
        passedEl = choices[0];
      }
    }

    passedEl.classList.add(this.config.classNames.highlightedState);
    passedEl.setAttribute('aria-selected', 'true');
    this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
      el: passedEl
    });

    if (this.dropdown.isActive) {
      // IE11 ignores aria-label and blocks virtual keyboard
      // if aria-activedescendant is set without a dropdown
      this.input.setActiveDescendant(passedEl.id);
      this.containerOuter.setActiveDescendant(passedEl.id);
    }
  };

  Choices.prototype._addItem = function (_a) {
    var value = _a.value,
        _b = _a.label,
        label = _b === void 0 ? null : _b,
        _c = _a.choiceId,
        choiceId = _c === void 0 ? -1 : _c,
        _d = _a.groupId,
        groupId = _d === void 0 ? -1 : _d,
        _e = _a.customProperties,
        customProperties = _e === void 0 ? {} : _e,
        _f = _a.placeholder,
        placeholder = _f === void 0 ? false : _f,
        _g = _a.keyCode,
        keyCode = _g === void 0 ? -1 : _g;
    var passedValue = typeof value === 'string' ? value.trim() : value;
    var items = this._store.items;
    var passedLabel = label || passedValue;
    var passedOptionId = choiceId || -1;
    var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
    var id = items ? items.length + 1 : 1; // If a prepended value has been passed, prepend it

    if (this.config.prependValue) {
      passedValue = this.config.prependValue + passedValue.toString();
    } // If an appended value has been passed, append it


    if (this.config.appendValue) {
      passedValue += this.config.appendValue.toString();
    }

    this._store.dispatch((0, items_1.addItem)({
      value: passedValue,
      label: passedLabel,
      id: id,
      choiceId: passedOptionId,
      groupId: groupId,
      customProperties: customProperties,
      placeholder: placeholder,
      keyCode: keyCode
    }));

    if (this._isSelectOneElement) {
      this.removeActiveItems(id);
    } // Trigger change event


    this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
      id: id,
      value: passedValue,
      label: passedLabel,
      customProperties: customProperties,
      groupValue: group && group.value ? group.value : null,
      keyCode: keyCode
    });
  };

  Choices.prototype._removeItem = function (item) {
    var id = item.id,
        value = item.value,
        label = item.label,
        customProperties = item.customProperties,
        choiceId = item.choiceId,
        groupId = item.groupId;
    var group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;

    if (!id || !choiceId) {
      return;
    }

    this._store.dispatch((0, items_1.removeItem)(id, choiceId));

    this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
      id: id,
      value: value,
      label: label,
      customProperties: customProperties,
      groupValue: group && group.value ? group.value : null
    });
  };

  Choices.prototype._addChoice = function (_a) {
    var value = _a.value,
        _b = _a.label,
        label = _b === void 0 ? null : _b,
        _c = _a.isSelected,
        isSelected = _c === void 0 ? false : _c,
        _d = _a.isDisabled,
        isDisabled = _d === void 0 ? false : _d,
        _e = _a.groupId,
        groupId = _e === void 0 ? -1 : _e,
        _f = _a.customProperties,
        customProperties = _f === void 0 ? {} : _f,
        _g = _a.placeholder,
        placeholder = _g === void 0 ? false : _g,
        _h = _a.keyCode,
        keyCode = _h === void 0 ? -1 : _h;

    if (typeof value === 'undefined' || value === null) {
      return;
    } // Generate unique id


    var choices = this._store.choices;
    var choiceLabel = label || value;
    var choiceId = choices ? choices.length + 1 : 1;
    var choiceElementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choiceId);

    this._store.dispatch((0, choices_1.addChoice)({
      id: choiceId,
      groupId: groupId,
      elementId: choiceElementId,
      value: value,
      label: choiceLabel,
      disabled: isDisabled,
      customProperties: customProperties,
      placeholder: placeholder,
      keyCode: keyCode
    }));

    if (isSelected) {
      this._addItem({
        value: value,
        label: choiceLabel,
        choiceId: choiceId,
        customProperties: customProperties,
        placeholder: placeholder,
        keyCode: keyCode
      });
    }
  };

  Choices.prototype._addGroup = function (_a) {
    var _this = this;

    var group = _a.group,
        id = _a.id,
        _b = _a.valueKey,
        valueKey = _b === void 0 ? 'value' : _b,
        _c = _a.labelKey,
        labelKey = _c === void 0 ? 'label' : _c;
    var groupChoices = (0, utils_1.isType)('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));
    var groupId = id || Math.floor(new Date().valueOf() * Math.random());
    var isDisabled = group.disabled ? group.disabled : false;

    if (groupChoices) {
      this._store.dispatch((0, groups_1.addGroup)({
        value: group.label,
        id: groupId,
        active: true,
        disabled: isDisabled
      }));

      var addGroupChoices = function (choice) {
        var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;

        _this._addChoice({
          value: choice[valueKey],
          label: (0, utils_1.isType)('Object', choice) ? choice[labelKey] : choice.innerHTML,
          isSelected: choice.selected,
          isDisabled: isOptDisabled,
          groupId: groupId,
          customProperties: choice.customProperties,
          placeholder: choice.placeholder
        });
      };

      groupChoices.forEach(addGroupChoices);
    } else {
      this._store.dispatch((0, groups_1.addGroup)({
        value: group.label,
        id: group.id,
        active: false,
        disabled: group.disabled
      }));
    }
  };

  Choices.prototype._getTemplate = function (template) {
    var _a;

    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    var classNames = this.config.classNames;
    return (_a = this._templates[template]).call.apply(_a, __spreadArray([this, classNames], args, false));
  };

  Choices.prototype._createTemplates = function () {
    var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
    var userTemplates = {};

    if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === 'function') {
      userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
    }

    this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);
  };

  Choices.prototype._createElements = function () {
    this.containerOuter = new components_1.Container({
      element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type),
      classNames: this.config.classNames,
      type: this.passedElement.element.type,
      position: this.config.position
    });
    this.containerInner = new components_1.Container({
      element: this._getTemplate('containerInner'),
      classNames: this.config.classNames,
      type: this.passedElement.element.type,
      position: this.config.position
    });
    this.input = new components_1.Input({
      element: this._getTemplate('input', this._placeholderValue),
      classNames: this.config.classNames,
      type: this.passedElement.element.type,
      preventPaste: !this.config.paste
    });
    this.choiceList = new components_1.List({
      element: this._getTemplate('choiceList', this._isSelectOneElement)
    });
    this.itemList = new components_1.List({
      element: this._getTemplate('itemList', this._isSelectOneElement)
    });
    this.dropdown = new components_1.Dropdown({
      element: this._getTemplate('dropdown'),
      classNames: this.config.classNames,
      type: this.passedElement.element.type
    });
  };

  Choices.prototype._createStructure = function () {
    // Hide original element
    this.passedElement.conceal(); // Wrap input in container preserving DOM ordering

    this.containerInner.wrap(this.passedElement.element); // Wrapper inner container with outer container

    this.containerOuter.wrap(this.containerInner.element);

    if (this._isSelectOneElement) {
      this.input.placeholder = this.config.searchPlaceholderValue || '';
    } else if (this._placeholderValue) {
      this.input.placeholder = this._placeholderValue;
      this.input.setWidth();
    }

    this.containerOuter.element.appendChild(this.containerInner.element);
    this.containerOuter.element.appendChild(this.dropdown.element);
    this.containerInner.element.appendChild(this.itemList.element);

    if (!this._isTextElement) {
      this.dropdown.element.appendChild(this.choiceList.element);
    }

    if (!this._isSelectOneElement) {
      this.containerInner.element.appendChild(this.input.element);
    } else if (this.config.searchEnabled) {
      this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
    }

    if (this._isSelectElement) {
      this._highlightPosition = 0;
      this._isSearching = false;

      this._startLoading();

      if (this._presetGroups.length) {
        this._addPredefinedGroups(this._presetGroups);
      } else {
        this._addPredefinedChoices(this._presetChoices);
      }

      this._stopLoading();
    }

    if (this._isTextElement) {
      this._addPredefinedItems(this._presetItems);
    }
  };

  Choices.prototype._addPredefinedGroups = function (groups) {
    var _this = this; // If we have a placeholder option


    var placeholderChoice = this.passedElement.placeholderOption;

    if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === 'SELECT') {
      this._addChoice({
        value: placeholderChoice.value,
        label: placeholderChoice.innerHTML,
        isSelected: placeholderChoice.selected,
        isDisabled: placeholderChoice.disabled,
        placeholder: true
      });
    }

    groups.forEach(function (group) {
      return _this._addGroup({
        group: group,
        id: group.id || null
      });
    });
  };

  Choices.prototype._addPredefinedChoices = function (choices) {
    var _this = this; // If sorting is enabled or the user is searching, filter choices


    if (this.config.shouldSort) {
      choices.sort(this.config.sorter);
    }

    var hasSelectedChoice = choices.some(function (choice) {
      return choice.selected;
    });
    var firstEnabledChoiceIndex = choices.findIndex(function (choice) {
      return choice.disabled === undefined || !choice.disabled;
    });
    choices.forEach(function (choice, index) {
      var _a = choice.value,
          value = _a === void 0 ? '' : _a,
          label = choice.label,
          customProperties = choice.customProperties,
          placeholder = choice.placeholder;

      if (_this._isSelectElement) {
        // If the choice is actually a group
        if (choice.choices) {
          _this._addGroup({
            group: choice,
            id: choice.id || null
          });
        } else {
          /**
           * If there is a selected choice already or the choice is not the first in
           * the array, add each choice normally.
           *
           * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
           */
          var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index === firstEnabledChoiceIndex;
          var isSelected = shouldPreselect ? true : choice.selected;
          var isDisabled = choice.disabled;

          _this._addChoice({
            value: value,
            label: label,
            isSelected: !!isSelected,
            isDisabled: !!isDisabled,
            placeholder: !!placeholder,
            customProperties: customProperties
          });
        }
      } else {
        _this._addChoice({
          value: value,
          label: label,
          isSelected: !!choice.selected,
          isDisabled: !!choice.disabled,
          placeholder: !!choice.placeholder,
          customProperties: customProperties
        });
      }
    });
  };

  Choices.prototype._addPredefinedItems = function (items) {
    var _this = this;

    items.forEach(function (item) {
      if (typeof item === 'object' && item.value) {
        _this._addItem({
          value: item.value,
          label: item.label,
          choiceId: item.id,
          customProperties: item.customProperties,
          placeholder: item.placeholder
        });
      }

      if (typeof item === 'string') {
        _this._addItem({
          value: item
        });
      }
    });
  };

  Choices.prototype._setChoiceOrItem = function (item) {
    var _this = this;

    var itemType = (0, utils_1.getType)(item).toLowerCase();
    var handleType = {
      object: function () {
        if (!item.value) {
          return;
        } // If we are dealing with a select input, we need to create an option first
        // that is then selected. For text inputs we can just add items normally.


        if (!_this._isTextElement) {
          _this._addChoice({
            value: item.value,
            label: item.label,
            isSelected: true,
            isDisabled: false,
            customProperties: item.customProperties,
            placeholder: item.placeholder
          });
        } else {
          _this._addItem({
            value: item.value,
            label: item.label,
            choiceId: item.id,
            customProperties: item.customProperties,
            placeholder: item.placeholder
          });
        }
      },
      string: function () {
        if (!_this._isTextElement) {
          _this._addChoice({
            value: item,
            label: item,
            isSelected: true,
            isDisabled: false
          });
        } else {
          _this._addItem({
            value: item
          });
        }
      }
    };
    handleType[itemType]();
  };

  Choices.prototype._findAndSelectChoiceByValue = function (value) {
    var _this = this;

    var choices = this._store.choices; // Check 'value' property exists and the choice isn't already selected

    var foundChoice = choices.find(function (choice) {
      return _this.config.valueComparer(choice.value, value);
    });

    if (foundChoice && !foundChoice.selected) {
      this._addItem({
        value: foundChoice.value,
        label: foundChoice.label,
        choiceId: foundChoice.id,
        groupId: foundChoice.groupId,
        customProperties: foundChoice.customProperties,
        placeholder: foundChoice.placeholder,
        keyCode: foundChoice.keyCode
      });
    }
  };

  Choices.prototype._generatePlaceholderValue = function () {
    if (this._isSelectElement && this.passedElement.placeholderOption) {
      var placeholderOption = this.passedElement.placeholderOption;
      return placeholderOption ? placeholderOption.text : null;
    }

    var _a = this.config,
        placeholder = _a.placeholder,
        placeholderValue = _a.placeholderValue;
    var dataset = this.passedElement.element.dataset;

    if (placeholder) {
      if (placeholderValue) {
        return placeholderValue;
      }

      if (dataset.placeholder) {
        return dataset.placeholder;
      }
    }

    return null;
  };

  return Choices;
}();

exports["default"] = Choices;

/***/ }),

/***/ 613:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_75047__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var utils_1 = __nested_webpack_require_75047__(799);

var constants_1 = __nested_webpack_require_75047__(883);

var Container =
/** @class */
function () {
  function Container(_a) {
    var element = _a.element,
        type = _a.type,
        classNames = _a.classNames,
        position = _a.position;
    this.element = element;
    this.classNames = classNames;
    this.type = type;
    this.position = position;
    this.isOpen = false;
    this.isFlipped = false;
    this.isFocussed = false;
    this.isDisabled = false;
    this.isLoading = false;
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }

  Container.prototype.addEventListeners = function () {
    this.element.addEventListener('focus', this._onFocus);
    this.element.addEventListener('blur', this._onBlur);
  };

  Container.prototype.removeEventListeners = function () {
    this.element.removeEventListener('focus', this._onFocus);
    this.element.removeEventListener('blur', this._onBlur);
  };
  /**
   * Determine whether container should be flipped based on passed
   * dropdown position
   */


  Container.prototype.shouldFlip = function (dropdownPos) {
    if (typeof dropdownPos !== 'number') {
      return false;
    } // If flip is enabled and the dropdown bottom position is
    // greater than the window height flip the dropdown.


    var shouldFlip = false;

    if (this.position === 'auto') {
      shouldFlip = !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
    } else if (this.position === 'top') {
      shouldFlip = true;
    }

    return shouldFlip;
  };

  Container.prototype.setActiveDescendant = function (activeDescendantID) {
    this.element.setAttribute('aria-activedescendant', activeDescendantID);
  };

  Container.prototype.removeActiveDescendant = function () {
    this.element.removeAttribute('aria-activedescendant');
  };

  Container.prototype.open = function (dropdownPos) {
    this.element.classList.add(this.classNames.openState);
    this.element.setAttribute('aria-expanded', 'true');
    this.isOpen = true;

    if (this.shouldFlip(dropdownPos)) {
      this.element.classList.add(this.classNames.flippedState);
      this.isFlipped = true;
    }
  };

  Container.prototype.close = function () {
    this.element.classList.remove(this.classNames.openState);
    this.element.setAttribute('aria-expanded', 'false');
    this.removeActiveDescendant();
    this.isOpen = false; // A dropdown flips if it does not have space within the page

    if (this.isFlipped) {
      this.element.classList.remove(this.classNames.flippedState);
      this.isFlipped = false;
    }
  };

  Container.prototype.focus = function () {
    if (!this.isFocussed) {
      this.element.focus();
    }
  };

  Container.prototype.addFocusState = function () {
    this.element.classList.add(this.classNames.focusState);
  };

  Container.prototype.removeFocusState = function () {
    this.element.classList.remove(this.classNames.focusState);
  };

  Container.prototype.enable = function () {
    this.element.classList.remove(this.classNames.disabledState);
    this.element.removeAttribute('aria-disabled');

    if (this.type === constants_1.SELECT_ONE_TYPE) {
      this.element.setAttribute('tabindex', '0');
    }

    this.isDisabled = false;
  };

  Container.prototype.disable = function () {
    this.element.classList.add(this.classNames.disabledState);
    this.element.setAttribute('aria-disabled', 'true');

    if (this.type === constants_1.SELECT_ONE_TYPE) {
      this.element.setAttribute('tabindex', '-1');
    }

    this.isDisabled = true;
  };

  Container.prototype.wrap = function (element) {
    (0, utils_1.wrap)(element, this.element);
  };

  Container.prototype.unwrap = function (element) {
    if (this.element.parentNode) {
      // Move passed element outside this element
      this.element.parentNode.insertBefore(element, this.element); // Remove this element

      this.element.parentNode.removeChild(this.element);
    }
  };

  Container.prototype.addLoadingState = function () {
    this.element.classList.add(this.classNames.loadingState);
    this.element.setAttribute('aria-busy', 'true');
    this.isLoading = true;
  };

  Container.prototype.removeLoadingState = function () {
    this.element.classList.remove(this.classNames.loadingState);
    this.element.removeAttribute('aria-busy');
    this.isLoading = false;
  };

  Container.prototype._onFocus = function () {
    this.isFocussed = true;
  };

  Container.prototype._onBlur = function () {
    this.isFocussed = false;
  };

  return Container;
}();

exports["default"] = Container;

/***/ }),

/***/ 217:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var Dropdown =
/** @class */
function () {
  function Dropdown(_a) {
    var element = _a.element,
        type = _a.type,
        classNames = _a.classNames;
    this.element = element;
    this.classNames = classNames;
    this.type = type;
    this.isActive = false;
  }

  Object.defineProperty(Dropdown.prototype, "distanceFromTopWindow", {
    /**
     * Bottom position of dropdown in viewport coordinates
     */
    get: function () {
      return this.element.getBoundingClientRect().bottom;
    },
    enumerable: false,
    configurable: true
  });

  Dropdown.prototype.getChild = function (selector) {
    return this.element.querySelector(selector);
  };
  /**
   * Show dropdown to user by adding active state class
   */


  Dropdown.prototype.show = function () {
    this.element.classList.add(this.classNames.activeState);
    this.element.setAttribute('aria-expanded', 'true');
    this.isActive = true;
    return this;
  };
  /**
   * Hide dropdown from user
   */


  Dropdown.prototype.hide = function () {
    this.element.classList.remove(this.classNames.activeState);
    this.element.setAttribute('aria-expanded', 'false');
    this.isActive = false;
    return this;
  };

  return Dropdown;
}();

exports["default"] = Dropdown;

/***/ }),

/***/ 520:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_81291__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WrappedSelect = exports.WrappedInput = exports.List = exports.Input = exports.Container = exports.Dropdown = void 0;

var dropdown_1 = __importDefault(__nested_webpack_require_81291__(217));

exports.Dropdown = dropdown_1.default;

var container_1 = __importDefault(__nested_webpack_require_81291__(613));

exports.Container = container_1.default;

var input_1 = __importDefault(__nested_webpack_require_81291__(11));

exports.Input = input_1.default;

var list_1 = __importDefault(__nested_webpack_require_81291__(624));

exports.List = list_1.default;

var wrapped_input_1 = __importDefault(__nested_webpack_require_81291__(541));

exports.WrappedInput = wrapped_input_1.default;

var wrapped_select_1 = __importDefault(__nested_webpack_require_81291__(982));

exports.WrappedSelect = wrapped_select_1.default;

/***/ }),

/***/ 11:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_82353__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var utils_1 = __nested_webpack_require_82353__(799);

var constants_1 = __nested_webpack_require_82353__(883);

var Input =
/** @class */
function () {
  function Input(_a) {
    var element = _a.element,
        type = _a.type,
        classNames = _a.classNames,
        preventPaste = _a.preventPaste;
    this.element = element;
    this.type = type;
    this.classNames = classNames;
    this.preventPaste = preventPaste;
    this.isFocussed = this.element.isEqualNode(document.activeElement);
    this.isDisabled = element.disabled;
    this._onPaste = this._onPaste.bind(this);
    this._onInput = this._onInput.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }

  Object.defineProperty(Input.prototype, "placeholder", {
    set: function (placeholder) {
      this.element.placeholder = placeholder;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Input.prototype, "value", {
    get: function () {
      return (0, utils_1.sanitise)(this.element.value);
    },
    set: function (value) {
      this.element.value = value;
    },
    enumerable: false,
    configurable: true
  });

  Input.prototype.addEventListeners = function () {
    this.element.addEventListener('paste', this._onPaste);
    this.element.addEventListener('input', this._onInput, {
      passive: true
    });
    this.element.addEventListener('focus', this._onFocus, {
      passive: true
    });
    this.element.addEventListener('blur', this._onBlur, {
      passive: true
    });
  };

  Input.prototype.removeEventListeners = function () {
    this.element.removeEventListener('input', this._onInput);
    this.element.removeEventListener('paste', this._onPaste);
    this.element.removeEventListener('focus', this._onFocus);
    this.element.removeEventListener('blur', this._onBlur);
  };

  Input.prototype.enable = function () {
    this.element.removeAttribute('disabled');
    this.isDisabled = false;
  };

  Input.prototype.disable = function () {
    this.element.setAttribute('disabled', '');
    this.isDisabled = true;
  };

  Input.prototype.focus = function () {
    if (!this.isFocussed) {
      this.element.focus();
    }
  };

  Input.prototype.blur = function () {
    if (this.isFocussed) {
      this.element.blur();
    }
  };

  Input.prototype.clear = function (setWidth) {
    if (setWidth === void 0) {
      setWidth = true;
    }

    if (this.element.value) {
      this.element.value = '';
    }

    if (setWidth) {
      this.setWidth();
    }

    return this;
  };
  /**
   * Set the correct input width based on placeholder
   * value or input value
   */


  Input.prototype.setWidth = function () {
    // Resize input to contents or placeholder
    var _a = this.element,
        style = _a.style,
        value = _a.value,
        placeholder = _a.placeholder;
    style.minWidth = "".concat(placeholder.length + 1, "ch");
    style.width = "".concat(value.length + 1, "ch");
  };

  Input.prototype.setActiveDescendant = function (activeDescendantID) {
    this.element.setAttribute('aria-activedescendant', activeDescendantID);
  };

  Input.prototype.removeActiveDescendant = function () {
    this.element.removeAttribute('aria-activedescendant');
  };

  Input.prototype._onInput = function () {
    if (this.type !== constants_1.SELECT_ONE_TYPE) {
      this.setWidth();
    }
  };

  Input.prototype._onPaste = function (event) {
    if (this.preventPaste) {
      event.preventDefault();
    }
  };

  Input.prototype._onFocus = function () {
    this.isFocussed = true;
  };

  Input.prototype._onBlur = function () {
    this.isFocussed = false;
  };

  return Input;
}();

exports["default"] = Input;

/***/ }),

/***/ 624:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_86236__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var constants_1 = __nested_webpack_require_86236__(883);

var List =
/** @class */
function () {
  function List(_a) {
    var element = _a.element;
    this.element = element;
    this.scrollPos = this.element.scrollTop;
    this.height = this.element.offsetHeight;
  }

  List.prototype.clear = function () {
    this.element.innerHTML = '';
  };

  List.prototype.append = function (node) {
    this.element.appendChild(node);
  };

  List.prototype.getChild = function (selector) {
    return this.element.querySelector(selector);
  };

  List.prototype.hasChildren = function () {
    return this.element.hasChildNodes();
  };

  List.prototype.scrollToTop = function () {
    this.element.scrollTop = 0;
  };

  List.prototype.scrollToChildElement = function (element, direction) {
    var _this = this;

    if (!element) {
      return;
    }

    var listHeight = this.element.offsetHeight; // Scroll position of dropdown

    var listScrollPosition = this.element.scrollTop + listHeight;
    var elementHeight = element.offsetHeight; // Distance from bottom of element to top of parent

    var elementPos = element.offsetTop + elementHeight; // Difference between the element and scroll position

    var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
    requestAnimationFrame(function () {
      _this._animateScroll(destination, direction);
    });
  };

  List.prototype._scrollDown = function (scrollPos, strength, destination) {
    var easing = (destination - scrollPos) / strength;
    var distance = easing > 1 ? easing : 1;
    this.element.scrollTop = scrollPos + distance;
  };

  List.prototype._scrollUp = function (scrollPos, strength, destination) {
    var easing = (scrollPos - destination) / strength;
    var distance = easing > 1 ? easing : 1;
    this.element.scrollTop = scrollPos - distance;
  };

  List.prototype._animateScroll = function (destination, direction) {
    var _this = this;

    var strength = constants_1.SCROLLING_SPEED;
    var choiceListScrollTop = this.element.scrollTop;
    var continueAnimation = false;

    if (direction > 0) {
      this._scrollDown(choiceListScrollTop, strength, destination);

      if (choiceListScrollTop < destination) {
        continueAnimation = true;
      }
    } else {
      this._scrollUp(choiceListScrollTop, strength, destination);

      if (choiceListScrollTop > destination) {
        continueAnimation = true;
      }
    }

    if (continueAnimation) {
      requestAnimationFrame(function () {
        _this._animateScroll(destination, direction);
      });
    }
  };

  return List;
}();

exports["default"] = List;

/***/ }),

/***/ 730:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_89083__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var utils_1 = __nested_webpack_require_89083__(799);

var WrappedElement =
/** @class */
function () {
  function WrappedElement(_a) {
    var element = _a.element,
        classNames = _a.classNames;
    this.element = element;
    this.classNames = classNames;

    if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
      throw new TypeError('Invalid element passed');
    }

    this.isDisabled = false;
  }

  Object.defineProperty(WrappedElement.prototype, "isActive", {
    get: function () {
      return this.element.dataset.choice === 'active';
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WrappedElement.prototype, "dir", {
    get: function () {
      return this.element.dir;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WrappedElement.prototype, "value", {
    get: function () {
      return this.element.value;
    },
    set: function (value) {
      // you must define setter here otherwise it will be readonly property
      this.element.value = value;
    },
    enumerable: false,
    configurable: true
  });

  WrappedElement.prototype.conceal = function () {
    // Hide passed input
    this.element.classList.add(this.classNames.input);
    this.element.hidden = true; // Remove element from tab index

    this.element.tabIndex = -1; // Backup original styles if any

    var origStyle = this.element.getAttribute('style');

    if (origStyle) {
      this.element.setAttribute('data-choice-orig-style', origStyle);
    }

    this.element.setAttribute('data-choice', 'active');
  };

  WrappedElement.prototype.reveal = function () {
    // Reinstate passed element
    this.element.classList.remove(this.classNames.input);
    this.element.hidden = false;
    this.element.removeAttribute('tabindex'); // Recover original styles if any

    var origStyle = this.element.getAttribute('data-choice-orig-style');

    if (origStyle) {
      this.element.removeAttribute('data-choice-orig-style');
      this.element.setAttribute('style', origStyle);
    } else {
      this.element.removeAttribute('style');
    }

    this.element.removeAttribute('data-choice'); // Re-assign values - this is weird, I know
    // @todo Figure out why we need to do this

    this.element.value = this.element.value; // eslint-disable-line no-self-assign
  };

  WrappedElement.prototype.enable = function () {
    this.element.removeAttribute('disabled');
    this.element.disabled = false;
    this.isDisabled = false;
  };

  WrappedElement.prototype.disable = function () {
    this.element.setAttribute('disabled', '');
    this.element.disabled = true;
    this.isDisabled = true;
  };

  WrappedElement.prototype.triggerEvent = function (eventType, data) {
    (0, utils_1.dispatchEvent)(this.element, eventType, data);
  };

  return WrappedElement;
}();

exports["default"] = WrappedElement;

/***/ }),

/***/ 541:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_92176__) {

"use strict";


var __extends = this && this.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var wrapped_element_1 = __importDefault(__nested_webpack_require_92176__(730));

var WrappedInput =
/** @class */
function (_super) {
  __extends(WrappedInput, _super);

  function WrappedInput(_a) {
    var element = _a.element,
        classNames = _a.classNames,
        delimiter = _a.delimiter;

    var _this = _super.call(this, {
      element: element,
      classNames: classNames
    }) || this;

    _this.delimiter = delimiter;
    return _this;
  }

  Object.defineProperty(WrappedInput.prototype, "value", {
    get: function () {
      return this.element.value;
    },
    set: function (value) {
      this.element.setAttribute('value', value);
      this.element.value = value;
    },
    enumerable: false,
    configurable: true
  });
  return WrappedInput;
}(wrapped_element_1.default);

exports["default"] = WrappedInput;

/***/ }),

/***/ 982:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_94062__) {

"use strict";


var __extends = this && this.__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var wrapped_element_1 = __importDefault(__nested_webpack_require_94062__(730));

var WrappedSelect =
/** @class */
function (_super) {
  __extends(WrappedSelect, _super);

  function WrappedSelect(_a) {
    var element = _a.element,
        classNames = _a.classNames,
        template = _a.template;

    var _this = _super.call(this, {
      element: element,
      classNames: classNames
    }) || this;

    _this.template = template;
    return _this;
  }

  Object.defineProperty(WrappedSelect.prototype, "placeholderOption", {
    get: function () {
      return this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
      this.element.querySelector('option[placeholder]');
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WrappedSelect.prototype, "optionGroups", {
    get: function () {
      return Array.from(this.element.getElementsByTagName('OPTGROUP'));
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WrappedSelect.prototype, "options", {
    get: function () {
      return Array.from(this.element.options);
    },
    set: function (options) {
      var _this = this;

      var fragment = document.createDocumentFragment();

      var addOptionToFragment = function (data) {
        // Create a standard select option
        var option = _this.template(data); // Append it to fragment


        fragment.appendChild(option);
      }; // Add each list item to list


      options.forEach(function (optionData) {
        return addOptionToFragment(optionData);
      });
      this.appendDocFragment(fragment);
    },
    enumerable: false,
    configurable: true
  });

  WrappedSelect.prototype.appendDocFragment = function (fragment) {
    this.element.innerHTML = '';
    this.element.appendChild(fragment);
  };

  return WrappedSelect;
}(wrapped_element_1.default);

exports["default"] = WrappedSelect;

/***/ }),

/***/ 883:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SCROLLING_SPEED = exports.SELECT_MULTIPLE_TYPE = exports.SELECT_ONE_TYPE = exports.TEXT_TYPE = exports.KEY_CODES = exports.ACTION_TYPES = exports.EVENTS = void 0;
exports.EVENTS = {
  showDropdown: 'showDropdown',
  hideDropdown: 'hideDropdown',
  change: 'change',
  choice: 'choice',
  search: 'search',
  addItem: 'addItem',
  removeItem: 'removeItem',
  highlightItem: 'highlightItem',
  highlightChoice: 'highlightChoice',
  unhighlightItem: 'unhighlightItem'
};
exports.ACTION_TYPES = {
  ADD_CHOICE: 'ADD_CHOICE',
  FILTER_CHOICES: 'FILTER_CHOICES',
  ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
  CLEAR_CHOICES: 'CLEAR_CHOICES',
  ADD_GROUP: 'ADD_GROUP',
  ADD_ITEM: 'ADD_ITEM',
  REMOVE_ITEM: 'REMOVE_ITEM',
  HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
  CLEAR_ALL: 'CLEAR_ALL',
  RESET_TO: 'RESET_TO',
  SET_IS_LOADING: 'SET_IS_LOADING'
};
exports.KEY_CODES = {
  BACK_KEY: 46,
  DELETE_KEY: 8,
  ENTER_KEY: 13,
  A_KEY: 65,
  ESC_KEY: 27,
  UP_KEY: 38,
  DOWN_KEY: 40,
  PAGE_UP_KEY: 33,
  PAGE_DOWN_KEY: 34
};
exports.TEXT_TYPE = 'text';
exports.SELECT_ONE_TYPE = 'select-one';
exports.SELECT_MULTIPLE_TYPE = 'select-multiple';
exports.SCROLLING_SPEED = 4;

/***/ }),

/***/ 789:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_98421__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DEFAULT_CONFIG = exports.DEFAULT_CLASSNAMES = void 0;

var utils_1 = __nested_webpack_require_98421__(799);

exports.DEFAULT_CLASSNAMES = {
  containerOuter: 'choices',
  containerInner: 'choices__inner',
  input: 'choices__input',
  inputCloned: 'choices__input--cloned',
  list: 'choices__list',
  listItems: 'choices__list--multiple',
  listSingle: 'choices__list--single',
  listDropdown: 'choices__list--dropdown',
  item: 'choices__item',
  itemSelectable: 'choices__item--selectable',
  itemDisabled: 'choices__item--disabled',
  itemChoice: 'choices__item--choice',
  placeholder: 'choices__placeholder',
  group: 'choices__group',
  groupHeading: 'choices__heading',
  button: 'choices__button',
  activeState: 'is-active',
  focusState: 'is-focused',
  openState: 'is-open',
  disabledState: 'is-disabled',
  highlightedState: 'is-highlighted',
  selectedState: 'is-selected',
  flippedState: 'is-flipped',
  loadingState: 'is-loading',
  noResults: 'has-no-results',
  noChoices: 'has-no-choices'
};
exports.DEFAULT_CONFIG = {
  items: [],
  choices: [],
  silent: false,
  renderChoiceLimit: -1,
  maxItemCount: -1,
  addItems: true,
  addItemFilter: null,
  removeItems: true,
  removeItemButton: false,
  editItems: false,
  duplicateItemsAllowed: true,
  delimiter: ',',
  paste: true,
  searchEnabled: true,
  searchChoices: true,
  searchFloor: 1,
  searchResultLimit: 4,
  searchFields: ['label', 'value'],
  position: 'auto',
  resetScrollPosition: true,
  shouldSort: true,
  shouldSortItems: false,
  sorter: utils_1.sortByAlpha,
  placeholder: true,
  placeholderValue: null,
  searchPlaceholderValue: null,
  prependValue: null,
  appendValue: null,
  renderSelectedChoices: 'auto',
  loadingText: 'Loading...',
  noResultsText: 'No results found',
  noChoicesText: 'No choices to choose from',
  itemSelectText: 'Press to select',
  uniqueItemText: 'Only unique values can be added',
  customAddItemText: 'Only values matching specific conditions can be added',
  addItemText: function (value) {
    return "Press Enter to add <b>\"".concat((0, utils_1.sanitise)(value), "\"</b>");
  },
  maxItemText: function (maxItemCount) {
    return "Only ".concat(maxItemCount, " values can be added");
  },
  valueComparer: function (value1, value2) {
    return value1 === value2;
  },
  fuseOptions: {
    includeScore: true
  },
  callbackOnInit: null,
  callbackOnCreateTemplates: null,
  classNames: exports.DEFAULT_CLASSNAMES
};

/***/ }),

/***/ 799:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diff = exports.cloneObject = exports.existsInArray = exports.dispatchEvent = exports.sortByScore = exports.sortByAlpha = exports.strToEl = exports.sanitise = exports.isScrolledIntoView = exports.getAdjacentEl = exports.wrap = exports.isType = exports.getType = exports.generateId = exports.generateChars = exports.getRandomNumber = void 0;

var getRandomNumber = function (min, max) {
  return Math.floor(Math.random() * (max - min) + min);
};

exports.getRandomNumber = getRandomNumber;

var generateChars = function (length) {
  return Array.from({
    length: length
  }, function () {
    return (0, exports.getRandomNumber)(0, 36).toString(36);
  }).join('');
};

exports.generateChars = generateChars;

var generateId = function (element, prefix) {
  var id = element.id || element.name && "".concat(element.name, "-").concat((0, exports.generateChars)(2)) || (0, exports.generateChars)(4);
  id = id.replace(/(:|\.|\[|\]|,)/g, '');
  id = "".concat(prefix, "-").concat(id);
  return id;
};

exports.generateId = generateId;

var getType = function (obj) {
  return Object.prototype.toString.call(obj).slice(8, -1);
};

exports.getType = getType;

var isType = function (type, obj) {
  return obj !== undefined && obj !== null && (0, exports.getType)(obj) === type;
};

exports.isType = isType;

var wrap = function (element, wrapper) {
  if (wrapper === void 0) {
    wrapper = document.createElement('div');
  }

  if (element.parentNode) {
    if (element.nextSibling) {
      element.parentNode.insertBefore(wrapper, element.nextSibling);
    } else {
      element.parentNode.appendChild(wrapper);
    }
  }

  return wrapper.appendChild(element);
};

exports.wrap = wrap;

var getAdjacentEl = function (startEl, selector, direction) {
  if (direction === void 0) {
    direction = 1;
  }

  var prop = "".concat(direction > 0 ? 'next' : 'previous', "ElementSibling");
  var sibling = startEl[prop];

  while (sibling) {
    if (sibling.matches(selector)) {
      return sibling;
    }

    sibling = sibling[prop];
  }

  return sibling;
};

exports.getAdjacentEl = getAdjacentEl;

var isScrolledIntoView = function (element, parent, direction) {
  if (direction === void 0) {
    direction = 1;
  }

  if (!element) {
    return false;
  }

  var isVisible;

  if (direction > 0) {
    // In view from bottom
    isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
  } else {
    // In view from top
    isVisible = element.offsetTop >= parent.scrollTop;
  }

  return isVisible;
};

exports.isScrolledIntoView = isScrolledIntoView;

var sanitise = function (value) {
  if (typeof value !== 'string') {
    return value;
  }

  return value.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
};

exports.sanitise = sanitise;

exports.strToEl = function () {
  var tmpEl = document.createElement('div');
  return function (str) {
    var cleanedInput = str.trim();
    tmpEl.innerHTML = cleanedInput;
    var firldChild = tmpEl.children[0];

    while (tmpEl.firstChild) {
      tmpEl.removeChild(tmpEl.firstChild);
    }

    return firldChild;
  };
}();

var sortByAlpha = function (_a, _b) {
  var value = _a.value,
      _c = _a.label,
      label = _c === void 0 ? value : _c;
  var value2 = _b.value,
      _d = _b.label,
      label2 = _d === void 0 ? value2 : _d;
  return label.localeCompare(label2, [], {
    sensitivity: 'base',
    ignorePunctuation: true,
    numeric: true
  });
};

exports.sortByAlpha = sortByAlpha;

var sortByScore = function (a, b) {
  var _a = a.score,
      scoreA = _a === void 0 ? 0 : _a;
  var _b = b.score,
      scoreB = _b === void 0 ? 0 : _b;
  return scoreA - scoreB;
};

exports.sortByScore = sortByScore;

var dispatchEvent = function (element, type, customArgs) {
  if (customArgs === void 0) {
    customArgs = null;
  }

  var event = new CustomEvent(type, {
    detail: customArgs,
    bubbles: true,
    cancelable: true
  });
  return element.dispatchEvent(event);
};

exports.dispatchEvent = dispatchEvent;

var existsInArray = function (array, value, key) {
  if (key === void 0) {
    key = 'value';
  }

  return array.some(function (item) {
    if (typeof value === 'string') {
      return item[key] === value.trim();
    }

    return item[key] === value;
  });
};

exports.existsInArray = existsInArray;

var cloneObject = function (obj) {
  return JSON.parse(JSON.stringify(obj));
};

exports.cloneObject = cloneObject;
/**
 * Returns an array of keys present on the first but missing on the second object
 */

var diff = function (a, b) {
  var aKeys = Object.keys(a).sort();
  var bKeys = Object.keys(b).sort();
  return aKeys.filter(function (i) {
    return bKeys.indexOf(i) < 0;
  });
};

exports.diff = diff;

/***/ }),

/***/ 273:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultState = void 0;
exports.defaultState = [];

function choices(state, action) {
  if (state === void 0) {
    state = exports.defaultState;
  }

  if (action === void 0) {
    action = {};
  }

  switch (action.type) {
    case 'ADD_CHOICE':
      {
        var addChoiceAction = action;
        var choice = {
          id: addChoiceAction.id,
          elementId: addChoiceAction.elementId,
          groupId: addChoiceAction.groupId,
          value: addChoiceAction.value,
          label: addChoiceAction.label || addChoiceAction.value,
          disabled: addChoiceAction.disabled || false,
          selected: false,
          active: true,
          score: 9999,
          customProperties: addChoiceAction.customProperties,
          placeholder: addChoiceAction.placeholder || false
        };
        /*
          A disabled choice appears in the choice dropdown but cannot be selected
          A selected choice has been added to the passed input's value (added as an item)
          An active choice appears within the choice dropdown
        */

        return __spreadArray(__spreadArray([], state, true), [choice], false);
      }

    case 'ADD_ITEM':
      {
        var addItemAction_1 = action; // When an item is added and it has an associated choice,
        // we want to disable it so it can't be chosen again

        if (addItemAction_1.choiceId > -1) {
          return state.map(function (obj) {
            var choice = obj;

            if (choice.id === parseInt("".concat(addItemAction_1.choiceId), 10)) {
              choice.selected = true;
            }

            return choice;
          });
        }

        return state;
      }

    case 'REMOVE_ITEM':
      {
        var removeItemAction_1 = action; // When an item is removed and it has an associated choice,
        // we want to re-enable it so it can be chosen again

        if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
          return state.map(function (obj) {
            var choice = obj;

            if (choice.id === parseInt("".concat(removeItemAction_1.choiceId), 10)) {
              choice.selected = false;
            }

            return choice;
          });
        }

        return state;
      }

    case 'FILTER_CHOICES':
      {
        var filterChoicesAction_1 = action;
        return state.map(function (obj) {
          var choice = obj; // Set active state based on whether choice is
          // within filtered results

          choice.active = filterChoicesAction_1.results.some(function (_a) {
            var item = _a.item,
                score = _a.score;

            if (item.id === choice.id) {
              choice.score = score;
              return true;
            }

            return false;
          });
          return choice;
        });
      }

    case 'ACTIVATE_CHOICES':
      {
        var activateChoicesAction_1 = action;
        return state.map(function (obj) {
          var choice = obj;
          choice.active = activateChoicesAction_1.active;
          return choice;
        });
      }

    case 'CLEAR_CHOICES':
      {
        return exports.defaultState;
      }

    default:
      {
        return state;
      }
  }
}

exports["default"] = choices;

/***/ }),

/***/ 871:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultState = void 0;
exports.defaultState = [];

function groups(state, action) {
  if (state === void 0) {
    state = exports.defaultState;
  }

  if (action === void 0) {
    action = {};
  }

  switch (action.type) {
    case 'ADD_GROUP':
      {
        var addGroupAction = action;
        return __spreadArray(__spreadArray([], state, true), [{
          id: addGroupAction.id,
          value: addGroupAction.value,
          active: addGroupAction.active,
          disabled: addGroupAction.disabled
        }], false);
      }

    case 'CLEAR_CHOICES':
      {
        return [];
      }

    default:
      {
        return state;
      }
  }
}

exports["default"] = groups;

/***/ }),

/***/ 655:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_111034__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultState = void 0;

var redux_1 = __nested_webpack_require_111034__(857);

var items_1 = __importDefault(__nested_webpack_require_111034__(52));

var groups_1 = __importDefault(__nested_webpack_require_111034__(871));

var choices_1 = __importDefault(__nested_webpack_require_111034__(273));

var loading_1 = __importDefault(__nested_webpack_require_111034__(502));

var utils_1 = __nested_webpack_require_111034__(799);

exports.defaultState = {
  groups: [],
  items: [],
  choices: [],
  loading: false
};
var appReducer = (0, redux_1.combineReducers)({
  items: items_1.default,
  groups: groups_1.default,
  choices: choices_1.default,
  loading: loading_1.default
});

var rootReducer = function (passedState, action) {
  var state = passedState; // If we are clearing all items, groups and options we reassign
  // state and then pass that state to our proper reducer. This isn't
  // mutating our actual state
  // See: http://stackoverflow.com/a/35641992

  if (action.type === 'CLEAR_ALL') {
    state = exports.defaultState;
  } else if (action.type === 'RESET_TO') {
    return (0, utils_1.cloneObject)(action.state);
  }

  return appReducer(state, action);
};

exports["default"] = rootReducer;

/***/ }),

/***/ 52:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultState = void 0;
exports.defaultState = [];

function items(state, action) {
  if (state === void 0) {
    state = exports.defaultState;
  }

  if (action === void 0) {
    action = {};
  }

  switch (action.type) {
    case 'ADD_ITEM':
      {
        var addItemAction = action; // Add object to items array

        var newState = __spreadArray(__spreadArray([], state, true), [{
          id: addItemAction.id,
          choiceId: addItemAction.choiceId,
          groupId: addItemAction.groupId,
          value: addItemAction.value,
          label: addItemAction.label,
          active: true,
          highlighted: false,
          customProperties: addItemAction.customProperties,
          placeholder: addItemAction.placeholder || false,
          keyCode: null
        }], false);

        return newState.map(function (obj) {
          var item = obj;
          item.highlighted = false;
          return item;
        });
      }

    case 'REMOVE_ITEM':
      {
        // Set item to inactive
        return state.map(function (obj) {
          var item = obj;

          if (item.id === action.id) {
            item.active = false;
          }

          return item;
        });
      }

    case 'HIGHLIGHT_ITEM':
      {
        var highlightItemAction_1 = action;
        return state.map(function (obj) {
          var item = obj;

          if (item.id === highlightItemAction_1.id) {
            item.highlighted = highlightItemAction_1.highlighted;
          }

          return item;
        });
      }

    default:
      {
        return state;
      }
  }
}

exports["default"] = items;

/***/ }),

/***/ 502:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.defaultState = void 0;
exports.defaultState = false;

var general = function (state, action) {
  if (state === void 0) {
    state = exports.defaultState;
  }

  if (action === void 0) {
    action = {};
  }

  switch (action.type) {
    case 'SET_IS_LOADING':
      {
        return action.isLoading;
      }

    default:
      {
        return state;
      }
  }
};

exports["default"] = general;

/***/ }),

/***/ 744:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_115203__) {

"use strict";


var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
/* eslint-disable @typescript-eslint/no-explicit-any */

var redux_1 = __nested_webpack_require_115203__(857);

var index_1 = __importDefault(__nested_webpack_require_115203__(655));

var Store =
/** @class */
function () {
  function Store() {
    this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
  }
  /**
   * Subscribe store to function call (wrapped Redux method)
   */


  Store.prototype.subscribe = function (onChange) {
    this._store.subscribe(onChange);
  };
  /**
   * Dispatch event to store (wrapped Redux method)
   */


  Store.prototype.dispatch = function (action) {
    this._store.dispatch(action);
  };

  Object.defineProperty(Store.prototype, "state", {
    /**
     * Get store object (wrapping Redux method)
     */
    get: function () {
      return this._store.getState();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "items", {
    /**
     * Get items from store
     */
    get: function () {
      return this.state.items;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "activeItems", {
    /**
     * Get active items from store
     */
    get: function () {
      return this.items.filter(function (item) {
        return item.active === true;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "highlightedActiveItems", {
    /**
     * Get highlighted items from store
     */
    get: function () {
      return this.items.filter(function (item) {
        return item.active && item.highlighted;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "choices", {
    /**
     * Get choices from store
     */
    get: function () {
      return this.state.choices;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "activeChoices", {
    /**
     * Get active choices from store
     */
    get: function () {
      return this.choices.filter(function (choice) {
        return choice.active === true;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "selectableChoices", {
    /**
     * Get selectable choices from store
     */
    get: function () {
      return this.choices.filter(function (choice) {
        return choice.disabled !== true;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "searchableChoices", {
    /**
     * Get choices that can be searched (excluding placeholders)
     */
    get: function () {
      return this.selectableChoices.filter(function (choice) {
        return choice.placeholder !== true;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "placeholderChoice", {
    /**
     * Get placeholder choice from store
     */
    get: function () {
      return __spreadArray([], this.choices, true).reverse().find(function (choice) {
        return choice.placeholder === true;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "groups", {
    /**
     * Get groups from store
     */
    get: function () {
      return this.state.groups;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Store.prototype, "activeGroups", {
    /**
     * Get active groups from store
     */
    get: function () {
      var _a = this,
          groups = _a.groups,
          choices = _a.choices;

      return groups.filter(function (group) {
        var isActive = group.active === true && group.disabled === false;
        var hasActiveOptions = choices.some(function (choice) {
          return choice.active === true && choice.disabled === false;
        });
        return isActive && hasActiveOptions;
      }, []);
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Get loading state from store
   */

  Store.prototype.isLoading = function () {
    return this.state.loading;
  };
  /**
   * Get single choice by it's ID
   */


  Store.prototype.getChoiceById = function (id) {
    return this.activeChoices.find(function (choice) {
      return choice.id === parseInt(id, 10);
    });
  };
  /**
   * Get group by group id
   */


  Store.prototype.getGroupById = function (id) {
    return this.groups.find(function (group) {
      return group.id === id;
    });
  };

  return Store;
}();

exports["default"] = Store;

/***/ }),

/***/ 686:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/**
 * Helpers to create HTML elements used by Choices
 * Can be overridden by providing `callbackOnCreateTemplates` option
 */

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var templates = {
  containerOuter: function (_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType) {
    var containerOuter = _a.containerOuter;
    var div = Object.assign(document.createElement('div'), {
      className: containerOuter
    });
    div.dataset.type = passedElementType;

    if (dir) {
      div.dir = dir;
    }

    if (isSelectOneElement) {
      div.tabIndex = 0;
    }

    if (isSelectElement) {
      div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');

      if (searchEnabled) {
        div.setAttribute('aria-autocomplete', 'list');
      }
    }

    div.setAttribute('aria-haspopup', 'true');
    div.setAttribute('aria-expanded', 'false');
    return div;
  },
  containerInner: function (_a) {
    var containerInner = _a.containerInner;
    return Object.assign(document.createElement('div'), {
      className: containerInner
    });
  },
  itemList: function (_a, isSelectOneElement) {
    var list = _a.list,
        listSingle = _a.listSingle,
        listItems = _a.listItems;
    return Object.assign(document.createElement('div'), {
      className: "".concat(list, " ").concat(isSelectOneElement ? listSingle : listItems)
    });
  },
  placeholder: function (_a, value) {
    var placeholder = _a.placeholder;
    return Object.assign(document.createElement('div'), {
      className: placeholder,
      innerHTML: value
    });
  },
  item: function (_a, _b, removeItemButton) {
    var item = _a.item,
        button = _a.button,
        highlightedState = _a.highlightedState,
        itemSelectable = _a.itemSelectable,
        placeholder = _a.placeholder;
    var id = _b.id,
        value = _b.value,
        label = _b.label,
        customProperties = _b.customProperties,
        active = _b.active,
        disabled = _b.disabled,
        highlighted = _b.highlighted,
        isPlaceholder = _b.placeholder;
    var div = Object.assign(document.createElement('div'), {
      className: item,
      innerHTML: label
    });
    Object.assign(div.dataset, {
      item: '',
      id: id,
      value: value,
      customProperties: customProperties
    });

    if (active) {
      div.setAttribute('aria-selected', 'true');
    }

    if (disabled) {
      div.setAttribute('aria-disabled', 'true');
    }

    if (isPlaceholder) {
      div.classList.add(placeholder);
    }

    div.classList.add(highlighted ? highlightedState : itemSelectable);

    if (removeItemButton) {
      if (disabled) {
        div.classList.remove(itemSelectable);
      }

      div.dataset.deletable = '';
      /** @todo This MUST be localizable, not hardcoded! */

      var REMOVE_ITEM_TEXT = 'Remove item';
      var removeButton = Object.assign(document.createElement('button'), {
        type: 'button',
        className: button,
        innerHTML: REMOVE_ITEM_TEXT
      });
      removeButton.setAttribute('aria-label', "".concat(REMOVE_ITEM_TEXT, ": '").concat(value, "'"));
      removeButton.dataset.button = '';
      div.appendChild(removeButton);
    }

    return div;
  },
  choiceList: function (_a, isSelectOneElement) {
    var list = _a.list;
    var div = Object.assign(document.createElement('div'), {
      className: list
    });

    if (!isSelectOneElement) {
      div.setAttribute('aria-multiselectable', 'true');
    }

    div.setAttribute('role', 'listbox');
    return div;
  },
  choiceGroup: function (_a, _b) {
    var group = _a.group,
        groupHeading = _a.groupHeading,
        itemDisabled = _a.itemDisabled;
    var id = _b.id,
        value = _b.value,
        disabled = _b.disabled;
    var div = Object.assign(document.createElement('div'), {
      className: "".concat(group, " ").concat(disabled ? itemDisabled : '')
    });
    div.setAttribute('role', 'group');
    Object.assign(div.dataset, {
      group: '',
      id: id,
      value: value
    });

    if (disabled) {
      div.setAttribute('aria-disabled', 'true');
    }

    div.appendChild(Object.assign(document.createElement('div'), {
      className: groupHeading,
      innerHTML: value
    }));
    return div;
  },
  choice: function (_a, _b, selectText) {
    var item = _a.item,
        itemChoice = _a.itemChoice,
        itemSelectable = _a.itemSelectable,
        selectedState = _a.selectedState,
        itemDisabled = _a.itemDisabled,
        placeholder = _a.placeholder;
    var id = _b.id,
        value = _b.value,
        label = _b.label,
        groupId = _b.groupId,
        elementId = _b.elementId,
        isDisabled = _b.disabled,
        isSelected = _b.selected,
        isPlaceholder = _b.placeholder;
    var div = Object.assign(document.createElement('div'), {
      id: elementId,
      innerHTML: label,
      className: "".concat(item, " ").concat(itemChoice)
    });

    if (isSelected) {
      div.classList.add(selectedState);
    }

    if (isPlaceholder) {
      div.classList.add(placeholder);
    }

    div.setAttribute('role', groupId && groupId > 0 ? 'treeitem' : 'option');
    Object.assign(div.dataset, {
      choice: '',
      id: id,
      value: value,
      selectText: selectText
    });

    if (isDisabled) {
      div.classList.add(itemDisabled);
      div.dataset.choiceDisabled = '';
      div.setAttribute('aria-disabled', 'true');
    } else {
      div.classList.add(itemSelectable);
      div.dataset.choiceSelectable = '';
    }

    return div;
  },
  input: function (_a, placeholderValue) {
    var input = _a.input,
        inputCloned = _a.inputCloned;
    var inp = Object.assign(document.createElement('input'), {
      type: 'text',
      className: "".concat(input, " ").concat(inputCloned),
      autocomplete: 'off',
      autocapitalize: 'off',
      spellcheck: false
    });
    inp.setAttribute('role', 'textbox');
    inp.setAttribute('aria-autocomplete', 'list');
    inp.setAttribute('aria-label', placeholderValue);
    return inp;
  },
  dropdown: function (_a) {
    var list = _a.list,
        listDropdown = _a.listDropdown;
    var div = document.createElement('div');
    div.classList.add(list, listDropdown);
    div.setAttribute('aria-expanded', 'false');
    return div;
  },
  notice: function (_a, innerHTML, type) {
    var item = _a.item,
        itemChoice = _a.itemChoice,
        noResults = _a.noResults,
        noChoices = _a.noChoices;

    if (type === void 0) {
      type = '';
    }

    var classes = [item, itemChoice];

    if (type === 'no-choices') {
      classes.push(noChoices);
    } else if (type === 'no-results') {
      classes.push(noResults);
    }

    return Object.assign(document.createElement('div'), {
      innerHTML: innerHTML,
      className: classes.join(' ')
    });
  },
  option: function (_a) {
    var label = _a.label,
        value = _a.value,
        customProperties = _a.customProperties,
        active = _a.active,
        disabled = _a.disabled;
    var opt = new Option(label, value, false, active);

    if (customProperties) {
      opt.dataset.customProperties = "".concat(customProperties);
    }

    opt.disabled = !!disabled;
    return opt;
  }
};
exports["default"] = templates;

/***/ }),

/***/ 996:
/***/ (function(module) {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ 70:
/***/ (function(module) {

/*!
 * Fuse.js v3.4.6 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
!function(e,t){  true?module.exports=t():0}(this,function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(e,t){e.exports=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}},function(e,t,n){function r(e){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var i=n(2),a=n(8),s=n(0),c=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.caseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m,S=n.id,x=void 0===S?null:S,b=n.keys,M=void 0===b?[]:b,_=n.shouldSort,L=void 0===_||_,w=n.getFn,A=void 0===w?a:w,C=n.sortFn,I=void 0===C?function(e,t){return e.score-t.score}:C,O=n.tokenize,j=void 0!==O&&O,P=n.matchAllTokens,F=void 0!==P&&P,T=n.includeMatches,z=void 0!==T&&T,E=n.includeScore,K=void 0!==E&&E,$=n.verbose,J=void 0!==$&&$;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k,id:x,keys:M,includeMatches:z,includeScore:K,shouldSort:L,getFn:A,sortFn:I,verbose:J,tokenize:j,matchAllTokens:F},this.setCollection(t)}var t,n,c;return t=e,(n=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var n=this._prepareSearchers(e),r=n.tokenSearchers,o=n.fullSearcher,i=this._search(r,o),a=i.weights,s=i.results;return this._computeScore(a,s),this.options.shouldSort&&this._sort(s),t.limit&&"number"==typeof t.limit&&(s=s.slice(0,t.limit)),this._format(s)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize)for(var n=e.split(this.options.tokenSeparator),r=0,o=n.length;r<o;r+=1)t.push(new i(n[r],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=this.list,r={},o=[];if("string"==typeof n[0]){for(var i=0,a=n.length;i<a;i+=1)this._analyze({key:"",value:n[i],record:i,index:i},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t});return{weights:null,results:o}}for(var s={},c=0,h=n.length;c<h;c+=1)for(var l=n[c],u=0,f=this.options.keys.length;u<f;u+=1){var d=this.options.keys[u];if("string"!=typeof d){if(s[d.name]={weight:1-d.weight||1},d.weight<=0||d.weight>1)throw new Error("Key weight has to be > 0 and <= 1");d=d.name}else s[d]={weight:1};this._analyze({key:d,value:this.options.getFn(l,d),record:l,index:c},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t})}return{weights:s,results:o}}},{key:"_analyze",value:function(e,t){var n=e.key,r=e.arrayIndex,o=void 0===r?-1:r,i=e.value,a=e.record,c=e.index,h=t.tokenSearchers,l=void 0===h?[]:h,u=t.fullSearcher,f=void 0===u?[]:u,d=t.resultMap,v=void 0===d?{}:d,p=t.results,g=void 0===p?[]:p;if(null!=i){var y=!1,m=-1,k=0;if("string"==typeof i){this._log("\nKey: ".concat(""===n?"-":n));var S=f.search(i);if(this._log('Full text: "'.concat(i,'", score: ').concat(S.score)),this.options.tokenize){for(var x=i.split(this.options.tokenSeparator),b=[],M=0;M<l.length;M+=1){var _=l[M];this._log('\nPattern: "'.concat(_.pattern,'"'));for(var L=!1,w=0;w<x.length;w+=1){var A=x[w],C=_.search(A),I={};C.isMatch?(I[A]=C.score,y=!0,L=!0,b.push(C.score)):(I[A]=1,this.options.matchAllTokens||b.push(1)),this._log('Token: "'.concat(A,'", score: ').concat(I[A]))}L&&(k+=1)}m=b[0];for(var O=b.length,j=1;j<O;j+=1)m+=b[j];m/=O,this._log("Token score average:",m)}var P=S.score;m>-1&&(P=(P+m)/2),this._log("Score average:",P);var F=!this.options.tokenize||!this.options.matchAllTokens||k>=l.length;if(this._log("\nCheck Matches: ".concat(F)),(y||S.isMatch)&&F){var T=v[c];T?T.output.push({key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}):(v[c]={item:a,output:[{key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}]},g.push(v[c]))}}else if(s(i))for(var z=0,E=i.length;z<E;z+=1)this._analyze({key:n,arrayIndex:z,value:i[z],record:a,index:c},{resultMap:v,results:g,tokenSearchers:l,fullSearcher:f})}}},{key:"_computeScore",value:function(e,t){this._log("\n\nComputing score:\n");for(var n=0,r=t.length;n<r;n+=1){for(var o=t[n].output,i=o.length,a=1,s=1,c=0;c<i;c+=1){var h=e?e[o[c].key].weight:1,l=(1===h?o[c].score:o[c].score||.001)*h;1!==h?s=Math.min(s,l):(o[c].nScore=l,a*=l)}t[n].score=1===s?a:s,this._log(t[n])}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn)}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var n=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===r(t)&&null!==t){if(-1!==n.indexOf(t))return;n.push(t)}return t})),n=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var n=e.output;t.matches=[];for(var r=0,o=n.length;r<o;r+=1){var i=n[r];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,n),c&&o(t,c),e}();e.exports=c},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var o=n(3),i=n(4),a=n(7),s=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.isCaseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k},this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,n,s;return t=e,(n=[{key:"search",value:function(e){if(this.options.isCaseSensitive||(e=e.toLowerCase()),this.pattern===e)return{isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]};var t=this.options,n=t.maxPatternLength,r=t.tokenSeparator;if(this.pattern.length>n)return o(e,this.pattern,r);var a=this.options,s=a.location,c=a.distance,h=a.threshold,l=a.findAllMatches,u=a.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:s,distance:c,threshold:h,findAllMatches:l,minMatchCharLength:u})}}])&&r(t.prototype,n),s&&r(t,s),e}();e.exports=s},function(e,t){var n=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(n,"\\$&").replace(r,"|")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,n){var r=n(5),o=n(6);e.exports=function(e,t,n,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,d=void 0!==f&&f,v=i.minMatchCharLength,p=void 0===v?1:v,g=s,y=e.length,m=u,k=e.indexOf(t,g),S=t.length,x=[],b=0;b<y;b+=1)x[b]=0;if(-1!==k){var M=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});if(m=Math.min(M,m),-1!==(k=e.lastIndexOf(t,g+S))){var _=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});m=Math.min(_,m)}}k=-1;for(var L=[],w=1,A=S+y,C=1<<(S<=31?S-1:30),I=0;I<S;I+=1){for(var O=0,j=A;O<j;){r(t,{errors:I,currentLocation:g+j,expectedLocation:g,distance:h})<=m?O=j:A=j,j=Math.floor((A-O)/2+O)}A=j;var P=Math.max(1,g-j+1),F=d?y:Math.min(g+j,y)+S,T=Array(F+2);T[F+1]=(1<<I)-1;for(var z=F;z>=P;z-=1){var E=z-1,K=n[e.charAt(E)];if(K&&(x[E]=1),T[z]=(T[z+1]<<1|1)&K,0!==I&&(T[z]|=(L[z+1]|L[z])<<1|1|L[z+1]),T[z]&C&&(w=r(t,{errors:I,currentLocation:E,expectedLocation:g,distance:h}))<=m){if(m=w,(k=E)<=g)break;P=Math.max(1,2*g-k)}}if(r(t,{errors:I+1,currentLocation:g,expectedLocation:g,distance:h})>m)break;L=T}return{isMatch:k>=0,score:0===w?.001:w,matchedIndices:o(x,p)}}},function(e,t){e.exports=function(e,t){var n=t.errors,r=void 0===n?0:n,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=r/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=[],r=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===r?r=i:s||-1===r||((o=i-1)-r+1>=t&&n.push([r,o]),r=-1)}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n}},function(e,t){e.exports=function(e){for(var t={},n=e.length,r=0;r<n;r+=1)t[e.charAt(r)]=0;for(var o=0;o<n;o+=1)t[e.charAt(o)]|=1<<n-o-1;return t}},function(e,t,n){var r=n(0);e.exports=function(e,t){return function e(t,n,o){if(n){var i=n.indexOf("."),a=n,s=null;-1!==i&&(a=n.slice(0,i),s=n.slice(i+1));var c=t[a];if(null!=c)if(s||"string"!=typeof c&&"number"!=typeof c)if(r(c))for(var h=0,l=c.length;h<l;h+=1)e(c[h],s,o);else s&&e(c,s,o);else o.push(c.toString())}else o.push(t);return o}(e,t,[])}}])});

/***/ }),

/***/ 857:
/***/ (function(__unused_webpack_module, __webpack_exports__, __nested_webpack_require_143393__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_143393__.r(__webpack_exports__);

// EXPORTS
__nested_webpack_require_143393__.d(__webpack_exports__, {
  "__DO_NOT_USE__ActionTypes": function() { return /* binding */ ActionTypes; },
  "applyMiddleware": function() { return /* binding */ applyMiddleware; },
  "bindActionCreators": function() { return /* binding */ bindActionCreators; },
  "combineReducers": function() { return /* binding */ combineReducers; },
  "compose": function() { return /* binding */ compose; },
  "createStore": function() { return /* binding */ createStore; }
});

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js


function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}
;// CONCATENATED MODULE: ./node_modules/redux/es/redux.js


/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (false) {}

  return typeOfVal;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error(  true ? formatProdErrorMessage(0) : 0);
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error(  true ? formatProdErrorMessage(1) : 0);
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error(  true ? formatProdErrorMessage(2) : 0);
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error(  true ? formatProdErrorMessage(3) : 0);
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error(  true ? formatProdErrorMessage(4) : 0);
    }

    if (isDispatching) {
      throw new Error(  true ? formatProdErrorMessage(5) : 0);
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error(  true ? formatProdErrorMessage(6) : 0);
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing what changed. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(  true ? formatProdErrorMessage(7) : 0);
    }

    if (typeof action.type === 'undefined') {
      throw new Error(  true ? formatProdErrorMessage(8) : 0);
    }

    if (isDispatching) {
      throw new Error(  true ? formatProdErrorMessage(9) : 0);
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error(  true ? formatProdErrorMessage(10) : 0);
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error(  true ? formatProdErrorMessage(11) : 0);
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error(  true ? formatProdErrorMessage(12) : 0);
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error(  true ? formatProdErrorMessage(13) : 0);
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (false) {}

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (false) {}

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (false) { var warningMessage; }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error(  true ? formatProdErrorMessage(14) : 0);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error(  true ? formatProdErrorMessage(16) : 0);
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error(  true ? formatProdErrorMessage(15) : 0);
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if (false) {}




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_167232__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_167232__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_167232__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_167232__.o(definition, key) && !__nested_webpack_require_167232__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_167232__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_167232__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nested_webpack_require_167232__(373);
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ 2296:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(4429);

var $SyntaxError = __webpack_require__(3464);
var $TypeError = __webpack_require__(4453);

var gopd = __webpack_require__(7296);

/** @type {import('.')} */
module.exports = function defineDataProperty(
	obj,
	property,
	value
) {
	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
		throw new $TypeError('`obj` must be an object or a function`');
	}
	if (typeof property !== 'string' && typeof property !== 'symbol') {
		throw new $TypeError('`property` must be a string or a symbol`');
	}
	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
	}
	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
		throw new $TypeError('`loose`, if provided, must be a boolean');
	}

	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
	var nonWritable = arguments.length > 4 ? arguments[4] : null;
	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
	var loose = arguments.length > 6 ? arguments[6] : false;

	/* @type {false | TypedPropertyDescriptor<unknown>} */
	var desc = !!gopd && gopd(obj, property);

	if ($defineProperty) {
		$defineProperty(obj, property, {
			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
			value: value,
			writable: nonWritable === null && desc ? desc.writable : !nonWritable
		});
	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
		obj[property] = value; // eslint-disable-line no-param-reassign
	} else {
		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
	}
};


/***/ }),

/***/ 9741:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

( function( window, factory ) {
  /*global define: false, module: false */
  'use strict';
  // universal module definition
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

}( window, function factory() {
  'use strict';

  var matchesMethod = ( function() {
    var ElemProto = window.Element.prototype;
    // check for the standard method name first
    if ( ElemProto.matches ) {
      return 'matches';
    }
    // check un-prefixed
    if ( ElemProto.matchesSelector ) {
      return 'matchesSelector';
    }
    // check vendor prefixes
    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];

    for ( var i=0; i < prefixes.length; i++ ) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';
      if ( ElemProto[ method ] ) {
        return method;
      }
    }
  })();

  return function matchesSelector( elem, selector ) {
    return elem[ matchesMethod ]( selector );
  };

}));


/***/ }),

/***/ 4429:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(210);

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 3981:
/***/ (function(module) {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 1648:
/***/ (function(module) {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 4726:
/***/ (function(module) {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 6712:
/***/ (function(module) {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 3464:
/***/ (function(module) {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 4453:
/***/ (function(module) {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 3915:
/***/ (function(module) {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 7158:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

( function( global, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if ( true ) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

}( typeof window != 'undefined' ? window : this, function() {

"use strict";

function EvEmitter() {}

var proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // set events hash
  var events = this._events = this._events || {};
  // set listeners array
  var listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( listeners.indexOf( listener ) == -1 ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  var onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  var index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  // copy over to avoid interference if .off() in listener
  listeners = listeners.slice(0);
  args = args || [];
  // once stuff
  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  for ( var i=0; i < listeners.length; i++ ) {
    var listener = listeners[i]
    var isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
  }

  return this;
};

proto.allOff = function() {
  delete this._events;
  delete this._onceEvents;
};

return EvEmitter;

}));


/***/ }),

/***/ 9047:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Fizzy UI utils v2.0.7
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

( function( window, factory ) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
      __webpack_require__(9741)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( matchesSelector ) {
      return factory( window, matchesSelector );
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

}( window, function factory( window, matchesSelector ) {

'use strict';

var utils = {};

// ----- extend ----- //

// extends objects
utils.extend = function( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
};

// ----- modulo ----- //

utils.modulo = function( num, div ) {
  return ( ( num % div ) + div ) % div;
};

// ----- makeArray ----- //

var arraySlice = Array.prototype.slice;

// turn element or nodeList into an array
utils.makeArray = function( obj ) {
  if ( Array.isArray( obj ) ) {
    // use object if already an array
    return obj;
  }
  // return empty array if undefined or null. #6
  if ( obj === null || obj === undefined ) {
    return [];
  }

  var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
  if ( isArrayLike ) {
    // convert nodeList to array
    return arraySlice.call( obj );
  }

  // array of single index
  return [ obj ];
};

// ----- removeFrom ----- //

utils.removeFrom = function( ary, obj ) {
  var index = ary.indexOf( obj );
  if ( index != -1 ) {
    ary.splice( index, 1 );
  }
};

// ----- getParent ----- //

utils.getParent = function( elem, selector ) {
  while ( elem.parentNode && elem != document.body ) {
    elem = elem.parentNode;
    if ( matchesSelector( elem, selector ) ) {
      return elem;
    }
  }
};

// ----- getQueryElement ----- //

// use element as selector string
utils.getQueryElement = function( elem ) {
  if ( typeof elem == 'string' ) {
    return document.querySelector( elem );
  }
  return elem;
};

// ----- handleEvent ----- //

// enable .ontype to trigger from .addEventListener( elem, 'type' )
utils.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

// ----- filterFindElements ----- //

utils.filterFindElements = function( elems, selector ) {
  // make array of elems
  elems = utils.makeArray( elems );
  var ffElems = [];

  elems.forEach( function( elem ) {
    // check that elem is an actual element
    if ( !( elem instanceof HTMLElement ) ) {
      return;
    }
    // add elem if no selector
    if ( !selector ) {
      ffElems.push( elem );
      return;
    }
    // filter & find items if we have a selector
    // filter
    if ( matchesSelector( elem, selector ) ) {
      ffElems.push( elem );
    }
    // find children
    var childElems = elem.querySelectorAll( selector );
    // concat childElems to filterFound array
    for ( var i=0; i < childElems.length; i++ ) {
      ffElems.push( childElems[i] );
    }
  });

  return ffElems;
};

// ----- debounceMethod ----- //

utils.debounceMethod = function( _class, methodName, threshold ) {
  threshold = threshold || 100;
  // original method
  var method = _class.prototype[ methodName ];
  var timeoutName = methodName + 'Timeout';

  _class.prototype[ methodName ] = function() {
    var timeout = this[ timeoutName ];
    clearTimeout( timeout );

    var args = arguments;
    var _this = this;
    this[ timeoutName ] = setTimeout( function() {
      method.apply( _this, args );
      delete _this[ timeoutName ];
    }, threshold );
  };
};

// ----- docReady ----- //

utils.docReady = function( callback ) {
  var readyState = document.readyState;
  if ( readyState == 'complete' || readyState == 'interactive' ) {
    // do async to allow for other scripts to run. metafizzy/flickity#441
    setTimeout( callback );
  } else {
    document.addEventListener( 'DOMContentLoaded', callback );
  }
};

// ----- htmlInit ----- //

// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
utils.toDashed = function( str ) {
  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
    return $1 + '-' + $2;
  }).toLowerCase();
};

var console = window.console;
/**
 * allow user to initialize classes via [data-namespace] or .js-namespace class
 * htmlInit( Widget, 'widgetName' )
 * options are parsed from data-namespace-options
 */
utils.htmlInit = function( WidgetClass, namespace ) {
  utils.docReady( function() {
    var dashedNamespace = utils.toDashed( namespace );
    var dataAttr = 'data-' + dashedNamespace;
    var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
    var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
    var elems = utils.makeArray( dataAttrElems )
      .concat( utils.makeArray( jsDashElems ) );
    var dataOptionsAttr = dataAttr + '-options';
    var jQuery = window.jQuery;

    elems.forEach( function( elem ) {
      var attr = elem.getAttribute( dataAttr ) ||
        elem.getAttribute( dataOptionsAttr );
      var options;
      try {
        options = attr && JSON.parse( attr );
      } catch ( error ) {
        // log error, do not initialize
        if ( console ) {
          console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
          ': ' + error );
        }
        return;
      }
      // initialize
      var instance = new WidgetClass( elem, options );
      // make available via $().data('namespace')
      if ( jQuery ) {
        jQuery.data( elem, namespace, instance );
      }
    });

  });
};

// -----  ----- //

return utils;

}));


/***/ }),

/***/ 7648:
/***/ (function(module) {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 8612:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(7648);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 210:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var undefined;

var $Error = __webpack_require__(1648);
var $EvalError = __webpack_require__(3981);
var $RangeError = __webpack_require__(4726);
var $ReferenceError = __webpack_require__(6712);
var $SyntaxError = __webpack_require__(3464);
var $TypeError = __webpack_require__(4453);
var $URIError = __webpack_require__(3915);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(1405)();
var hasProto = __webpack_require__(8185)();

var getProto = Object.getPrototypeOf || (
	hasProto
		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
		: null
);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(8612);
var hasOwn = __webpack_require__(8824);
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 6131:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */

/* jshint browser: true, strict: true, undef: true, unused: true */
/* globals console: false */

( function( window, factory ) {
  /* jshint strict: false */ /* globals define, module */
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

})( window, function factory() {
'use strict';

// -------------------------- helpers -------------------------- //

// get a number from a string, not a percentage
function getStyleSize( value ) {
  var num = parseFloat( value );
  // not a percent like '100%', and a number
  var isValid = value.indexOf('%') == -1 && !isNaN( num );
  return isValid && num;
}

function noop() {}

var logError = typeof console == 'undefined' ? noop :
  function( message ) {
    console.error( message );
  };

// -------------------------- measurements -------------------------- //

var measurements = [
  'paddingLeft',
  'paddingRight',
  'paddingTop',
  'paddingBottom',
  'marginLeft',
  'marginRight',
  'marginTop',
  'marginBottom',
  'borderLeftWidth',
  'borderRightWidth',
  'borderTopWidth',
  'borderBottomWidth'
];

var measurementsLength = measurements.length;

function getZeroSize() {
  var size = {
    width: 0,
    height: 0,
    innerWidth: 0,
    innerHeight: 0,
    outerWidth: 0,
    outerHeight: 0
  };
  for ( var i=0; i < measurementsLength; i++ ) {
    var measurement = measurements[i];
    size[ measurement ] = 0;
  }
  return size;
}

// -------------------------- getStyle -------------------------- //

/**
 * getStyle, get style of element, check for Firefox bug
 * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 */
function getStyle( elem ) {
  var style = getComputedStyle( elem );
  if ( !style ) {
    logError( 'Style returned ' + style +
      '. Are you running this code in a hidden iframe on Firefox? ' +
      'See https://bit.ly/getsizebug1' );
  }
  return style;
}

// -------------------------- setup -------------------------- //

var isSetup = false;

var isBoxSizeOuter;

/**
 * setup
 * check isBoxSizerOuter
 * do on first getSize() rather than on page load for Firefox bug
 */
function setup() {
  // setup once
  if ( isSetup ) {
    return;
  }
  isSetup = true;

  // -------------------------- box sizing -------------------------- //

  /**
   * Chrome & Safari measure the outer-width on style.width on border-box elems
   * IE11 & Firefox<29 measures the inner-width
   */
  var div = document.createElement('div');
  div.style.width = '200px';
  div.style.padding = '1px 2px 3px 4px';
  div.style.borderStyle = 'solid';
  div.style.borderWidth = '1px 2px 3px 4px';
  div.style.boxSizing = 'border-box';

  var body = document.body || document.documentElement;
  body.appendChild( div );
  var style = getStyle( div );
  // round value for browser zoom. desandro/masonry#928
  isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;
  getSize.isBoxSizeOuter = isBoxSizeOuter;

  body.removeChild( div );
}

// -------------------------- getSize -------------------------- //

function getSize( elem ) {
  setup();

  // use querySeletor if elem is string
  if ( typeof elem == 'string' ) {
    elem = document.querySelector( elem );
  }

  // do not proceed on non-objects
  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
    return;
  }

  var style = getStyle( elem );

  // if hidden, everything is 0
  if ( style.display == 'none' ) {
    return getZeroSize();
  }

  var size = {};
  size.width = elem.offsetWidth;
  size.height = elem.offsetHeight;

  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

  // get all measurements
  for ( var i=0; i < measurementsLength; i++ ) {
    var measurement = measurements[i];
    var value = style[ measurement ];
    var num = parseFloat( value );
    // any 'auto', 'medium' value will be 0
    size[ measurement ] = !isNaN( num ) ? num : 0;
  }

  var paddingWidth = size.paddingLeft + size.paddingRight;
  var paddingHeight = size.paddingTop + size.paddingBottom;
  var marginWidth = size.marginLeft + size.marginRight;
  var marginHeight = size.marginTop + size.marginBottom;
  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
  var borderHeight = size.borderTopWidth + size.borderBottomWidth;

  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

  // overwrite width and height if we can get it from style
  var styleWidth = getStyleSize( style.width );
  if ( styleWidth !== false ) {
    size.width = styleWidth +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
  }

  var styleHeight = getStyleSize( style.height );
  if ( styleHeight !== false ) {
    size.height = styleHeight +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
  }

  size.innerWidth = size.width - ( paddingWidth + borderWidth );
  size.innerHeight = size.height - ( paddingHeight + borderHeight );

  size.outerWidth = size.width + marginWidth;
  size.outerHeight = size.height + marginHeight;

  return size;
}

return getSize;

});


/***/ }),

/***/ 7296:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(210);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 1044:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(4429);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	return !!$defineProperty;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!$defineProperty) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;


/***/ }),

/***/ 8185:
/***/ (function(module) {

"use strict";


var test = {
	__proto__: null,
	foo: {}
};

var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
	// @ts-expect-error: TS errors on an inherited property for some reason
	return { __proto__: test }.foo === test.foo
		&& !(test instanceof $Object);
};


/***/ }),

/***/ 1405:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(5419);

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 5419:
/***/ (function(module) {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 8824:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(8612);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ 8751:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Masonry v4.2.2
 * Cascading grid layout library
 * https://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /*globals define, module, require */
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(5724),
        __webpack_require__(6131)
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

}( window, function factory( Outlayer, getSize ) {

'use strict';

// -------------------------- masonryDefinition -------------------------- //

  // create an Outlayer layout class
  var Masonry = Outlayer.create('masonry');
  // isFitWidth -> fitWidth
  Masonry.compatOptions.fitWidth = 'isFitWidth';

  var proto = Masonry.prototype;

  proto._resetLayout = function() {
    this.getSize();
    this._getMeasurement( 'columnWidth', 'outerWidth' );
    this._getMeasurement( 'gutter', 'outerWidth' );
    this.measureColumns();

    // reset column Y
    this.colYs = [];
    for ( var i=0; i < this.cols; i++ ) {
      this.colYs.push( 0 );
    }

    this.maxY = 0;
    this.horizontalColIndex = 0;
  };

  proto.measureColumns = function() {
    this.getContainerWidth();
    // if columnWidth is 0, default to outerWidth of first item
    if ( !this.columnWidth ) {
      var firstItem = this.items[0];
      var firstItemElem = firstItem && firstItem.element;
      // columnWidth fall back to item of first element
      this.columnWidth = firstItemElem && getSize( firstItemElem ).outerWidth ||
        // if first elem has no width, default to size of container
        this.containerWidth;
    }

    var columnWidth = this.columnWidth += this.gutter;

    // calculate columns
    var containerWidth = this.containerWidth + this.gutter;
    var cols = containerWidth / columnWidth;
    // fix rounding errors, typically with gutters
    var excess = columnWidth - containerWidth % columnWidth;
    // if overshoot is less than a pixel, round up, otherwise floor it
    var mathMethod = excess && excess < 1 ? 'round' : 'floor';
    cols = Math[ mathMethod ]( cols );
    this.cols = Math.max( cols, 1 );
  };

  proto.getContainerWidth = function() {
    // container is parent if fit width
    var isFitWidth = this._getOption('fitWidth');
    var container = isFitWidth ? this.element.parentNode : this.element;
    // check that this.size and size are there
    // IE8 triggers resize on body size change, so they might not be
    var size = getSize( container );
    this.containerWidth = size && size.innerWidth;
  };

  proto._getItemLayoutPosition = function( item ) {
    item.getSize();
    // how many columns does this brick span
    var remainder = item.size.outerWidth % this.columnWidth;
    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
    // round if off by 1 pixel, otherwise use ceil
    var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );
    colSpan = Math.min( colSpan, this.cols );
    // use horizontal or top column position
    var colPosMethod = this.options.horizontalOrder ?
      '_getHorizontalColPosition' : '_getTopColPosition';
    var colPosition = this[ colPosMethod ]( colSpan, item );
    // position the brick
    var position = {
      x: this.columnWidth * colPosition.col,
      y: colPosition.y
    };
    // apply setHeight to necessary columns
    var setHeight = colPosition.y + item.size.outerHeight;
    var setMax = colSpan + colPosition.col;
    for ( var i = colPosition.col; i < setMax; i++ ) {
      this.colYs[i] = setHeight;
    }

    return position;
  };

  proto._getTopColPosition = function( colSpan ) {
    var colGroup = this._getTopColGroup( colSpan );
    // get the minimum Y value from the columns
    var minimumY = Math.min.apply( Math, colGroup );

    return {
      col: colGroup.indexOf( minimumY ),
      y: minimumY,
    };
  };

  /**
   * @param {Number} colSpan - number of columns the element spans
   * @returns {Array} colGroup
   */
  proto._getTopColGroup = function( colSpan ) {
    if ( colSpan < 2 ) {
      // if brick spans only one column, use all the column Ys
      return this.colYs;
    }

    var colGroup = [];
    // how many different places could this brick fit horizontally
    var groupCount = this.cols + 1 - colSpan;
    // for each group potential horizontal position
    for ( var i = 0; i < groupCount; i++ ) {
      colGroup[i] = this._getColGroupY( i, colSpan );
    }
    return colGroup;
  };

  proto._getColGroupY = function( col, colSpan ) {
    if ( colSpan < 2 ) {
      return this.colYs[ col ];
    }
    // make an array of colY values for that one group
    var groupColYs = this.colYs.slice( col, col + colSpan );
    // and get the max value of the array
    return Math.max.apply( Math, groupColYs );
  };

  // get column position based on horizontal index. #873
  proto._getHorizontalColPosition = function( colSpan, item ) {
    var col = this.horizontalColIndex % this.cols;
    var isOver = colSpan > 1 && col + colSpan > this.cols;
    // shift to next row if item can't fit on current row
    col = isOver ? 0 : col;
    // don't let zero-size items take up space
    var hasSize = item.size.outerWidth && item.size.outerHeight;
    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;

    return {
      col: col,
      y: this._getColGroupY( col, colSpan ),
    };
  };

  proto._manageStamp = function( stamp ) {
    var stampSize = getSize( stamp );
    var offset = this._getElementOffset( stamp );
    // get the columns that this stamp affects
    var isOriginLeft = this._getOption('originLeft');
    var firstX = isOriginLeft ? offset.left : offset.right;
    var lastX = firstX + stampSize.outerWidth;
    var firstCol = Math.floor( firstX / this.columnWidth );
    firstCol = Math.max( 0, firstCol );
    var lastCol = Math.floor( lastX / this.columnWidth );
    // lastCol should not go over if multiple of columnWidth #425
    lastCol -= lastX % this.columnWidth ? 0 : 1;
    lastCol = Math.min( this.cols - 1, lastCol );
    // set colYs to bottom of the stamp

    var isOriginTop = this._getOption('originTop');
    var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +
      stampSize.outerHeight;
    for ( var i = firstCol; i <= lastCol; i++ ) {
      this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );
    }
  };

  proto._getContainerSize = function() {
    this.maxY = Math.max.apply( Math, this.colYs );
    var size = {
      height: this.maxY
    };

    if ( this._getOption('fitWidth') ) {
      size.width = this._getContainerFitWidth();
    }

    return size;
  };

  proto._getContainerFitWidth = function() {
    var unusedCols = 0;
    // count unused columns
    var i = this.cols;
    while ( --i ) {
      if ( this.colYs[i] !== 0 ) {
        break;
      }
      unusedCols++;
    }
    // fit container to columns that have been used
    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;
  };

  proto.needsResizeLayout = function() {
    var previousWidth = this.containerWidth;
    this.getContainerWidth();
    return previousWidth != this.containerWidth;
  };

  return Masonry;

}));


/***/ }),

/***/ 631:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
// ie, `has-tostringtag/shams
var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
    ? Symbol.toStringTag
    : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

function addNumericSeparator(num, str) {
    if (
        num === Infinity
        || num === -Infinity
        || num !== num
        || (num && num > -1000 && num < 1000)
        || $test.call(/e/, str)
    ) {
        return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
        if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
        }
    }
    return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(4654);
var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
        var bigIntStr = String(obj) + 'n';
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
        }
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
            return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
            mapForEach.call(obj, function (value, key) {
                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
            });
        }
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
            setForEach.call(obj, function (value) {
                setParts.push(inspect(value, obj));
            });
        }
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
        return '{ [object Window] }';
    }
    if (obj === __webpack_require__.g) {
        return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ 652:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Outlayer Item
 */

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if ( true ) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(7158),
        __webpack_require__(6131)
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

}( window, function factory( EvEmitter, getSize ) {
'use strict';

// ----- helpers ----- //

function isEmptyObj( obj ) {
  for ( var prop in obj ) {
    return false;
  }
  prop = null;
  return true;
}

// -------------------------- CSS3 support -------------------------- //


var docElemStyle = document.documentElement.style;

var transitionProperty = typeof docElemStyle.transition == 'string' ?
  'transition' : 'WebkitTransition';
var transformProperty = typeof docElemStyle.transform == 'string' ?
  'transform' : 'WebkitTransform';

var transitionEndEvent = {
  WebkitTransition: 'webkitTransitionEnd',
  transition: 'transitionend'
}[ transitionProperty ];

// cache all vendor properties that could have vendor prefix
var vendorProperties = {
  transform: transformProperty,
  transition: transitionProperty,
  transitionDuration: transitionProperty + 'Duration',
  transitionProperty: transitionProperty + 'Property',
  transitionDelay: transitionProperty + 'Delay'
};

// -------------------------- Item -------------------------- //

function Item( element, layout ) {
  if ( !element ) {
    return;
  }

  this.element = element;
  // parent layout class, i.e. Masonry, Isotope, or Packery
  this.layout = layout;
  this.position = {
    x: 0,
    y: 0
  };

  this._create();
}

// inherit EvEmitter
var proto = Item.prototype = Object.create( EvEmitter.prototype );
proto.constructor = Item;

proto._create = function() {
  // transition objects
  this._transn = {
    ingProperties: {},
    clean: {},
    onEnd: {}
  };

  this.css({
    position: 'absolute'
  });
};

// trigger specified handler for event type
proto.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

proto.getSize = function() {
  this.size = getSize( this.element );
};

/**
 * apply CSS styles to element
 * @param {Object} style
 */
proto.css = function( style ) {
  var elemStyle = this.element.style;

  for ( var prop in style ) {
    // use vendor property if available
    var supportedProp = vendorProperties[ prop ] || prop;
    elemStyle[ supportedProp ] = style[ prop ];
  }
};

 // measure position, and sets it
proto.getPosition = function() {
  var style = getComputedStyle( this.element );
  var isOriginLeft = this.layout._getOption('originLeft');
  var isOriginTop = this.layout._getOption('originTop');
  var xValue = style[ isOriginLeft ? 'left' : 'right' ];
  var yValue = style[ isOriginTop ? 'top' : 'bottom' ];
  var x = parseFloat( xValue );
  var y = parseFloat( yValue );
  // convert percent to pixels
  var layoutSize = this.layout.size;
  if ( xValue.indexOf('%') != -1 ) {
    x = ( x / 100 ) * layoutSize.width;
  }
  if ( yValue.indexOf('%') != -1 ) {
    y = ( y / 100 ) * layoutSize.height;
  }
  // clean up 'auto' or other non-integer values
  x = isNaN( x ) ? 0 : x;
  y = isNaN( y ) ? 0 : y;
  // remove padding from measurement
  x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
  y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

  this.position.x = x;
  this.position.y = y;
};

// set settled position, apply padding
proto.layoutPosition = function() {
  var layoutSize = this.layout.size;
  var style = {};
  var isOriginLeft = this.layout._getOption('originLeft');
  var isOriginTop = this.layout._getOption('originTop');

  // x
  var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
  var xProperty = isOriginLeft ? 'left' : 'right';
  var xResetProperty = isOriginLeft ? 'right' : 'left';

  var x = this.position.x + layoutSize[ xPadding ];
  // set in percentage or pixels
  style[ xProperty ] = this.getXValue( x );
  // reset other property
  style[ xResetProperty ] = '';

  // y
  var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
  var yProperty = isOriginTop ? 'top' : 'bottom';
  var yResetProperty = isOriginTop ? 'bottom' : 'top';

  var y = this.position.y + layoutSize[ yPadding ];
  // set in percentage or pixels
  style[ yProperty ] = this.getYValue( y );
  // reset other property
  style[ yResetProperty ] = '';

  this.css( style );
  this.emitEvent( 'layout', [ this ] );
};

proto.getXValue = function( x ) {
  var isHorizontal = this.layout._getOption('horizontal');
  return this.layout.options.percentPosition && !isHorizontal ?
    ( ( x / this.layout.size.width ) * 100 ) + '%' : x + 'px';
};

proto.getYValue = function( y ) {
  var isHorizontal = this.layout._getOption('horizontal');
  return this.layout.options.percentPosition && isHorizontal ?
    ( ( y / this.layout.size.height ) * 100 ) + '%' : y + 'px';
};

proto._transitionTo = function( x, y ) {
  this.getPosition();
  // get current x & y from top/left
  var curX = this.position.x;
  var curY = this.position.y;

  var didNotMove = x == this.position.x && y == this.position.y;

  // save end position
  this.setPosition( x, y );

  // if did not move and not transitioning, just go to layout
  if ( didNotMove && !this.isTransitioning ) {
    this.layoutPosition();
    return;
  }

  var transX = x - curX;
  var transY = y - curY;
  var transitionStyle = {};
  transitionStyle.transform = this.getTranslate( transX, transY );

  this.transition({
    to: transitionStyle,
    onTransitionEnd: {
      transform: this.layoutPosition
    },
    isCleaning: true
  });
};

proto.getTranslate = function( x, y ) {
  // flip cooridinates if origin on right or bottom
  var isOriginLeft = this.layout._getOption('originLeft');
  var isOriginTop = this.layout._getOption('originTop');
  x = isOriginLeft ? x : -x;
  y = isOriginTop ? y : -y;
  return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
};

// non transition + transform support
proto.goTo = function( x, y ) {
  this.setPosition( x, y );
  this.layoutPosition();
};

proto.moveTo = proto._transitionTo;

proto.setPosition = function( x, y ) {
  this.position.x = parseFloat( x );
  this.position.y = parseFloat( y );
};

// ----- transition ----- //

/**
 * @param {Object} style - CSS
 * @param {Function} onTransitionEnd
 */

// non transition, just trigger callback
proto._nonTransition = function( args ) {
  this.css( args.to );
  if ( args.isCleaning ) {
    this._removeStyles( args.to );
  }
  for ( var prop in args.onTransitionEnd ) {
    args.onTransitionEnd[ prop ].call( this );
  }
};

/**
 * proper transition
 * @param {Object} args - arguments
 *   @param {Object} to - style to transition to
 *   @param {Object} from - style to start transition from
 *   @param {Boolean} isCleaning - removes transition styles after transition
 *   @param {Function} onTransitionEnd - callback
 */
proto.transition = function( args ) {
  // redirect to nonTransition if no transition duration
  if ( !parseFloat( this.layout.options.transitionDuration ) ) {
    this._nonTransition( args );
    return;
  }

  var _transition = this._transn;
  // keep track of onTransitionEnd callback by css property
  for ( var prop in args.onTransitionEnd ) {
    _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];
  }
  // keep track of properties that are transitioning
  for ( prop in args.to ) {
    _transition.ingProperties[ prop ] = true;
    // keep track of properties to clean up when transition is done
    if ( args.isCleaning ) {
      _transition.clean[ prop ] = true;
    }
  }

  // set from styles
  if ( args.from ) {
    this.css( args.from );
    // force redraw. http://blog.alexmaccaw.com/css-transitions
    var h = this.element.offsetHeight;
    // hack for JSHint to hush about unused var
    h = null;
  }
  // enable transition
  this.enableTransition( args.to );
  // set styles that are transitioning
  this.css( args.to );

  this.isTransitioning = true;

};

// dash before all cap letters, including first for
// WebkitTransform => -webkit-transform
function toDashedAll( str ) {
  return str.replace( /([A-Z])/g, function( $1 ) {
    return '-' + $1.toLowerCase();
  });
}

var transitionProps = 'opacity,' + toDashedAll( transformProperty );

proto.enableTransition = function(/* style */) {
  // HACK changing transitionProperty during a transition
  // will cause transition to jump
  if ( this.isTransitioning ) {
    return;
  }

  // make `transition: foo, bar, baz` from style object
  // HACK un-comment this when enableTransition can work
  // while a transition is happening
  // var transitionValues = [];
  // for ( var prop in style ) {
  //   // dash-ify camelCased properties like WebkitTransition
  //   prop = vendorProperties[ prop ] || prop;
  //   transitionValues.push( toDashedAll( prop ) );
  // }
  // munge number to millisecond, to match stagger
  var duration = this.layout.options.transitionDuration;
  duration = typeof duration == 'number' ? duration + 'ms' : duration;
  // enable transition styles
  this.css({
    transitionProperty: transitionProps,
    transitionDuration: duration,
    transitionDelay: this.staggerDelay || 0
  });
  // listen for transition end event
  this.element.addEventListener( transitionEndEvent, this, false );
};

// ----- events ----- //

proto.onwebkitTransitionEnd = function( event ) {
  this.ontransitionend( event );
};

proto.onotransitionend = function( event ) {
  this.ontransitionend( event );
};

// properties that I munge to make my life easier
var dashedVendorProperties = {
  '-webkit-transform': 'transform'
};

proto.ontransitionend = function( event ) {
  // disregard bubbled events from children
  if ( event.target !== this.element ) {
    return;
  }
  var _transition = this._transn;
  // get property name of transitioned property, convert to prefix-free
  var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;

  // remove property that has completed transitioning
  delete _transition.ingProperties[ propertyName ];
  // check if any properties are still transitioning
  if ( isEmptyObj( _transition.ingProperties ) ) {
    // all properties have completed transitioning
    this.disableTransition();
  }
  // clean style
  if ( propertyName in _transition.clean ) {
    // clean up style
    this.element.style[ event.propertyName ] = '';
    delete _transition.clean[ propertyName ];
  }
  // trigger onTransitionEnd callback
  if ( propertyName in _transition.onEnd ) {
    var onTransitionEnd = _transition.onEnd[ propertyName ];
    onTransitionEnd.call( this );
    delete _transition.onEnd[ propertyName ];
  }

  this.emitEvent( 'transitionEnd', [ this ] );
};

proto.disableTransition = function() {
  this.removeTransitionStyles();
  this.element.removeEventListener( transitionEndEvent, this, false );
  this.isTransitioning = false;
};

/**
 * removes style property from element
 * @param {Object} style
**/
proto._removeStyles = function( style ) {
  // clean up transition styles
  var cleanStyle = {};
  for ( var prop in style ) {
    cleanStyle[ prop ] = '';
  }
  this.css( cleanStyle );
};

var cleanTransitionStyle = {
  transitionProperty: '',
  transitionDuration: '',
  transitionDelay: ''
};

proto.removeTransitionStyles = function() {
  // remove transition
  this.css( cleanTransitionStyle );
};

// ----- stagger ----- //

proto.stagger = function( delay ) {
  delay = isNaN( delay ) ? 0 : delay;
  this.staggerDelay = delay + 'ms';
};

// ----- show/hide/remove ----- //

// remove element from DOM
proto.removeElem = function() {
  this.element.parentNode.removeChild( this.element );
  // remove display: none
  this.css({ display: '' });
  this.emitEvent( 'remove', [ this ] );
};

proto.remove = function() {
  // just remove element if no transition support or no transition
  if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
    this.removeElem();
    return;
  }

  // start transition
  this.once( 'transitionEnd', function() {
    this.removeElem();
  });
  this.hide();
};

proto.reveal = function() {
  delete this.isHidden;
  // remove display: none
  this.css({ display: '' });

  var options = this.layout.options;

  var onTransitionEnd = {};
  var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
  onTransitionEnd[ transitionEndProperty ] = this.onRevealTransitionEnd;

  this.transition({
    from: options.hiddenStyle,
    to: options.visibleStyle,
    isCleaning: true,
    onTransitionEnd: onTransitionEnd
  });
};

proto.onRevealTransitionEnd = function() {
  // check if still visible
  // during transition, item may have been hidden
  if ( !this.isHidden ) {
    this.emitEvent('reveal');
  }
};

/**
 * get style property use for hide/reveal transition end
 * @param {String} styleProperty - hiddenStyle/visibleStyle
 * @returns {String}
 */
proto.getHideRevealTransitionEndProperty = function( styleProperty ) {
  var optionStyle = this.layout.options[ styleProperty ];
  // use opacity
  if ( optionStyle.opacity ) {
    return 'opacity';
  }
  // get first property
  for ( var prop in optionStyle ) {
    return prop;
  }
};

proto.hide = function() {
  // set flag
  this.isHidden = true;
  // remove display: none
  this.css({ display: '' });

  var options = this.layout.options;

  var onTransitionEnd = {};
  var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
  onTransitionEnd[ transitionEndProperty ] = this.onHideTransitionEnd;

  this.transition({
    from: options.visibleStyle,
    to: options.hiddenStyle,
    // keep hidden stuff hidden
    isCleaning: true,
    onTransitionEnd: onTransitionEnd
  });
};

proto.onHideTransitionEnd = function() {
  // check if still hidden
  // during transition, item may have been un-hidden
  if ( this.isHidden ) {
    this.css({ display: 'none' });
    this.emitEvent('hide');
  }
};

proto.destroy = function() {
  this.css({
    position: '',
    left: '',
    right: '',
    top: '',
    bottom: '',
    transition: '',
    transform: ''
  });
};

return Item;

}));


/***/ }),

/***/ 5724:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Outlayer v2.1.1
 * the brains and guts of a layout library
 * MIT license
 */

( function( window, factory ) {
  'use strict';
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if ( true ) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(7158),
        __webpack_require__(6131),
        __webpack_require__(9047),
        __webpack_require__(652)
      ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter, getSize, utils, Item ) {
        return factory( window, EvEmitter, getSize, utils, Item);
      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

}( window, function factory( window, EvEmitter, getSize, utils, Item ) {
'use strict';

// ----- vars ----- //

var console = window.console;
var jQuery = window.jQuery;
var noop = function() {};

// -------------------------- Outlayer -------------------------- //

// globally unique identifiers
var GUID = 0;
// internal store of all Outlayer intances
var instances = {};


/**
 * @param {Element, String} element
 * @param {Object} options
 * @constructor
 */
function Outlayer( element, options ) {
  var queryElement = utils.getQueryElement( element );
  if ( !queryElement ) {
    if ( console ) {
      console.error( 'Bad element for ' + this.constructor.namespace +
        ': ' + ( queryElement || element ) );
    }
    return;
  }
  this.element = queryElement;
  // add jQuery
  if ( jQuery ) {
    this.$element = jQuery( this.element );
  }

  // options
  this.options = utils.extend( {}, this.constructor.defaults );
  this.option( options );

  // add id for Outlayer.getFromElement
  var id = ++GUID;
  this.element.outlayerGUID = id; // expando
  instances[ id ] = this; // associate via id

  // kick it off
  this._create();

  var isInitLayout = this._getOption('initLayout');
  if ( isInitLayout ) {
    this.layout();
  }
}

// settings are for internal use only
Outlayer.namespace = 'outlayer';
Outlayer.Item = Item;

// default options
Outlayer.defaults = {
  containerStyle: {
    position: 'relative'
  },
  initLayout: true,
  originLeft: true,
  originTop: true,
  resize: true,
  resizeContainer: true,
  // item options
  transitionDuration: '0.4s',
  hiddenStyle: {
    opacity: 0,
    transform: 'scale(0.001)'
  },
  visibleStyle: {
    opacity: 1,
    transform: 'scale(1)'
  }
};

var proto = Outlayer.prototype;
// inherit EvEmitter
utils.extend( proto, EvEmitter.prototype );

/**
 * set options
 * @param {Object} opts
 */
proto.option = function( opts ) {
  utils.extend( this.options, opts );
};

/**
 * get backwards compatible option value, check old name
 */
proto._getOption = function( option ) {
  var oldOption = this.constructor.compatOptions[ option ];
  return oldOption && this.options[ oldOption ] !== undefined ?
    this.options[ oldOption ] : this.options[ option ];
};

Outlayer.compatOptions = {
  // currentName: oldName
  initLayout: 'isInitLayout',
  horizontal: 'isHorizontal',
  layoutInstant: 'isLayoutInstant',
  originLeft: 'isOriginLeft',
  originTop: 'isOriginTop',
  resize: 'isResizeBound',
  resizeContainer: 'isResizingContainer'
};

proto._create = function() {
  // get items from children
  this.reloadItems();
  // elements that affect layout, but are not laid out
  this.stamps = [];
  this.stamp( this.options.stamp );
  // set container style
  utils.extend( this.element.style, this.options.containerStyle );

  // bind resize method
  var canBindResize = this._getOption('resize');
  if ( canBindResize ) {
    this.bindResize();
  }
};

// goes through all children again and gets bricks in proper order
proto.reloadItems = function() {
  // collection of item elements
  this.items = this._itemize( this.element.children );
};


/**
 * turn elements into Outlayer.Items to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - collection of new Outlayer Items
 */
proto._itemize = function( elems ) {

  var itemElems = this._filterFindItemElements( elems );
  var Item = this.constructor.Item;

  // create new Outlayer Items for collection
  var items = [];
  for ( var i=0; i < itemElems.length; i++ ) {
    var elem = itemElems[i];
    var item = new Item( elem, this );
    items.push( item );
  }

  return items;
};

/**
 * get item elements to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - item elements
 */
proto._filterFindItemElements = function( elems ) {
  return utils.filterFindElements( elems, this.options.itemSelector );
};

/**
 * getter method for getting item elements
 * @returns {Array} elems - collection of item elements
 */
proto.getItemElements = function() {
  return this.items.map( function( item ) {
    return item.element;
  });
};

// ----- init & layout ----- //

/**
 * lays out all items
 */
proto.layout = function() {
  this._resetLayout();
  this._manageStamps();

  // don't animate first layout
  var layoutInstant = this._getOption('layoutInstant');
  var isInstant = layoutInstant !== undefined ?
    layoutInstant : !this._isLayoutInited;
  this.layoutItems( this.items, isInstant );

  // flag for initalized
  this._isLayoutInited = true;
};

// _init is alias for layout
proto._init = proto.layout;

/**
 * logic before any new layout
 */
proto._resetLayout = function() {
  this.getSize();
};


proto.getSize = function() {
  this.size = getSize( this.element );
};

/**
 * get measurement from option, for columnWidth, rowHeight, gutter
 * if option is String -> get element from selector string, & get size of element
 * if option is Element -> get size of element
 * else use option as a number
 *
 * @param {String} measurement
 * @param {String} size - width or height
 * @private
 */
proto._getMeasurement = function( measurement, size ) {
  var option = this.options[ measurement ];
  var elem;
  if ( !option ) {
    // default to 0
    this[ measurement ] = 0;
  } else {
    // use option as an element
    if ( typeof option == 'string' ) {
      elem = this.element.querySelector( option );
    } else if ( option instanceof HTMLElement ) {
      elem = option;
    }
    // use size of element, if element
    this[ measurement ] = elem ? getSize( elem )[ size ] : option;
  }
};

/**
 * layout a collection of item elements
 * @api public
 */
proto.layoutItems = function( items, isInstant ) {
  items = this._getItemsForLayout( items );

  this._layoutItems( items, isInstant );

  this._postLayout();
};

/**
 * get the items to be laid out
 * you may want to skip over some items
 * @param {Array} items
 * @returns {Array} items
 */
proto._getItemsForLayout = function( items ) {
  return items.filter( function( item ) {
    return !item.isIgnored;
  });
};

/**
 * layout items
 * @param {Array} items
 * @param {Boolean} isInstant
 */
proto._layoutItems = function( items, isInstant ) {
  this._emitCompleteOnItems( 'layout', items );

  if ( !items || !items.length ) {
    // no items, emit event with empty array
    return;
  }

  var queue = [];

  items.forEach( function( item ) {
    // get x/y object from method
    var position = this._getItemLayoutPosition( item );
    // enqueue
    position.item = item;
    position.isInstant = isInstant || item.isLayoutInstant;
    queue.push( position );
  }, this );

  this._processLayoutQueue( queue );
};

/**
 * get item layout position
 * @param {Outlayer.Item} item
 * @returns {Object} x and y position
 */
proto._getItemLayoutPosition = function( /* item */ ) {
  return {
    x: 0,
    y: 0
  };
};

/**
 * iterate over array and position each item
 * Reason being - separating this logic prevents 'layout invalidation'
 * thx @paul_irish
 * @param {Array} queue
 */
proto._processLayoutQueue = function( queue ) {
  this.updateStagger();
  queue.forEach( function( obj, i ) {
    this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );
  }, this );
};

// set stagger from option in milliseconds number
proto.updateStagger = function() {
  var stagger = this.options.stagger;
  if ( stagger === null || stagger === undefined ) {
    this.stagger = 0;
    return;
  }
  this.stagger = getMilliseconds( stagger );
  return this.stagger;
};

/**
 * Sets position of item in DOM
 * @param {Outlayer.Item} item
 * @param {Number} x - horizontal position
 * @param {Number} y - vertical position
 * @param {Boolean} isInstant - disables transitions
 */
proto._positionItem = function( item, x, y, isInstant, i ) {
  if ( isInstant ) {
    // if not transition, just set CSS
    item.goTo( x, y );
  } else {
    item.stagger( i * this.stagger );
    item.moveTo( x, y );
  }
};

/**
 * Any logic you want to do after each layout,
 * i.e. size the container
 */
proto._postLayout = function() {
  this.resizeContainer();
};

proto.resizeContainer = function() {
  var isResizingContainer = this._getOption('resizeContainer');
  if ( !isResizingContainer ) {
    return;
  }
  var size = this._getContainerSize();
  if ( size ) {
    this._setContainerMeasure( size.width, true );
    this._setContainerMeasure( size.height, false );
  }
};

/**
 * Sets width or height of container if returned
 * @returns {Object} size
 *   @param {Number} width
 *   @param {Number} height
 */
proto._getContainerSize = noop;

/**
 * @param {Number} measure - size of width or height
 * @param {Boolean} isWidth
 */
proto._setContainerMeasure = function( measure, isWidth ) {
  if ( measure === undefined ) {
    return;
  }

  var elemSize = this.size;
  // add padding and border width if border box
  if ( elemSize.isBorderBox ) {
    measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
      elemSize.borderLeftWidth + elemSize.borderRightWidth :
      elemSize.paddingBottom + elemSize.paddingTop +
      elemSize.borderTopWidth + elemSize.borderBottomWidth;
  }

  measure = Math.max( measure, 0 );
  this.element.style[ isWidth ? 'width' : 'height' ] = measure + 'px';
};

/**
 * emit eventComplete on a collection of items events
 * @param {String} eventName
 * @param {Array} items - Outlayer.Items
 */
proto._emitCompleteOnItems = function( eventName, items ) {
  var _this = this;
  function onComplete() {
    _this.dispatchEvent( eventName + 'Complete', null, [ items ] );
  }

  var count = items.length;
  if ( !items || !count ) {
    onComplete();
    return;
  }

  var doneCount = 0;
  function tick() {
    doneCount++;
    if ( doneCount == count ) {
      onComplete();
    }
  }

  // bind callback
  items.forEach( function( item ) {
    item.once( eventName, tick );
  });
};

/**
 * emits events via EvEmitter and jQuery events
 * @param {String} type - name of event
 * @param {Event} event - original event
 * @param {Array} args - extra arguments
 */
proto.dispatchEvent = function( type, event, args ) {
  // add original event to arguments
  var emitArgs = event ? [ event ].concat( args ) : args;
  this.emitEvent( type, emitArgs );

  if ( jQuery ) {
    // set this.$element
    this.$element = this.$element || jQuery( this.element );
    if ( event ) {
      // create jQuery event
      var $event = jQuery.Event( event );
      $event.type = type;
      this.$element.trigger( $event, args );
    } else {
      // just trigger with type if no event available
      this.$element.trigger( type, args );
    }
  }
};

// -------------------------- ignore & stamps -------------------------- //


/**
 * keep item in collection, but do not lay it out
 * ignored items do not get skipped in layout
 * @param {Element} elem
 */
proto.ignore = function( elem ) {
  var item = this.getItem( elem );
  if ( item ) {
    item.isIgnored = true;
  }
};

/**
 * return item to layout collection
 * @param {Element} elem
 */
proto.unignore = function( elem ) {
  var item = this.getItem( elem );
  if ( item ) {
    delete item.isIgnored;
  }
};

/**
 * adds elements to stamps
 * @param {NodeList, Array, Element, or String} elems
 */
proto.stamp = function( elems ) {
  elems = this._find( elems );
  if ( !elems ) {
    return;
  }

  this.stamps = this.stamps.concat( elems );
  // ignore
  elems.forEach( this.ignore, this );
};

/**
 * removes elements to stamps
 * @param {NodeList, Array, or Element} elems
 */
proto.unstamp = function( elems ) {
  elems = this._find( elems );
  if ( !elems ){
    return;
  }

  elems.forEach( function( elem ) {
    // filter out removed stamp elements
    utils.removeFrom( this.stamps, elem );
    this.unignore( elem );
  }, this );
};

/**
 * finds child elements
 * @param {NodeList, Array, Element, or String} elems
 * @returns {Array} elems
 */
proto._find = function( elems ) {
  if ( !elems ) {
    return;
  }
  // if string, use argument as selector string
  if ( typeof elems == 'string' ) {
    elems = this.element.querySelectorAll( elems );
  }
  elems = utils.makeArray( elems );
  return elems;
};

proto._manageStamps = function() {
  if ( !this.stamps || !this.stamps.length ) {
    return;
  }

  this._getBoundingRect();

  this.stamps.forEach( this._manageStamp, this );
};

// update boundingLeft / Top
proto._getBoundingRect = function() {
  // get bounding rect for container element
  var boundingRect = this.element.getBoundingClientRect();
  var size = this.size;
  this._boundingRect = {
    left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
    top: boundingRect.top + size.paddingTop + size.borderTopWidth,
    right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
    bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
  };
};

/**
 * @param {Element} stamp
**/
proto._manageStamp = noop;

/**
 * get x/y position of element relative to container element
 * @param {Element} elem
 * @returns {Object} offset - has left, top, right, bottom
 */
proto._getElementOffset = function( elem ) {
  var boundingRect = elem.getBoundingClientRect();
  var thisRect = this._boundingRect;
  var size = getSize( elem );
  var offset = {
    left: boundingRect.left - thisRect.left - size.marginLeft,
    top: boundingRect.top - thisRect.top - size.marginTop,
    right: thisRect.right - boundingRect.right - size.marginRight,
    bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
  };
  return offset;
};

// -------------------------- resize -------------------------- //

// enable event handlers for listeners
// i.e. resize -> onresize
proto.handleEvent = utils.handleEvent;

/**
 * Bind layout to window resizing
 */
proto.bindResize = function() {
  window.addEventListener( 'resize', this );
  this.isResizeBound = true;
};

/**
 * Unbind layout to window resizing
 */
proto.unbindResize = function() {
  window.removeEventListener( 'resize', this );
  this.isResizeBound = false;
};

proto.onresize = function() {
  this.resize();
};

utils.debounceMethod( Outlayer, 'onresize', 100 );

proto.resize = function() {
  // don't trigger if size did not change
  // or if resize was unbound. See #9
  if ( !this.isResizeBound || !this.needsResizeLayout() ) {
    return;
  }

  this.layout();
};

/**
 * check if layout is needed post layout
 * @returns Boolean
 */
proto.needsResizeLayout = function() {
  var size = getSize( this.element );
  // check that this.size and size are there
  // IE8 triggers resize on body size change, so they might not be
  var hasSizes = this.size && size;
  return hasSizes && size.innerWidth !== this.size.innerWidth;
};

// -------------------------- methods -------------------------- //

/**
 * add items to Outlayer instance
 * @param {Array or NodeList or Element} elems
 * @returns {Array} items - Outlayer.Items
**/
proto.addItems = function( elems ) {
  var items = this._itemize( elems );
  // add items to collection
  if ( items.length ) {
    this.items = this.items.concat( items );
  }
  return items;
};

/**
 * Layout newly-appended item elements
 * @param {Array or NodeList or Element} elems
 */
proto.appended = function( elems ) {
  var items = this.addItems( elems );
  if ( !items.length ) {
    return;
  }
  // layout and reveal just the new items
  this.layoutItems( items, true );
  this.reveal( items );
};

/**
 * Layout prepended elements
 * @param {Array or NodeList or Element} elems
 */
proto.prepended = function( elems ) {
  var items = this._itemize( elems );
  if ( !items.length ) {
    return;
  }
  // add items to beginning of collection
  var previousItems = this.items.slice(0);
  this.items = items.concat( previousItems );
  // start new layout
  this._resetLayout();
  this._manageStamps();
  // layout new stuff without transition
  this.layoutItems( items, true );
  this.reveal( items );
  // layout previous items
  this.layoutItems( previousItems );
};

/**
 * reveal a collection of items
 * @param {Array of Outlayer.Items} items
 */
proto.reveal = function( items ) {
  this._emitCompleteOnItems( 'reveal', items );
  if ( !items || !items.length ) {
    return;
  }
  var stagger = this.updateStagger();
  items.forEach( function( item, i ) {
    item.stagger( i * stagger );
    item.reveal();
  });
};

/**
 * hide a collection of items
 * @param {Array of Outlayer.Items} items
 */
proto.hide = function( items ) {
  this._emitCompleteOnItems( 'hide', items );
  if ( !items || !items.length ) {
    return;
  }
  var stagger = this.updateStagger();
  items.forEach( function( item, i ) {
    item.stagger( i * stagger );
    item.hide();
  });
};

/**
 * reveal item elements
 * @param {Array}, {Element}, {NodeList} items
 */
proto.revealItemElements = function( elems ) {
  var items = this.getItems( elems );
  this.reveal( items );
};

/**
 * hide item elements
 * @param {Array}, {Element}, {NodeList} items
 */
proto.hideItemElements = function( elems ) {
  var items = this.getItems( elems );
  this.hide( items );
};

/**
 * get Outlayer.Item, given an Element
 * @param {Element} elem
 * @param {Function} callback
 * @returns {Outlayer.Item} item
 */
proto.getItem = function( elem ) {
  // loop through items to get the one that matches
  for ( var i=0; i < this.items.length; i++ ) {
    var item = this.items[i];
    if ( item.element == elem ) {
      // return item
      return item;
    }
  }
};

/**
 * get collection of Outlayer.Items, given Elements
 * @param {Array} elems
 * @returns {Array} items - Outlayer.Items
 */
proto.getItems = function( elems ) {
  elems = utils.makeArray( elems );
  var items = [];
  elems.forEach( function( elem ) {
    var item = this.getItem( elem );
    if ( item ) {
      items.push( item );
    }
  }, this );

  return items;
};

/**
 * remove element(s) from instance and DOM
 * @param {Array or NodeList or Element} elems
 */
proto.remove = function( elems ) {
  var removeItems = this.getItems( elems );

  this._emitCompleteOnItems( 'remove', removeItems );

  // bail if no items to remove
  if ( !removeItems || !removeItems.length ) {
    return;
  }

  removeItems.forEach( function( item ) {
    item.remove();
    // remove item from collection
    utils.removeFrom( this.items, item );
  }, this );
};

// ----- destroy ----- //

// remove and disable Outlayer instance
proto.destroy = function() {
  // clean up dynamic styles
  var style = this.element.style;
  style.height = '';
  style.position = '';
  style.width = '';
  // destroy items
  this.items.forEach( function( item ) {
    item.destroy();
  });

  this.unbindResize();

  var id = this.element.outlayerGUID;
  delete instances[ id ]; // remove reference to instance by id
  delete this.element.outlayerGUID;
  // remove data for jQuery
  if ( jQuery ) {
    jQuery.removeData( this.element, this.constructor.namespace );
  }

};

// -------------------------- data -------------------------- //

/**
 * get Outlayer instance from element
 * @param {Element} elem
 * @returns {Outlayer}
 */
Outlayer.data = function( elem ) {
  elem = utils.getQueryElement( elem );
  var id = elem && elem.outlayerGUID;
  return id && instances[ id ];
};


// -------------------------- create Outlayer class -------------------------- //

/**
 * create a layout class
 * @param {String} namespace
 */
Outlayer.create = function( namespace, options ) {
  // sub-class Outlayer
  var Layout = subclass( Outlayer );
  // apply new options and compatOptions
  Layout.defaults = utils.extend( {}, Outlayer.defaults );
  utils.extend( Layout.defaults, options );
  Layout.compatOptions = utils.extend( {}, Outlayer.compatOptions  );

  Layout.namespace = namespace;

  Layout.data = Outlayer.data;

  // sub-class Item
  Layout.Item = subclass( Item );

  // -------------------------- declarative -------------------------- //

  utils.htmlInit( Layout, namespace );

  // -------------------------- jQuery bridge -------------------------- //

  // make into jQuery plugin
  if ( jQuery && jQuery.bridget ) {
    jQuery.bridget( namespace, Layout );
  }

  return Layout;
};

function subclass( Parent ) {
  function SubClass() {
    Parent.apply( this, arguments );
  }

  SubClass.prototype = Object.create( Parent.prototype );
  SubClass.prototype.constructor = SubClass;

  return SubClass;
}

// ----- helpers ----- //

// how many milliseconds are in each unit
var msUnits = {
  ms: 1,
  s: 1000
};

// munge time-like parameter into millisecond number
// '0.4s' -> 40
function getMilliseconds( time ) {
  if ( typeof time == 'number' ) {
    return time;
  }
  var matches = time.match( /(^\d*\.?\d*)(\w*)/ );
  var num = matches && matches[1];
  var unit = matches && matches[2];
  if ( !num.length ) {
    return 0;
  }
  num = parseFloat( num );
  var mult = msUnits[ unit ] || 1;
  return num * mult;
}

// ----- fin ----- //

// back in global
Outlayer.Item = Item;

return Outlayer;

}));


/***/ }),

/***/ 5798:
/***/ (function(module) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ 129:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(8261);
var parse = __webpack_require__(5235);
var formats = __webpack_require__(5798);

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ 5235:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2769);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: true,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };

    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        var existing = has.call(obj, key);
        if (existing && options.duplicates === 'combine') {
            obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === 'last') {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = options.allowEmptyArrays && leaf === '' ? [] : [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
            var index = parseInt(decodedRoot, 10);
            if (!options.parseArrays && decodedRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== decodedRoot
                && String(index) === decodedRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else if (decodedRoot !== '__proto__') {
                obj[decodedRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
        throw new TypeError('The duplicates option must be either combine, first, or last');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        duplicates: duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ 8261:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var getSideChannel = __webpack_require__(7478);
var utils = __webpack_require__(2769);
var formats = __webpack_require__(5798);
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = {};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    allowEmptyArrays,
    strictNullHandling,
    skipNulls,
    encodeDotInKeys,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') {
            if (pos === step) {
                throw new RangeError('Cyclic object value');
            } else {
                findFlag = true; // Break while
            }
        }
        if (typeof tmpSc.get(sentinel) === 'undefined') {
            step = 0;
        }
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        if (encodeValuesOnly && encoder) {
            obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + '[]';
    }

    for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            allowEmptyArrays,
            strictNullHandling,
            skipNulls,
            encodeDotInKeys,
            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }

    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = defaults.arrayFormat;
    }

    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }

    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat: arrayFormat,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.allowEmptyArrays,
            options.strictNullHandling,
            options.skipNulls,
            options.encodeDotInKeys,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ 2769:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var formats = __webpack_require__(5798);

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        /* eslint operator-linebreak: [2, "before"] */
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ 5666:
/***/ (function(module) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : 0
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ 7771:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(210);
var define = __webpack_require__(2296);
var hasDescriptors = __webpack_require__(1044)();
var gOPD = __webpack_require__(7296);

var $TypeError = __webpack_require__(4453);
var $floor = GetIntrinsic('%Math.floor%');

/** @typedef {(...args: unknown[]) => unknown} Func */

/** @type {<T extends Func = Func>(fn: T, length: number, loose?: boolean) => T} */
module.exports = function setFunctionLength(fn, length) {
	if (typeof fn !== 'function') {
		throw new $TypeError('`fn` is not a function');
	}
	if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
		throw new $TypeError('`length` must be a positive 32-bit integer');
	}

	var loose = arguments.length > 2 && !!arguments[2];

	var functionLengthIsConfigurable = true;
	var functionLengthIsWritable = true;
	if ('length' in fn && gOPD) {
		var desc = gOPD(fn, 'length');
		if (desc && !desc.configurable) {
			functionLengthIsConfigurable = false;
		}
		if (desc && !desc.writable) {
			functionLengthIsWritable = false;
		}
	}

	if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
		if (hasDescriptors) {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
		} else {
			define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
		}
	}
	return fn;
};


/***/ }),

/***/ 7478:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(210);
var callBound = __webpack_require__(1924);
var inspect = __webpack_require__(631);

var $TypeError = __webpack_require__(4453);
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('.').listGetNode} */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	/** @type {typeof list | NonNullable<(typeof list)['next']>} */
	var prev = list;
	/** @type {(typeof list)['next']} */
	var curr;
	for (; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			// eslint-disable-next-line no-extra-parens
			curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

/** @type {import('.').listGet} */
var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
/** @type {import('.').listSet} */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('.').ListNode<typeof value>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		});
	}
};
/** @type {import('.').listHas} */
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

/** @type {import('.')} */
module.exports = function getSideChannel() {
	/** @type {WeakMap<object, unknown>} */ var $wm;
	/** @type {Map<object, unknown>} */ var $m;
	/** @type {import('.').RootNode<unknown>} */ var $o;

	/** @type {import('.').Channel} */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ 2238:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/////////////////////////////////////////////////////////////////////////////////
/* UAParser.js v0.7.31
   Copyright  2012-2021 Faisal Salman <f@faisalman.com>
   MIT License *//*
   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
   Supports browser & node.js environment. 
   Demo   : https://faisalman.github.io/ua-parser-js
   Source : https://github.com/faisalman/ua-parser-js */
/////////////////////////////////////////////////////////////////////////////////

(function (window, undefined) {

    'use strict';

    //////////////
    // Constants
    /////////////


    var LIBVERSION  = '0.7.31',
        EMPTY       = '',
        UNKNOWN     = '?',
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',
        MAJOR       = 'major',
        MODEL       = 'model',
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        EMBEDDED    = 'embedded',
        UA_MAX_LENGTH = 255;

    var AMAZON  = 'Amazon',
        APPLE   = 'Apple',
        ASUS    = 'ASUS',
        BLACKBERRY = 'BlackBerry',
        BROWSER = 'Browser',
        CHROME  = 'Chrome',
        EDGE    = 'Edge',
        FIREFOX = 'Firefox',
        GOOGLE  = 'Google',
        HUAWEI  = 'Huawei',
        LG      = 'LG',
        MICROSOFT = 'Microsoft',
        MOTOROLA  = 'Motorola',
        OPERA   = 'Opera',
        SAMSUNG = 'Samsung',
        SONY    = 'Sony',
        XIAOMI  = 'Xiaomi',
        ZEBRA   = 'Zebra',
        FACEBOOK   = 'Facebook';

    ///////////
    // Helper
    //////////

    var extend = function (regexes, extensions) {
            var mergedRegexes = {};
            for (var i in regexes) {
                if (extensions[i] && extensions[i].length % 2 === 0) {
                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                } else {
                    mergedRegexes[i] = regexes[i];
                }
            }
            return mergedRegexes;
        },
        enumerize = function (arr) {
            var enums = {};
            for (var i=0; i<arr.length; i++) {
                enums[arr[i].toUpperCase()] = arr[i];
            }
            return enums;
        },
        has = function (str1, str2) {
            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
        },
        lowerize = function (str) {
            return str.toLowerCase();
        },
        majorize = function (version) {
            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined;
        },
        trim = function (str, len) {
            if (typeof(str) === STR_TYPE) {
                str = str.replace(/^\s\s*/, EMPTY).replace(/\s\s*$/, EMPTY);
                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
            }
    };

    ///////////////
    // Map helper
    //////////////

    var rgxMapper = function (ua, arrays) {

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length === 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length === 3) {
                                    // check whether function or regex
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        // call function (usually string mapper)
                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                    } else {
                                        // sanitize match using given regex
                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                    }
                                } else if (q.length === 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        strMapper = function (str, map) {

            for (var i in map) {
                // check if current value is array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return str;
    };

    ///////////////
    // String map
    //////////////

    // Safari < 3.0
    var oldSafariMap = {
            '1.0'   : '/8',
            '1.2'   : '/1',
            '1.3'   : '/3',
            '2.0'   : '/412',
            '2.0.2' : '/416',
            '2.0.3' : '/417',
            '2.0.4' : '/419',
            '?'     : '/'
        },
        windowsVersionMap = {
            'ME'        : '4.90',
            'NT 3.11'   : 'NT3.51',
            'NT 4.0'    : 'NT4.0',
            '2000'      : 'NT 5.0',
            'XP'        : ['NT 5.1', 'NT 5.2'],
            'Vista'     : 'NT 6.0',
            '7'         : 'NT 6.1',
            '8'         : 'NT 6.2',
            '8.1'       : 'NT 6.3',
            '10'        : ['NT 6.4', 'NT 10.0'],
            'RT'        : 'ARM'
    };

    //////////////
    // Regex map
    /////////////

    var regexes = {

        browser : [[

            /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
            ], [VERSION, [NAME, 'Chrome']], [
            /edg(?:e|ios|a)?\/([\w\.]+)/i                                       // Microsoft Edge
            ], [VERSION, [NAME, 'Edge']], [

            // Presto based
            /(opera mini)\/([-\w\.]+)/i,                                        // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,                 // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i                           // Opera
            ], [NAME, VERSION], [
            /opios[\/ ]+([\w\.]+)/i                                             // Opera mini on iphone >= 8.0
            ], [VERSION, [NAME, OPERA+' Mini']], [
            /\bopr\/([\w\.]+)/i                                                 // Opera Webkit
            ], [VERSION, [NAME, OPERA]], [

            // Mixed
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,      // Lunascape/Maxthon/Netfront/Jasmine/Blazer
            // Trident based
            /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,               // Avant/IEMobile/SlimBrowser
            /(ba?idubrowser)[\/ ]?([\w\.]+)/i,                                  // Baidu Browser
            /(?:ms|\()(ie) ([\w\.]+)/i,                                         // Internet Explorer

            // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i,
                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
            /(weibo)__([\d\.]+)/i                                               // Weibo
            ], [NAME, VERSION], [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i                 // UCBrowser
            ], [VERSION, [NAME, 'UC'+BROWSER]], [
            /\bqbcore\/([\w\.]+)/i                                              // WeChat Desktop for Windows Built-in Browser
            ], [VERSION, [NAME, 'WeChat(Win) Desktop']], [
            /micromessenger\/([\w\.]+)/i                                        // WeChat
            ], [VERSION, [NAME, 'WeChat']], [
            /konqueror\/([\w\.]+)/i                                             // Konqueror
            ], [VERSION, [NAME, 'Konqueror']], [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i                       // IE11
            ], [VERSION, [NAME, 'IE']], [
            /yabrowser\/([\w\.]+)/i                                             // Yandex
            ], [VERSION, [NAME, 'Yandex']], [
            /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
            ], [[NAME, /(.+)/, '$1 Secure '+BROWSER], VERSION], [
            /\bfocus\/([\w\.]+)/i                                               // Firefox Focus
            ], [VERSION, [NAME, FIREFOX+' Focus']], [
            /\bopt\/([\w\.]+)/i                                                 // Opera Touch
            ], [VERSION, [NAME, OPERA+' Touch']], [
            /coc_coc\w+\/([\w\.]+)/i                                            // Coc Coc Browser
            ], [VERSION, [NAME, 'Coc Coc']], [
            /dolfin\/([\w\.]+)/i                                                // Dolphin
            ], [VERSION, [NAME, 'Dolphin']], [
            /coast\/([\w\.]+)/i                                                 // Opera Coast
            ], [VERSION, [NAME, OPERA+' Coast']], [
            /miuibrowser\/([\w\.]+)/i                                           // MIUI Browser
            ], [VERSION, [NAME, 'MIUI '+BROWSER]], [
            /fxios\/([-\w\.]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, FIREFOX]], [
            /\bqihu|(qi?ho?o?|360)browser/i                                     // 360
            ], [[NAME, '360 '+BROWSER]], [
            /(oculus|samsung|sailfish)browser\/([\w\.]+)/i
            ], [[NAME, /(.+)/, '$1 '+BROWSER], VERSION], [                      // Oculus/Samsung/Sailfish Browser
            /(comodo_dragon)\/([\w\.]+)/i                                       // Comodo Dragon
            ], [[NAME, /_/g, ' '], VERSION], [
            /(electron)\/([\w\.]+) safari/i,                                    // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,                   // Tesla
            /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i            // QQBrowser/Baidu App/2345 Browser
            ], [NAME, VERSION], [
            /(metasr)[\/ ]?([\w\.]+)/i,                                         // SouGouBrowser
            /(lbbrowser)/i                                                      // LieBao Browser
            ], [NAME], [

            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i       // Facebook App for iOS & Android
            ], [[NAME, FACEBOOK], VERSION], [
            /safari (line)\/([\w\.]+)/i,                                        // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
            /(chromium|instagram)[\/ ]([-\w\.]+)/i                              // Chromium/Instagram
            ], [NAME, VERSION], [
            /\bgsa\/([\w\.]+) .*safari\//i                                      // Google Search Appliance on iOS
            ], [VERSION, [NAME, 'GSA']], [

            /headlesschrome(?:\/([\w\.]+)| )/i                                  // Chrome Headless
            ], [VERSION, [NAME, CHROME+' Headless']], [

            / wv\).+(chrome)\/([\w\.]+)/i                                       // Chrome WebView
            ], [[NAME, CHROME+' WebView'], VERSION], [

            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i           // Android Browser
            ], [VERSION, [NAME, 'Android '+BROWSER]], [

            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /version\/([\w\.]+) .*mobile\/\w+ (safari)/i                        // Mobile Safari
            ], [VERSION, [NAME, 'Mobile Safari']], [
            /version\/([\w\.]+) .*(mobile ?safari|safari)/i                     // Safari & Safari Mobile
            ], [VERSION, NAME], [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i                      // Safari < 3.0
            ], [NAME, [VERSION, strMapper, oldSafariMap]], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i                              // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /mobile vr; rv:([\w\.]+)\).+firefox/i                               // Firefox Reality
            ], [VERSION, [NAME, FIREFOX+' Reality']], [
            /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,                                            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,                         // Mozilla

            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i                                              // Links
            ], [NAME, VERSION]
        ],

        cpu : [[

            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i                     // AMD64 (x64)
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i                                                      // IA32 (quicktime)
            ], [[ARCHITECTURE, lowerize]], [

            /((?:i[346]|x)86)[;\)]/i                                            // IA32 (x86)
            ], [[ARCHITECTURE, 'ia32']], [

            /\b(aarch64|arm(v?8e?l?|_?64))\b/i                                 // ARM64
            ], [[ARCHITECTURE, 'arm64']], [

            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i                                   // ARMHF
            ], [[ARCHITECTURE, 'armhf']], [

            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
            ], [[ARCHITECTURE, 'arm']], [

            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i                            // PowerPC
            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [

            /(sun4\w)[;\)]/i                                                    // SPARC
            ], [[ARCHITECTURE, 'sparc']], [

            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ], [[ARCHITECTURE, lowerize]]
        ],

        device : [[

            //////////////////////////
            // MOBILES & TABLETS
            // Ordered by popularity
            /////////////////////////

            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
            /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
            /samsung[- ]([-\w]+)/i,
            /sec-(sgh\w+)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [

            // Apple
            /\((ip(?:hone|od)[\w ]*);/i                                         // iPod/iPhone
            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
            /\((ipad);[-\w\),; ]+apple/i,                                       // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [

            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
            /(?:huawei|honor)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [

            // Xiaomi
            /\b(poco[\w ]+)(?: bui|\))/i,                                       // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,                                           // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,                             // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,                   // Xiaomi Redmi
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i                        // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [

            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [

            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

            // Realme
            /\b(rmx[12]\d{3})(?: bui|;|\))/i
            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [

            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [

            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [

            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
            ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [

            // Google
            /(pixel c)\b/i                                                      // Google Pixel C
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i                         // Google Pixel
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [

            // Sony
            /droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [

            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [

            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi)( bui|\))/i,                                         // Kindle Fire without Silk
            /(kf[a-z]+)( bui|\)).+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i                     // Fire Phone
            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [

            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i                                      // BlackBerry PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i                                                    // BlackBerry 10
            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [

            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [

            // HTC
            /(nexus 9)/i                                                        // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,                         // HTC

            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [

            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, MOBILE]], [

            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
            /(hp) ([\w ]+\w)/i,                                                 // HP iPAQ
            /(asus)-?(\w+)/i,                                                   // Asus
            /(microsoft); (lumia[\w ]+)/i,                                      // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,                                          // Lenovo
            /(jolla)/i,                                                         // Jolla
            /(oppo) ?([\w ]+) bui/i                                             // OPPO
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /(archos) (gamepad2?)/i,                                            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(nook)[\w ]+build\/(\w+)/i,                                        // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,                                   // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,                                  // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,                                      // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,                                    // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i                                   // Vodafone
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(surface duo)/i                                                    // Surface Duo
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i                                 // Fairphone
            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
            /(u304aa)/i                                                         // AT&T
            ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [
            /\bsie-(\w*)/i                                                      // Siemens
            ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
            /\b(rct\w+) b/i                                                     // RCA Tablets
            ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
            /\b(venue[\d ]{2,7}) b/i                                            // Dell Venue Tablets
            ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
            /\b(q(?:mv|ta)\w+) b/i                                              // Verizon Tablet
            ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i                       // Barnes & Noble Tablet
            ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [
            /\b(tm\d{3}\w+) b/i
            ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [
            /\b(k88) b/i                                                        // ZTE K Series Tablet
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [
            /\b(nx\d{3}j) b/i                                                   // ZTE Nubia
            ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
            /\b(gen\d{3}) b.+49h/i                                              // Swiss GEN Mobile
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [
            /\b(zur\d{3}) b/i                                                   // Swiss ZUR Tablet
            ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [
            /\b((zeki)?tb.*\b) b/i                                              // Zeki Tablets
            ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i                                // Dragon Touch Tablet
            ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [
            /\b(ns-?\w{0,9}) b/i                                                // Insignia Tablets
            ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [
            /\b((nxa|next)-?\w{0,9}) b/i                                        // NextBook Tablets
            ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i                  // Voice Xtreme Phones
            ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [
            /\b(lvtel\-)?(v1[12]) b/i                                           // LvTel Phones
            ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [
            /\b(ph-1) /i                                                        // Essential PH-1
            ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [
            /\b(v(100md|700na|7011|917g).*\b) b/i                               // Envizen Tablets
            ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [
            /\b(trio[-\w\. ]+) b/i                                              // MachSpeed Tablets
            ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [
            /\btu_(1491) b/i                                                    // Rotor Tablets
            ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
            /(shield[\w ]+) b/i                                                 // Nvidia Shield Tablets
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [
            /(sprint) (\w+)/i                                                   // Sprint Phones
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i             // Zebra
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [

            ///////////////////
            // CONSOLES
            ///////////////////

            /(ouya)/i,                                                          // Ouya
            /(nintendo) ([wids3utch]+)/i                                        // Nintendo
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
            /droid.+; (shield) bui/i                                            // Nvidia
            ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
            /(playstation [345portablevi]+)/i                                   // Playstation
            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i                                // Microsoft Xbox
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [

            ///////////////////
            // SMARTTVS
            ///////////////////

            /smart-tv.+(samsung)/i                                              // Samsung
            ], [VENDOR, [TYPE, SMARTTV]], [
            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i        // LG SmartTV
            ], [[VENDOR, LG], [TYPE, SMARTTV]], [
            /(apple) ?tv/i                                                      // Apple TV
            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [
            /crkey/i                                                            // Google Chromecast
            ], [[MODEL, CHROME+'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /droid.+aft(\w)( bui|\))/i                                          // Fire TV
            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
            /\(dtv[\);].+(aquos)/i                                              // Sharp
            ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,                          // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i               // HbbTV devices
            ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i                   // SmartTV from Unidentified Vendors
            ], [[TYPE, SMARTTV]], [

            ///////////////////
            // WEARABLES
            ///////////////////

            /((pebble))app/i                                                    // Pebble
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
            /droid.+; (glass) \d/i                                              // Google Glass
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [
            /droid.+; (wt63?0{2,3})\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
            /(quest( 2)?)/i                                                     // Oculus Quest
            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [

            ///////////////////
            // EMBEDDED
            ///////////////////

            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i                              // Tesla
            ], [VENDOR, [TYPE, EMBEDDED]], [

            ////////////////////
            // MIXED (GENERIC)
            ///////////////////

            /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i           // Android Phones from Unidentified Vendors
            ], [MODEL, [TYPE, MOBILE]], [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i       // Android Tablets from Unidentified Vendors
            ], [MODEL, [TYPE, TABLET]], [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i                      // Unidentifiable Tablet
            ], [[TYPE, TABLET]], [
            /(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i              // Unidentifiable Mobile
            ], [[TYPE, MOBILE]], [
            /(android[-\w\. ]{0,9});.+buil/i                                    // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]
        ],

        engine : [[

            /windows.+ edge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, EDGE+'HTML']], [

            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
            ], [VERSION, [NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
            /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,                           // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i                                       // iCab
            ], [NAME, VERSION], [

            /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows
            /microsoft (windows) (vista|xp)/i                                   // Windows (iTunes)
            ], [NAME, VERSION], [
            /(windows) nt 6\.2; (arm)/i,                                        // Windows RT
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,            // Windows Phone
            /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
            ], [NAME, [VERSION, strMapper, windowsVersionMap]], [
            /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ], [[NAME, 'Windows'], [VERSION, strMapper, windowsVersionMap]], [

            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,              // iOS
            /cfnetwork\/.+darwin/i
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i                             // Mac OS
            ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [

            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86)/i                              // Android-x86
            ], [VERSION, NAME], [                                               // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,                                      // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,                                     // Tizen/KaiOS
            /\((series40);/i                                                    // Series 40
            ], [NAME, VERSION], [
            /\(bb(10);/i                                                        // BlackBerry 10
            ], [VERSION, [NAME, BLACKBERRY]], [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i         // Symbian
            ], [VERSION, [NAME, 'Symbian']], [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
            ], [VERSION, [NAME, FIREFOX+' OS']], [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i                              // WebOS
            ], [VERSION, [NAME, 'webOS']], [

            // Google Chromecast
            /crkey\/([\d\.]+)/i                                                 // Google Chromecast
            ], [VERSION, [NAME, CHROME+'cast']], [
            /(cros) [\w]+ ([\w\.]+\w)/i                                         // Chromium OS
            ], [[NAME, 'Chromium OS'], VERSION],[

            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,                 // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)

            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,                            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,                                           // Mint
            /(mageia|vectorlinux)[; ]/i,                                        // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                                                                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,                                         // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,                                                // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i                                                    // Haiku
            ], [NAME, VERSION], [
            /(sunos) ?([\w\.\d]*)/i                                             // Solaris
            ], [[NAME, 'Solaris'], VERSION], [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,                              // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,                                  // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX
            /(unix) ?([\w\.]*)/i                                                // UNIX
            ], [NAME, VERSION]
        ]
    };

    /////////////////
    // Constructor
    ////////////////

    var UAParser = function (ua, extensions) {

        if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined;
        }

        if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
        }

        var _ua = ua || ((typeof window !== UNDEF_TYPE && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;

        this.getBrowser = function () {
            var _browser = {};
            _browser[NAME] = undefined;
            _browser[VERSION] = undefined;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser.major = majorize(_browser.version);
            return _browser;
        };
        this.getCPU = function () {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
        };
        this.getDevice = function () {
            var _device = {};
            _device[VENDOR] = undefined;
            _device[MODEL] = undefined;
            _device[TYPE] = undefined;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            return _device;
        };
        this.getEngine = function () {
            var _engine = {};
            _engine[NAME] = undefined;
            _engine[VERSION] = undefined;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
        };
        this.getOS = function () {
            var _os = {};
            _os[NAME] = undefined;
            _os[VERSION] = undefined;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            return _os;
        };
        this.getResult = function () {
            return {
                ua      : this.getUA(),
                browser : this.getBrowser(),
                engine  : this.getEngine(),
                os      : this.getOS(),
                device  : this.getDevice(),
                cpu     : this.getCPU()
            };
        };
        this.getUA = function () {
            return _ua;
        };
        this.setUA = function (ua) {
            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;
            return this;
        };
        this.setUA(_ua);
        return this;
    };

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR]);
    UAParser.CPU = enumerize([ARCHITECTURE]);
    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

    ///////////
    // Export
    //////////

    // check js environment
    if (typeof(exports) !== UNDEF_TYPE) {
        // nodejs env
        if ("object" !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if ("function" === FUNC_TYPE && __webpack_require__.amdO) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                return UAParser;
            }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (typeof window !== UNDEF_TYPE) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);


/***/ }),

/***/ 4654:
/***/ (function() {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	!function() {
/******/ 		__webpack_require__.amdO = {};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js
var common_utils_namespaceObject = {};
__webpack_require__.r(common_utils_namespaceObject);
__webpack_require__.d(common_utils_namespaceObject, {
  "hasBrowserEnv": function() { return hasBrowserEnv; },
  "hasStandardBrowserEnv": function() { return hasStandardBrowserEnv; },
  "hasStandardBrowserWebWorkerEnv": function() { return hasStandardBrowserWebWorkerEnv; }
});

// EXTERNAL MODULE: ./src/main/webpack/dependencies/bootstrap/js/localeChooser.js
var localeChooser = __webpack_require__(1310);
;// CONCATENATED MODULE: ./stories/js/www.js
var www = {
  site: "www",
  rclocale: "en-au",
  requestObjType: "Channel",
  locale: "en-au",
  link: "/",
  channelOid: "0964c3a6179cd210VgnVCM100000cc2da00aRCRD",
  requestOid: "0964c3a6179cd210VgnVCM100000cc2da00aRCRD",
  channels: ["Home"],
  supportedLocales: ["fr_CA", "pt_PT", "th_TH", "vi_VN", "ar_EM", "de_DE", "en_AS", "en_AU", "en_CA", "en_EM", "en_GB", "en_IN", "en_SG", "en_US", "es_ES", "es_LA", "fr_BE", "fr_FR", "in_ID", "it_IT", "ja_JP", "ko_KR", "nl_BE", "nl_NL", "pl_PL", "pt_BR", "ru_RU", "tr_TR", "zh_CN", "zh_TW", "en_AP", "en_EU"],
  url: "https://www.seagate.com/",
  LOCALE_COOKIE_NAME_PERMANENT: "permanentLocaleCookie",
  inMgmtCDS: false,
  defaultdomianforCookie: ".seagate.com",
  LOCALE_COOKIE_NAME_TEMP: "userSelectedLocaleCookie",
  screenType: "desktop",
  labels: {
    my_dashboard_url_t2: "https://program.seagate.com/s",
    my_profile_url_ci: "https://myportal.seagate.com/consumer-identity/profile/",
    logout_url_ci: "https://myportal.seagate.com/consumer-identity/logout",
    logoutUrl: "https://ssologin.seagate.com/oam/server/logout?end_url=",
    my_profile_url_non_consumer: "https://partnerreg.seagate.com/partnerprofile/myaccount.jsp",
    search_Support: "Support",
    my_dashboard_url_ci: "https://myportal.seagate.com/consumer-identity/home.jsp",
    my_profile_url_sd: "https://seagate.my.site.com/seagatedirect/s/myprofile",
    loginProperty_MyAccount: "My Account",
    my_dashboard_url_supplier: "https://www.seagate.com/portal/site/supplier ",
    header_Login: "Login",
    my_dashboard_url_sd: "https://seagate.my.site.com/seagatedirect/s/",
    my_profile_url_t2: "https://program.seagate.com/s/editprofile",
    search_ViewAllResults: "View All Results",
    my_profile_url_supplier: "https://www.seagate.com/portal/site/supplier/myprofile"
  }
};
;// CONCATENATED MODULE: ./stories/js/wwwHelpers.js


if (typeof www != "undefined") {
  if (typeof window.www == "undefined") {
    window.www = www;
  }

  www.screenType = "desktop";
  window.www.screenType = "desktop";
  www.defaultdomianforCookie = ".seagate.com";

  if (window.location.hostname.indexOf("seagate.com") != -1) {
    www.defaultdomianforCookie = ".seagate.com";
  } else if (window.location.hostname.indexOf("lacie.com") != -1) {
    www.defaultdomianforCookie = ".lacie.com";
    lacie = true;
  }

  www.checkScreenType = function () {
    if (window.innerWidth < 767) {
      www.screenType = "mobile";
      window.www.screenType = "mobile";
    } else if (window.innerWidth >= 767 && window.innerWidth <= 1023) {
      www.screenType = "tablet";
      window.www.screenType = "tablet";
    }
  };

  www.checkScreenType();

  www.throttle = function (type, name, obj) {
    obj = obj || window;
    var running = false;

    var func = function func() {
      if (running) {
        return;
      }

      running = true;
      requestAnimationFrame(function () {
        obj.dispatchEvent(new CustomEvent(name));
        running = false;
      });
    };

    obj.addEventListener(type, func);
  };

  www.throttle("resize", "optimizedResize");

  if (typeof window.addEventListener == "function") {
    window.addEventListener("optimizedResize", function () {
      www.checkScreenType();
    });
  } else if (typeof window.attachEvent == "function") {
    node.attachEvent("onresize", function () {
      www.checkScreenType();
    });
  }

  www.getCookie = function (c_name) {
    var i,
        x,
        y,
        ARRcookies = document.cookie.split(";");

    for (i = 0; i < ARRcookies.length; i++) {
      x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="));
      y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1);
      x = x.replace(/^\s+|\s+$/g, "");

      if (x == c_name) {
        return unescape(y);
      }
    }
  };

  www.setPermanentCookie = function (c_name, value, exdays) {
    var exdate = new Date();
    exdate.setDate(exdate.getDate() + exdays);
    var c_value = escape(value) + (exdays == null ? "" : "; expires=" + exdate.toUTCString());
    document.cookie = c_name + "=" + c_value + "; path=/ ; domain=" + www.defaultdomianforCookie;
  };

  www.setSessionCookie = function (c_name, value) {
    document.cookie = c_name + "=" + escape(value) + "; path=/ ;domain=" + www.defaultdomianforCookie;
  };

  www.removeCookie = function (c_name) {
    document.cookie = c_name + "=;path=/;expires=Thu, 01-Jan-1970 00:00:01 GMT;domain=" + www.defaultdomianforCookie;
  };

  www.deleteCookie = function (name, path, domain) {
    if (www.getCookie(name)) {
      document.cookie = name + "=" + (path ? "; path=" + path : "") + (domain ? "; domain=" + domain : "") + "; expires=Thu, 01-Jan-70 00:00:01 GMT";
    }
  };

  www.goToLocale = function (locale) {
    var locales = locale.split("-");
    var localeURL = "/" + locales[1] + "/" + locales[0] + "/";
    var param = document.location.search;

    if (param.length > 0) {
      param = param.replace(/[?&]stxLoc=[^&]*/, "");

      if (param.length > 0 && param[0] == "&") {
        param = "?" + param.substring(1);
      }
    }

    var redirectPage = "";

    if (document.location.pathname.match(/\/\w{2,2}\/\w{2,2}\//)) {
      redirectPage = document.location.origin + localeURL + document.location.pathname.replace(/^\/\w{2,2}\/\w{2,2}\//, "") + param + document.location.hash;
    } else {
      if (document.location.pathname !== "/") {
        redirectPage = document.location.origin + localeURL.slice(0, -1) + document.location.pathname + param + document.location.hash;
      } else {
        redirectPage = document.location.origin + localeURL + param + document.location.hash;
      }
    }

    if (document.location.pathname.includes("/content/")) {
      redirectPage = document.location.origin + document.location.pathname.replace(/\/\w{2,2}\/\w{2,2}\//, localeURL) + param + document.location.hash;
    }

    document.location = redirectPage;
  };

  www.logout = function (redirectUrl) {
    if (/^www.*\.seagate\.com$/.test(document.location.hostname) && redirectUrl.match("end_url=$") == "end_url=") {
      var userRole = www.getCookie("USERROLE");

      if (userRole == "Supplier" || userRole == "d" || userRole == "o") {
        redirectUrl = redirectUrl + "https://" + document.location.hostname + "/direct-partners/";
      } else {
        redirectUrl = redirectUrl + "https://" + document.location.hostname + "/partners/";
      }
    }

    return redirectUrl;
  };

  www.deleteLoginCookies = function () {
    var domain = ".seagate.com";

    if (document.domain.indexOf(".lacie.com") != -1) {
      domain = ".lacie.com";
    }

    window.top.name = "something_unique";
    www.deleteCookie("SMSESSION", "/", domain);
    www.deleteCookie("USERDETAIL", "/", domain);
    www.deleteCookie("LOCALSMSESSION", "/", domain);
    www.deleteCookie("ISSPPUSER", "/", domain);
    www.deleteCookie("userSelectedLocaleCookie", "/", domain);
    www.deleteCookie("SPPLOCALE", "/", domain);
    www.deleteCookie("isSDUSER", "/", domain);
    www.deleteCookie("ISCIUSER", "/", domain);
    www.deleteCookie("CILOCALE", "/", domain);
    www.deleteCookie("USERROLE", "/", domain);
    www.deleteCookie("myRegisteredProducts", "/", domain);
  };

  www.isAuthor = function () {
    var isAuthorMode = false;
    var wcmmode = www.getCookie("wcmmode");

    if (wcmmode) {
      if (wcmmode == 'edit' || wcmmode == 'preview') {
        isAuthorMode = true;
      }
    }

    return isAuthorMode;
  };

  var cookieLocale = www.getCookie(www.LOCALE_COOKIE_NAME_TEMP) || www.getCookie(www.LOCALE_COOKIE_NAME_PERMANENT) || "en-us";

  if ((/^(origin-www|www).*\.(seagate|lacie)\.com$/.test(document.location.host) || /.*\.(seagate|lacie)\.com/.test(document.location.host)) && !www.isAuthor() && !/^.*(shop|store|myportal|seagategov)(.*)\.(seagate|lacie)\.com$/.test(document.location.host)) {
    if (document.location.search.indexOf("stxLoc") >= 0) {
      var stxLoc = document.location.search.match(/(?:[\?\&]stxLoc=)([a-z]{2,2}-[a-z]{2,2})(?:\&|$)/);

      if (stxLoc != null) {
        stxLoc = stxLoc[1];
        www.setSessionCookie(www.LOCALE_COOKIE_NAME_TEMP, stxLoc);
      }
    }

    if (!window.location.pathname.includes("/language-masters/") && !window.location.pathname.includes("/conf/") && !window.location.pathname.startsWith("/ww/")) {
      var pageLocale = "/us/en/";

      if (window.location.pathname.match(/\/\w{2,2}\/\w{2,2}\//)) {
        pageLocale = window.location.pathname.match(/\/\w{2,2}\/\w{2,2}\//)[0];
      }

      var pageLocaleUrl = pageLocale.split("/");
      pageLocale = pageLocaleUrl[2] + "-" + pageLocaleUrl[1];

      if (cookieLocale != undefined && cookieLocale != "" && cookieLocale != pageLocale) {
        www.goToLocale(cookieLocale);
      }

      cookieLocale = pageLocale;
    }
  }

  www.locale = cookieLocale;
}

www.userDetail = www.getCookie("USERDETAIL");
www.userRole = www.getCookie("USERROLE"); //WeChat

try {
  if (/^https?:\/\/(origin-www|www).*\.seagate\.com\/cn\/zh\/support\/(products\/|warranty-and-replacements\/|downloads\/)?(\?|\#)?.*$/.test(document.location.href)) {
    document.addEventListener("DOMContentLoaded", function () {
      fetch("/ww/contacts/?action=isOfficeHour&opensAt=8&closesAt=17&weekend=true&timezone=Asia/Shanghai", {
        method: 'GET'
      }).then(function (response) {
        return response.json();
      }).then(function (data) {
        if (typeof data != "undefined" && typeof data.isOfficeHour != "undefined" && data.isOfficeHour) {
          var weChatSidebar = document.createElement("div");
          weChatSidebar.id = "wechat-sidebar";
          var weChatSidebarTop = window.innerHeight / 4 * 3 - 380;
          weChatSidebar.style.cssText = "position: fixed; top: " + weChatSidebarTop + "px; right: 0; z-index: 999; cursor: pointer;";
          var weChatSidebarText = document.createElement("div");
          weChatSidebarText.className = "wechat-sidebar-text";
          weChatSidebarText.innerHTML = "&nbsp;&nbsp;";
          weChatSidebarText.style.cssText = "padding: 10px; border: 2px solid #4e8c38; border-radius: 10px; background: #6ebe49; writing-mode: tb-rl; letter-spacing: 10px; font-size: 20px; float: right; color: #fff;";
          weChatSidebar.appendChild(weChatSidebarText);
          var weChatSidebarDetail = document.createElement("div");
          weChatSidebarDetail.className = "wechat-sidebar-detail";
          weChatSidebarDetail.style.cssText = "display: none; padding: 10px; border: 2px solid #4e8c38; border-radius: 10px; background: #6ebe49; font-size: 14px; float: right; width: 150px; color: #fff;";
          var weChatSidebarClose = document.createElement("button");
          weChatSidebarClose.className = "wechat-sidebar-close";
          weChatSidebarClose.innerHTML = "";
          weChatSidebarClose.style.cssText = "color: black; font-weight: bold; float: right; font-size: 20px; text-decoration: none; border: none; background: transparent;";
          weChatSidebarDetail.appendChild(weChatSidebarClose);
          var weChatSidebarQR = document.createElement("img");
          weChatSidebarQR.src = "/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/images/STX_WEBSUPPORT_web support page.png";
          weChatSidebarQR.style.cssText = "width: 150px;";
          weChatSidebarDetail.appendChild(weChatSidebarQR);
          weChatSidebarDetail.innerHTML += " SeagateSeagate<br><br><br>";
          weChatSidebar.appendChild(weChatSidebarDetail);
          var weChatSidebarIcon = document.createElement("img");
          weChatSidebarIcon.className = "wechat-sidebar-icon";
          weChatSidebarIcon.src = "/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/images/WeChat-Icon-Concept-20180802-Color-v11b-stx-120x120.jpg";
          weChatSidebarIcon.style.cssText = "border: solid #4e8c38; border-radius: 50%; width: 80px; float: right; position: relative; margin-top: 125px; margin-right: -48px;";
          weChatSidebar.appendChild(weChatSidebarIcon);
          document.getElementsByTagName("body")[0].appendChild(weChatSidebar);
          weChatSidebar.addEventListener("click", function () {
            document.querySelector("#wechat-sidebar .wechat-sidebar-text").style.display = "none";
            document.querySelector("#wechat-sidebar .wechat-sidebar-detail").style.display = "block";
            document.querySelector("#wechat-sidebar .wechat-sidebar-icon").style.marginTop = "440px";
            document.querySelector("#wechat-sidebar .wechat-sidebar-icon").style.marginRight = "-150px";
          });
          document.querySelector("#wechat-sidebar .wechat-sidebar-close").addEventListener("click", function (e) {
            e.stopPropagation();
            document.querySelector("#wechat-sidebar .wechat-sidebar-detail").style.display = "none";
            document.querySelector("#wechat-sidebar .wechat-sidebar-text").style.display = "block";
            document.querySelector("#wechat-sidebar .wechat-sidebar-icon").style.marginTop = "125px";
            document.querySelector("#wechat-sidebar .wechat-sidebar-icon").style.marginRight = "-48px";
          });
        }
      });
    });
  }
} catch (e) {} // fonts


if (/^www.*\.seagate\.com$/.test(document.location.host)) {
  var MTIProjectId = "28c2f6ed-3fb0-4fa7-ac8b-422a605504ba";

  (function () {
    var mtTracking = document.createElement("script");
    mtTracking.type = "text/javascript";
    mtTracking.async = "true";
    mtTracking.src = "/content/dam/seagate/migrated-assets/ww/redesign/assets/fonts/mtiFontTrackingCode.js";
    (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(mtTracking);
  })();
} // Polyfill - closest


if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}

if (!Element.prototype.closest) {
  Element.prototype.closest = function (s) {
    var el = this;

    do {
      if (Element.prototype.matches.call(el, s)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);

    return null;
  };
} // Polyfill - append


(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty("append")) {
      return;
    }

    Object.defineProperty(item, "append", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function append() {
        var argArr = Array.prototype.slice.call(arguments),
            docFrag = document.createDocumentFragment();
        argArr.forEach(function (argItem) {
          var isNode = argItem instanceof Node;
          docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
        });
        this.appendChild(docFrag);
      }
    });
  });
})([Element.prototype, Document.prototype, DocumentFragment.prototype]); // Polyfill - remove


(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty("remove")) {
      return;
    }

    Object.defineProperty(item, "remove", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
;// CONCATENATED MODULE: ./stories/js/LanguageSelector.js


if (typeof www != "undefined") {
  if (typeof www.labels == "undefined") {
    www.labels = {};
  }

  var loginTags = document.querySelectorAll(".global-header-login");
  var myAccountTags = document.querySelectorAll(".global-header-my-account");
  var loginModal = document.getElementById("login");

  if (/^(origin-www|www|partnerreg).*\.(seagate|lacie)\.com$/.test(document.location.host) || /^.*\.force\.com$/.test(document.location.host) || /.*\.(seagate|lacie)\.com/.test(document.location.host)) {
    setTimeout(function () {
      www.userDetail = www.getCookie("USERDETAIL");
      www.userRole = www.getCookie("USERROLE");

      if (www.userDetail != undefined && www.userDetail != "") {
        var loginText = '';
        loginTags.forEach(function (loginTag) {
          loginText = loginTag.innerText.trim();
          loginTag.style.display = 'none';
        });
        var myAccountText = '';
        myAccountTags.forEach(function (myAccountTag) {
          myAccountText = myAccountTag.innerText.trim();
          myAccountTag.style.display = 'flex';
        });

        if (loginModal) {
          loginModal.querySelector(".modal__header h3").innerText = myAccountText;
        }

        var myAccount = loginModal.querySelector(".modal__content.Modal-groups.my-account");
        myAccount.querySelector("p.username").innerText = www.userDetail;

        if (www.userRole != undefined && www.userRole != "") {
          var myProfile = myAccount.querySelector("a.my-profile");
          var mDashboard = myAccount.querySelector("a.my-dashboard");
          var logout = myAccount.querySelector("a.logout");

          if (www.userRole == "CI") {
            myProfile.setAttribute("href", www.labels.my_profile_url_ci);
            mDashboard.setAttribute("href", www.labels.my_dashboard_url_ci);
            logout.setAttribute("href", www.logout(www.labels.logout_url_ci));
          } else if (www.userRole == "Employee") {
            mDashboard.parentElement.style.display = "none";
            myProfile.parentElement.style.display = "none";
            logout.setAttribute("href", www.logout(www.labels.logoutUrl));
          } else if (www.userRole == "Supplier") {
            myProfile.setAttribute("href", www.labels.my_profile_url_supplier);
            mDashboard.setAttribute("href", www.labels.my_dashboard_url_supplier);
            logout.setAttribute("href", www.logout(www.labels.logoutUrl));
          } else if (www.userRole == "d" || www.userRole == "o") {
            myProfile.setAttribute("href", www.labels.my_profile_url_sd);
            mDashboard.setAttribute("href", www.labels.my_dashboard_url_sd);
            logout.setAttribute("href", www.logout(www.labels.logoutUrl));
          } else if (www.userRole.indexOf("spp") != -1) {
            myProfile.setAttribute("href", www.labels.my_profile_url_t2);
            mDashboard.setAttribute("href", www.labels.my_dashboard_url_t2);
            logout.setAttribute("href", www.logout(www.labels.logoutUrl));
          } else {
            mDashboard.parentElement.style.display = "none";
            myProfile.setAttribute("href", www.labels.my_profile_url_non_consumer);
            logout.setAttribute("href", www.logout(www.labels.logoutUrl));
          }
        }

        if (loginModal) {
          loginModal.classList.add("Modal--my-account");
          loginModal.querySelector(".modal__content.Modal-groups.login").style.display = "none";
          loginModal.querySelector(".modal__content.Modal-groups.my-account").style.display = "flex";
        }
      } else {
        var loginText = '';
        loginTags.forEach(function (loginTag) {
          loginText = loginTag.innerText.trim();
          loginTag.style.display = 'block';
        });
        var myAccountText = '';
        myAccountTags.forEach(function (myAccountTag) {
          myAccountText = myAccountTag.innerText.trim();
          myAccountTag.style.display = 'none';
        });

        if (loginModal) {
          loginModal.querySelector(".modal__header h3").innerText = loginText;
          loginModal.querySelector(".modal__content.Modal-groups.my-account").style.display = "none";
          loginModal.querySelector(".modal__content.Modal-groups.login").style.display = "flex";
        }
      } // loginModal.querySelector(".login-loading").style.display = "none";

    }, 8888);
  } // locale selector


  var displayLocaleSelector = false;

  if (/^(origin-www|www|partnerreg).*\.(seagate|lacie)\.com$/.test(document.location.host) || /^.*\.force\.com$/.test(document.location.host) || /.*\.(seagate|lacie)\.com/.test(document.location.host)) {
    displayLocaleSelector = true;
  }

  if (displayLocaleSelector) {
    if (www.isAuthor()) {
      var LanguageSelector_pageLocale = "/us/en/";

      if (window.location.pathname.match(/\/\w{2,2}\/\w{2,2}\//)) {
        LanguageSelector_pageLocale = window.location.pathname.match(/\/\w{2,2}\/\w{2,2}\//)[0];
      }

      var LanguageSelector_pageLocaleUrl = LanguageSelector_pageLocale.split("/");
      www.locale = LanguageSelector_pageLocaleUrl[2] + "-" + LanguageSelector_pageLocaleUrl[1];
    }

    var currentCountryText = document.querySelector("#modal-locale-selector [data-locale='" + www.locale + "'") && document.querySelector("#modal-locale-selector [data-locale='" + www.locale + "'").innerText.trim();
    document.querySelectorAll(".currentCountryText") && document.querySelectorAll(".currentCountryText").forEach(function (element) {
      element.innerText = currentCountryText;
    });
    document.querySelectorAll("#modal-locale-selector [data-locale]").forEach(function (element) {
      element.addEventListener("click", function (e) {
        e.preventDefault();
        var locale = this.getAttribute("data-locale");

        if (/^partnerreg.*\.(seagate|lacie)\.com$/.test(document.location.host)) {
          window.location = document.location.pathname + "?languageselect=" + locale;
        } else {
          if (!/^[a-zA-Z]{2,2}-[a-zA-Z]{2,2}$/.test(locale)) {
            locale = "en-us";
          }

          if (!www.isAuthor()) {
            var rememberMe = document.getElementById("rememberMe").checked;
            www.setSessionCookie(www.LOCALE_COOKIE_NAME_TEMP, locale);

            if (rememberMe) {
              www.setPermanentCookie(www.LOCALE_COOKIE_NAME_PERMANENT, locale, 60);
            }
          }

          if (!/^.*(shop|store|myportal|seagategov)(.*)\.(seagate|lacie)\.com$/.test(document.location.host)) {
            fetch('/ww/ispageavailable?path=' + window.location.pathname + "&locale=" + locale.replace("-", "_")).then(function (response) {
              return response.json();
            }).then(function (data) {
              if (data && data.available) {
                if (www.getCookie("customer_token") !== undefined && typeof eCommerceConfig != "undefined" && eCommerceConfig['enableECommerceRedirectUrl'] == "true" && eCommerceConfig['eCommerceLocales'].split(",").includes(locale.replace("-", "_"))) {
                  window.location = eCommerceConfig['eCommerceRedirectUrl'];
                  return;
                }

                www.goToLocale(locale);
              } else {
                var redirectPage = "";

                if (document.location.pathname.indexOf("/content/seagate/language-masters") != -1) {
                  if (locale == "en-us") {
                    redirectPage = "/content/seagate/language-masters/en/home.html";
                  } else {
                    redirectPage = "/content/seagate/language-masters/" + locale.replace("-", "_") + "/home.html";
                  }
                } else if (document.location.pathname.indexOf("/content/seagate") != -1 && document.location.pathname.match(/\/\w{2,2}\/\w{2,2}\//)) {
                  var locales = locale.split("-");
                  var localeURL = "/" + locales[1] + "/" + locales[0] + "/";
                  redirectPage = "/content/seagate" + localeURL + "home.html";
                } else if (document.location.pathname.match(/\/\w{2,2}\/\w{2,2}\//)) {
                  var locales = locale.split("-");
                  var localeURL = "/" + locales[1] + "/" + locales[0] + "/";
                  redirectPage = localeURL + "/home";
                } else {
                  redirectPage = "/home";
                }

                document.location = document.location.origin + redirectPage;
              }
            });
          } else {
            window.location.reload();
          }
        }
      }, false);
    });
  } else {
    document.querySelectorAll(".SecondaryNav-region").forEach(function (element) {
      element.style.display = "none";
    });
  }
}
// EXTERNAL MODULE: ./node_modules/@babel/polyfill/lib/index.js
var lib = __webpack_require__(6981);
// EXTERNAL MODULE: ./stories/js/polyfills/CustomEvent.js
var polyfills_CustomEvent = __webpack_require__(78);
// EXTERNAL MODULE: ./stories/js/polyfills/IntersectionObserver.js
var polyfills_IntersectionObserver = __webpack_require__(5198);
// EXTERNAL MODULE: ./stories/js/polyfills/ForEachPolyfill.js
var ForEachPolyfill = __webpack_require__(7215);
// EXTERNAL MODULE: ./stories/js/polyfills/ClosestPolyfill.js
var ClosestPolyfill = __webpack_require__(4433);
;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/finally.js
/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

/* harmony default export */ var src_finally = (finallyConstructor);

;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/allSettled.js
function allSettled(arr) {
  var P = this;
  return new P(function(resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(
        new TypeError(
          typeof arr +
            ' ' +
            arr +
            ' is not iterable(cannot read property Symbol(Symbol.iterator))'
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        var then = val.then;
        if (typeof then === 'function') {
          then.call(
            val,
            function(val) {
              res(i, val);
            },
            function(e) {
              args[i] = { status: 'rejected', reason: e };
              if (--remaining === 0) {
                resolve(args);
              }
            }
          );
          return;
        }
      }
      args[i] = { status: 'fulfilled', value: val };
      if (--remaining === 0) {
        resolve(args);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}

/* harmony default export */ var src_allSettled = (allSettled);

;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/index.js



// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function src_Promise(fn) {
  if (!(this instanceof src_Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  src_Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof src_Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    src_Promise._immediateFn(function() {
      if (!self._handled) {
        src_Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

src_Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

src_Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

src_Promise.prototype['finally'] = src_finally;

src_Promise.all = function(arr) {
  return new src_Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

src_Promise.allSettled = src_allSettled;

src_Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === src_Promise) {
    return value;
  }

  return new src_Promise(function(resolve) {
    resolve(value);
  });
};

src_Promise.reject = function(value) {
  return new src_Promise(function(resolve, reject) {
    reject(value);
  });
};

src_Promise.race = function(arr) {
  return new src_Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      src_Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
src_Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

src_Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ var src = (src_Promise);

;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/polyfill.js




/** @suppress {undefinedVars} */
var globalNS = (function() {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof __webpack_require__.g !== 'undefined') {
    return __webpack_require__.g;
  }
  throw new Error('unable to locate global object');
})();

// Expose the polyfill if Promise is undefined or set to a
// non-function value. The latter can be due to a named HTMLElement
// being exposed by browsers for legacy reasons.
// https://github.com/taylorhakes/promise-polyfill/issues/114
if (typeof globalNS['Promise'] !== 'function') {
  globalNS['Promise'] = src;
} else {
  if (!globalNS.Promise.prototype['finally']) {
    globalNS.Promise.prototype['finally'] = src_finally;
  } 
  if (!globalNS.Promise.allSettled) {
    globalNS.Promise.allSettled = src_allSettled;
  }
}

;// CONCATENATED MODULE: ./node_modules/whatwg-fetch/fetch.js
var fetch_global =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  (typeof fetch_global !== 'undefined' && fetch_global)

var support = {
  searchParams: 'URLSearchParams' in fetch_global,
  iterable: 'Symbol' in fetch_global && 'iterator' in Symbol,
  blob:
    'FileReader' in fetch_global &&
    'Blob' in fetch_global &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in fetch_global,
  arrayBuffer: 'ArrayBuffer' in fetch_global
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsText(blob)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    this.bodyUsed = this.bodyUsed
    this._bodyInit = body
    if (!body) {
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this)
        if (isConsumed) {
          return isConsumed
        }
        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          )
        } else {
          return Promise.resolve(this._bodyArrayBuffer)
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = fetch_global.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch_fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      setTimeout(function() {
        resolve(new Response(body, options))
      }, 0)
    }

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'))
      }, 0)
    }

    function fixUrl(url) {
      try {
        return url === '' && fetch_global.location.href ? fetch_global.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob'
      } else if (
        support.arrayBuffer &&
        request.headers.get('Content-Type') &&
        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
      ) {
        xhr.responseType = 'arraybuffer'
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
      })
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch_fetch.polyfill = true

if (!fetch_global.fetch) {
  fetch_global.fetch = fetch_fetch
  fetch_global.Headers = Headers
  fetch_global.Request = Request
  fetch_global.Response = Response
}

;// CONCATENATED MODULE: ./stories/js/utilities/CustomUtil.js
var _CustomUtil;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CustomUtil = (_CustomUtil = {
  settings: {
    headerFixed: false,
    headerFixedFlag: '.ShyNav',
    headerStaticHeight: 0,
    headerFixedHeight: 0,
    headerTop: 0,
    headerStatus: 2 // 0 = hide, 1 = show part, 2 = show all

  },
  screenIs: 'isLaptop',
  isNavFixed: function isNavFixed() {
    var fixedNav = document.querySelector(this.settings.headerFixedFlag);
    return fixedNav != null && (fixedNav.style.position == 'fixed' || getComputedStyle(fixedNav).position == 'fixed');
  },
  initSettings: function initSettings() {
    var header = document.querySelector(this.settings.headerFixedFlag);

    if (this.isNavFixed()) {
      this.settings.headerFixed = true;
      this.settings.headerFixedHeight = header.clientHeight;
      this.settings.headerTop = parseInt(header.style.top.slice(0, header.style.top.length - 2));
    } else {
      this.settings.headerFixedHeight = 0;
    }

    return this;
  },
  updateSettings: function updateSettings() {
    var header = document.querySelector(this.settings.headerFixedFlag);

    if (this.isNavFixed()) {
      this.settings.headerFixed = true;
      this.settings.headerFixedHeight = header.clientHeight;
      this.settings.headerTop = parseInt(header.style.top.slice(0, header.style.top.length - 2));
    } else {
      this.settings.headerFixedHeight = 0;
    }
  },
  getAllStickyTop: function getAllStickyTop() {
    var in_sticky = document.querySelectorAll('.with-sticky.in-sticky');
    var sticky_top = 0;

    for (var i = 0; i < in_sticky.length; i++) {
      sticky_top += parseInt(in_sticky[i].clientHeight);
    }

    return sticky_top;
  },
  checkNavigationSection: function checkNavigationSection() {
    var navigationSection = document.querySelector('.NavigationSection');

    if (navigationSection) {
      return true;
    } else {
      return false;
    }
  },
  checkInPageNav: function checkInPageNav() {
    var inPageNav = document.querySelector('.InPageNav');

    if (inPageNav) {
      return true;
    } else {
      return false;
    }
  },
  checkPrimaryNavEComm: function checkPrimaryNavEComm() {
    var navigationSection = document.querySelector('.PrimaryNavEComm');

    if (navigationSection) {
      return true;
    } else {
      return false;
    }
  },
  getInPageNavHeight: function getInPageNavHeight() {
    var inPageNav = document.querySelector('.InPageNav');

    if (inPageNav) {
      return inPageNav.clientHeight;
    } else {
      return 0;
    }
  },
  getNavigationSectionHeight: function getNavigationSectionHeight() {
    var navigationSection = document.querySelector('.NavigationSection');

    if (navigationSection) {
      return navigationSection.clientHeight;
    } else {
      return 0;
    }
  },
  revealStickyElements: function revealStickyElements() {
    var erevealEls = document.querySelectorAll('[data-ereveal]');
    var erevealEvent = new CustomEvent('isERevealed', {
      detail: {
        isERevealed: true
      }
    });
    var observerConfig = {
      rootMargin: '0px 0px 0px 0px',
      threshold: 0
    };
    var observer = new IntersectionObserver(function (elements, self) {
      elements.forEach(function (element) {
        if (element.isIntersecting) {
          // Add class and stop watching
          element.target.classList.add('is-erevealed'); //element.target.dispatchEvent(erevealEvent);
          //self.unobserve(element.target);
        } else {
          element.target.classList.remove('is-erevealed'); //element.target.dispatchEvent(erevealEvent);
          //self.unobserve(element.target);
        }
      });
    }, observerConfig);
    erevealEls.forEach(function (element) {
      var delay = parseInt(element.dataset.ereveal, 10) || 0; //element.style.transitionDelay = `${0.0625 * delay}s`;

      observer.observe(element);
    });
  },
  getInStickyTop: function getInStickyTop(ele) {
    var with_sticky = document.querySelectorAll('.with-sticky');
    var in_sticky = document.querySelectorAll('.with-sticky.in-sticky:not(.side-sticky)');
    var index = [].indexOf.call(with_sticky, ele);
    var eleTop = 0;

    for (var i = 0; i < in_sticky.length; i++) {
      var in_index = [].indexOf.call(with_sticky, in_sticky[i]);
      var stickyHeight = in_sticky[i].clientHeight;

      if (in_index < index) {
        if (in_sticky[i].querySelector('.with-drop')) {
          var drop = in_sticky[i].querySelector('.with-drop');

          if (this.screenIs == 'isMobile') {
            eleTop += parseInt(stickyHeight + drop.clientHeight);
          } else {
            eleTop += parseInt(stickyHeight);
          }
        } else {
          eleTop += parseInt(stickyHeight);
        }
      }
    }

    return eleTop;
  },
  bindStickyEvent: function bindStickyEvent(condition, ele) {
    var eleTop = this.getInStickyTop(ele);
    var scroTop = window.scrollY || document.documentElement.scrollTop;

    if (condition) {
      ele.classList.add('sticky-fixed');
      this.setStickyElementTop(ele, eleTop);
    } else {
      if (this.checkNavigationSection() && this.checkInPageNav()) {
        var breadcrumbs = document.querySelector('.Breadcrumbs');
        var gapH = breadcrumbs != null ? this.settings.headerFixedHeight + breadcrumbs.clientHeight : this.settings.headerFixedHeight;

        if (ele.classList.contains('NavigationSection') && scroTop < gapH) {
          //up to shynav position, remove NavigationSection fixed, show shynav.
          if (ele.dataset.direction == 'up') {
            ele.classList.remove('sticky-fixed');
            ele.style.top = '0';
            document.querySelector(this.settings.headerFixedFlag).style.top = '0';
          }
        } else {
          if (!ele.classList.contains('NavigationSection')) {
            ele.classList.remove('sticky-fixed');
            ele.style.top = '0';
          }

          this.checkStickyElementTop(ele, eleTop);
        }
      } else {
        ele.classList.remove('sticky-fixed');
        ele.style.top = '0';
      }
    }
  },
  bindStickySidebarEvent: function bindStickySidebarEvent(options) {
    //debugger;
    var eleTop = options.overlap ? 0 : this.getInStickyTop(options.element);
    var scroTop = window.scrollY || document.documentElement.scrollTop;

    if (options.condition) {
      //To Sticky 
      options.element.classList.add('sticky-fixed');

      if (!options.isLong) {
        //When sidebar content override window visible height.
        this.setStickyElementTop(options.element, eleTop);
      } else {
        //debugger;
        var topFlag = options.element.querySelector('.top-flag');
        var bottomFlag = options.element.querySelector('.bottom-flag');
        var top_bottom_ele = options.element.querySelector('.top-bottom');
        var scrollbarHeight = parseInt(window.innerHeight * (window.innerHeight / document.body.offsetHeight));

        if (options.direction == 'down') {
          topFlag.classList.remove('is-erevealed');

          if (bottomFlag && !bottomFlag.classList.contains('is-erevealed')) {
            var gap = scroTop - options.startTop;

            if (options.element.getAttribute('data-stickyBottom') != null) {
              //Scroll Down After Scoll Up.
              var stickyBottom = parseInt(options.element.getAttribute('data-stickyBottom'));

              if (gap > stickyBottom) {
                var currentTop = parseInt(options.element.style.top.slice(0, options.element.style.top.length - 2)) || 0;
                gap = currentTop - options.scrollGap;
              } else {
                gap = stickyBottom;
              }

              options.element.style.top = gap + 'px';
            } else {
              //Initial Scroll Down.
              options.element.style.top = -gap + 'px';
            }
          } else {
            //Set stickyBottom value
            var currentTop = parseInt(options.element.style.top.slice(0, options.element.style.top.length - 2)) || 0;

            if (options.element.getAttribute('data-stickyBottom') == null) {
              options.element.setAttribute('data-stickyBottom', currentTop);
            }
          }
        } else {
          //Scroll Up
          bottomFlag.classList.remove('is-erevealed');

          if (scroTop > options.startTop) {
            var currentTop = parseInt(options.element.style.top.slice(0, options.element.style.top.length - 2)) || 0;
            var gap = currentTop - options.scrollGap;
            var stickyTop = this.settings.headerFixedHeight + eleTop;

            if (gap > stickyTop) {
              gap = stickyTop;
            }

            options.element.style.top = gap + 'px';
          }
        }
      }
    } else {
      if (scroTop < options.startTop) {
        //Remove Sticky when to start.
        options.element.classList.remove('sticky-fixed');
        options.element.style.top = '0';
      } else {
        //Sticky up when to end.
        if (!options.isLong) {
          var gap = scroTop - parseInt(options.element.getAttribute('data-stickyEnd'));
          options.element.style.top = -gap + 'px';
        } else {
          var currentTop = parseInt(options.element.style.top.slice(0, options.element.style.top.length - 2)) || 0;
          var gap = currentTop - options.scrollGap;
          options.element.style.top = gap + 'px';
        }
      }
    }
  },
  updateStickyElements: function updateStickyElements() {
    var _this = this;

    var with_sticky = document.querySelectorAll('.with-sticky');
    with_sticky.forEach(function (item) {
      var eleTop = _this.getInStickyTop(item);

      if (_this.checkElementSticky(item)) {
        _this.setStickyElementTop(item, eleTop);
      }
    });
  },
  checkStickyElementTop: function checkStickyElementTop(ele, eleTop) {
    var scroTop = window.scrollY || document.documentElement.scrollTop;

    if (ele.classList.contains('NavigationSection')) {
      var endTop = parseInt(ele.getAttribute('data-stickyEnd'));

      if (ele.dataset.direction == 'up') {
        //up
        //For page with both NavigationSection and InPageNav
        //when up, skynav hide, NavigationSection will top
        //ele.removeAttribute('data-stickyEnd');
        ele.style.top = '0px';
      }
    } else {
      if (document.querySelector('.NavigationSection').dataset.direction == 'up') {
        if (this.checkElementSticky(ele)) {
          ele.style.top = parseInt(ele.style.top) + this.getNavigationSectionHeight() + 'px';
        }
      }
    }
  }
}, _defineProperty(_CustomUtil, "getAllStickyTop", function getAllStickyTop() {
  var allTop = 0;
  var in_sticky_active = document.querySelectorAll('.with-sticky.in-sticky.sticky-fixed:not(.side-sticky)');
  in_sticky_active.forEach(function (isa) {
    allTop += isa.clientHeight;
  });

  if (document.body.dataset.direction == 'up') {
    allTop += this.settings.headerFixedHeight;
  }

  return allTop;
}), _defineProperty(_CustomUtil, "getStickyMaxTop", function getStickyMaxTop() {
  var body = document.body,
      html = document.documentElement;
  var height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
  var footerHeight = document.querySelector('.Footer') ? document.querySelector('.Footer').clientHeight : 0;
  var gap = this.settings.headerFixedHeight + 48;
  var maxTop = height - footerHeight - this.getAllStickyTop();
  return maxTop;
}), _defineProperty(_CustomUtil, "checkElementSticky", function checkElementSticky(ele) {
  if (ele && ele.classList.contains('sticky-fixed')) {
    return true;
  } else {
    return false;
  }
}), _defineProperty(_CustomUtil, "setStickyElementTop", function setStickyElementTop(ele, eleTop) {
  var endTop = parseInt(ele.getAttribute('data-stickyEnd'));
  var scroTop = window.scrollY || document.documentElement.scrollTop;
  var scroGap = parseInt(window.innerHeight * (window.innerHeight / document.body.offsetHeight));
  var gap = scroTop - endTop;

  if (this.settings.headerStatus == 2) {
    //show nav
    ele.style.top = this.settings.headerFixedHeight + eleTop + 'px';
  } else if (this.settings.headerStatus == 1) {
    //show part
    ele.style.top = this.settings.headerFixedHeight + this.settings.headerTop + eleTop + 'px';
  } else {
    //not show 
    ele.style.top = eleTop + 0 + 'px';
  }

  if (this.checkNavigationSection() && this.checkInPageNav()) {
    if (document.querySelector('.NavigationSection').dataset.direction == 'up') {
      //When not fetch the shynav position
      var breadcrumbs = document.querySelector('.Breadcrumbs');
      var gapHeight = breadcrumbs != null ? this.settings.headerFixedHeight + breadcrumbs.clientHeight : this.settings.headerFixedHeight;

      if (scroTop > gapHeight) {
        ele.style.top = parseInt(ele.style.top) - this.settings.headerFixedHeight + 'px'; // + this.getNavigationSectionHeight()) + 'px';
      }
    }
  }

  if (document.querySelector('body').dataset.direction == 'up' || scroTop < endTop) {
    // up 
    if (document.querySelector('body').dataset.direction == 'up' && scroTop > endTop) {
      if (ele.classList.contains('LongFormContentCover-sidebar')) {
        if (this.screenIs == 'isLaptop') {
          this.setStickyElementEndTop(ele, eleTop, gap);
        }
      }
    } else {//debugger;
    }
  } else {
    //down
    if (this.screenIs == 'isLaptop') {
      this.setStickyElementEndTop(ele, eleTop, gap);
    }

    if (this.checkNavigationSection() && this.checkInPageNav()) {
      //For page with both NavigationSection and InPageNav
      //when down, NavigationSection will hide
      if (!ele.classList.contains('NavigationSection') && this.checkElementSticky(document.querySelector('.InPageNav'))) {
        ele.style.top = parseInt(ele.style.top) - this.getNavigationSectionHeight() + 'px';
      } else {
        this.setStickyElementEndTop(ele, eleTop, gap);
      }
    }
  }
}), _defineProperty(_CustomUtil, "setStickyElementEndTop", function setStickyElementEndTop(ele, eleTop, gap) {
  if (this.settings.headerStatus == 2) {
    ele.style.top = this.settings.headerFixedHeight + eleTop - gap + 'px';
  } else if (this.settings.headerStatus == 1) {
    ele.style.top = this.settings.headerFixedHeight + this.settings.headerTop + eleTop - gap + 'px';
  } else {
    ele.style.top = eleTop + 0 - gap + 'px';
  }
}), _defineProperty(_CustomUtil, "getStyle", function getStyle(ele) {
  return window.getComputedStyle(ele);
}), _defineProperty(_CustomUtil, "getEvent", function getEvent(event) {
  return event ? event : window.event;
}), _defineProperty(_CustomUtil, "getTarget", function getTarget(event) {
  return event.target || event.srcElement;
}), _defineProperty(_CustomUtil, "preventDefault", function preventDefault(event) {
  if (event.preventDefault) {
    event.preventDefault();
  } else {
    event.returnValue = false;
  }
}), _defineProperty(_CustomUtil, "stopPropagation", function stopPropagation(event) {
  if (event.stopPropagation) {
    event.stopPropagation();
  } else {
    event.cacelBubble = true;
  }
}), _defineProperty(_CustomUtil, "addHandler", function addHandler(element, type, handler) {
  if (element.addEventListener) {
    element.addEventListener(type, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent('on' + type, handler);
  } else {
    element['on' + type] = handler;
  }
}), _defineProperty(_CustomUtil, "removeHandler", function removeHandler(element, type, handler) {
  if (element.removeEventListener) {
    element.removeEventListener(type, handler, false);
  } else if (element.detachEvent) {
    element.detachEvent('on' + type, handler);
  } else {
    element['on' + type] = null;
  }
}), _defineProperty(_CustomUtil, "isLocalhost", function isLocalhost() {
  if (document.domain == 'localhost' && document.location.pathname == '/iframe.html') {
    return true;
  } else {
    return false;
  }
}), _defineProperty(_CustomUtil, "initCheckScreen", function initCheckScreen() {
  var check = document.querySelector('.check-screen');

  if (check == null) {
    var node = document.createElement('div');
    node.className = 'check-screen';
    var body = document.querySelector('body');
    body.appendChild(node);
  }

  check = document.querySelector('.check-screen');
  var checkStyle = window.getComputedStyle(check, null);
  var sNav = document.querySelector('.SecondaryNav');

  if (checkStyle.content == '"laptop"') {
    this.screenIs = 'isLaptop';
  } else if (checkStyle.content == '"tablet"') {
    this.screenIs = 'isTablet';
  } else if (checkStyle.content == '"mobile"') {
    this.screenIs = 'isMobile';
  } else {
    if (sNav && window.getComputedStyle(sNav, null).display == 'none') {
      this.screenIs = 'isMobile';
    } else {
      this.screenIs = 'isLaptop';
    }
  }

  var body = document.querySelector('body');
  body.setAttribute('data-viewport', this.screenIs);
}), _defineProperty(_CustomUtil, "setSameBoxElementHeight", function setSameBoxElementHeight(box, ele) {
  var tallest = 0;
  var boxes = document.querySelectorAll(box);

  if (boxes && boxes.length > 0) {
    boxes.forEach(function (item) {
      var element = item.querySelector(ele);

      if (element) {
        element.style.height = 'auto'; // reset height in case an empty div has been populated

        if (element.clientHeight > tallest) {
          tallest = element.clientHeight;
        }
      }
    });
  }

  var items = document.querySelectorAll(box + ' ' + ele);

  if (items && items.length > 0) {
    items.forEach(function (item) {
      item.style.height = tallest + 'px';
    });
  }
}), _defineProperty(_CustomUtil, "setSameRowElementHeight", function setSameRowElementHeight(row, box, ele) {
  var rows = document.querySelectorAll(row);

  if (rows && rows.length > 0) {
    rows.forEach(function (rowItem) {
      var tallest = 0;
      var boxes = rowItem.querySelectorAll(box);

      if (boxes && boxes.length > 0) {
        boxes.forEach(function (item) {
          var element = item.querySelector(ele);

          if (element) {
            element.style.height = 'auto'; // reset height in case an empty div has been populated

            if (element.clientHeight > tallest) {
              tallest = element.clientHeight;
            }
          }
        });
      }

      var items = rowItem.querySelectorAll(box + ' ' + ele);

      if (items && items.length > 0) {
        items.forEach(function (item) {
          item.style.height = tallest + 'px';
        });
      }
    });
  }
}), _defineProperty(_CustomUtil, "setSameRowBoxHeight", function setSameRowBoxHeight(row, box) {
  document.querySelectorAll(row).forEach(function (rowItem) {
    var tallest = 0;
    rowItem.querySelectorAll(box).forEach(function (item) {
      var element = item;
      element.style.height = 'auto'; // reset height in case an empty div has been populated

      if (element.clientHeight > tallest) {
        tallest = element.clientHeight;
      }
    });
    rowItem.querySelectorAll(box).forEach(function (item) {
      item.style.height = tallest + 'px';
    });
  });
}), _defineProperty(_CustomUtil, "setColumnCellHeight", function setColumnCellHeight(column, row, ele) {
  if (column && column.length > 0) {
    var length = column[0].querySelectorAll(row).length;
    var eleLength = 1;

    if (ele && column[0].querySelectorAll(ele).length > 0) {
      eleLength = column[0].querySelectorAll(ele).length;
    }

    for (var s = 0; s < eleLength; s++) {
      //var e_tallest = 0;
      for (var i = 0; i < length; i++) {
        var c_tallest = 0;
        var e_tallest = 0;

        for (var j = 0; j < column.length; j++) {
          var element;
          var elements;

          if (ele) {
            element = column[j].querySelectorAll(row)[i].querySelectorAll(ele)[s];

            if (element != null) {
              element.style.height = 'auto';

              if (element.clientHeight > e_tallest) {
                e_tallest = element.clientHeight;
              }
            }
          }

          var cell = column[j].querySelectorAll(row)[i];
          cell.style.height = 'auto';

          if (cell.clientHeight > c_tallest) {
            c_tallest = cell.clientHeight; //For TableFeatureComparison

            if (cell.querySelector('.col-label-placeholder') && cell.classList.contains('cell-section')) {
              var placeholderHeight = cell.querySelector('.col-label-placeholder').clientHeight;
              c_tallest = cell.clientHeight + placeholderHeight;
            }
          }
        }

        for (var k = 0; k < column.length; k++) {
          var element;

          if (ele) {
            element = column[k].querySelectorAll(row)[i].querySelectorAll(ele)[s];

            if (element != null) {
              element.style.height = e_tallest + 'px';
            }
          }

          var cell = column[k].querySelectorAll(row)[i];
          cell.style.height = c_tallest + 'px'; //For TableFeatureComparison

          if (cell.querySelector('.col-label-placeholder')) {
            var cellPlaceholder = column[1].querySelectorAll(row)[i];
            var placeholderHeight = cellPlaceholder.querySelector('.col-label-placeholder').clientHeight;

            if (cell.querySelector('.col-value')) {
              cell.querySelector('.col-value').style.marginTop = placeholderHeight + 16 + 'px';
            }
          }
        }
      }
    }
  }
}), _defineProperty(_CustomUtil, "checkStickyPosition", function checkStickyPosition(container) {
  var offsetTop = container.offsetTop;

  if (container != null && container.closest('.ContentLayoutBackground') != null) {
    offsetTop += container.closest('.ContentLayoutBackground').offsetTop;
  }

  return offsetTop;
}), _defineProperty(_CustomUtil, "checkHashForVS", function checkHashForVS() {
  var hashStr = document.location.hash.slice(1);
  var hashTarget = document.querySelector('[data-hash="' + hashStr + '"]');

  if (hashTarget && hashTarget.closest('.VerticalSliderNew')) {
    return true;
  } else {
    return false;
  }
}), _CustomUtil);
/* harmony default export */ var utilities_CustomUtil = (CustomUtil);
;// CONCATENATED MODULE: ./stories/js/utilities/commonFuc.js

var shyNav = document.querySelector('[data-shy-nav]');
var isshyNavSticky = false;
var inPageNav = document.querySelector('.InPageNav');
var isinPageNavSticky = false;
var container;

if (inPageNav) {
  container = inPageNav;
} else {
  container = shyNav;
}

var offTop;
var hashTargetTop;
var reload = false;
var hashStr;
var hashTarget;
hashStr = document.location.hash.slice(1);
hashTarget = document.getElementById(hashStr);
window.addEventListener("load", function (e) {
  e.preventDefault();

  if (hashStr && hashTarget) {
    setTimeout(function () {
      //debugger;
      updateScrollPositionForOutHash2(container, hashTarget);
    }, 500);
  }
});
document.addEventListener("DOMContentLoaded", function (e) {
  e.preventDefault();

  if (hashStr && hashTarget) {
    //window.scrollTo(0, 0);
    offTop = container.offsetTop;
    hashTargetTop = hashTarget.offsetTop; //debugger;

    if (sessionStorage.getItem('reload-url') != null) {
      if (window.location.href == sessionStorage.getItem('reload-url')) {
        reload = true;
      } else {
        reload = false;
      }
    }
  }
});
window.addEventListener("beforeunload", function (e) {
  //debugger;
  sessionStorage.setItem('reload-url', window.location.href);
});
window.addEventListener('hashchange', function (e) {
  //debugger;
  e.preventDefault();
  hashStr = document.location.hash.slice(1);
  hashTarget = document.getElementById(hashStr);

  if (container && inPageNav == null) {
    if (hashTarget) {
      setTimeout(function () {
        //debugger;
        updateScrollPositionForInHash(container, hashTarget);
      }, 500);
    }
  }
}, false);

function updateScrollPositionForInHash(container, hashTarget) {
  var eleTop = utilities_CustomUtil.getInStickyTop(container);
  utilities_CustomUtil.updateSettings();
  hashTargetTop = hashTarget.offsetTop;
  var scrollTo = hashTargetTop; //debugger;

  if (utilities_CustomUtil.settings.headerStatus != 0) {
    scrollTo = hashTargetTop - eleTop - utilities_CustomUtil.settings.headerFixedHeight;
  }

  window.scrollTo(0, scrollTo);
}

function updateScrollPositionForOutHash(container, hashTarget) {
  var eleTop = utilities_CustomUtil.getInStickyTop(container);
  utilities_CustomUtil.updateSettings();
  offTop = container.offsetTop;
  var scrollTo = hashTargetTop; //debugger;

  if (hashTargetTop > offTop) {
    if (inPageNav) {
      scrollTo = hashTargetTop - 2 * container.clientHeight; //- CustomUtil.settings.headerFixedHeight

      if (!reload) {
        scrollTo = hashTargetTop - 2 * container.clientHeight - utilities_CustomUtil.settings.headerFixedHeight;
      }
    } else {
      scrollTo = hashTargetTop; //- CustomUtil.settings.headerFixedHeight;
    }
  } else {
    scrollTo = hashTargetTop; //- CustomUtil.settings.headerFixedHeight;
  }

  window.scrollTo(0, scrollTo);
  setTimeout(function () {
    //debugger;
    var shyTop = utilities_CustomUtil.getInStickyTop(shyNav);

    if (reload) {
      if (utilities_CustomUtil.settings.headerStatus != 0) {
        scrollTo -= utilities_CustomUtil.settings.headerFixedHeight;
        window.scrollTo(0, scrollTo);
      }
    }
  }, 500);
}

function updateScrollPositionForOutHash2(container, hashTarget) {
  //debugger;
  var scroTop = window.scrollY || document.documentElement.scrollTop;
  var scrollTo = hashTargetTop; //scroTop;

  var eleTop = utilities_CustomUtil.getInStickyTop(container);

  if (utilities_CustomUtil.settings.headerStatus != 0 && inPageNav == null) {
    scrollTo = scroTop - utilities_CustomUtil.settings.headerFixedHeight;
  }

  if (container.classList.contains('sticky-fixed')) {
    scrollTo = scroTop - utilities_CustomUtil.settings.headerFixedHeight - container.clientHeight;
    ;
  }

  window.scrollTo(0, scrollTo);
}
;// CONCATENATED MODULE: ./stories/js/components/Button.js
function Button() {
  var NAME = "button-".concat(Math.random());
  console.log(NAME);
}

/* harmony default export */ var components_Button = (Button);
;// CONCATENATED MODULE: ./stories/js/components/Eyebrow.js
function Eyebrow() {
  console.log('Eyebrow');
}

/* harmony default export */ var components_Eyebrow = (Eyebrow);
;// CONCATENATED MODULE: ./stories/js/components/Card.js
function Card() {
  var NAME = "card-".concat(Math.random());
  console.log(NAME);
}

/* harmony default export */ var components_Card = (Card);
;// CONCATENATED MODULE: ./node_modules/micromodal/dist/micromodal.es.js
function e(e,t){for(var o=0;o<t.length;o++){var n=t[o];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function t(e){return function(e){if(Array.isArray(e))return o(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return o(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return o(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var o=0,n=new Array(t);o<t;o++)n[o]=e[o];return n}var n,i,a,r,s,l=(n=["a[href]","area[href]",'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',"select:not([disabled]):not([aria-hidden])","textarea:not([disabled]):not([aria-hidden])","button:not([disabled]):not([aria-hidden])","iframe","object","embed","[contenteditable]",'[tabindex]:not([tabindex^="-"])'],i=function(){function o(e){var n=e.targetModal,i=e.triggers,a=void 0===i?[]:i,r=e.onShow,s=void 0===r?function(){}:r,l=e.onClose,c=void 0===l?function(){}:l,d=e.openTrigger,u=void 0===d?"data-micromodal-trigger":d,f=e.closeTrigger,h=void 0===f?"data-micromodal-close":f,v=e.openClass,g=void 0===v?"is-open":v,m=e.disableScroll,b=void 0!==m&&m,y=e.disableFocus,p=void 0!==y&&y,w=e.awaitCloseAnimation,E=void 0!==w&&w,k=e.awaitOpenAnimation,M=void 0!==k&&k,A=e.debugMode,C=void 0!==A&&A;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),this.modal=document.getElementById(n),this.config={debugMode:C,disableScroll:b,openTrigger:u,closeTrigger:h,openClass:g,onShow:s,onClose:c,awaitCloseAnimation:E,awaitOpenAnimation:M,disableFocus:p},a.length>0&&this.registerTriggers.apply(this,t(a)),this.onClick=this.onClick.bind(this),this.onKeydown=this.onKeydown.bind(this)}var i,a,r;return i=o,(a=[{key:"registerTriggers",value:function(){for(var e=this,t=arguments.length,o=new Array(t),n=0;n<t;n++)o[n]=arguments[n];o.filter(Boolean).forEach((function(t){t.addEventListener("click",(function(t){return e.showModal(t)}))}))}},{key:"showModal",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(this.activeElement=document.activeElement,this.modal.setAttribute("aria-hidden","false"),this.modal.classList.add(this.config.openClass),this.scrollBehaviour("disable"),this.addEventListeners(),this.config.awaitOpenAnimation){var o=function t(){e.modal.removeEventListener("animationend",t,!1),e.setFocusToFirstNode()};this.modal.addEventListener("animationend",o,!1)}else this.setFocusToFirstNode();this.config.onShow(this.modal,this.activeElement,t)}},{key:"closeModal",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=this.modal;if(this.modal.setAttribute("aria-hidden","true"),this.removeEventListeners(),this.scrollBehaviour("enable"),this.activeElement&&this.activeElement.focus&&this.activeElement.focus(),this.config.onClose(this.modal,this.activeElement,e),this.config.awaitCloseAnimation){var o=this.config.openClass;this.modal.addEventListener("animationend",(function e(){t.classList.remove(o),t.removeEventListener("animationend",e,!1)}),!1)}else t.classList.remove(this.config.openClass)}},{key:"closeModalById",value:function(e){this.modal=document.getElementById(e),this.modal&&this.closeModal()}},{key:"scrollBehaviour",value:function(e){if(this.config.disableScroll){var t=document.querySelector("body");switch(e){case"enable":Object.assign(t.style,{overflow:""});break;case"disable":Object.assign(t.style,{overflow:"hidden"})}}}},{key:"addEventListeners",value:function(){this.modal.addEventListener("touchstart",this.onClick),this.modal.addEventListener("click",this.onClick),document.addEventListener("keydown",this.onKeydown)}},{key:"removeEventListeners",value:function(){this.modal.removeEventListener("touchstart",this.onClick),this.modal.removeEventListener("click",this.onClick),document.removeEventListener("keydown",this.onKeydown)}},{key:"onClick",value:function(e){(e.target.hasAttribute(this.config.closeTrigger)||e.target.parentNode.hasAttribute(this.config.closeTrigger))&&(e.preventDefault(),e.stopPropagation(),this.closeModal(e))}},{key:"onKeydown",value:function(e){27===e.keyCode&&this.closeModal(e),9===e.keyCode&&this.retainFocus(e)}},{key:"getFocusableNodes",value:function(){var e=this.modal.querySelectorAll(n);return Array.apply(void 0,t(e))}},{key:"setFocusToFirstNode",value:function(){var e=this;if(!this.config.disableFocus){var t=this.getFocusableNodes();if(0!==t.length){var o=t.filter((function(t){return!t.hasAttribute(e.config.closeTrigger)}));o.length>0&&o[0].focus(),0===o.length&&t[0].focus()}}}},{key:"retainFocus",value:function(e){var t=this.getFocusableNodes();if(0!==t.length)if(t=t.filter((function(e){return null!==e.offsetParent})),this.modal.contains(document.activeElement)){var o=t.indexOf(document.activeElement);e.shiftKey&&0===o&&(t[t.length-1].focus(),e.preventDefault()),!e.shiftKey&&t.length>0&&o===t.length-1&&(t[0].focus(),e.preventDefault())}else t[0].focus()}}])&&e(i.prototype,a),r&&e(i,r),o}(),a=null,r=function(e){if(!document.getElementById(e))return console.warn("MicroModal: Seems like you have missed %c'".concat(e,"'"),"background-color: #f8f9fa;color: #50596c;font-weight: bold;","ID somewhere in your code. Refer example below to resolve it."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<div class="modal" id="'.concat(e,'"></div>')),!1},s=function(e,t){if(function(e){e.length<=0&&(console.warn("MicroModal: Please specify at least one %c'micromodal-trigger'","background-color: #f8f9fa;color: #50596c;font-weight: bold;","data attribute."),console.warn("%cExample:","background-color: #f8f9fa;color: #50596c;font-weight: bold;",'<a href="#" data-micromodal-trigger="my-modal"></a>'))}(e),!t)return!0;for(var o in t)r(o);return!0},{init:function(e){var o=Object.assign({},{openTrigger:"data-micromodal-trigger"},e),n=t(document.querySelectorAll("[".concat(o.openTrigger,"]"))),r=function(e,t){var o=[];return e.forEach((function(e){var n=e.attributes[t].value;void 0===o[n]&&(o[n]=[]),o[n].push(e)})),o}(n,o.openTrigger);if(!0!==o.debugMode||!1!==s(n,r))for(var l in r){var c=r[l];o.targetModal=l,o.triggers=t(c),a=new i(o)}},show:function(e,t){var o=t||{};o.targetModal=e,!0===o.debugMode&&!1===r(e)||(a&&a.removeEventListeners(),(a=new i(o)).showModal())},close:function(e){e?a.closeModalById(e):a.closeModal()}});"undefined"!=typeof window&&(window.MicroModal=l);/* harmony default export */ var micromodal_es = (l);

;// CONCATENATED MODULE: ./stories/js/components/FindRetailerModal.js


function FindRetailerModal() {
  console.log('Micromodal FindRetailerModal');
}

FindRetailerModal.prototype.init = function (modal, tiggerObj) {
  if (tiggerObj.currentTarget.dataset.micromodalTrigger.indexOf('whereToBuy') != -1) {
    var sku = tiggerObj.currentTarget.dataset.model;
    var country = tiggerObj.currentTarget.dataset.country;
    var category = tiggerObj.currentTarget.dataset.category;
    var isexternal = tiggerObj.currentTarget.dataset.isexternal;
    var site = tiggerObj.currentTarget.dataset.site;
    var locale = tiggerObj.currentTarget.dataset.locale;
    var buynowlabel = tiggerObj.currentTarget.dataset.buynowlabel;

    if (buynowlabel === undefined) {
      buynowlabel = 'Buy Now';
    }

    if (!utilities_CustomUtil.isLocalhost()) {
      resetCountry(country);
      getProductInfo(sku, locale.toLowerCase(), site);
      buildBlueBoard(sku, locale, country, category, isexternal, site, buynowlabel);

      if (wheretobuypopup != undefined && !wheretobuypopup) {
        countryChange(sku, locale, category, isexternal, site, buynowlabel);
        wheretobuypopup = true;
      }
    }
  }
};

var getWwwDomain = function getWwwDomain() {
  var wwwHost = document.location.host;
  var wwwDomain = 'www.seagate.com';

  if (wwwHost.indexOf('wwwedit') != -1) {
    wwwDomain = 'wwwedit.seagate.com';
  } else if (wwwHost.indexOf('wwwstgedit') != -1) {
    wwwDomain = 'wwwstgedit.seagate.com';
  } else if (wwwHost.indexOf('wwwstg') != -1) {
    wwwDomain = 'wwwstg.seagate.com';
  }

  return wwwDomain;
};

var resetCountry = function resetCountry(country) {
  document.querySelector('#wheretobuycontent').innerHTML = '';
  document.querySelector('#wheretobuyloading').classList.remove('hide');
  var countryselector = document.querySelector('#wheretobuycountriesoptions');
  countryselector.value = country;
};

var getProductInfo = function getProductInfo(sku, locale, brand) {
  var productInfoDiv = document.querySelector('.product-info.wheretobuy');
  var skuName = "skuName_".concat(locale.split('_')[0]);
  var wwwDomain = getWwwDomain();
  var productQuery = "/ww/solrQueryResponseRetrieval?q=*&collection=product&wt=json&indent=true&start=0&rows=1&omitHeader=true&fq=seaLocale:".concat(locale, "&fq=brand:").concat(brand, "&fq=modelNumber:").concat(sku, "&fl=modelNumber,imagePath,").concat(skuName);
  console.log(productQuery);
  var html = '';
  productInfoDiv.innerHTML = html;
  fetch(productQuery).then(function (response) {
    return response.json();
  }).then(function (data) {
    var docs = data.response.docs;
    docs.forEach(function (item) {
      html = "\n\t\t\t\t\t<img src=\"".concat(item.imagePath, "\">\n\t\t\t\t\t<h3 class=\"product-title\">").concat(item[skuName], "</h3> \n\t\t\t\t\t<p class=\"copy product-description\"></p>\n                    <p class=\"copy product-model\">").concat(productInfoDiv.dataset.modellabel).concat(item.modelNumber, "</p>\n                    <a class=\"product-change\" data-micromodal-close>").concat(productInfoDiv.dataset.changeproduct, "</a>\n\t\t\t\t");
      productInfoDiv.innerHTML = html;
    });
  });
};

var countryChange = function countryChange(sku, locale, category, isexternal, site, buynowlabel) {
  var countryselector = document.querySelector('#wheretobuycountriesoptions');
  countryselector.addEventListener('change', function (event) {
    var selectedCountry = event.target.selectedOptions[0].value;
    document.querySelector('#wheretobuycontent').innerHTML = '';
    document.querySelector('#wheretobuyloading').classList.remove('hide');
    getBlueBoardRetailers(sku, locale, selectedCountry, category, isexternal, site, buynowlabel);
  });
};

var showPriceInBlueboard = function showPriceInBlueboard(is_blueboard_emea_country, is_blueboard_locale, country, rcLocaleJS) {
  var showPrice = false;
  var isEmeaCountry = false;
  var isBlueBoardEmeaCountry = is_blueboard_emea_country.split(',');
  var isBlueBoardLocales = is_blueboard_locale.split(',');

  for (var i = 0; i < isBlueBoardEmeaCountry.length; i++) {
    if (country == isBlueBoardEmeaCountry[i]) {
      isEmeaCountry = true;
      break;
    }
  }

  if (!isEmeaCountry) {
    for (var _i = 0; _i < isBlueBoardLocales.length; _i++) {
      if (rcLocaleJS == isBlueBoardLocales[_i]) {
        showPrice = true;
        break;
      }
    }
  }

  return showPrice;
};

var buildBlueBoard = function buildBlueBoard(sku, locale, country, categories, isexternal, site, buynowlabel) {
  getBlueBoardRetailers(sku, locale, country, categories, isexternal, site, buynowlabel);
};

var getBlueBoardRetailers = function getBlueBoardRetailers(sku, locale, country, categories, isexternal, site, buynowlabel) {
  getWTBResellers(sku, country, categories, isexternal, site, buynowlabel);
  /*
  let hasContent = false;
  let wwwDomain = getWwwDomain();
  let bbQueryBase = '/ww/solrQueryResponseRetrieval?q=*&collection=blueboard&wt=json&indent=true&start=0&rows=1000&omitHeader=true&fl=is_seagate,is_lacie,is_pdp,is_pdp_lacie,logo_url_pdp,is_blueboard,country,url,product_url,product_sku,current_price,currency_code,retailer_name&sort=current_price+asc';
  let bbQuery = bbQueryBase + '&fq=country:' + country;
  bbQuery = bbQuery + '&fq=product_sku:' + sku;
  if ('lacie' == site) {
    bbQuery = bbQuery + '&fq=((is_lacie:true AND is_pdp_lacie:true AND is_blueboard:lacie) OR is_blueboard:both)';
  } else {
    bbQuery = bbQuery + '&fq=((is_seagate:true AND is_pdp:true AND is_blueboard:seagate) OR is_blueboard:both)';
  }
  console.log('bbQuery ' + bbQuery);
  let isBlueBoardEmeaCountry =
    'AT,RO,DE,DZ,BH,CY,EG,IQ,JO,KW,LB,MA,OM,PS,QA,SA,AE,YE,LI,CH,GH,GR,IR,IL,KE,NG,SD,SY,AF,AX,AO,BQ,BA,BW,BV,IO,BG,HR,CW,CZ,DK,em,ER,EE,ET,FO,FK,FI,GM,GE,GI,GB,GL,GD,GG,HU,IS,IE,IM,JE,LV,LS,LR,LT,MK,MW,MT,YT,MD,ME,MS,MZ,NA,NL,AN,NO,PT,RS,SL,SK,SI,SO,ZA,GS,SS,SR,SJ,SZ,SE,TZ,TM,UG,UA,GB,UZ,VG,WF,EH,ZM,ZW,GQ,ES,AL,AD,BE,BJ,BF,BI,CM,CF,TD,KM,CG,CD,CI,DJ,FR,GF,PF,TF,GA,GP,GN,LU,MG,ML,MR,MU,MC,NC,NE,RE,RW,BL,MF,ST,SN,SC,TG,TN,IT,LY,SM,VA,PL,AM,AZ,BY,KZ,KG,RU,TJ,TR';
  let isBlueBoardLocales = 'en_US,en_CA,fr_CA';
  let rcLocaleJS = locale;
  let showPrice = showPriceInBlueboard(isBlueBoardEmeaCountry, isBlueBoardLocales, country, rcLocaleJS);
   fetch(bbQuery)
    .then((response) => response.json())
    .then((data) => {
      console.log(data);
      const docs = data.response.docs;
      console.log(docs);
      let content = '';
      let hasContent = false;
      docs.forEach(function (item) {
        const product_url = item.product_url;
        const current_price = item.current_price;
        const currency_code = item.currency_code;
        const retailer_name = item.retailer_name;
        const img = item.logo_url_pdp;
        const country = item.country;
        const price = new Intl.NumberFormat(country, { style: 'currency', currency: currency_code }).format(
          current_price
        );
        if (showPrice && current_price > 0) {
          hasContent = true;
          content += `
  				<div class="row align-items-center">
                            <div class="col-md d-flex justify-content-center">
                                <a href="${product_url}" title="${retailer_name}" data-reseller="${retailer_name}" target="_blank" class="gtm-wtb-bb">
                                <img src="${img}" alt="${retailer_name}">
                                </a>
                            </div>
                            <div class="col-md d-flex justify-content-center">
                                <a href="${product_url}" class="Button Button-tertiary gtm-wtb-bb" data-reseller="${retailer_name}" target="_blank">
                                <span>${price} <i class="Button-arrow"></i></span>
                                </a>
                            </div>
                        </div>
  			`;
        } else {
          hasContent = true;
          content += `
  				<div class="row align-items-center">
                            <div class="col-md d-flex justify-content-center">
                                <a href="${product_url}" title="${retailer_name}" data-reseller="${retailer_name}" target="_blank" class="gtm-wtb-bb">
                                <img src="${img}" alt="${retailer_name}">
                                </a>
                            </div>
                            <div class="col-md d-flex justify-content-center">
                                <a href="${product_url}" class="Button Button-tertiary gtm-wtb-bb" data-reseller="${retailer_name}" target="_blank">
                                <span>${buynowlabel} <i class="Button-arrow"></i></span>
                                </a>
                            </div>
                        </div>
  			`;
        }
      });
       let findRetailerModal = document.querySelector('#wheretobuycontent');
      findRetailerModal.innerHTML = '';
      if (hasContent) {
        document.querySelector('#wheretobuyloading').classList.add('hide');
        findRetailerModal.classList.remove('no-content');
        findRetailerModal.innerHTML = content;
      } else {
        getWTBResellers(sku, country, categories, isexternal, site, buynowlabel);
      }
    });
    */
};

var getWTBResellers = function getWTBResellers(sku, country, categories, isexternal, site, buynowlabel) {
  var wwwDomain = getWwwDomain();
  var wtbQueryBase = '/ww/solrQueryResponseRetrieval?q=*&collection=wtb&wt=json&indent=true&start=0&rows=1000&omitHeader=true&fl=is_wtblogo_available,is_pdplogo_available,phone,name,logo_url_pdp,logo_url,website,lacie_website,is_external,is_internal,external_drives,internal_drives,lacie_external_drives&sort=wtbnewsortingweigth+asc';
  var wtbQuerySeagatePdp = '&fq=partner_type:Reseller&fq=is_active:true&fq=is_pdp:true&fq=is_seagate:true&fq=!website:%22%22';
  var wtbQueryLaCiePdp = '&fq=partner_type:Reseller&fq=is_active:true&fq=is_pdp_lacie:true&fq=is_lacie:true&fq=!lacie_website:%22%22';
  var wtbQuery = '';
  var wtbCategories = categories;
  var isExternal = isexternal == 'true' ? true : false;

  if ('lacie' == site) {
    wtbQuery = wtbQueryBase + wtbQueryLaCiePdp + '&fq=country:' + country;
  } else {
    wtbQuery = wtbQueryBase + wtbQuerySeagatePdp + '&fq=country:' + country;
  }

  if (wtbCategories != '') {
    var wtbCategoriesArray = wtbCategories.split(',');
    var wtbCategoriesNewArray = [];

    if (isExternal && 'seagate' == site) {
      for (var i = 0; i < wtbCategoriesArray.length; i++) {
        wtbCategoriesNewArray[i] = 'external_drives:"' + wtbCategoriesArray[i] + '"';
      }

      wtbCategories = '(' + wtbCategoriesNewArray.join(' OR ') + ')';
      wtbQuery = wtbQuery + '&fq=' + wtbCategories;
    } else if (!isExternal && 'seagate' == site) {
      for (var _i2 = 0; _i2 < wtbCategoriesArray.length; _i2++) {
        wtbCategoriesNewArray[_i2] = 'internal_drives:"' + wtbCategoriesArray[_i2] + '"';
      }

      wtbCategories = '(' + wtbCategoriesNewArray.join(' OR ') + ')';
      wtbQuery = wtbQuery + '&fq=' + wtbCategories;
    } else if ('lacie' == site) {
      for (var _i3 = 0; _i3 < wtbCategoriesArray.length; _i3++) {
        wtbCategoriesNewArray[_i3] = 'lacie_external_drives:"' + wtbCategoriesArray[_i3] + '"';
      }

      wtbCategories = '(' + wtbCategoriesNewArray.join(' OR ') + ')';
      wtbQuery = wtbQuery + '&fq=' + wtbCategories;
    }
  }

  console.log('wtbQuery ' + wtbQuery);
  fetch(wtbQuery).then(function (response) {
    return response.json();
  }).then(function (data) {
    console.log(data);
    var docs = data.response.docs;
    console.log(docs);
    var content = '';
    var hasContent = false;
    docs.forEach(function (item) {
      var website = item.website.indexOf('http') == 0 ? item.website : 'http://' + item.website;
      var lacie_website = item.lacie_website.indexOf('http') == 0 ? item.lacie_website : 'http://' + item.lacie_website;
      var company_name = item.is_wtblogo_available ? '' : '<span class="wtb-name">' + item.name + '</span>';

      if ('lacie' == site) {
        content += "\n\t\t\t\t\t\t<div class=\"row align-items-center\">\n                            <div class=\"col-md d-flex justify-content-center\">\n                                <a href=\"".concat(lacie_website, "\" title=\"").concat(item.name, "\" data-reseller=\"").concat(item.name, "\" target=\"_blank\" class=\"gtm-wtb\">\n                                <img src=\"").concat(item.logo_url_pdp, "\" alt=\"").concat(item.name, "\">\n                                </a>\n                            </div>\n                            <div class=\"col-md d-flex justify-content-center\">\n                                <a href=\"").concat(lacie_website, "\" class=\"Button Button-tertiary gtm-wtb\" data-reseller=\"").concat(item.name, "\" target=\"_blank\">\n                                <span>").concat(buynowlabel, " <i class=\"Button-arrow\"></i></span>\n                                </a>\n                            </div>\n                        </div>\n\t\t\t\t\t");
        hasContent = true;
      } else if ('seagate' == site) {
        content += "\n\t\t\t\t\t\t<div class=\"row align-items-center\">\n                            <div class=\"col-md d-flex justify-content-center\">\n                                <a href=\"".concat(website, "\" title=\"").concat(item.name, "\" data-reseller=\"").concat(item.name, "\" target=\"_blank\" class=\"gtm-wtb\">\n                                <img src=\"").concat(item.logo_url_pdp, "\" alt=\"").concat(item.name, "\">\n                                </a>\n                            </div>\n                            <div class=\"col-md d-flex justify-content-center\">\n                                <a href=\"").concat(website, "\" class=\"Button Button-tertiary gtm-wtb\" data-reseller=\"").concat(item.name, "\" target=\"_blank\">\n                                <span>").concat(buynowlabel, " <i class=\"Button-arrow\"></i></span>\n                                </a>\n                            </div>\n                        </div>\n\t\t\t\t\t");
        hasContent = true;
      }
    });
    var findRetailerModal = document.querySelector('#wheretobuycontent');
    findRetailerModal.innerHTML = '';

    if (hasContent) {
      document.querySelector('#wheretobuyloading').classList.add('hide');
      findRetailerModal.classList.remove('no-content');
      findRetailerModal.innerHTML = content;
    } else {
      document.querySelector('#wheretobuyloading').classList.add('hide');
      var nocontent = document.querySelector('#nowheretobuycontent');

      if (nocontent === null) {
        nocontent = '<p>Reseller List not Available</p>';
      } else {
        nocontent = nocontent.innerHTML;
      }

      findRetailerModal.innerHTML = nocontent;
      findRetailerModal.classList.add('no-content');
    }
  });
};

/* harmony default export */ var components_FindRetailerModal = (FindRetailerModal);
;// CONCATENATED MODULE: ./stories/js/components/Modal.js




function init() {
  console.log('Micromodal'); // Videos

  var firstScriptTag = document.getElementsByTagName('script')[0];
  var youtubeTag, vimeoTag;
  var videoLinks = document.querySelectorAll("[data-micromodal-trigger]");
  videoLinks.forEach(function (videoLink) {
    var modalId = videoLink.getAttribute("data-micromodal-trigger");

    if (!document.getElementById(modalId)) {
      var videoUrl = videoLink.getAttribute("href");

      if (videoUrl) {
        var videoEmbedUrl = "";
        var videoType = "";
        var videoId = videoLink.getAttribute("data-video-id");

        if (/^https?:\/\/www\.youtube\.com\/.+/.test(videoUrl)) {
          videoType = "youtube";
          videoEmbedUrl = "https://www.youtube.com/embed/";

          if (youtubeTag == undefined) {
            youtubeTag = document.createElement('script');
            youtubeTag.src = "https://www.youtube.com/iframe_api";
            firstScriptTag.parentNode.insertBefore(youtubeTag, firstScriptTag);
          }
        } else if (/^https?:\/\/(www\.)?vimeo\.com\/.+/.test(videoUrl)) {
          videoType = "vimeo";
          videoEmbedUrl = "https://player.vimeo.com/video/";

          if (vimeoTag == undefined) {
            vimeoTag = document.createElement('script');
            vimeoTag.src = "https://player.vimeo.com/api/player.js";
            firstScriptTag.parentNode.insertBefore(vimeoTag, firstScriptTag);
          }
        } else if (/^https?:\/\/v\.qq\.com\/.+/.test(videoUrl)) {
          videoType = "tencent";
          videoEmbedUrl = "https://v.qq.com/txp/iframe/player.html?vid=";
        } else {
          videoType = "file";
          videoEmbedUrl = videoUrl;
        }

        if (videoEmbedUrl != "") {
          videoEmbedUrl += videoId;

          if (videoType == "youtube") {
            videoEmbedUrl += "?enablejsapi=1";
          }

          var modalHTML = "<div class='Modal Modal--video micromodal-slide' id='" + modalId + "' aria-hidden='true' data-video-type='" + videoType + "' data-video-id='" + videoId + "'>" + "<div class='modal__overlay' tabindex='-1' data-micromodal-close>" + "<div class='modal__container u-btlbr-small' role='dialog' aria-modal='true' aria-labelledby='" + modalId + "'>" + "<div class='modal__content'>" + "<div class='modal_body'>" + "<div class='modal-video'>" + "<div><button class='modal__close' aria-label='Close modal' data-micromodal-close></button></div>" + "<div class='modal-video-box'>" + "<iframe id='player-" + modalId + "-" + videoId + "' type='text/html' width='640' height='360' src='" + videoEmbedUrl + "' frameborder='0' allow='autoplay; fullscreen; picture-in-picture'></iframe>" + "</div>" + "</div>" + "</div>" + "</div>" + "</div>" + "</div>" + "</div>";
          document.body.insertAdjacentHTML("beforeend", modalHTML);
        }
      }
    }
  });
  micromodal_es.init({
    awaitCloseAnimation: true,
    onClose: function onClose(modal, targetObj) {
      if (modal.classList.contains('Modal--video')) {
        try {
          var videoId = modal.getAttribute("data-video-id");
          var videoType = modal.getAttribute("data-video-type");
          var iframe = modal.querySelector("iframe");

          if (videoType == "youtube") {
            var player = YT.get(iframe.getAttribute("id"));
            player.stopVideo();
          } else if (videoType == "tencent") {
            iframe.src = iframe.src.replace("&autoplay=true", "");
          } else if (videoType == "vimeo") {
            var player = new Vimeo.Player(iframe);
            player.unload();
          }
        } catch (e) {}
      }
    },
    onShow: function onShow(modal, tiggerObj, eventObj) {
      //console.info(''.concat(modal.id, ' is shown'));
      if (modal.classList.contains('Modal--video')) {
        try {
          var videoId = modal.getAttribute("data-video-id");
          var videoType = modal.getAttribute("data-video-type");
          var iframe = modal.querySelector("iframe");

          if (videoType == "youtube") {
            var player = YT.get(iframe.getAttribute("id"));

            if (player) {
              player.playVideo();
            } else {
              new YT.Player(iframe.getAttribute("id"), {
                events: {
                  'onReady': function onReady(event) {
                    event.target.playVideo();
                  }
                }
              });
            }
          } else if (videoType == "tencent") {
            iframe.src += "&autoplay=true";
          } else if (videoType == "vimeo") {
            var player = new Vimeo.Player(iframe);
            player.play();
          }
        } catch (e) {}
      } else {
        if (tiggerObj.localName == 'body') {
          var findRetailerModal = new components_FindRetailerModal();
          findRetailerModal.init(modal, eventObj);
        }

        if (modal.classList.contains('CardLayoutOverlayCards-modal')) {
          var header = modal.querySelector('.modal__header');
          var content = modal.querySelector('.modal__content');

          if (cu.screenIs == 'isLaptop') {
            content.style.height = 'calc(100vh - ' + header.clientHeight + 'px - 40px)';
          } else {
            content.style.height = 'calc(100vh - ' + header.clientHeight + 'px)';
          }
        }
      }
    }
  });
  var modallinks = document.querySelectorAll('[data-micromodal-trigger]');
  modallinks.forEach(function (element) {
    element.addEventListener('click', function (event) {
      event.preventDefault();
    });
  });
  var cu = utilities_CustomUtil.initSettings();
  cu.initCheckScreen();
}

/* harmony default export */ var Modal = (init);
;// CONCATENATED MODULE: ./stories/js/components/Hash.js


function Hash() {
  console.log('Hash');
  var inPageNav = document.querySelector('.InPageNav');
  var prevScroTop = 0;
  var ticking = false;

  function updateHashScrollPosition(container, target) {
    var eleTop = container ? utilities_CustomUtil.getInStickyTop(container) : 0;
    var top = target.offsetTop;
    utilities_CustomUtil.updateSettings();
    var scrollTo = top;

    if (top > prevScroTop) {
      //down
      if (container) {
        if (container.classList.contains('sticky-fixed')) {
          scrollTo = top - eleTop - container.clientHeight;
        } else {
          scrollTo = top - eleTop - 2 * container.clientHeight;
        }
      } else {
        scrollTo = top - eleTop;
      }
    } else {
      //up
      if (container) {
        if (container.classList.contains('sticky-fixed')) {
          if (!utilities_CustomUtil.checkNavigationSection() && !utilities_CustomUtil.checkInPageNav()) {
            scrollTo = top - eleTop - container.clientHeight - utilities_CustomUtil.settings.headerFixedHeight;
          } else {
            scrollTo = top - eleTop - container.clientHeight - utilities_CustomUtil.settings.headerFixedHeight;
          }
        } else {
          scrollTo = top - eleTop - 2 * container.clientHeight;
        }
      } else {
        scrollTo = top - eleTop - utilities_CustomUtil.settings.headerFixedHeight;
        ;
      }
    }

    if (container) {
      if (container.classList.contains('sticky-fixed')) {
        scrollTo = top - eleTop - container.clientHeight - utilities_CustomUtil.settings.headerFixedHeight;
      }
    }

    var pdp = document.querySelector('.EcomProductDetail');

    if (pdp) {
      var pdpStock = pdp ? pdp.getAttribute("data-stock") : '';
      var pdpStickyHeader = document.querySelector('.EcomProductDetail-header');
      var isMobile = utilities_CustomUtil.screenIs == 'isMobile' ? true : false;
      var pdpStickyHeaderHeight = pdpStickyHeader ? isMobile ? 100 : 74 : 0;

      if (top > prevScroTop) {
        //down
        if (container) {
          if (container.classList.contains('sticky-fixed')) {
            scrollTo = top - eleTop - container.clientHeight;

            if (pdpStock != "out" && pdpStickyHeader) {
              scrollTo -= pdpStickyHeaderHeight;
            }
          } else {
            scrollTo = top - eleTop - 2 * container.clientHeight;

            if (pdpStock != "out" && pdpStickyHeader) {
              scrollTo -= pdpStickyHeaderHeight;
            }
          }
        }
      } else {
        if (pdpStock != "out" && pdpStickyHeader) {
          scrollTo -= pdpStickyHeaderHeight;
        }
      }
    }

    window.scrollTo(0, scrollTo);
  }

  var isIntersecting = false;
  var observerConfig = {
    threshold: 0
  };
  var observer = new IntersectionObserver(function (elements, self) {
    elements.forEach(function (element) {
      if (element.isIntersecting) {
        // Add class and stop watching
        isIntersecting = true;
      } else {
        isIntersecting = false;
      }

      self.unobserve(element.target);
    });
  }, observerConfig);
  var node = document.querySelector('.VerticalSliderNew');

  if (node) {//observer.observe(node);
  }

  function anchorByHash() {
    var container = inPageNav ? inPageNav : null;
    var str = document.location.hash.slice(1);
    var target = document.getElementById(str);

    if (!target) {
      target = document.querySelector('[data-hash="' + str + '"]');

      if (target && target.closest('.VerticalSliderNew')) {
        target = target.closest('.VerticalSliderNew');

        if (!isIntersecting) {//when need to anchor to inner slide
          //updateHashScrollPosition(container, target, true);
        }
      }
    } else {
      setTimeout(function () {
        //debugger;
        updateHashScrollPosition(container, target, true);
      }, 500);
    }
  }

  ; //document.body.classList.add('no-scroll');
  //window.scrollTo(0,0);

  window.addEventListener('scroll', function (e) {
    if (!ticking) {
      window.requestAnimationFrame(function () {
        var scroTop = window.scrollY || document.documentElement.scrollTop;
        prevScroTop = scroTop;
        ticking = false;
      });
      ticking = true;
    }
  });
  window.addEventListener('load', function (e) {
    e.preventDefault();
    setTimeout(function () {
      //debugger; 
      anchorByHash(); //document.body.classList.remove('no-scroll');
    }, 500);
  }, false);
  window.addEventListener('hashchange', function (e) {
    //debugger;
    e.preventDefault();
    anchorByHash();
  }, false);
}

/* harmony default export */ var components_Hash = (Hash);
;// CONCATENATED MODULE: ./stories/js/modules/CardLayout/index.js
function CardLayout() {}

/* harmony default export */ var modules_CardLayout = (CardLayout);
;// CONCATENATED MODULE: ./stories/js/utilities/RevealElements.js
function revealElements() {
  var revealEls = document.querySelectorAll('[data-reveal]');
  var revealEvent = new CustomEvent('isRevealed', {
    detail: {
      isRevealed: true
    }
  });
  var observerConfig = {
    rootMargin: '0px 0px -9% 0px',
    threshold: 0
  };
  var observer = new IntersectionObserver(function (elements, self) {
    elements.forEach(function (element) {
      if (element.isIntersecting) {
        // Add class and stop watching
        element.target.classList.add('is-revealed');
        element.target.dispatchEvent(revealEvent);
        self.unobserve(element.target);
      }
    });
  }, observerConfig);
  revealEls.forEach(function (element) {
    var delay = parseInt(element.dataset.reveal, 10) || 0;
    element.style.transitionDelay = "".concat(0.0625 * delay, "s");
    observer.observe(element);
  });
}
;// CONCATENATED MODULE: ./node_modules/swiper/swiper-bundle.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./node_modules/ssr-window/ssr-window.esm.js
/**
 * SSR Window 3.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: November 9, 2020
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend(target, src) {
    if (target === void 0) { target = {}; }
    if (src === void 0) { src = {}; }
    Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (isObject(src[key]) &&
            isObject(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

var ssrDocument = {
    body: {},
    addEventListener: function () { },
    removeEventListener: function () { },
    activeElement: {
        blur: function () { },
        nodeName: '',
    },
    querySelector: function () {
        return null;
    },
    querySelectorAll: function () {
        return [];
    },
    getElementById: function () {
        return null;
    },
    createEvent: function () {
        return {
            initEvent: function () { },
        };
    },
    createElement: function () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute: function () { },
            getElementsByTagName: function () {
                return [];
            },
        };
    },
    createElementNS: function () {
        return {};
    },
    importNode: function () {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
function getDocument() {
    var doc = typeof document !== 'undefined' ? document : {};
    extend(doc, ssrDocument);
    return doc;
}

var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState: function () { },
        pushState: function () { },
        go: function () { },
        back: function () { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener: function () { },
    removeEventListener: function () { },
    getComputedStyle: function () {
        return {
            getPropertyValue: function () {
                return '';
            },
        };
    },
    Image: function () { },
    Date: function () { },
    screen: {},
    setTimeout: function () { },
    clearTimeout: function () { },
    matchMedia: function () {
        return {};
    },
    requestAnimationFrame: function (callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame: function (id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    },
};
function getWindow() {
    var win = typeof window !== 'undefined' ? window : {};
    extend(win, ssrWindow);
    return win;
}



;// CONCATENATED MODULE: ./node_modules/dom7/dom7.esm.js
/**
 * Dom7 3.0.0
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * https://framework7.io/docs/dom7.html
 *
 * Copyright 2020, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: November 9, 2020
 */


function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/* eslint-disable no-proto */
function makeReactive(obj) {
  var proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get: function get() {
      return proto;
    },
    set: function set(value) {
      proto.__proto__ = value;
    }
  });
}

var Dom7 = /*#__PURE__*/function (_Array) {
  _inheritsLoose(Dom7, _Array);

  function Dom7(items) {
    var _this;

    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
    makeReactive(_assertThisInitialized(_this));
    return _this;
  }

  return Dom7;
}( /*#__PURE__*/_wrapNativeSuper(Array));

function arrayFlat(arr) {
  if (arr === void 0) {
    arr = [];
  }

  var res = [];
  arr.forEach(function (el) {
    if (Array.isArray(el)) {
      res.push.apply(res, arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  var uniqueArray = [];

  for (var i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }

  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, function (match, group) {
    return group.toUpperCase();
  });
}

function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }

  var a = [];
  var res = context.querySelectorAll(selector);

  for (var i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }

  return a;
}

function $(selector, context) {
  var window = getWindow();
  var document = getDocument();
  var arr = [];

  if (!context && selector instanceof Dom7) {
    return selector;
  }

  if (!selector) {
    return new Dom7(arr);
  }

  if (typeof selector === 'string') {
    var html = selector.trim();

    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      var toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      var tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;

      for (var i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);

  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }

  return new Dom7(arrayUnique(arr));
}

$.fn = Dom7.prototype;

function addClass() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList;

    (_el$classList = el.classList).add.apply(_el$classList, classNames);
  });
  return this;
}

function removeClass() {
  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    classes[_key2] = arguments[_key2];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList2;

    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
  });
  return this;
}

function toggleClass() {
  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    classes[_key3] = arguments[_key3];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    classNames.forEach(function (className) {
      el.classList.toggle(className);
    });
  });
}

function hasClass() {
  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    classes[_key4] = arguments[_key4];
  }

  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  return arrayFilter(this, function (el) {
    return classNames.filter(function (className) {
      return el.classList.contains(className);
    }).length > 0;
  }).length > 0;
}

function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs


  for (var i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (var attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }

  return this;
}

function removeAttr(attr) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }

  return this;
}

function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (var i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        for (var propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }

    return this;
  }

  return this;
}

function data(key, value) {
  var el;

  if (typeof value === 'undefined') {
    el = this[0];
    if (!el) return undefined; // Get value

    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }

    var dataKey = el.getAttribute("data-" + key);

    if (dataKey) {
      return dataKey;
    }

    return undefined;
  } // Set value


  for (var i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }

  return this;
}

function removeData(key) {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}

function dataset() {
  var el = this[0];
  if (!el) return undefined;
  var dataset = {}; // eslint-disable-line

  if (el.dataset) {
    for (var dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (var i = 0; i < el.attributes.length; i += 1) {
      var _attr = el.attributes[i];

      if (_attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(_attr.name.split('data-')[1])] = _attr.value;
      }
    }
  }

  for (var key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }

  return dataset;
}

function val(value) {
  if (typeof value === 'undefined') {
    // get value
    var el = this[0];
    if (!el) return undefined;

    if (el.multiple && el.nodeName.toLowerCase() === 'select') {
      var values = [];

      for (var i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }

      return values;
    }

    return el.value;
  } // set value


  for (var _i = 0; _i < this.length; _i += 1) {
    var _el = this[_i];

    if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === 'select') {
      for (var j = 0; j < _el.options.length; j += 1) {
        _el.options[j].selected = value.indexOf(_el.options[j].value) >= 0;
      }
    } else {
      _el.value = value;
    }
  }

  return this;
}

function value(value) {
  return this.val(value);
}

function transform(transform) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }

  return this;
}

function transition(duration) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
  }

  return this;
}

function on() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;

  function handleLiveEvent(e) {
    var target = e.target;
    if (!target) return;
    var eventData = e.target.dom7EventData || [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
      var _parents = $(target).parents(); // eslint-disable-line


      for (var k = 0; k < _parents.length; k += 1) {
        if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
      }
    }
  }

  function handleEvent(e) {
    var eventData = e && e.target ? e.target.dom7EventData || [] : [];

    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }

    listener.apply(this, eventData);
  }

  var events = eventType.split(' ');
  var j;

  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        var event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener: listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        var _event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

        el.dom7LiveListeners[_event].push({
          listener: listener,
          proxyListener: handleLiveEvent
        });

        el.addEventListener(_event, handleLiveEvent, capture);
      }
    }
  }

  return this;
}

function off() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  var eventType = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  if (!capture) capture = false;
  var events = eventType.split(' ');

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      var handlers = void 0;

      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }

      if (handlers && handlers.length) {
        for (var k = handlers.length - 1; k >= 0; k -= 1) {
          var handler = handlers[k];

          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }

  return this;
}

function once() {
  var dom = this;

  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }

  var eventName = args[0],
      targetSelector = args[1],
      listener = args[2],
      capture = args[3];

  if (typeof args[1] === 'function') {
    eventName = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }

  function onceHandler() {
    for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      eventArgs[_key8] = arguments[_key8];
    }

    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);

    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }

  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}

function trigger() {
  var window = getWindow();

  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  var events = args[0].split(' ');
  var eventData = args[1];

  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];

    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];

      if (window.CustomEvent) {
        var evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter(function (data, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }

  return this;
}

function transitionEnd(callback) {
  var dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }

  if (callback) {
    dom.on('transitionend', fireCallBack);
  }

  return this;
}

function animationEnd(callback) {
  var dom = this;

  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('animationend', fireCallBack);
  }

  if (callback) {
    dom.on('animationend', fireCallBack);
  }

  return this;
}

function width() {
  var window = getWindow();

  if (this[0] === window) {
    return window.innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}

function dom7_esm_outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles = this.styles();

      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
    }

    return this[0].offsetWidth;
  }

  return null;
}

function height() {
  var window = getWindow();

  if (this[0] === window) {
    return window.innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}

function dom7_esm_outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles2 = this.styles();

      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
    }

    return this[0].offsetHeight;
  }

  return null;
}

function offset() {
  if (this.length > 0) {
    var window = getWindow();
    var document = getDocument();
    var el = this[0];
    var box = el.getBoundingClientRect();
    var body = document.body;
    var clientTop = el.clientTop || body.clientTop || 0;
    var clientLeft = el.clientLeft || body.clientLeft || 0;
    var scrollTop = el === window ? window.scrollY : el.scrollTop;
    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }

  return null;
}

function hide() {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }

  return this;
}

function show() {
  var window = getWindow();

  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.style.display === 'none') {
      el.style.display = '';
    }

    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }

  return this;
}

function styles() {
  var window = getWindow();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}

function css(props, value) {
  var window = getWindow();
  var i;

  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (var _prop in props) {
          this[i].style[_prop] = props[_prop];
        }
      }

      return this;
    }
  }

  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }

    return this;
  }

  return this;
}

function each(callback) {
  if (!callback) return this;
  this.forEach(function (el, index) {
    callback.apply(el, [el, index]);
  });
  return this;
}

function filter(callback) {
  var result = arrayFilter(this, callback);
  return $(result);
}

function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }

  return this;
}

function dom7_esm_text(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }

  for (var i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }

  return this;
}

function is(selector) {
  var window = getWindow();
  var document = getDocument();
  var el = this[0];
  var compareWith;
  var i;
  if (!el || typeof selector === 'undefined') return false;

  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = $(selector);

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  if (selector === document) {
    return el === document;
  }

  if (selector === window) {
    return el === window;
  }

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;

    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }

    return false;
  }

  return false;
}

function dom7_esm_index() {
  var child = this[0];
  var i;

  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }

    return i;
  }

  return undefined;
}

function eq(index) {
  if (typeof index === 'undefined') return this;
  var length = this.length;

  if (index > length - 1) {
    return $([]);
  }

  if (index < 0) {
    var returnIndex = length + index;
    if (returnIndex < 0) return $([]);
    return $([this[returnIndex]]);
  }

  return $([this[index]]);
}

function append() {
  var newChild;
  var document = getDocument();

  for (var k = 0; k < arguments.length; k += 1) {
    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

    for (var i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;

        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (var j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}

function appendTo(parent) {
  $(parent).append(this);
  return this;
}

function prepend(newChild) {
  var document = getDocument();
  var i;
  var j;

  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;

      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }

  return this;
}

function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}

function insertBefore(selector) {
  var before = $(selector);

  for (var i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (var j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}

function insertAfter(selector) {
  var after = $(selector);

  for (var i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (var j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}

function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }

      return $([]);
    }

    if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
    return $([]);
  }

  return $([]);
}

function nextAll(selector) {
  var nextEls = [];
  var el = this[0];
  if (!el) return $([]);

  while (el.nextElementSibling) {
    var _next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if ($(_next).is(selector)) nextEls.push(_next);
    } else nextEls.push(_next);

    el = _next;
  }

  return $(nextEls);
}

function prev(selector) {
  if (this.length > 0) {
    var el = this[0];

    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }

      return $([]);
    }

    if (el.previousElementSibling) return $([el.previousElementSibling]);
    return $([]);
  }

  return $([]);
}

function prevAll(selector) {
  var prevEls = [];
  var el = this[0];
  if (!el) return $([]);

  while (el.previousElementSibling) {
    var _prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if ($(_prev).is(selector)) prevEls.push(_prev);
    } else prevEls.push(_prev);

    el = _prev;
  }

  return $(prevEls);
}

function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}

function dom7_esm_parent(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }

  return $(parents);
}

function parents(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var _parent = this[i].parentNode; // eslint-disable-line

    while (_parent) {
      if (selector) {
        if ($(_parent).is(selector)) parents.push(_parent);
      } else {
        parents.push(_parent);
      }

      _parent = _parent.parentNode;
    }
  }

  return $(parents);
}

function closest(selector) {
  var closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return $([]);
  }

  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }

  return closest;
}

function find(selector) {
  var foundElements = [];

  for (var i = 0; i < this.length; i += 1) {
    var found = this[i].querySelectorAll(selector);

    for (var j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }

  return $(foundElements);
}

function children(selector) {
  var children = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var childNodes = this[i].children;

    for (var j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }

  return $(children);
}

function remove() {
  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }

  return this;
}

function detach() {
  return this.remove();
}

function add() {
  var dom = this;
  var i;
  var j;

  for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    els[_key10] = arguments[_key10];
  }

  for (i = 0; i < els.length; i += 1) {
    var toAdd = $(els[i]);

    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }

  return dom;
}

function empty() {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];

    if (el.nodeType === 1) {
      for (var j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }

      el.textContent = '';
    }
  }

  return this;
}

function scrollTo() {
  var window = getWindow();

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var left = args[0],
      top = args[1],
      duration = args[2],
      easing = args[3],
      callback = args[4];

  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    left = args[0];
    top = args[1];
    duration = args[2];
    callback = args[3];
    easing = args[4];
  }

  if (typeof easing === 'undefined') easing = 'swing';
  return this.each(function animate() {
    var el = this;
    var currentTop;
    var currentLeft;
    var maxTop;
    var maxLeft;
    var newTop;
    var newLeft;
    var scrollTop; // eslint-disable-line

    var scrollLeft; // eslint-disable-line

    var animateTop = top > 0 || top === 0;
    var animateLeft = left > 0 || left === 0;

    if (typeof easing === 'undefined') {
      easing = 'swing';
    }

    if (animateTop) {
      currentTop = el.scrollTop;

      if (!duration) {
        el.scrollTop = top;
      }
    }

    if (animateLeft) {
      currentLeft = el.scrollLeft;

      if (!duration) {
        el.scrollLeft = left;
      }
    }

    if (!duration) return;

    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }

    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }

    var startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;

    function render(time) {
      if (time === void 0) {
        time = new Date().getTime();
      }

      if (startTime === null) {
        startTime = time;
      }

      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      var easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      var done;
      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);

      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }

      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }

      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      window.requestAnimationFrame(render);
    }

    window.requestAnimationFrame(render);
  });
} // scrollTop(top, duration, easing, callback) {


function scrollTop() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var top = args[0],
      duration = args[1],
      easing = args[2],
      callback = args[3];

  if (args.length === 3 && typeof easing === 'function') {
    top = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }

  var dom = this;

  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }

  return dom.scrollTo(undefined, top, duration, easing, callback);
}

function scrollLeft() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  var left = args[0],
      duration = args[1],
      easing = args[2],
      callback = args[3];

  if (args.length === 3 && typeof easing === 'function') {
    left = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }

  var dom = this;

  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }

  return dom.scrollTo(left, undefined, duration, easing, callback);
}

function animate(initialProps, initialParams) {
  var window = getWindow();
  var els = this;
  var a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing' // or 'linear'

      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */

    }, initialParams),
    elements: els,
    animating: false,
    que: [],
    easingProgress: function easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }

      if (typeof easing === 'function') {
        return easing(progress);
      }

      return progress;
    },
    stop: function stop() {
      if (a.frameId) {
        window.cancelAnimationFrame(a.frameId);
      }

      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done: function done(complete) {
      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);

      if (a.que.length > 0) {
        var que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate: function animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }

      var elements = []; // Define & Cache Initials & Units

      a.elements.each(function (el, index) {
        var initialFullValue;
        var initialValue;
        var unit;
        var finalValue;
        var finalFullValue;
        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
        elements[index] = {
          container: el
        };
        Object.keys(props).forEach(function (prop) {
          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue: initialFullValue,
            initialValue: initialValue,
            unit: unit,
            finalValue: finalValue,
            finalFullValue: finalFullValue,
            currentValue: initialValue
          };
        });
      });
      var startTime = null;
      var time;
      var elementsDone = 0;
      var propsDone = 0;
      var done;
      var began = false;
      a.animating = true;

      function render() {
        time = new Date().getTime();
        var progress;
        var easeProgress; // let el;

        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }

        if (startTime === null) {
          startTime = time;
        }

        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }

        elements.forEach(function (element) {
          var el = element;
          if (done || el.done) return;
          Object.keys(props).forEach(function (prop) {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            var _el$prop = el[prop],
                initialValue = _el$prop.initialValue,
                finalValue = _el$prop.finalValue,
                unit = _el$prop.unit;
            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            var currentValue = el[prop].currentValue;

            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;

              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }

              if (elementsDone === elements.length) {
                done = true;
              }
            }

            if (done) {
              a.done(params.complete);
              return;
            }

            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return; // Then call

        a.frameId = window.requestAnimationFrame(render);
      }

      a.frameId = window.requestAnimationFrame(render);
      return a;
    }
  };

  if (a.elements.length === 0) {
    return els;
  }

  var animateInstance;

  for (var i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }

  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  var els = this;

  for (var i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

var noTrigger = 'resize scroll'.split(' ');

function shortcut(name) {
  function eventHandler() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (typeof args[0] === 'undefined') {
      for (var i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();else {
            $(this[i]).trigger(name);
          }
        }
      }

      return this;
    }

    return this.on.apply(this, [name].concat(args));
  }

  return eventHandler;
}

var click = shortcut('click');
var dom7_esm_blur = shortcut('blur');
var dom7_esm_focus = shortcut('focus');
var focusin = shortcut('focusin');
var focusout = shortcut('focusout');
var keyup = shortcut('keyup');
var keydown = shortcut('keydown');
var keypress = shortcut('keypress');
var dom7_esm_submit = shortcut('submit');
var change = shortcut('change');
var mousedown = shortcut('mousedown');
var mousemove = shortcut('mousemove');
var mouseup = shortcut('mouseup');
var mouseenter = shortcut('mouseenter');
var mouseleave = shortcut('mouseleave');
var mouseout = shortcut('mouseout');
var mouseover = shortcut('mouseover');
var touchstart = shortcut('touchstart');
var touchend = shortcut('touchend');
var touchmove = shortcut('touchmove');
var resize = shortcut('resize');
var dom7_esm_scroll = shortcut('scroll');

/* harmony default export */ var dom7_esm = ($);


;// CONCATENATED MODULE: ./node_modules/swiper/esm/utils/dom.js

var Methods = {
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  toggleClass: toggleClass,
  attr: attr,
  removeAttr: removeAttr,
  transform: transform,
  transition: transition,
  on: on,
  off: off,
  trigger: trigger,
  transitionEnd: transitionEnd,
  outerWidth: dom7_esm_outerWidth,
  outerHeight: dom7_esm_outerHeight,
  styles: styles,
  offset: offset,
  css: css,
  each: each,
  html: html,
  text: dom7_esm_text,
  is: is,
  index: dom7_esm_index,
  eq: eq,
  append: append,
  prepend: prepend,
  next: next,
  nextAll: nextAll,
  prev: prev,
  prevAll: prevAll,
  parent: dom7_esm_parent,
  parents: parents,
  closest: closest,
  find: find,
  children: children,
  filter: filter,
  remove: remove
};
Object.keys(Methods).forEach(function (methodName) {
  Object.defineProperty($.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
/* harmony default export */ var dom = ($);
;// CONCATENATED MODULE: ./node_modules/swiper/esm/utils/utils.js


function deleteProps(obj) {
  var object = obj;
  Object.keys(object).forEach(function (key) {
    try {
      object[key] = null;
    } catch (e) {// no getter for object
    }

    try {
      delete object[key];
    } catch (e) {// something got wrong
    }
  });
}

function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return setTimeout(callback, delay);
}

function now() {
  return Date.now();
}

function utils_getComputedStyle(el) {
  var window = getWindow();
  var style;

  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }

  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }

  if (!style) {
    style = el.style;
  }

  return style;
}

function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }

  var window = getWindow();
  var matrix;
  var curTransform;
  var transformMatrix;
  var curStyle = utils_getComputedStyle(el, null);

  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;

    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(function (a) {
        return a.replace(',', '.');
      }).join(', ');
    } // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case


    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }

  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
  }

  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
  }

  return curTransform || 0;
}

function utils_isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}

function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }

  return node && (node.nodeType === 1 || node.nodeType === 11);
}

function utils_extend() {
  var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  var noExtend = ['__proto__', 'constructor', 'prototype'];

  for (var i = 1; i < arguments.length; i += 1) {
    var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
        return noExtend.indexOf(key) < 0;
      });

      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

        if (desc !== undefined && desc.enumerable) {
          if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            to[nextKey] = {};

            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }

  return to;
}

function bindModuleMethods(instance, obj) {
  Object.keys(obj).forEach(function (key) {
    if (utils_isObject(obj[key])) {
      Object.keys(obj[key]).forEach(function (subKey) {
        if (typeof obj[key][subKey] === 'function') {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }

    instance[key] = obj[key];
  });
}

function classesToSelector(classes) {
  if (classes === void 0) {
    classes = '';
  }

  return "." + classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.');
}

function createElementIfNotDefined($container, params, createElements, checkProps) {
  var document = getDocument();

  if (createElements) {
    Object.keys(checkProps).forEach(function (key) {
      if (!params[key] && params.auto === true) {
        var element = document.createElement('div');
        element.className = checkProps[key];
        $container.append(element);
        params[key] = element;
      }
    });
  }

  return params;
}


;// CONCATENATED MODULE: ./node_modules/swiper/esm/utils/get-support.js

var get_support_support;

function calcSupport() {
  var window = getWindow();
  var document = getDocument();
  return {
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
    observer: function checkObserver() {
      return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
    }(),
    passiveListener: function checkPassiveListener() {
      var supportsPassive = false;

      try {
        var opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get: function get() {
            supportsPassive = true;
          }
        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {// No support
      }

      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}

function getSupport() {
  if (!get_support_support) {
    get_support_support = calcSupport();
  }

  return get_support_support;
}


;// CONCATENATED MODULE: ./node_modules/swiper/esm/utils/get-device.js


var device;

function calcDevice(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      userAgent = _ref.userAgent;

  var support = getSupport();
  var window = getWindow();
  var platform = window.navigator.platform;
  var ua = userAgent || window.navigator.userAgent;
  var device = {
    ios: false,
    android: false
  };
  var screenWidth = window.screen.width;
  var screenHeight = window.screen.height;
  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  var windows = platform === 'Win32';
  var macos = platform === 'MacIntel'; // iPadOs 13 fix

  var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

  if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  } // Android


  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }

  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  } // Export object


  return device;
}

function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }

  if (!device) {
    device = calcDevice(overrides);
  }

  return device;
}


;// CONCATENATED MODULE: ./node_modules/swiper/esm/utils/get-browser.js

var browser;

function calcBrowser() {
  var window = getWindow();

  function isSafari() {
    var ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }

  return {
    isEdge: !!window.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}

function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }

  return browser;
}


;// CONCATENATED MODULE: ./node_modules/swiper/esm/modules/resize/resize.js



var supportsResizeObserver = function supportsResizeObserver() {
  var window = getWindow();
  return typeof window.ResizeObserver !== 'undefined';
};

/* harmony default export */ var resize_resize = ({
  name: 'resize',
  create: function create() {
    var swiper = this;
    utils_extend(swiper, {
      resize: {
        observer: null,
        createObserver: function createObserver() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.resize.observer = new ResizeObserver(function (entries) {
            var width = swiper.width,
                height = swiper.height;
            var newWidth = width;
            var newHeight = height;
            entries.forEach(function (_ref) {
              var contentBoxSize = _ref.contentBoxSize,
                  contentRect = _ref.contentRect,
                  target = _ref.target;
              if (target && target !== swiper.el) return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });

            if (newWidth !== width || newHeight !== height) {
              swiper.resize.resizeHandler();
            }
          });
          swiper.resize.observer.observe(swiper.el);
        },
        removeObserver: function removeObserver() {
          if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
            swiper.resize.observer.unobserve(swiper.el);
            swiper.resize.observer = null;
          }
        },
        resizeHandler: function resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler: function orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        }
      }
    });
  },
  on: {
    init: function init(swiper) {
      var window = getWindow();

      if (swiper.params.resizeObserver && supportsResizeObserver()) {
        swiper.resize.createObserver();
        return;
      } // Emit resize


      window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy: function destroy(swiper) {
      var window = getWindow();
      swiper.resize.removeObserver();
      window.removeEventListener('resize', swiper.resize.resizeHandler);
      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    }
  }
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/modules/observer/observer.js
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }



var Observer = {
  attach: function attach(target, options) {
    if (options === void 0) {
      options = {};
    }

    var window = getWindow();
    var swiper = this;
    var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    var observer = new ObserverFunc(function (mutations) {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }

      var observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    swiper.observer.observers.push(observer);
  },
  init: function init() {
    var swiper = this;
    if (!swiper.support.observer || !swiper.params.observer) return;

    if (swiper.params.observeParents) {
      var containerParents = swiper.$el.parents();

      for (var i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    } // Observe container


    swiper.observer.attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    }); // Observe wrapper

    swiper.observer.attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  },
  destroy: function destroy() {
    var swiper = this;
    swiper.observer.observers.forEach(function (observer) {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  }
};
/* harmony default export */ var observer = ({
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      observer: _extends({}, Observer, {
        observers: []
      })
    });
  },
  on: {
    init: function init(swiper) {
      swiper.observer.init();
    },
    destroy: function destroy(swiper) {
      swiper.observer.destroy();
    }
  }
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/modular.js

/* harmony default export */ var modular = ({
  useParams: function useParams(instanceParams) {
    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName]; // Extend params

      if (module.params) {
        utils_extend(instanceParams, module.params);
      }
    });
  },
  useModules: function useModules(modulesParams) {
    if (modulesParams === void 0) {
      modulesParams = {};
    }

    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function (moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      } // Module create callback


      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events-emitter.js
/* eslint-disable no-underscore-dangle */
/* harmony default export */ var events_emitter = ({
  on: function on(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(function (event) {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once: function once(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;

    function onceHandler() {
      self.off(events, onceHandler);

      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      handler.apply(self, args);
    }

    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny: function onAny(handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';

    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }

    return self;
  },
  offAny: function offAny(handler) {
    var self = this;
    if (!self.eventsAnyListeners) return self;
    var index = self.eventsAnyListeners.indexOf(handler);

    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }

    return self;
  },
  off: function off(events, handler) {
    var self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(function (event) {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler, index) {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit: function emit() {
    var self = this;
    if (!self.eventsListeners) return self;
    var events;
    var data;
    var context;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    data.unshift(context);
    var eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(function (event) {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(function (eventHandler) {
          eventHandler.apply(context, [event].concat(data));
        });
      }

      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler) {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateSize.js

function updateSize() {
  var swiper = this;
  var width;
  var height;
  var $el = swiper.$el;

  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }

  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }

  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  } // Subtract paddings


  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  utils_extend(swiper, {
    width: width,
    height: height,
    size: swiper.isHorizontal() ? width : height
  });
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateSlides.js

function updateSlides() {
  var swiper = this;

  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore


    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }

  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }

  var params = swiper.params;
  var $wrapperEl = swiper.$wrapperEl,
      swiperSize = swiper.size,
      rtl = swiper.rtlTranslate,
      wrongRTL = swiper.wrongRTL;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  var slides = $wrapperEl.children("." + swiper.params.slideClass);
  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  var snapGrid = [];
  var slidesGrid = [];
  var slidesSizesGrid = [];
  var offsetBefore = params.slidesOffsetBefore;

  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  var offsetAfter = params.slidesOffsetAfter;

  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  var previousSnapGridLength = swiper.snapGrid.length;
  var previousSlidesGridLength = swiper.slidesGrid.length;
  var spaceBetween = params.spaceBetween;
  var slidePosition = -offsetBefore;
  var prevSlideSize = 0;
  var index = 0;

  if (typeof swiperSize === 'undefined') {
    return;
  }

  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }

  swiper.virtualSize = -spaceBetween; // reset margins

  if (rtl) slides.css({
    marginLeft: '',
    marginBottom: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: '',
    marginTop: ''
  });
  var slidesNumberEvenToRows;

  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }

    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  } // Calc slides


  var slideSize;
  var slidesPerColumn = params.slidesPerColumn;
  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

  for (var i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    var slide = slides.eq(i);

    if (params.slidesPerColumn > 1) {
      // Set slides order
      var newSlideOrderIndex = void 0;
      var column = void 0;
      var row = void 0;

      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
        slide.css({
          '-webkit-box-ordinal-group': newSlideOrderIndex,
          '-moz-box-ordinal-group': newSlideOrderIndex,
          '-ms-flex-order': newSlideOrderIndex,
          '-webkit-order': newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - column * slidesPerColumn;

        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
          row += 1;

          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }

      slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : '');
    }

    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      var slideStyles = getComputedStyle(slide[0]);
      var currentTransform = slide[0].style.transform;
      var currentWebKitTransform = slide[0].style.webkitTransform;

      if (currentTransform) {
        slide[0].style.transform = 'none';
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }

      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        var width = getDirectionPropertyValue(slideStyles, 'width');
        var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        var boxSizing = slideStyles.getPropertyValue('box-sizing');

        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          var _slide$ = slide[0],
              clientWidth = _slide$.clientWidth,
              offsetWidth = _slide$.offsetWidth;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }

      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }

      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }

      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = slideSize + "px";
      }
    }

    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }

    slidesSizesGrid.push(slideSize);

    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }

  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  var newSlidesGrid;

  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: swiper.virtualSize + params.spaceBetween + "px"
    });
  }

  if (params.setWrapperSize) {
    var _$wrapperEl$css;

    $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
  }

  if (params.slidesPerColumn > 1) {
    var _$wrapperEl$css2;

    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));

    if (params.centeredSlides) {
      newSlidesGrid = [];

      for (var _i = 0; _i < snapGrid.length; _i += 1) {
        var slidesGridItem = snapGrid[_i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }

      snapGrid = newSlidesGrid;
    }
  } // Remove last grid elements depending on width


  if (!params.centeredSlides) {
    newSlidesGrid = [];

    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
      var _slidesGridItem = snapGrid[_i2];
      if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(_slidesGridItem);
      }
    }

    snapGrid = newSlidesGrid;

    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }

  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    var _slides$filter$css;

    var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter(function (_, slideIndex) {
      if (!params.cssMode) return true;

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
  }

  if (params.centeredSlides && params.centeredSlidesBounds) {
    var allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    var maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(function (snap) {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }

  if (params.centerInsufficientSlides) {
    var _allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    _allSlidesSize -= params.spaceBetween;

    if (_allSlidesSize < swiperSize) {
      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
      snapGrid.forEach(function (snap, snapIndex) {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach(function (snap, snapIndex) {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  utils_extend(swiper, {
    slides: slides,
    snapGrid: snapGrid,
    slidesGrid: slidesGrid,
    slidesSizesGrid: slidesSizesGrid
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }

  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }

  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
  var swiper = this;
  var activeSlides = [];
  var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  var newHeight = 0;
  var i;

  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }

  var getSlideByIndex = function getSlideByIndex(index) {
    if (isVirtual) {
      return swiper.slides.filter(function (el) {
        return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
      })[0];
    }

    return swiper.slides.eq(index)[0];
  }; // Find slides currently in view


  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(function (slide) {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        var index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  } // Find new height from highest slide in view


  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      var height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  } // Update Height


  if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
  var swiper = this;
  var slides = swiper.slides;

  for (var i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateSlidesProgress.js

function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }

  var swiper = this;
  var params = swiper.params;
  var slides = swiper.slides,
      rtl = swiper.rtlTranslate;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  var offsetCenter = -translate;
  if (rtl) offsetCenter = translate; // Visible Slides

  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (var i = 0; i < slides.length; i += 1) {
    var slide = slides[i];
    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }

    slide.progress = rtl ? -slideProgress : slideProgress;
  }

  swiper.visibleSlides = dom(swiper.visibleSlides);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateProgress.js

function updateProgress(translate) {
  var swiper = this;

  if (typeof translate === 'undefined') {
    var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }

  var params = swiper.params;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  var progress = swiper.progress,
      isBeginning = swiper.isBeginning,
      isEnd = swiper.isEnd;
  var wasBeginning = isBeginning;
  var wasEnd = isEnd;

  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }

  utils_extend(swiper, {
    progress: progress,
    isBeginning: isBeginning,
    isEnd: isEnd
  });
  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }

  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }

  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateSlidesClasses.js
function updateSlidesClasses() {
  var swiper = this;
  var slides = swiper.slides,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex,
      realIndex = swiper.realIndex;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
  var activeSlide;

  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
  } else {
    activeSlide = slides.eq(activeIndex);
  } // Active classes


  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
    }
  } // Next Slide


  var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  } // Prev Slide


  var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }

  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
    }

    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
    }
  }

  swiper.emitSlidesClasses();
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateActiveIndex.js

function updateActiveIndex(newActiveIndex) {
  var swiper = this;
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  var slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid,
      params = swiper.params,
      previousIndex = swiper.activeIndex,
      previousRealIndex = swiper.realIndex,
      previousSnapIndex = swiper.snapIndex;
  var activeIndex = newActiveIndex;
  var snapIndex;

  if (typeof activeIndex === 'undefined') {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    } // Normalize slideIndex


    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }

  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }

  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }

    return;
  } // Get real index


  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  utils_extend(swiper, {
    snapIndex: snapIndex,
    realIndex: realIndex,
    previousIndex: previousIndex,
    activeIndex: activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');

  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }

  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/updateClickedSlide.js

function updateClickedSlide(e) {
  var swiper = this;
  var params = swiper.params;
  var slide = dom(e.target).closest("." + params.slideClass)[0];
  var slideFound = false;
  var slideIndex;

  if (slide) {
    for (var i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;

    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(dom(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }

  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/update/index.js









/* harmony default export */ var update = ({
  updateSize: updateSize,
  updateSlides: updateSlides,
  updateAutoHeight: updateAutoHeight,
  updateSlidesOffset: updateSlidesOffset,
  updateSlidesProgress: updateSlidesProgress,
  updateProgress: updateProgress,
  updateSlidesClasses: updateSlidesClasses,
  updateActiveIndex: updateActiveIndex,
  updateClickedSlide: updateClickedSlide
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/translate/getTranslate.js

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }

  var swiper = this;
  var params = swiper.params,
      rtl = swiper.rtlTranslate,
      translate = swiper.translate,
      $wrapperEl = swiper.$wrapperEl;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  if (params.cssMode) {
    return translate;
  }

  var currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/translate/setTranslate.js
function setTranslate(translate, byController) {
  var swiper = this;
  var rtl = swiper.rtlTranslate,
      params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      wrapperEl = swiper.wrapperEl,
      progress = swiper.progress;
  var x = 0;
  var y = 0;
  var z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
  }

  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/translate/minTranslate.js
function minTranslate() {
  return -this.snapGrid[0];
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/translate/maxTranslate.js
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/translate/translateTo.js
function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (translateBounds === void 0) {
    translateBounds = true;
  }

  var swiper = this;
  var params = swiper.params,
      wrapperEl = swiper.wrapperEl;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  var minTranslate = swiper.minTranslate();
  var maxTranslate = swiper.maxTranslate();
  var newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

  swiper.updateProgress(newTranslate);

  if (params.cssMode) {
    var isH = swiper.isHorizontal();

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);

    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;

          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }

  return true;
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/translate/index.js





/* harmony default export */ var translate = ({
  getTranslate: getSwiperTranslate,
  setTranslate: setTranslate,
  minTranslate: minTranslate,
  maxTranslate: maxTranslate,
  translateTo: translateTo
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/transition/setTransition.js
function setTransition(duration, byController) {
  var swiper = this;

  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }

  swiper.emit('setTransition', duration, byController);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/transition/transitionStart.js
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var activeIndex = swiper.activeIndex,
      params = swiper.params,
      previousIndex = swiper.previousIndex;
  if (params.cssMode) return;

  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }

    swiper.emit('slideChangeTransitionStart');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/transition/transitionEnd.js
function transitionEnd_transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var activeIndex = swiper.activeIndex,
      previousIndex = swiper.previousIndex,
      params = swiper.params;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  var dir = direction;

  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }

    swiper.emit('slideChangeTransitionEnd');

    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/transition/index.js



/* harmony default export */ var core_transition = ({
  setTransition: setTransition,
  transitionStart: transitionStart,
  transitionEnd: transitionEnd_transitionEnd
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/slideTo.js
function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index + "] given.");
  }

  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    var indexAsNumber = parseInt(index, 10);
    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */

    var isValidNumber = isFinite(indexAsNumber);

    if (!isValidNumber) {
      throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + "] given.");
    } // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.


    index = indexAsNumber;
  }

  var swiper = this;
  var slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  var params = swiper.params,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      previousIndex = swiper.previousIndex,
      activeIndex = swiper.activeIndex,
      rtl = swiper.rtlTranslate,
      wrapperEl = swiper.wrapperEl,
      enabled = swiper.enabled;

  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }

  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  var translate = -snapGrid[snapIndex]; // Update progress

  swiper.updateProgress(translate); // Normalize slideIndex

  if (params.normalizeSlideIndex) {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      var normalizedTranslate = -Math.floor(translate * 100);
      var normalizedGird = Math.floor(slidesGrid[i] * 100);
      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGird) {
        slideIndex = i;
      }
    }
  } // Directions locks


  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }

    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  var direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex); // Update Height

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    swiper.updateSlidesClasses();

    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }

    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }

    return false;
  }

  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    var t = -translate;

    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }

    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;

        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }

    return true;
  }

  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);

    if (!swiper.animating) {
      swiper.animating = true;

      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }

      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/slideToLoop.js
function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }

  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var newIndex = index;

  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/slideNext.js
/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating,
      enabled = swiper.enabled;
  if (!enabled) return swiper;
  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/slidePrev.js
/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  var params = swiper.params,
      animating = swiper.animating,
      snapGrid = swiper.snapGrid,
      slidesGrid = swiper.slidesGrid,
      rtlTranslate = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return swiper;

  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix(); // eslint-disable-next-line

    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }

  var translate = rtlTranslate ? swiper.translate : -swiper.translate;

  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }

  var normalizedTranslate = normalize(translate);
  var normalizedSnapGrid = snapGrid.map(function (val) {
    return normalize(val);
  });
  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach(function (snap) {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }

  var prevIndex;

  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }

  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/slideReset.js
/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  var swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/slideToClosest.js
/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }

  if (runCallbacks === void 0) {
    runCallbacks = true;
  }

  if (threshold === void 0) {
    threshold = 0.5;
  }

  var swiper = this;
  var index = swiper.activeIndex;
  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    var currentSnap = swiper.snapGrid[snapIndex];
    var nextSnap = swiper.snapGrid[snapIndex + 1];

    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    var prevSnap = swiper.snapGrid[snapIndex - 1];
    var _currentSnap = swiper.snapGrid[snapIndex];

    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/slideToClickedSlide.js


function slideToClickedSlide() {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl;
  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  var slideToIndex = swiper.clickedIndex;
  var realIndex;

  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(dom(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
        nextTick(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
      nextTick(function () {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/slide/index.js







/* harmony default export */ var slide = ({
  slideTo: slideTo,
  slideToLoop: slideToLoop,
  slideNext: slideNext,
  slidePrev: slidePrev,
  slideReset: slideReset,
  slideToClosest: slideToClosest,
  slideToClickedSlide: slideToClickedSlide
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/loop/loopCreate.js


function loopCreate() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
  var slides = $wrapperEl.children("." + params.slideClass);

  if (params.loopFillGroupWithBlank) {
    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

    if (blankSlidesNum !== params.slidesPerGroup) {
      for (var i = 0; i < blankSlidesNum; i += 1) {
        var blankNode = dom(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
        $wrapperEl.append(blankNode);
      }

      slides = $wrapperEl.children("." + params.slideClass);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;

  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  var prependSlides = [];
  var appendSlides = [];
  slides.each(function (el, index) {
    var slide = dom(el);

    if (index < swiper.loopedSlides) {
      appendSlides.push(el);
    }

    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }

    slide.attr('data-swiper-slide-index', index);
  });

  for (var _i = 0; _i < appendSlides.length; _i += 1) {
    $wrapperEl.append(dom(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }

  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
    $wrapperEl.prepend(dom(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/loop/loopFix.js
function loopFix() {
  var swiper = this;
  swiper.emit('beforeLoopFix');
  var activeIndex = swiper.activeIndex,
      slides = swiper.slides,
      loopedSlides = swiper.loopedSlides,
      allowSlidePrev = swiper.allowSlidePrev,
      allowSlideNext = swiper.allowSlideNext,
      snapGrid = swiper.snapGrid,
      rtl = swiper.rtlTranslate;
  var newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  var snapTranslate = -snapGrid[activeIndex];
  var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    var slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;

    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

    if (_slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }

  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/loop/loopDestroy.js
function loopDestroy() {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      slides = swiper.slides;
  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
  slides.removeAttr('data-swiper-slide-index');
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/loop/index.js



/* harmony default export */ var loop = ({
  loopCreate: loopCreate,
  loopFix: loopFix,
  loopDestroy: loopDestroy
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
  var swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  var el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
  var swiper = this;

  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }

  swiper.el.style.cursor = '';
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/grab-cursor/index.js


/* harmony default export */ var grab_cursor = ({
  setGrabCursor: setGrabCursor,
  unsetGrabCursor: unsetGrabCursor
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/manipulation/appendSlide.js
function appendSlide(slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params;

  if (params.loop) {
    swiper.loopDestroy();
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/manipulation/prependSlide.js
function prependSlide(slides) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;

  if (params.loop) {
    swiper.loopDestroy();
  }

  var newActiveIndex = activeIndex + 1;

  if (typeof slides === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }

    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  swiper.slideTo(newActiveIndex, 0, false);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/manipulation/addSlide.js
function addSlide(index, slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
      params = swiper.params,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }

  var baseLength = swiper.slides.length;

  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }

  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }

  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  var slidesBuffer = [];

  for (var i = baseLength - 1; i >= index; i -= 1) {
    var currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (var _i = 0; _i < slides.length; _i += 1) {
      if (slides[_i]) $wrapperEl.append(slides[_i]);
    }

    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
    $wrapperEl.append(slidesBuffer[_i2]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/manipulation/removeSlide.js
function removeSlide(slidesIndexes) {
  var swiper = this;
  var params = swiper.params,
      $wrapperEl = swiper.$wrapperEl,
      activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;

  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }

  var newActiveIndex = activeIndexBuffer;
  var indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (var i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }

    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }

  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/manipulation/removeAllSlides.js
function removeAllSlides() {
  var swiper = this;
  var slidesIndexes = [];

  for (var i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }

  swiper.removeSlide(slidesIndexes);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/manipulation/index.js





/* harmony default export */ var manipulation = ({
  appendSlide: appendSlide,
  prependSlide: prependSlide,
  addSlide: addSlide,
  removeSlide: removeSlide,
  removeAllSlides: removeAllSlides
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events/onTouchStart.js


 // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd

function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }

  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    var found = el.closest(selector);
    return found || __closestFrom(el.getRootNode().host);
  }

  return __closestFrom(base);
}

function onTouchStart(event) {
  var swiper = this;
  var document = getDocument();
  var window = getWindow();
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      enabled = swiper.enabled;
  if (!enabled) return;

  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }

  var e = event;
  if (e.originalEvent) e = e.originalEvent;
  var $targetEl = dom(e.target);

  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }

  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return; // change target el for shadow root component

  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = dom(event.path[0]);
  }

  var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass;
  var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }

  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  var startX = touches.currentX;
  var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }

  utils_extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;

  if (e.type !== 'touchstart') {
    var preventDefault = true;
    if ($targetEl.is(data.focusableElements)) preventDefault = false;

    if (document.activeElement && dom(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }

    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }

  swiper.emit('touchStart', e);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events/onTouchMove.js



function onTouchMove(event) {
  var document = getDocument();
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    return;
  }

  if (data.isTouchEvent && e.type !== 'touchmove') return;
  var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }

  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;

    if (data.isTouched) {
      utils_extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }

    return;
  }

  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }

  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && dom(e.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }

  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }

  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  var diffX = touches.currentX - touches.startX;
  var diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    var touchAngle;

    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }

  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }

  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }

  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }

  if (!data.startMoving) {
    return;
  }

  swiper.allowClick = false;

  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }

  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }

    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);

    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }

    data.allowMomentumBounce = false; // Grab Cursor

    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }

    swiper.emit('sliderFirstMove', e);
  }

  swiper.emit('sliderMove', e);
  data.isMoved = true;
  var diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  var disableParentSwiper = true;
  var resistanceRatio = params.resistanceRatio;

  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }

  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  } // Directions locks


  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }

  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  } // Threshold


  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger || params.cssMode) return; // Update active index in free mode

  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }

  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }

    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: now()
    });
  } // Update progress


  swiper.updateProgress(data.currentTranslate); // Update translate

  swiper.setTranslate(data.currentTranslate);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events/onTouchEnd.js

function onTouchEnd(event) {
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
      touches = swiper.touches,
      rtl = swiper.rtlTranslate,
      $wrapperEl = swiper.$wrapperEl,
      slidesGrid = swiper.slidesGrid,
      snapGrid = swiper.snapGrid,
      enabled = swiper.enabled;
  if (!enabled) return;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;

  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }

  data.allowTouchCallbacks = false;

  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }

    data.isMoved = false;
    data.startMoving = false;
    return;
  } // Return Grab Cursor


  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  } // Time diff


  var touchEndTime = now();
  var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);

    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }

  data.lastClickTime = now();
  nextTick(function () {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  var currentPos;

  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.cssMode) {
    return;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }

      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        var lastMoveEvent = data.velocities.pop();
        var velocityEvent = data.velocities.pop();
        var distance = lastMoveEvent.position - velocityEvent.position;
        var time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;

        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        } // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.


        if (time > 150 || now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }

      swiper.velocity *= params.freeModeMomentumVelocityRatio;
      data.velocities.length = 0;
      var momentumDuration = 1000 * params.freeModeMomentumRatio;
      var momentumDistance = swiper.velocity * momentumDuration;
      var newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      var doBounce = false;
      var afterBouncePosition;
      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      var needsLoopFix;

      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }

          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }

          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }

        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        var nextSlide;

        for (var j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }

        newPosition = -newPosition;
      }

      if (needsLoopFix) {
        swiper.once('transitionEnd', function () {
          swiper.loopFix();
        });
      } // Fix duration


      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }

        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(function () {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(function () {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);

        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      swiper.emit('_freeModeNoMomentumRelease');
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    return;
  } // Find current slide


  var stopIndex = 0;
  var groupSize = swiper.slidesSizesGrid[0];

  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (typeof slidesGrid[i + _increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + _increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  } // Find current slide size


  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }

    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }

    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }

      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events/onResize.js
function onResize() {
  var swiper = this;
  var params = swiper.params,
      el = swiper.el;
  if (el && el.offsetWidth === 0) return; // Breakpoints

  if (params.breakpoints) {
    swiper.setBreakpoint();
  } // Save locks


  var allowSlideNext = swiper.allowSlideNext,
      allowSlidePrev = swiper.allowSlidePrev,
      snapGrid = swiper.snapGrid; // Disable locks on resize

  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();

  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }

  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  } // Return locks after resize


  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events/onClick.js
function onClick(e) {
  var swiper = this;
  if (!swiper.enabled) return;

  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();

    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events/onScroll.js
function onScroll() {
  var swiper = this;
  var wrapperEl = swiper.wrapperEl,
      rtlTranslate = swiper.rtlTranslate,
      enabled = swiper.enabled;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;

  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  } // eslint-disable-next-line


  if (swiper.translate === -0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }

  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }

  swiper.emit('setTranslate', swiper.translate, false);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/events/index.js







var dummyEventAttached = false;

function dummyEventListener() {}

function attachEvents() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);

  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
        passive: false,
        capture: capture
      } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }

      if (!dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      document.addEventListener('mousemove', swiper.onTouchMove, capture);
      document.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  } // Resize handler


  if (params.updateOnWindowResize) {
    swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper.on('observerUpdate', onResize, true);
  }
}

function detachEvents() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
      touchEvents = swiper.touchEvents,
      el = swiper.el,
      wrapperEl = swiper.wrapperEl,
      device = swiper.device,
      support = swiper.support;
  var capture = !!params.nested; // Touch Events

  if (!support.touch && support.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }

    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.removeEventListener('mousedown', swiper.onTouchStart, false);
      document.removeEventListener('mousemove', swiper.onTouchMove, capture);
      document.removeEventListener('mouseup', swiper.onTouchEnd, false);
    }
  } // Prevent Links Clicks


  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener('click', swiper.onClick, true);
  }

  if (params.cssMode) {
    wrapperEl.removeEventListener('scroll', swiper.onScroll);
  } // Resize handler


  swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
}

/* harmony default export */ var events = ({
  attachEvents: attachEvents,
  detachEvents: detachEvents
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/breakpoints/setBreakpoint.js

function setBreakpoint() {
  var swiper = this;
  var activeIndex = swiper.activeIndex,
      initialized = swiper.initialized,
      _swiper$loopedSlides = swiper.loopedSlides,
      loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
      params = swiper.params,
      $el = swiper.$el;
  var breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

  var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

  if (breakpointOnlyParams) {
    ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
      var paramValue = breakpointOnlyParams[param];
      if (typeof paramValue === 'undefined') return;

      if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
        breakpointOnlyParams[param] = 'auto';
      } else if (param === 'slidesPerView') {
        breakpointOnlyParams[param] = parseFloat(paramValue);
      } else {
        breakpointOnlyParams[param] = parseInt(paramValue, 10);
      }
    });
  }

  var breakpointParams = breakpointOnlyParams || swiper.originalParams;
  var wasMultiRow = params.slidesPerColumn > 1;
  var isMultiRow = breakpointParams.slidesPerColumn > 1;
  var wasEnabled = params.enabled;

  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(params.containerModifierClass + "multirow");

    if (breakpointParams.slidesPerColumnFill && breakpointParams.slidesPerColumnFill === 'column' || !breakpointParams.slidesPerColumnFill && params.slidesPerColumnFill === 'column') {
      $el.addClass(params.containerModifierClass + "multirow-column");
    }

    swiper.emitContainerClasses();
  }

  var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

  if (directionChanged && initialized) {
    swiper.changeDirection();
  }

  utils_extend(swiper.params, breakpointParams);
  var isEnabled = swiper.params.enabled;
  utils_extend(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });

  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }

  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);

  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }

  swiper.emit('breakpoint', breakpointParams);
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/breakpoints/getBreakpoint.js

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }

  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  var breakpoint = false;
  var window = getWindow();
  var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  var points = Object.keys(breakpoints).map(function (point) {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      var minRatio = parseFloat(point.substr(1));
      var value = currentHeight * minRatio;
      return {
        value: value,
        point: point
      };
    }

    return {
      value: point,
      point: point
    };
  });
  points.sort(function (a, b) {
    return parseInt(a.value, 10) - parseInt(b.value, 10);
  });

  for (var i = 0; i < points.length; i += 1) {
    var _points$i = points[i],
        point = _points$i.point,
        value = _points$i.value;

    if (base === 'window') {
      if (window.matchMedia("(min-width: " + value + "px)").matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }

  return breakpoint || 'max';
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/breakpoints/index.js


/* harmony default export */ var breakpoints = ({
  setBreakpoint: setBreakpoint,
  getBreakpoint: getBreakpoint
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/classes/addClasses.js
function prepareClasses(entries, prefix) {
  var resultClasses = [];
  entries.forEach(function (item) {
    if (typeof item === 'object') {
      Object.keys(item).forEach(function (classNames) {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}

function addClasses() {
  var swiper = this;
  var classNames = swiper.classNames,
      params = swiper.params,
      rtl = swiper.rtl,
      $el = swiper.$el,
      device = swiper.device,
      support = swiper.support; // prettier-ignore

  var suffixes = prepareClasses(['initialized', params.direction, {
    'pointer-events': support.pointerEvents && !support.touch
  }, {
    'free-mode': params.freeMode
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'multirow': params.slidesPerColumn > 1
  }, {
    'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }], params.containerModifierClass);
  classNames.push.apply(classNames, suffixes);
  $el.addClass([].concat(classNames).join(' '));
  swiper.emitContainerClasses();
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/classes/removeClasses.js
function removeClasses() {
  var swiper = this;
  var $el = swiper.$el,
      classNames = swiper.classNames;
  $el.removeClass(classNames.join(' '));
  swiper.emitContainerClasses();
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/classes/index.js


/* harmony default export */ var classes = ({
  addClasses: addClasses,
  removeClasses: removeClasses
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/images/loadImage.js


function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  var window = getWindow();
  var image;

  function onReady() {
    if (callback) callback();
  }

  var isPicture = dom(imageEl).parent('picture')[0];

  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window.Image();
      image.onload = onReady;
      image.onerror = onReady;

      if (sizes) {
        image.sizes = sizes;
      }

      if (srcset) {
        image.srcset = srcset;
      }

      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/images/preloadImages.js
function preloadImages() {
  var swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');

  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }

  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
    var imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
  }
}
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/images/index.js


/* harmony default export */ var core_images = ({
  loadImage: loadImage,
  preloadImages: preloadImages
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/check-overflow/index.js
function checkOverflow() {
  var swiper = this;
  var params = swiper.params;
  var wasLocked = swiper.isLocked;
  var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }

  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked; // events

  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    if (swiper.navigation) swiper.navigation.update();
  }
}

/* harmony default export */ var check_overflow = ({
  checkOverflow: checkOverflow
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/defaults.js
/* harmony default export */ var defaults = ({
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: false,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // Images
  preloadImages: true,
  updateOnImagesReady: true,
  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  // NS
  containerModifierClass: 'swiper-container-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/core/core-class.js
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* eslint no-param-reassign: "off" */























var prototypes = {
  modular: modular,
  eventsEmitter: events_emitter,
  update: update,
  translate: translate,
  transition: core_transition,
  slide: slide,
  loop: loop,
  grabCursor: grab_cursor,
  manipulation: manipulation,
  events: events,
  breakpoints: breakpoints,
  checkOverflow: check_overflow,
  classes: classes,
  images: core_images
};
var extendedDefaults = {};

var Swiper = /*#__PURE__*/function () {
  function Swiper() {
    var el;
    var params;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      el = args[0];
      params = args[1];
    }

    if (!params) params = {};
    params = utils_extend({}, params);
    if (el && !params.el) params.el = el;

    if (params.el && dom(params.el).length > 1) {
      var swipers = [];
      dom(params.el).each(function (containerEl) {
        var newParams = utils_extend({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    } // Swiper Instance


    var swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];

    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }

    Object.keys(swiper.modules).forEach(function (moduleName) {
      var module = swiper.modules[moduleName];

      if (module.params) {
        var moduleParamName = Object.keys(module.params)[0];
        var moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) return;

        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }

        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
      }
    }); // Extend defaults with modules params

    var swiperParams = utils_extend({}, defaults);
    swiper.useParams(swiperParams); // Extend defaults with passed params

    swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = utils_extend({}, swiper.params);
    swiper.passedParams = utils_extend({}, params); // add event listeners

    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(function (eventName) {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }

    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    } // Save Dom lib


    swiper.$ = dom; // Extend Swiper

    utils_extend(swiper, {
      enabled: swiper.params.enabled,
      el: el,
      // Classes
      classNames: [],
      // Slides
      slides: dom(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal: function isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical: function isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEvents: function touchEvents() {
        var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
        var desktop = ['mousedown', 'mousemove', 'mouseup'];

        if (swiper.support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        }

        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    }); // Install Modules

    swiper.useModules();
    swiper.emit('_swiper'); // Init

    if (swiper.params.init) {
      swiper.init();
    } // Return app instance


    return swiper;
  }

  var _proto = Swiper.prototype;

  _proto.enable = function enable() {
    var swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;

    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    swiper.emit('enable');
  };

  _proto.disable = function disable() {
    var swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;

    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }

    swiper.emit('disable');
  };

  _proto.setProgress = function setProgress(progress, speed) {
    var swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    var min = swiper.minTranslate();
    var max = swiper.maxTranslate();
    var current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  };

  _proto.emitContainerClasses = function emitContainerClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    var classes = swiper.el.className.split(' ').filter(function (className) {
      return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', classes.join(' '));
  };

  _proto.getSlideClasses = function getSlideClasses(slideEl) {
    var swiper = this;
    return slideEl.className.split(' ').filter(function (className) {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  };

  _proto.emitSlidesClasses = function emitSlidesClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    var updates = [];
    swiper.slides.each(function (slideEl) {
      var classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl: slideEl,
        classNames: classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  };

  _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
    var swiper = this;
    var params = swiper.params,
        slides = swiper.slides,
        slidesGrid = swiper.slidesGrid,
        swiperSize = swiper.size,
        activeIndex = swiper.activeIndex;
    var spv = 1;

    if (params.centeredSlides) {
      var slideSize = slides[activeIndex].swiperSlideSize;
      var breakLoop;

      for (var i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }

      for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
        if (slides[_i] && !breakLoop) {
          slideSize += slides[_i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
        if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }

    return spv;
  };

  _proto.update = function update() {
    var swiper = this;
    if (!swiper || swiper.destroyed) return;
    var snapGrid = swiper.snapGrid,
        params = swiper.params; // Breakpoints

    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    var translated;

    if (swiper.params.freeMode) {
      setTranslate();

      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (!translated) {
        setTranslate();
      }
    }

    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }

    swiper.emit('update');
  };

  _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }

    var swiper = this;
    var currentDirection = swiper.params.direction;

    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }

    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }

    swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each(function (slideEl) {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  };

  _proto.mount = function mount(el) {
    var swiper = this;
    if (swiper.mounted) return true; // Find el

    var $el = dom(el || swiper.params.el);
    el = $el[0];

    if (!el) {
      return false;
    }

    el.swiper = swiper;

    var getWrapperSelector = function getWrapperSelector() {
      return "." + (swiper.params.wrapperClass || '').trim().split(' ').join('.');
    };

    var getWrapper = function getWrapper() {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        var res = dom(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

        res.children = function (options) {
          return $el.children(options);
        };

        return res;
      }

      return $el.children(getWrapperSelector());
    }; // Find Wrapper


    var $wrapperEl = getWrapper();

    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      var document = getDocument();
      var wrapper = document.createElement('div');
      $wrapperEl = dom(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children("." + swiper.params.slideClass).each(function (slideEl) {
        $wrapperEl.append(slideEl);
      });
    }

    utils_extend(swiper, {
      $el: $el,
      el: el,
      $wrapperEl: $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box'
    });
    return true;
  };

  _proto.init = function init(el) {
    var swiper = this;
    if (swiper.initialized) return swiper;
    var mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit'); // Set breakpoint

    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    } // Add Classes


    swiper.addClasses(); // Create loop

    if (swiper.params.loop) {
      swiper.loopCreate();
    } // Update size


    swiper.updateSize(); // Update slides

    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    } // Set Grab Cursor


    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    } // Slide To Initial Slide


    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    } // Attach events


    swiper.attachEvents(); // Init Flag

    swiper.initialized = true; // Emit

    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  };

  _proto.destroy = function destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }

    if (cleanStyles === void 0) {
      cleanStyles = true;
    }

    var swiper = this;
    var params = swiper.params,
        $el = swiper.$el,
        $wrapperEl = swiper.$wrapperEl,
        slides = swiper.slides;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy'); // Init Flag

    swiper.initialized = false; // Detach events

    swiper.detachEvents(); // Destroy loop

    if (params.loop) {
      swiper.loopDestroy();
    } // Cleanup styles


    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');

      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
      }
    }

    swiper.emit('destroy'); // Detach emitter events

    Object.keys(swiper.eventsListeners).forEach(function (eventName) {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      deleteProps(swiper);
    }

    swiper.destroyed = true;
    return null;
  };

  Swiper.extendDefaults = function extendDefaults(newDefaults) {
    utils_extend(extendedDefaults, newDefaults);
  };

  Swiper.installModule = function installModule(module) {
    if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
    var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + now();
    Swiper.prototype.modules[name] = module;
  };

  Swiper.use = function use(module) {
    if (Array.isArray(module)) {
      module.forEach(function (m) {
        return Swiper.installModule(m);
      });
      return Swiper;
    }

    Swiper.installModule(module);
    return Swiper;
  };

  _createClass(Swiper, null, [{
    key: "extendedDefaults",
    get: function get() {
      return extendedDefaults;
    }
  }, {
    key: "defaults",
    get: function get() {
      return defaults;
    }
  }]);

  return Swiper;
}();

Object.keys(prototypes).forEach(function (prototypeGroup) {
  Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([resize_resize, observer]);
/* harmony default export */ var core_class = (Swiper);
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/navigation/navigation.js
function navigation_extends() { navigation_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return navigation_extends.apply(this, arguments); }



var Navigation = {
  toggleEl: function toggleEl($el, disabled) {
    $el[disabled ? 'addClass' : 'removeClass'](this.params.navigation.disabledClass);
    if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;
  },
  update: function update() {
    // Update Navigation Buttons
    var swiper = this;
    var params = swiper.params.navigation;
    var toggleEl = swiper.navigation.toggleEl;
    if (swiper.params.loop) return;
    var _swiper$navigation = swiper.navigation,
        $nextEl = _swiper$navigation.$nextEl,
        $prevEl = _swiper$navigation.$prevEl;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        toggleEl($prevEl, true);
      } else {
        toggleEl($prevEl, false);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $prevEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        toggleEl($nextEl, true);
      } else {
        toggleEl($nextEl, false);
      }

      if (swiper.params.watchOverflow && swiper.enabled) {
        $nextEl[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    }
  },
  onPrevClick: function onPrevClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick: function onNextClick(e) {
    var swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init: function init() {
    var swiper = this;
    var params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper.$el, swiper.params.navigation, swiper.params.createElements, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    var $nextEl;
    var $prevEl;

    if (params.nextEl) {
      $nextEl = dom(params.nextEl);

      if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }

    if (params.prevEl) {
      $prevEl = dom(params.prevEl);

      if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }

    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    utils_extend(swiper.navigation, {
      $nextEl: $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl: $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });

    if (!swiper.enabled) {
      if ($nextEl) $nextEl.addClass(params.lockClass);
      if ($prevEl) $prevEl.addClass(params.lockClass);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var _swiper$navigation2 = swiper.navigation,
        $nextEl = _swiper$navigation2.$nextEl,
        $prevEl = _swiper$navigation2.$prevEl;

    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }

    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }
};
/* harmony default export */ var navigation = ({
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      navigation: navigation_extends({}, Navigation)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge: function toEdge(swiper) {
      swiper.navigation.update();
    },
    fromEdge: function fromEdge(swiper) {
      swiper.navigation.update();
    },
    destroy: function destroy(swiper) {
      swiper.navigation.destroy();
    },
    'enable disable': function enableDisable(swiper) {
      var _swiper$navigation3 = swiper.navigation,
          $nextEl = _swiper$navigation3.$nextEl,
          $prevEl = _swiper$navigation3.$prevEl;

      if ($nextEl) {
        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }

      if ($prevEl) {
        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
      }
    },
    click: function click(swiper, e) {
      var _swiper$navigation4 = swiper.navigation,
          $nextEl = _swiper$navigation4.$nextEl,
          $prevEl = _swiper$navigation4.$prevEl;
      var targetEl = e.target;

      if (swiper.params.navigation.hideOnClick && !dom(targetEl).is($prevEl) && !dom(targetEl).is($nextEl)) {
        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
        var isHidden;

        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }

        if (isHidden === true) {
          swiper.emit('navigationShow');
        } else {
          swiper.emit('navigationHide');
        }

        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }

        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    }
  }
});
;// CONCATENATED MODULE: ./stories/js/modules/CardLayoutCarousel/index.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




core_class.use([navigation]);

function CardLayoutCarousel() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    /*selector: '.CardLayoutCarousel-contentPanel'*/
  },
      el = _ref.el;

  var transitionSpeed = 300;
  var swiperTarget = el.getAttribute('id');
  var leftButtonEl = document.getElementById('control-left-' + swiperTarget);
  var rightButtonEl = document.getElementById('control-right-' + swiperTarget);
  var cardsSwiper = new core_class(el, {
    effect: 'slide',
    speed: transitionSpeed,
    slidesPerView: 'auto',
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    watchOverflow: true,
    loop: false,
    navigation: {
      nextEl: rightButtonEl,
      prevEl: leftButtonEl
    }
  });
  revealElements();
  rightButtonEl.addEventListener('click', function (e) {
    var container = e.currentTarget.parentElement.parentElement;

    if (e.currentTarget.classList.contains('swiper-button-disabled')) {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.add('last-visible');
      });
    } else {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }
  });
  leftButtonEl.addEventListener('click', function (e) {
    var container = e.currentTarget.parentElement.parentElement;
    var lastVisibles = container.querySelectorAll('.last-visible');

    if (lastVisibles) {
      lastVisibles.forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }
  });
  return {
    destroy: function destroy() {
      cardsSwiper.detachEvents();
      cardsSwiper.destroy();
    }
  };
}

CardLayoutCarousel.defaultSelector = '.CardLayoutCarousel .swiper-container';

CardLayoutCarousel.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? CardLayoutCarousel.defaultSelector : _ref2$selector;

  return _toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return CardLayoutCarousel({
      el: el
    });
  });
};

/* harmony default export */ var modules_CardLayoutCarousel = (CardLayoutCarousel);
// EXTERNAL MODULE: ./node_modules/masonry-layout/masonry.js
var masonry = __webpack_require__(8751);
var masonry_default = /*#__PURE__*/__webpack_require__.n(masonry);
;// CONCATENATED MODULE: ./stories/js/modules/CardLayoutMasonry/index.js



function CardLayoutMasonry() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    selector: '.CardLayoutMasonry'
  },
      el = _ref.el;

  var msnry = new (masonry_default())(el, {
    // options
    itemSelector: '.CardLayoutMasonry-card',
    columnWidth: '.CardLayoutMasonry-card--grid-sizer',
    gutter: '.CardLayoutMasonry-card--gutter-sizer',
    percentPosition: true,
    initLayout: false
  });
  msnry.layout();
  revealElements();
}

/* harmony default export */ var modules_CardLayoutMasonry = (CardLayoutMasonry);
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/pagination/pagination.js
function pagination_extends() { pagination_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return pagination_extends.apply(this, arguments); }



var Pagination = {
  update: function update() {
    // Render || Update Pagination bullets/items
    var swiper = this;
    var rtl = swiper.rtl;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el; // Current/Total

    var current;
    var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }

      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    } // Types


    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      var bullets = swiper.pagination.bullets;
      var firstIndex;
      var lastIndex;
      var midIndex;

      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

          if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }

        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }

      bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

      if ($el.length > 1) {
        bullets.each(function (bullet) {
          var $bullet = dom(bullet);
          var bulletIndex = $bullet.index();

          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }

          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(params.bulletActiveClass + "-main");
            }

            if (bulletIndex === firstIndex) {
              $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
            }

            if (bulletIndex === lastIndex) {
              $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          }
        });
      } else {
        var $bullet = bullets.eq(current);
        var bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);

        if (params.dynamicBullets) {
          var $firstDisplayedBullet = bullets.eq(firstIndex);
          var $lastDisplayedBullet = bullets.eq(lastIndex);

          for (var i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(params.bulletActiveClass + "-main");
          }

          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
              for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
              }

              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
            } else {
              $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          } else {
            $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
            $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
          }
        }
      }

      if (params.dynamicBullets) {
        var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
        var offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
      }
    }

    if (params.type === 'fraction') {
      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
    }

    if (params.type === 'progressbar') {
      var progressbarDirection;

      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }

      var scale = (current + 1) / total;
      var scaleX = 1;
      var scaleY = 1;

      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }

      $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
    }

    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', $el[0]);
    } else {
      swiper.emit('paginationUpdate', $el[0]);
    }

    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  render: function render() {
    // Render Container
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    var $el = swiper.pagination.$el;
    var paginationHTML = '';

    if (params.type === 'bullets') {
      var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }

      for (var i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
        }
      }

      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
    }

    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + ("<span class=\"" + params.totalClass + "\"></span>");
      }

      $el.html(paginationHTML);
    }

    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
      }

      $el.html(paginationHTML);
    }

    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init: function init() {
    var swiper = this;
    swiper.params.pagination = createElementIfNotDefined(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
      el: 'swiper-pagination'
    });
    var params = swiper.params.pagination;
    if (!params.el) return;
    var $el = dom(params.el);
    if ($el.length === 0) return;

    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass("" + params.modifierClass + params.type + "-dynamic");
      swiper.pagination.dynamicBulletIndex = 0;

      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }

    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
        e.preventDefault();
        var index = dom(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    utils_extend(swiper.pagination, {
      $el: $el,
      el: $el[0]
    });

    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  },
  destroy: function destroy() {
    var swiper = this;
    var params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    var $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

    if (params.clickable) {
      $el.off('click', classesToSelector(params.bulletClass));
    }
  }
};
/* harmony default export */ var pagination = ({
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: function formatFractionCurrent(number) {
        return number;
      },
      formatFractionTotal: function formatFractionTotal(number) {
        return number;
      },
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-',
      // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable',
      // NEW
      lockClass: 'swiper-pagination-lock'
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      pagination: pagination_extends({
        dynamicBulletIndex: 0
      }, Pagination)
    });
  },
  on: {
    init: function init(swiper) {
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange: function activeIndexChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange: function snapIndexChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange: function slidesLengthChange(swiper) {
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange: function snapGridLengthChange(swiper) {
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy: function destroy(swiper) {
      swiper.pagination.destroy();
    },
    'enable disable': function enableDisable(swiper) {
      var $el = swiper.pagination.$el;

      if ($el) {
        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
      }
    },
    click: function click(swiper, e) {
      var targetEl = e.target;

      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !dom(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
        var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

        if (isHidden === true) {
          swiper.emit('paginationShow');
        } else {
          swiper.emit('paginationHide');
        }

        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    }
  }
});
;// CONCATENATED MODULE: ./stories/js/modules/CardLayoutProductDetailsSlider/index.js



core_class.use([pagination]);

function CardLayoutProductDetailsSlider() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    selector: '.CardLayoutProductDetailsSlider'
  },
      el = _ref.el;

  var transitionSpeed = 300;
  var swiperTarget = el.getAttribute('id');
  var leftButtonEl = document.getElementById('control-left-' + swiperTarget);
  var rightButtonEl = document.getElementById('control-right-' + swiperTarget);
  var contentSwiper = new core_class(el, {
    effect: 'slide',
    speed: transitionSpeed,
    slidesPerView: 'auto',
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    pagination: {
      el: '#pagination-' + swiperTarget,
      type: 'progressbar'
    },
    navigation: {
      nextEl: rightButtonEl,
      prevEl: leftButtonEl
    }
  });
  revealElements();
  return {
    destroy: function destroy() {
      contentSwiper.detachEvents();
      contentSwiper.destroy();
    }
  };
}

/* harmony default export */ var modules_CardLayoutProductDetailsSlider = (CardLayoutProductDetailsSlider);
;// CONCATENATED MODULE: ./stories/js/modules/FeatureContentLayout/index.js
function FeatureContentLayout() {}

/* harmony default export */ var modules_FeatureContentLayout = (FeatureContentLayout);
;// CONCATENATED MODULE: ./stories/js/modules/FeaturedContent/index.js


function FeaturedContent() {
  revealElements();
}

/* harmony default export */ var modules_FeaturedContent = (FeaturedContent);
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/autoplay/autoplay.js
function autoplay_extends() { autoplay_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return autoplay_extends.apply(this, arguments); }

/* eslint no-underscore-dangle: "off" */


var Autoplay = {
  run: function run() {
    var swiper = this;
    var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    var delay = swiper.params.autoplay.delay;

    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }

    clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.timeout = nextTick(function () {
      var autoplayResult;

      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }

      if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();else if (autoplayResult === false) {
        swiper.autoplay.run();
      }
    }, delay);
  },
  start: function start() {
    var swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop: function stop() {
    var swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }

    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause: function pause(speed) {
    var swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;

    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        swiper.$wrapperEl[0].addEventListener(event, swiper.autoplay.onTransitionEnd);
      });
    }
  },
  onVisibilityChange: function onVisibilityChange() {
    var swiper = this;
    var document = getDocument();

    if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
      swiper.autoplay.pause();
    }

    if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
      swiper.autoplay.run();
      swiper.autoplay.paused = false;
    }
  },
  onTransitionEnd: function onTransitionEnd(e) {
    var swiper = this;
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
    if (e.target !== swiper.$wrapperEl[0]) return;
    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);
    });
    swiper.autoplay.paused = false;

    if (!swiper.autoplay.running) {
      swiper.autoplay.stop();
    } else {
      swiper.autoplay.run();
    }
  },
  onMouseEnter: function onMouseEnter() {
    var swiper = this;

    if (swiper.params.autoplay.disableOnInteraction) {
      swiper.autoplay.stop();
    } else {
      swiper.autoplay.pause();
    }

    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      swiper.$wrapperEl[0].removeEventListener(event, swiper.autoplay.onTransitionEnd);
    });
  },
  onMouseLeave: function onMouseLeave() {
    var swiper = this;

    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }

    swiper.autoplay.paused = false;
    swiper.autoplay.run();
  },
  attachMouseEvents: function attachMouseEvents() {
    var swiper = this;

    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on('mouseenter', swiper.autoplay.onMouseEnter);
      swiper.$el.on('mouseleave', swiper.autoplay.onMouseLeave);
    }
  },
  detachMouseEvents: function detachMouseEvents() {
    var swiper = this;
    swiper.$el.off('mouseenter', swiper.autoplay.onMouseEnter);
    swiper.$el.off('mouseleave', swiper.autoplay.onMouseLeave);
  }
};
/* harmony default export */ var autoplay = ({
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      autoplay: autoplay_extends({}, Autoplay, {
        running: false,
        paused: false
      })
    });
  },
  on: {
    init: function init(swiper) {
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
        var document = getDocument();
        document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
        swiper.autoplay.attachMouseEvents();
      }
    },
    beforeTransitionStart: function beforeTransitionStart(swiper, speed, internal) {
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove: function sliderFirstMove(swiper) {
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    touchEnd: function touchEnd(swiper) {
      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.run();
      }
    },
    destroy: function destroy(swiper) {
      swiper.autoplay.detachMouseEvents();

      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }

      var document = getDocument();
      document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
    }
  }
});
;// CONCATENATED MODULE: ./node_modules/swiper/esm/components/effect-fade/effect-fade.js
function effect_fade_extends() { effect_fade_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return effect_fade_extends.apply(this, arguments); }


var Fade = {
  setTranslate: function setTranslate() {
    var swiper = this;
    var slides = swiper.slides;

    for (var i = 0; i < slides.length; i += 1) {
      var $slideEl = swiper.slides.eq(i);
      var offset = $slideEl[0].swiperSlideOffset;
      var tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      var ty = 0;

      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }

      var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl.css({
        opacity: slideOpacity
      }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
    }
  },
  setTransition: function setTransition(duration) {
    var swiper = this;
    var slides = swiper.slides,
        $wrapperEl = swiper.$wrapperEl;
    slides.transition(duration);

    if (swiper.params.virtualTranslate && duration !== 0) {
      var eventTriggered = false;
      slides.transitionEnd(function () {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

        for (var i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  }
};
/* harmony default export */ var effect_fade = ({
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false
    }
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      fadeEffect: effect_fade_extends({}, Fade)
    });
  },
  on: {
    beforeInit: function beforeInit(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(swiper.params.containerModifierClass + "fade");
      var overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true
      };
      utils_extend(swiper.params, overwriteParams);
      utils_extend(swiper.originalParams, overwriteParams);
    },
    setTranslate: function setTranslate(swiper) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition: function setTransition(swiper, duration) {
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    }
  }
});
// EXTERNAL MODULE: ./node_modules/ua-parser-js/src/ua-parser.js
var ua_parser = __webpack_require__(2238);
var ua_parser_default = /*#__PURE__*/__webpack_require__.n(ua_parser);
;// CONCATENATED MODULE: ./stories/js/modules/ContentLayoutCarousel/index.js
function ContentLayoutCarousel_toConsumableArray(arr) { return ContentLayoutCarousel_arrayWithoutHoles(arr) || ContentLayoutCarousel_iterableToArray(arr) || ContentLayoutCarousel_unsupportedIterableToArray(arr) || ContentLayoutCarousel_nonIterableSpread(); }

function ContentLayoutCarousel_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ContentLayoutCarousel_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ContentLayoutCarousel_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ContentLayoutCarousel_arrayLikeToArray(o, minLen); }

function ContentLayoutCarousel_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function ContentLayoutCarousel_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return ContentLayoutCarousel_arrayLikeToArray(arr); }

function ContentLayoutCarousel_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable no-param-reassign,no-return-assign */



core_class.use([autoplay, effect_fade]);

var ContentLayoutCarousel = function ContentLayoutCarousel() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      el = _ref.el;

  var autoplayDelay = 5000;
  var transitionSpeed = 300;
  var singleSlideClass = 'ContentLayoutCarousel--singleSlide';
  var bgSwiperEl = el.querySelector('.ContentLayoutCarousel-backgroundContainer .swiper-container');
  var contentSwiperEl = el.querySelector('.ContentLayoutCarousel-contentPanel .swiper-container');
  var SliderSwiperEl = el.querySelector('.ContentLayoutCarousel-contentPanel .swiper-wrapper');
  var SliderActiveEl = el.querySelector('.ContentLayoutCarousel-contentPanel .swiper-slide-active');
  var leftButtonEl = el.querySelector('.ContentLayoutCarousel-navArrowButton-left');
  var paginationContainerEl = el.querySelector('.ContentLayoutCarousel-paginationContainer');
  var rightButtonEl = el.querySelector('.ContentLayoutCarousel-navArrowButton-right');
  var browserInfo = new (ua_parser_default())().getBrowser();
  var isAutoplayRunning = true;

  var isSingleSlide = function () {
    if (el.classList.contains(singleSlideClass) || contentSwiperEl.querySelector('.swiper-wrapper').children.length < 2) {
      el.classList.add(singleSlideClass);
      return true;
    }
  }();

  var bgSwiper = new core_class(bgSwiperEl, {
    effect: 'fade',
    fadeEffect: {
      crossFade: true
    }
  });
  var contentSwiper = new core_class(contentSwiperEl, {
    // NOTE: Auto height does not work on IE11.
    allowTouchMove: !isSingleSlide,
    autoHeight: !(browserInfo.name === 'IE' && /^11/.test(browserInfo.version)),
    autoplay: isSingleSlide ? false : {
      delay: autoplayDelay
    },
    effect: 'fade',
    fadeEffect: {
      crossFade: true
    },
    loop: true,
    speed: transitionSpeed
  });

  var updateProgressBars = function updateProgressBars() {
    paginationContainerEl.querySelectorAll('.ContentLayoutCarousel-paginationButton-progressBar').forEach(function (barEl, i) {
      var isActiveIndex = i === contentSwiper.realIndex;
      barEl.style.transition = isActiveIndex && isAutoplayRunning ? "width ".concat(autoplayDelay + transitionSpeed, "ms linear") : 'none';
      barEl.style.width = isActiveIndex ? '100%' : 0;
    });
  };

  var old = 0;

  var setSwiperHeightForIE = function setSwiperHeightForIE() {
    if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version) && !isSingleSlide) {
      SliderActiveEl = contentSwiperEl.querySelector('.swiper-slide-active');

      if (SliderActiveEl) {
        SliderActiveEl.style.height = 'auto';
        SliderSwiperEl.style.height = 'auto';

        if (old != contentSwiper.realIndex) {
          SliderSwiperEl.style.height = SliderActiveEl.clientHeight + 'px';
          old = contentSwiper.realIndex;
        }
      }
    }
  };

  leftButtonEl.addEventListener('click', leftButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slidePrev();
  });
  rightButtonEl.addEventListener('click', rightButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slideNext();
  });
  contentSwiper.on('slideChange', function () {
    bgSwiper.slideTo(contentSwiper.realIndex);
    updateProgressBars();
  });
  contentSwiper.on('transitionEnd', function () {
    //console.log('*** contentSwiper.realIndex', contentSwiper.realIndex);
    setSwiperHeightForIE();
  });
  contentSwiper.on('autoplayStop', function () {
    return isAutoplayRunning = false;
  });
  paginationContainerEl.children.forEach(function (child, i) {
    return child.addEventListener('click', child.handleClick = function () {
      contentSwiper.autoplay.stop();
      contentSwiper.slideToLoop(i);
    });
  });
  setSwiperHeightForIE();
  updateProgressBars();
  return {
    destroy: function destroy() {
      bgSwiper.destroy();
      contentSwiper.detachEvents();
      contentSwiper.destroy();
      leftButtonEl.removeEventListener('click', leftButtonEl.handleClick);
      rightButtonEl.removeEventListener('click', rightButtonEl.handleClick);
      paginationContainerEl.children.forEach(function (child) {
        return child.removeEventListener('click', child.handleClick);
      });
    }
  };
};

ContentLayoutCarousel.defaultSelector = '.ContentLayoutCarousel';

ContentLayoutCarousel.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? ContentLayoutCarousel.defaultSelector : _ref2$selector;

  return ContentLayoutCarousel_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return ContentLayoutCarousel({
      el: el
    });
  });
};

/* harmony default export */ var modules_ContentLayoutCarousel = (ContentLayoutCarousel);
// EXTERNAL MODULE: ./node_modules/choices.js/public/assets/scripts/choices.js
var choices = __webpack_require__(4529);
var choices_default = /*#__PURE__*/__webpack_require__.n(choices);
;// CONCATENATED MODULE: ./stories/js/modules/Form/placeholders.js
/* floatl version 2.0.1 */
function placeholders_addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += ' ' + className;
  }
}

function placeholders_removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var re = new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi');
    element.className = element.className.replace(re, ' ');
  }
}

function addEventListener(element, event, cb) {
  if (element.addEventListener) {
    element.addEventListener(event, cb);
  } else {
    element.attachEvent('on' + event, function () {
      cb.call(element);
    });
  }
}

function removeEventListener(element, event, cb) {
  if (element.removeEventListener) {
    element.removeEventListener(event, cb);
  } else {
    element.detachEvent('on' + event, cb);
  }
}

var Placeholder =
/** @class */
function () {
  function Placeholder(element) {
    var _this = this;

    this.handleChange = function () {
      if (_this.input.value === '') {
        placeholders_removeClass(_this.element, Placeholder.ACTIVE_CLASS);
      } else {
        placeholders_addClass(_this.element, Placeholder.ACTIVE_CLASS);
      }
    };

    this.addFocusedClass = function () {
      if (!_this.element.classList.contains('Form-group-file')) {
        placeholders_addClass(_this.element, Placeholder.FOCUSED_CLASS);
      }
    };

    this.removeFocusedClass = function () {
      if (!_this.element.classList.contains('Form-group-file')) {
        placeholders_removeClass(_this.element, Placeholder.FOCUSED_CLASS);
      }
    };

    this.element = element;
    this.label = element.querySelectorAll('[data-placeholder-label]')[0];
    this.input = element.querySelectorAll('[data-placeholder-input]')[0]; // Return early if not both the label and input are present

    if (!this.label || !this.input) {
      return;
    }

    if (this.input.nodeName === 'TEXTAREA') {
      placeholders_addClass(this.element, Placeholder.MULTILINE_CLASS);
    }

    if (this.input.getAttribute('required') != null) {
      placeholders_addClass(this.element, Placeholder.MREQUIRED_CLASS);
    } // Handle initial value


    this.handleChange(); // Bind event listeners

    addEventListener(this.input, 'focus', this.addFocusedClass);
    addEventListener(this.input, 'blur', this.removeFocusedClass);

    for (var _i = 0, _a = ['keyup', 'blur', 'change', 'input']; _i < _a.length; _i++) {
      var event_1 = _a[_i];
      addEventListener(this.input, event_1, this.handleChange);
    }
  }

  Placeholder.prototype.destroy = function () {
    removeEventListener(this.input, 'focus', this.addFocusedClass);
    removeEventListener(this.input, 'blur', this.removeFocusedClass);

    for (var _i = 0, _a = ['keyup', 'blur', 'change', 'input']; _i < _a.length; _i++) {
      var event_2 = _a[_i];
      removeEventListener(this.input, event_2, this.handleChange);
    }
  };

  Placeholder.FOCUSED_CLASS = 'is-focused';
  Placeholder.ACTIVE_CLASS = 'is-active';
  Placeholder.MULTILINE_CLASS = 'is-multiline';
  Placeholder.MREQUIRED_CLASS = 'is-required';
  return Placeholder;
}();

/* harmony default export */ var placeholders = (Placeholder);
;// CONCATENATED MODULE: ./stories/js/components/MFDropdown.js
var MFDropdown = function MFDropdown(container, options) {
  var container = document.querySelectorAll(container);

  if (container && container.length > 0) {
    return container.forEach(function (c) {
      new MFDropdown()._init(c, options);
    });
  }
};

MFDropdown.fn = MFDropdown.prototype = {
  constructor: MFDropdown,
  _defaults: {
    dropClass: 'MFDropdown',
    dropButtonClass: 'MFDropdown-btn',
    dropMenuClass: 'MFDropdown-menu',
    dropHeaderClass: 'MFDropdown-header',
    dropToggleClass: 'MFDropdown-toggle',
    dropItemClass: 'MFDropdown-item',
    dropLinkClass: 'MFDropdown-link',
    focusedClass: 'is-focused',
    activeClass: 'is-active',
    requiredClass: 'is-required',
    errorClass: 'is-error',
    selectedClass: 'selected',
    disabledClass: 'disabled',
    openedClass: 'opened',
    multiClass: 'multi',
    control: 'href',
    placeholder: 'Select'
  },
  _init: function _init(container, options) {
    this._setElements(container, options);

    this._buildDropdownButton();

    this._buildDropdownToggle();

    this._buildDropdownMenu();

    if (this.dropdown.querySelector('.Form-help')) {
      this.dropdown.appendChild(this.dropdown.querySelector('.Form-help'));
    }

    this._bindEvents();

    return this;
  },
  _setElements: function _setElements(container, options) {
    this.opts = Object.assign({}, this._defaults, options);
    this.dropdown = container;
    this.select = this.dropdown.querySelector('select');
    this.optionGroups = this.select.querySelectorAll('optgroup');
    this.options = this.select.querySelectorAll('option:not([value=""]');
    this.dropButton = this.dropdown.getElementsByClassName(this.opts.dropButtonClass);
    this.dropItems = this.dropdown.getElementsByClassName(this.opts.dropItemClass);
    this.dropLinks = this.dropdown.getElementsByClassName(this.opts.dropLinkClass);
    this.isMulti = this.select.getAttribute('multiple') != null ? true : false;
    this.isRequired = false;
    this.length = this.options.length;
  },
  _buildDropdownButton: function _buildDropdownButton() {
    var that = this;
    var hinput = document.createElement('input');
    hinput.setAttribute('type', 'hidden');
    that.hiddenInput = hinput;
    var type = that.select.getAttribute('data-template') != null ? that.select.getAttribute('data-template') : 'input';
    var input = document.createElement(type);
    input.className = that.opts.dropButtonClass + ' Form-input';

    if (that.select.parentElement.querySelector('[data-placeholder-label]')) {
      var newLable = that.select.parentElement.querySelector('[data-placeholder-label]').textContent;
      input.setAttribute('placeholder', newLable);
    } else {
      if (that.select.getAttribute('placeholder') != null) {
        input.setAttribute('placeholder', that.select.getAttribute('placeholder'));
      } else {
        input.setAttribute('placeholder', that.opts.placeholder);
      }
    }

    if (type.toLowerCase() != 'input') {
      if (that.select.parentElement.querySelector('[data-placeholder-label]')) {
        input.innerHTML = that.select.parentElement.querySelector('[data-placeholder-label]').textContent;
      } else {
        input.innerHTML = input.getAttribute('placeholder');
      }
    }

    input.setAttribute('data-placeholder-input', '');

    if (that.select.getAttribute('required') != null) {
      input.setAttribute('required', '');
      that.dropdown.classList.add(that.opts.requiredClass);
      that.isRequired = true;
    }

    if (that.select.getAttribute('disabled') != null) {
      input.setAttribute('disabled', '');
    }

    if (that.isMulti) {
      that.dropdown.classList.add(that.opts.multiClass);
    }

    input.setAttribute('readonly', '');
    var hasSelected = false;
    var selectedString = '';
    var selectedHiddenString = '';
    that.options.forEach(function (option) {
      if (option.getAttribute('selected') != null) {
        hasSelected = true;
        selectedString += option.innerHTML + ',';
        selectedHiddenString += option.value + ',';
      }
    });

    if (hasSelected) {
      input.value = selectedString.slice(0, -1); //To get select opt text to display

      hinput.value = selectedHiddenString.slice(0, -1); //To get select opt value to submit
    }

    hinput.id = that.select.id ? that.select.id : '';
    that.select.id = '';
    hinput.name = that.select.name ? that.select.name : '';
    that.select.name = '';
    that.dropdown.appendChild(input);
    that.dropdown.appendChild(hinput);
  },
  _buildDropdownToggle: function _buildDropdownToggle() {
    var that = this;
    var span = document.createElement('span');
    span.className = that.opts.dropToggleClass;
    that.dropdown.appendChild(span);
  },
  _buildDropdownMenu: function _buildDropdownMenu() {
    var that = this;
    var html = '';
    var ul = document.createElement('ul');
    ul.className = that.opts.dropMenuClass;

    if (that.optionGroups && that.optionGroups.length > 0) {
      that.optionGroups.forEach(function (group, i) {
        html += '<li class="' + that.opts.dropHeaderClass + '">' + group.getAttribute('label') + '</li>';
        group.querySelectorAll('option').forEach(function (option, j) {
          var selectedClass = option.getAttribute('selected') != null ? 'selected' : '';
          var liClass = that.opts.dropItemClass + ' ' + group.nodeName + '-' + i + ' ' + selectedClass;
          html += '<li class="' + liClass + '"><a class="' + that.opts.dropLinkClass + '" data-value="' + option.value + '">' + option.innerHTML + '</a></li>';
        });
      });
    } else {
      that.options.forEach(function (option, j) {
        var selectedClass = option.getAttribute('selected') != null ? 'selected' : '';
        var liClass = that.opts.dropItemClass + ' ' + selectedClass;
        html += '<li class="' + liClass + '"><a class="' + that.opts.dropLinkClass + '" data-value="' + option.value + '">' + option.innerHTML + '</a></li>';
      });
    }

    ul.innerHTML = html;
    this.dropdown.appendChild(ul);
  },
  _checkMAX: function _checkMAX(array, max) {
    that.checkMAX = array.length <= max;
  },
  _bindEvents: function _bindEvents() {
    var _this = this;

    var that = this;
    that.dropButton = that.dropdown.getElementsByClassName(that.opts.dropButtonClass)[0];
    that.dropToggle = that.dropdown.getElementsByClassName(that.opts.dropToggleClass)[0];
    that.dropItems = that.dropdown.getElementsByClassName(that.opts.dropItemClass);
    that.dropButton.addEventListener('blur', function (e) {//that.dropdown.classList.remove(that.opts.focusedClass);
    });
    that.dropButton.addEventListener('click', function (e) {
      that.dropdown.classList.add('clicking');
      that.dropdown.classList.toggle(that.opts.openedClass);

      if (that.dropdown.classList.contains(that.opts.openedClass)) {
        that.dropdown.classList.add(that.opts.focusedClass);
      } else {
        that.dropdown.classList.remove(that.opts.focusedClass);

        that._updateStatus();

        that.dropdown.classList.remove('clicking');
      }
    });
    that.dropToggle.addEventListener('click', function (e) {
      that.dropdown.classList.add('clicking');
      that.dropdown.classList.toggle(that.opts.openedClass);

      if (that.dropdown.classList.contains(that.opts.openedClass)) {
        that.dropdown.classList.add(that.opts.focusedClass);
      } else {
        that.dropdown.classList.remove(that.opts.focusedClass);

        that._updateStatus();

        that.dropdown.classList.remove('clicking');
      }
    });
    that.dropItems.forEach(function (item) {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        var value = e.currentTarget.querySelector('.' + that.opts.dropLinkClass).innerHTML;
        var hvalue = e.currentTarget.querySelector('.' + that.opts.dropLinkClass).getAttribute('data-value');

        if (that.dropdown.classList.contains('is-error')) {
          that.dropdown.classList.remove('is-error');
        }

        if (!that.isMulti) {
          Array.from(that.dropItems).filter(function (i) {
            return i.classList.contains(that.opts.selectedClass);
          }).forEach(function (j) {
            j.classList.toggle(that.opts.selectedClass);
          });
          e.currentTarget.classList.toggle(that.opts.selectedClass);
          that.dropButton.value = value;
          that.hiddenInput.value = hvalue;
          that.dropdown.classList.toggle(that.opts.openedClass);
        } else {
          var valueArray = that.dropButton.value != '' ? Array.from(that.dropButton.value.split(', ')) : [];
          var hvalueArray = that.hiddenInput.value != '' ? Array.from(that.hiddenInput.value.split(', ')) : [];

          if (that.optionGroups && that.optionGroups.length > 0) {
            var gArray = Array.from(e.currentTarget.classList).filter(function (i) {
              return i.indexOf('OPTGROUP-') != -1;
            });

            if (gArray.length > 0) {
              var selectedGroupItems = that.dropdown.querySelectorAll('.' + gArray[0] + '.' + that.opts.selectedClass);
              var g = that.select.querySelectorAll('optgroup')[gArray[0].split('-')[1]];
              var gmax = g.getAttribute('data-max-options') ? g.getAttribute('data-max-options') : null;

              if (!e.currentTarget.classList.contains(that.opts.selectedClass)) {
                if (selectedGroupItems.length < gmax || gmax == null) {
                  e.currentTarget.classList.add(that.opts.selectedClass);
                }
              } else {
                e.currentTarget.classList.remove(that.opts.selectedClass);
              }
            }
          } else {
            var max = that.select.getAttribute('data-max-options') ? that.select.getAttribute('data-max-options') : null;

            if (!e.currentTarget.classList.contains(that.opts.selectedClass)) {
              if (valueArray.length < max || max == null) {
                e.currentTarget.classList.add(that.opts.selectedClass);
              }
            } else {
              e.currentTarget.classList.remove(that.opts.selectedClass);
            }
          }

          if (e.currentTarget.classList.contains(that.opts.selectedClass)) {
            if (valueArray.indexOf(value) == -1) {
              valueArray.push(value);
            }

            that.dropButton.value = valueArray.join(', ');

            if (hvalueArray.indexOf(hvalue) == -1) {
              hvalueArray.push(hvalue);
            }

            that.hiddenInput.value = hvalueArray.join(', ');
          } else {
            valueArray = valueArray.filter(function (i) {
              return i != value;
            });
            that.dropButton.value = valueArray.join(', ');
            hvalueArray = hvalueArray.filter(function (i) {
              return i != hvalue;
            });
            that.hiddenInput.value = hvalueArray.join(', ');
          }
        } //if (that.dropButton.value != '') {
        //that.dropdown.classList.add(that.opts.focusedClass);
        //   that.dropdown.classList.add(that.opts.activedClass);
        //} else {
        //that.dropdown.classList.remove(that.opts.focusedClass);
        //  that.dropdown.classList.remove(that.opts.activedClass);
        // }


        if (!that.isMult) {
          that._triggerSelect(hvalue);
        } else {
          that._triggerSelect(hvalueArray);
        }

        that._updateStatus();
      });
    });
    document.addEventListener('click', function (e) {
      var that = _this;
      var inside = that.dropdown.contains(e.target);

      if (!inside) {
        that.dropdown.classList.remove(that.opts.focusedClass);
        that.dropdown.classList.remove(that.opts.openedClass);

        if (that.dropdown.classList.contains('clicking')) {
          that._updateStatus();

          that.dropdown.classList.remove('clicking');
        }
      }
    }, false);
  },
  _triggerSelect: function _triggerSelect(value) {
    var that = this;

    if (that.select) {
      that.select.value = value;
    }
  },
  _updateStatus: function _updateStatus(target) {
    var that = this;

    if (that.dropButton.value != '') {
      that.dropdown.classList.add(that.opts.activeClass);
      that.dropdown.classList.remove('is-error');
      that.dropdown.classList.add('is-success');
    } else {
      that.dropdown.classList.remove(that.opts.activeClass);

      if (that.isRequired) {
        that.dropdown.classList.remove('is-success');
        that.dropdown.classList.add('is-error');
      }
    }

    that.dropdown.classList.remove(that.opts.focusedClass);

    that._complete();
  },
  _complete: function _complete(callback) {
    var that = this;
    var customEvent = new CustomEvent('mf.dropdown', {
      detail: {
        ele: that
      }
    });

    if (window.dispatchEvent) {
      that.dropdown.dispatchEvent(customEvent);
    } else {
      that.dropdown.fireEvent(customEvent);
    }

    callback && callback();
  },
  length: 0,
  push: [].push,
  sort: [].sort,
  splice: [].splice
};
/* harmony default export */ var components_MFDropdown = (MFDropdown);
;// CONCATENATED MODULE: ./stories/js/modules/Form/index.js




function Form() {
  console.log('Form');
  var pelements = document.querySelectorAll('.placeholder-element');
  var velements = document.querySelectorAll('.value-element');
  var fgroups = document.querySelectorAll('.Form-group');
  var groups = document.querySelectorAll('[data-placeholder]');
  var selects = document.querySelectorAll('[data-select]');
  var selectOptions = {
    shouldSort: false
  };
  pelements.forEach(function (pelement) {
    var id = pelement.id;

    if (id) {
      var label = pelement.parentElement.querySelector('label[for="' + id + '"]');

      if (label) {
        pelement.placeholder = label.textContent;
      }
    }
  });
  velements.forEach(function (velement) {
    var id = velement.id;

    if (id) {
      var label = velement.parentElement.querySelector('label[for="' + id + '"]');

      if (label) {
        velement.value = label.textContent;
      }
    }
  });
  fgroups.forEach(function (fgroup) {
    var label = fgroup.querySelector('[data-placeholder-label]');

    if (label) {
      var eles = fgroup.querySelectorAll('[placeholder]');
      eles.forEach(function (ele) {
        ele.placeholder = label.textContent;
      });
    }
  });
  groups.forEach(function (group) {
    var placeholder = new placeholders(group);
    console.log(placeholder);
  });
  var dropdowns = components_MFDropdown('.MFDropdown');
  var inputs = document.querySelectorAll('[data-placeholder-input]');
  inputs.forEach(function (input) {
    input.addEventListener('blur', function (e) {
      if (e.currentTarget.getAttribute('required') != undefined && e.currentTarget.getAttribute('data-placeholder-file') == undefined && !e.currentTarget.parentElement.classList.contains('MFDropdown')) {
        if (e.currentTarget.value.trim() == '') {
          e.currentTarget.parentElement.classList.remove('is-success');
          e.currentTarget.parentElement.classList.add('is-error');
        } else {
          e.currentTarget.parentElement.classList.remove('is-error');
          e.currentTarget.parentElement.classList.add('is-success');
        }
      }

      var type = input.getAttribute('type');

      if (type && type.toLocaleLowerCase() == 'email') {
        var reMail = /^(?:[a-zA-Z0-9]+[_\-\+\.]?)*[a-zA-Z0-9]+@(?:([a-zA-Z0-9]+[_\-]?)*[a-zA-Z0-9]+\.)+([a-zA-Z]{2,})+$/;

        if (!reMail.test(e.currentTarget.value)) {
          e.currentTarget.parentElement.classList.remove('is-success');
          e.currentTarget.parentElement.classList.add('is-error');
        } else {
          e.currentTarget.parentElement.classList.remove('is-error');
          e.currentTarget.parentElement.classList.add('is-success');
        }
      }
    });
  });
  selects.forEach(function (select) {
    new (choices_default())(select, selectOptions);
    console.log('SELECT:', select);
  });
  var radioboxes = document.querySelectorAll(".Form-group-rcbox input[type='radio']");
  var checkboxes = document.querySelectorAll(".Form-group-rcbox input[type='checkbox']");
  checkboxes.forEach(function (box) {
    if (box.getAttribute('required') != null) {
      box.closest('.Form-group-rcbox').classList.add('is-required');
    }

    box.addEventListener('click', function (e) {
      updateRCBoxStatus(e.currentTarget);
    });
  });
  radioboxes.forEach(function (box) {
    if (box.getAttribute('required') != null) {
      box.closest('.Form-group-rcbox').classList.add('is-required');
    }

    box.addEventListener('click', function (e) {
      updateRCBoxStatus(e.currentTarget);
    });
  });

  var updateRCBoxStatus = function updateRCBoxStatus(box) {
    if (box && box.getAttribute('required') != null) {
      if (box.checked) {
        box.closest('.Form-group-rcbox').classList.remove('is-error');
        box.closest('.Form-group-rcbox').classList.add('is-success');
      } else {
        box.closest('.Form-group-rcbox').classList.remove('is-success');
        box.closest('.Form-group-rcbox').classList.add('is-error');
      }
    }
  };

  var validateRCBox = function validateRCBox(id) {
    var form = document.getElementById(id);

    if (form) {
      var _radioboxes = form.querySelectorAll(".Form-group-rcbox input[type='radio']");

      var _checkboxes = form.querySelectorAll(".Form-group-rcbox input[type='checkbox']");

      _checkboxes.forEach(function (box) {
        updateRCBoxStatus(box);
      });

      _radioboxes.forEach(function (box) {
        if (box.getAttribute('required') != null) {
          updateRCBoxStatus(box);
        }
      });
    }
  };

  var fileInput = document.querySelectorAll('[data-placeholder-file]');
  var fileUpload = document.querySelectorAll('.Form-fileupload');
  var fileClear = document.querySelectorAll('.Form-fileclear');
  fileInput.forEach(function (input) {
    input.addEventListener('click', function (e) {
      var upload = e.currentTarget.parentElement.querySelector('.Form-fileupload');
      e.currentTarget.parentElement.classList.add('is-focused');
      e.currentTarget.parentElement.classList.add('is-clicked');

      if (upload) {
        upload.click();
      }
    });
  });
  fileUpload.forEach(function (upload) {
    upload.addEventListener('change', function (e) {
      var files = e.currentTarget.files;
      var parentE = e.currentTarget.parentElement;
      var fileContainer = parentE.querySelector('.file-name');

      if (files && files.length > 0) {
        fileContainer.innerHTML = files[0].name;
        parentE.querySelector('.Form-input').value = fileContainer.innerHTML;

        if (parentE.classList.contains('is-error')) {
          parentE.classList.remove('is-error');
        }

        parentE.classList.add('is-success');
      } else {
        if (parentE.querySelector('.Form-input').value != '') {
          parentE.classList.remove('is-error');
          parentE.classList.add('is-success');
        }
      }
    });
  });
  fileClear.forEach(function (clear) {
    clear.addEventListener('click', function (e) {
      var parentE = e.currentTarget.parentElement;
      parentE.querySelector('.Form-fileupload').value = null;
      parentE.querySelector('.Form-input').value = null;
      var fileContainer = parentE.querySelector('.file-name');
      fileContainer.innerHTML = '';
      parentE.classList.remove('is-success');

      if (parentE.classList.contains('is-active')) {
        parentE.classList.remove('is-active');
      }

      if (parentE.querySelector('.Form-input').getAttribute('required') != undefined) {
        parentE.classList.remove('is-success');
        parentE.classList.add('is-error');
      } //parentE.classList.remove('is-focused');

    }, false);
  });

  window.onfocus = function () {
    setTimeout(function () {
      fileUpload.forEach(function (upload) {
        var parentE = upload.parentElement;
        parentE.classList.remove('is-focused');

        if (upload.value.length == 0 && parentE.querySelector('.Form-input').value == '') {
          if (parentE.classList.contains('is-required') && parentE.classList.contains('is-clicked')) {
            parentE.classList.add('is-error');
          }
        } else {
          parentE.classList.remove('is-error');
        }
      });
    }, 100);
  };

  var submits = document.querySelectorAll('[data-submit]');
  submits.forEach(function (submit) {
    submit.addEventListener('click', function (e) {
      var id = e.currentTarget.getAttribute('data-submit');
      var form = document.getElementById(id);

      if (form) {
        if (form.querySelectorAll('.is-error').length == 0) {
          form.querySelectorAll('.is-required').forEach(function (ele) {
            if (!ele.classList.contains('is-success')) {
              ele.classList.add('is-error');
            }
          });
        }

        validateRCBox(id);

        if (form.querySelectorAll('.is-error').length != 0) {
          e.preventDefault();
          return false;
        }
      } //add follow check in detail form submit logic.
      //validateForSubmit(form);

    });
  });

  var validateForSubmit = function validateForSubmit(form) {
    var noError = form.find('.is-error').length == 0 && form.find('.is-required').length == form.find('.is-success').length;

    if (noError) {// post data.
    } else {
      if (form.find('.is-error').length == 0) {
        form.find('.is-required').not('.is-success').addClass('is-error');
      }
    }
  };
}

/* harmony default export */ var modules_Form = (Form);
;// CONCATENATED MODULE: ./stories/js/modules/Footer/index.js
function Footer() {
  console.log('Footer');
}

/* harmony default export */ var modules_Footer = (Footer);
;// CONCATENATED MODULE: ./stories/js/modules/NavigationMenu/index.js
// import { Group, Panel, Trigger } from 'lego-toggle';
// import state from 'lego-state';
// import MobileNav from 'lego-mobile-nav';
function MobileMenu() {
  var body = document.body;
  var mobileMenu = document.querySelector('[data-mobilemenu]');
  var mobileMenuTriggers = document.querySelectorAll('[data-mobilemenu-trigger]');
  var mobileSubmenus = document.querySelectorAll('[data-submenu]');
  var submenuTriggers = document.querySelectorAll('[data-submenu-trigger]');
  mobileMenuTriggers.forEach(function (trigger) {
    trigger.addEventListener('click', function () {
      mobileMenuTriggers.forEach(function () {
        return trigger.classList.toggle('is-active');
      });
      document.body.classList.toggle('is-mobileMenuOpen');
      mobileMenu.classList.toggle('is-open');
      mobileMenu.querySelector('.MobileMenu-subMenus-menu').classList.remove('is-open');
      body.classList.remove('is-submenuOpen');
      body.classList.remove('is-submenuChildOpen');
    });
  });
  submenuTriggers.forEach(function (trigger) {
    var submenuName = trigger.dataset.submenuTrigger;
    trigger.addEventListener('click', function () {
      mobileSubmenus.forEach(function (submenu) {
        submenu.classList.remove('is-open');
      });

      if (submenuName) {
        var submenu = document.querySelector("[data-submenu=\"".concat(submenuName, "\"]"));
        submenu.classList.add('is-open');
        body.classList.add('is-submenuOpen');

        if (submenu.dataset.submenuChild) {
          body.classList.add('is-submenuChildOpen');
        } else {
          body.classList.remove('is-submenuChildOpen');
        }
      } else {
        var openSubmenu = document.querySelector('[data-submenu].is-open');

        if (openSubmenu) {
          openSubmenu.classList.remove('is-open');
        }

        body.classList.remove('is-submenuOpen');
        body.classList.remove('is-submenuChildOpen');
      }
    });
  });
}

function NavigationMenu() {
  console.log('NavigationMenu');
  var timeoutMouseenter = {};
  var delay = 250;
  var navMenus = document.querySelectorAll('[data-navigationmenu]');
  navMenus.forEach(function (navMenu) {
    var wideCallout = navMenu.querySelector('.NavigationMenu-wideCallout');
    var navMenuTabs = navMenu.querySelectorAll('[data-navigationmenu-tab]');
    var navMenuContents = navMenu.querySelectorAll('[data-navigationmenu-content]');
    var navMenuCallouts = navMenu.querySelectorAll('[data-navigationmenu-callout]');
    navMenuTabs.forEach(function (tab) {
      var connectedContent = navMenu.querySelector("[data-navigationmenu-content=\"".concat(tab.dataset.navigationmenuTab, "\"]"));
      var connectedCallout = navMenu.querySelector("[data-navigationmenu-callout=\"".concat(tab.dataset.navigationmenuTab, "\"]"));
      var id = tab.getAttribute("data-navigationmenu-tab");
      tab.addEventListener('mouseenter', function () {
        timeoutMouseenter[id] = setTimeout(function () {
          navMenuTabs.forEach(function (otherTab) {
            return otherTab.classList.remove('is-active');
          });
          tab.classList.add('is-active');
          navMenuContents.forEach(function (content) {
            content.classList.remove('is-active');
            connectedContent.classList.add('is-active');
          });
          navMenuCallouts.forEach(function (callout) {
            callout.classList.remove('is-active');

            if (connectedCallout != undefined) {
              connectedCallout.classList.add('is-active');
              wideCallout.removeAttribute("style");
            } else {
              wideCallout.style.display = "none";
            }
          });
        }, delay);
      });
      tab.addEventListener('mouseleave', function () {
        if (typeof timeoutMouseenter[id] != "undefined") {
          clearTimeout(timeoutMouseenter[id]);
        }
      });
    });
  });
}


;// CONCATENATED MODULE: ./stories/js/components/MFTab.js
var MFTab = function MFTab(container, options) {
  if (container != undefined) {
    return new MFTab()._init(container, options);
  }
};

MFTab.fn = MFTab.prototype = {
  constructor: MFTab,
  _defaults: {
    tabClass: 'MFTab',
    tabItemClass: 'MFTab-item',
    tabLinkClass: 'MFTab-link ',
    tabContentClass: 'MFTab-content',
    tabPaneClass: 'MFTab-pane',
    activeClass: 'active',
    control: 'href'
  },
  _init: function _init(container, options) {
    this._setElements(container, options);

    this._bindEvents();

    return this;
  },
  _setElements: function _setElements(container, options) {
    this.opts = Object.assign({}, this._defaults, options);
    this.tab = document.getElementById(container);
    this.tabItems = this.tab.getElementsByClassName(this.opts.tabItemClass);
    this.tabLinks = this.tab.getElementsByClassName(this.opts.tabLinkClass);
    this.tabContent = document.querySelector('[data-target="' + container + '"]');
    this.tabPanes = this.tabContent.getElementsByClassName(this.opts.tabPaneClass);
    this._previousElement = this.tabPanes[0];
    this._currentElement = this.tabPanes[0];
    this.length = this.tabItems.length;
  },
  _bindEvents: function _bindEvents() {
    var that = this;
    that.tab.addEventListener('click', function (e) {
      e.preventDefault();
      var target = e.target;
      var tabTarget;

      if (!target.classList.contains(that.opts.tabClass) && !target.classList.contains(that.opts.tabItemClass)) {
        if (target.nodeName != 'A') {
          tabTarget = target.parentElement.getAttribute(that.opts.control).slice(1) || null;
        } else {
          tabTarget = target.getAttribute(that.opts.control).slice(1) || null;
        }

        if (tabTarget != null) {
          that._update(tabTarget);
        }
      }
    });
  },
  _update: function _update(tabTarget) {
    var that = this;

    that._updateStatus(tabTarget);
  },
  _updateStatus: function _updateStatus(tabTarget) {
    var that = this;
    that.tabLinks.forEach(function (item, i) {
      var itemAttr = item.getAttribute(that.opts.control).slice(1);

      if (itemAttr != tabTarget) {
        item.classList.remove(that.opts.activeClass);
      } else {
        item.classList.add(that.opts.activeClass);
      }
    });
    that.tabPanes.forEach(function (item, i) {
      if (item.id != tabTarget) {
        if (item.classList.contains(that.opts.activeClass)) {
          that._previousElement = item;
        }

        item.classList.remove(that.opts.activeClass);
      } else {
        item.classList.add(that.opts.activeClass);
        that._currentElement = item;
      }
    });

    that._complete();
  },
  _complete: function _complete(callback) {
    var that = this;
    var hiddenEvent = new CustomEvent('hidden.mf.tab', {
      detail: {
        relatedTarget: that._previousElement
      }
    });
    var shownEvent = new CustomEvent('shown.mf.tab', {
      detail: {
        relatedTarget: that._currentElement
      }
    });

    if (window.dispatchEvent) {
      that.tab.dispatchEvent(hiddenEvent);
      that.tab.dispatchEvent(shownEvent);
    } else {
      that.tab.fireEvent(hiddenEvent);
      that.tab.fireEvent(shownEvent);
    }

    callback && callback();
  },
  show: function show(callback) {
    console.log('show');
    callback && callback();
  },
  hide: function hide(callback) {
    console.log('hide');
    callback && callback();
  },
  length: 0,
  push: [].push,
  sort: [].sort,
  splice: [].splice
};
/* harmony default export */ var components_MFTab = (MFTab);
;// CONCATENATED MODULE: ./stories/js/modules/Partners/index.js



function Partners() {
  console.log('Partners');
  var partners = document.querySelectorAll('.partners');

  if (partners && partners.length > 0) {
    partners.forEach(function (partner) {
      revealElements();
      var parterTabs = partner.querySelector('.partners-tabs');
      var parterTab = partner.querySelector('.partners-tab');
      var TabId = parterTab ? parterTab.id : null;
      var trigger = partner.querySelector('[data-partners-trigger]');
      var triggerText = partner.querySelector('.partners-trigger-inner-text');
      var tabActiveLink = partner.querySelector('.MFTab-link.active');
      var tab;

      if (parterTab) {
        tab = components_MFTab(TabId);
        parterTab.addEventListener('shown.mf.tab', function (event) {
          tabActiveLink = partner.querySelector('.MFTab-link.active');

          if (tabActiveLink) {
            triggerText.innerHTML = tabActiveLink.innerHTML;
          }

          if (parterTabs.classList.contains('open')) {
            parterTabs.classList.remove('open');
          }
        });
      }

      if (tabActiveLink) {
        triggerText.innerHTML = tabActiveLink.innerHTML;
      }

      if (trigger) {
        trigger.addEventListener('click', function () {
          //debugger;
          parterTabs.classList.toggle('open');
        });
      }
    });
  }
}

/* harmony default export */ var modules_Partners = (Partners);
;// CONCATENATED MODULE: ./stories/js/modules/PrimaryNav/index.js



function PrimaryNav() {
  console.log('PrimaryNav');
  var shyNav = document.querySelector('[data-shy-nav]');
  var shyPlaceholder = document.querySelector('.ShyNav-shim');
  var navLinks = document.querySelectorAll('[data-navigationmenu-section]');
  var submenus = document.querySelectorAll('[data-navigationmenu]');
  var search = document.querySelector('[data-search]');
  var secondaryNav = document.querySelector('.SecondaryNav');
  var activeMenu = document.querySelector('.NavigationMenu.is-active');
  var mobildRow = document.querySelector('.PrimaryNav >.Container--row');
  var alertBanner = document.querySelector('.AlertBar');
  var alertHeight = 0;
  var shyPlaceholderHeight = shyPlaceholder ? shyPlaceholder.clientHeight : 0;
  var hashload = document.location.hash ? true : false;
  var uaResult = new (ua_parser_default())().getResult();
  var browserInfo = new (ua_parser_default())().getBrowser();
  var customUtil = utilities_CustomUtil.initSettings();
  customUtil.initCheckScreen();
  updateElementsWithAlert();

  function updateElementsWithAlert() {
    shyPlaceholderHeight = customUtil.screenIs == 'isMobile' ? 76 : 143;

    if (alertBanner) {
      if (customUtil.screenIs == 'isMobile') {
        shyNav.appendChild(alertBanner);
      } else {
        shyNav.insertBefore(alertBanner, search);
      }

      shyPlaceholder.style.height = shyPlaceholderHeight + alertBanner.clientHeight + 'px';
      shyNav.style.height = shyPlaceholder.clientHeight + 'px';

      if (customUtil.screenIs == 'isMobile') {
        search.style.top = mobildRow.clientHeight + alertBanner.clientHeight + 'px';
      } else {
        search.style.top = secondaryNav.clientHeight + alertBanner.clientHeight + 'px';
      }

      submenus.forEach(function (menu) {
        if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
          menu.style.top = shyNav.clientHeight + 'px';
        }

        if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
          menu.style.top = shyNav.clientHeight + 'px';
        }
      });
    }
  }

  var timeoutMouseenter = {};
  var timeoutMouseleave = {};
  var delay = 250;
  navLinks.forEach(function (link) {
    var linkSubmenu = document.querySelector("[data-navigationmenu=\"".concat(link.dataset.navigationmenuSection, "\"]"));

    if (linkSubmenu) {
      var id = link.getAttribute('data-navigationmenu-section');
      link.addEventListener('mouseenter', function () {
        if (typeof timeoutMouseleave[id] != 'undefined') {
          clearTimeout(timeoutMouseleave[id]);
        }

        timeoutMouseenter[id] = setTimeout(function () {
          linkSubmenu.classList.add('is-active'); //reset submenu top

          var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

          if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
            linkSubmenu.style.top = shytop + shyNav.clientHeight + 'px';
          }

          if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
            linkSubmenu.style.top = shytop + shyNav.clientHeight + 'px';
          }
        }, delay);
      });
      link.addEventListener('mouseleave', function () {
        if (typeof timeoutMouseenter[id] != 'undefined') {
          clearTimeout(timeoutMouseenter[id]);
        }

        timeoutMouseleave[id] = setTimeout(function () {
          linkSubmenu.classList.remove('is-active');
        }, delay);
      });
    }
  });
  submenus.forEach(function (submenu) {
    var id = submenu.getAttribute('data-navigationmenu');
    submenu.addEventListener('mouseenter', function (e) {
      if (typeof timeoutMouseleave[id] != 'undefined') {
        clearTimeout(timeoutMouseleave[id]);
      } //submenu.classList.add('is-active');

    });
    submenu.addEventListener('mouseleave', function () {
      timeoutMouseleave[id] = setTimeout(function () {
        submenu.classList.remove('is-active');
        var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

        if (0 - shytop > shyNav.clientHeight) {
          shyNav.style.top = -parseInt(shyNav.clientHeight) + 'px';
          customUtil.settings.headerStatus = 0;
          customUtil.updateStickyElements();
        }
      }, delay);
    });
  });

  if (shyNav) {
    var scrollPosition = 0;
    var scrollUpPosition = 0;
    var scrollDownPosition = 0;
    var currentlyScrollingDown = false;
    var ticking = false;
    var isStuck = false;
    var longScroll = false;
    var navHeight = parseInt(shyNav.clientHeight);
    var prevScroTop = 0;
    var directionSwitch = false;
    var activeMenuHeight = 0;
    submenus.forEach(function (menu) {
      if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
        menu.style.top = shyNav.clientHeight + 'px';
      }

      if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
        menu.style.top = shyNav.clientHeight + 'px';
      }
    });

    function updateHeaderPositionWhenScroll() {
      var scroTop = window.scrollY || document.documentElement.scrollTop;
      navHeight = shyNav.clientHeight;

      if (alertBanner) {
        alertHeight = alertBanner.clientHeight;
      }

      if (shyNav.clientHeight == 0) {
        navHeight = customUtil.screenIs == 'isMobile' ? 76 + alertHeight : 143 + alertHeight;
      }

      activeMenu = document.querySelector('.NavigationMenu.is-active');

      if (search && search.classList.contains('is-touched')) {
        //Condition when searchbox opened.
        navHeight = shyNav.clientHeight + search.clientHeight;
      }

      if (activeMenu) {
        //Condition when submenu opened.
        navHeight = shyNav.clientHeight + activeMenu.clientHeight;
        activeMenuHeight = activeMenu.clientHeight;
      } else {
        if (search && !search.classList.contains('is-touched')) {
          if (scroTop <= prevScroTop) {
            //Condition when submenu opened and scroll outside, then scrollup, firstly reset primarynav top.
            if (!directionSwitch) {
              var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

              if (0 - parseInt(shytop) > parseInt(shyNav.clientHeight)) {
                shyNav.style.top = -parseInt(shyNav.clientHeight) + 'px';
                directionSwitch = true;
              }
            }
          }
        }
      }

      var navTopPX = shyNav.style.top;
      var navTop = parseInt(navTopPX.slice(0, navTopPX.length - 2));
      var setTop = 0;

      if (scroTop > prevScroTop) {
        // Scroll Down
        document.querySelector('body').setAttribute('data-direction', 'down');
        var topValue = navTop > -navHeight ? parseInt(navTop - (scroTop - prevScroTop)) : -navHeight;

        if (-topValue > navHeight) {
          //long scroll as anchor
          setTop = -navHeight;
        } else {
          setTop = scroTop > navHeight ? topValue : -(0 - scroTop) < shyPlaceholder.clientHeight ? 0 - scroTop : topValue;
        }

        shyNav.style.top = setTop + 'px';

        if (search) {
          if (customUtil.screenIs == 'isMobile') {
            search.style.top = setTop + mobildRow.clientHeight + alertHeight + 'px';
          } else {
            search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
          }
        }

        if (activeMenu) {
          if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
            activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
          }

          if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
            activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
          }
        }

        directionSwitch = false;
      } else {
        // Scroll Up
        document.querySelector('body').setAttribute('data-direction', 'up');

        if (customUtil.checkNavigationSection() && customUtil.checkInPageNav()) {
          if (scroTop > navHeight) {
            //When not fetch the shynav position, hide shynav
            setTop = 0;
          } else {
            //When fetch the shynav position, show shynav as before
            var _topValue = parseInt(navTop - (scroTop - prevScroTop)) > 0 ? 0 : parseInt(navTop - (scroTop - prevScroTop));

            setTop = navTop >= 0 ? 0 : _topValue;
            shyNav.style.top = setTop + 'px';

            if (search) {
              if (customUtil.screenIs == 'isMobile') {
                search.style.top = setTop + mobildRow.clientHeight + alertHeight + 'px';
              } else {
                search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
              }
            }

            if (activeMenu) {
              if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
                activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
              }

              if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
                activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
              }
            }
          }
        } else {
          var _topValue2 = parseInt(navTop - (scroTop - prevScroTop)) > 0 ? 0 : parseInt(navTop - (scroTop - prevScroTop));

          setTop = navTop >= 0 ? 0 : _topValue2;
          shyNav.style.top = setTop + 'px';

          if (search) {
            if (customUtil.screenIs == 'isMobile') {
              search.style.top = setTop + mobildRow.clientHeight + alertHeight + 'px';
            } else {
              search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
            }
          }

          if (activeMenu) {
            if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
              activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
            }

            if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
              activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
            }
          }
        }
      } // 0 = hide, 1 = show part, 2 = show all


      if (setTop == 0) {
        customUtil.settings.headerStatus = 2;
      } else if (setTop == -navHeight) {
        customUtil.settings.headerStatus = 0;
      } else {
        customUtil.settings.headerStatus = 1;
      } //console.log('headerStatus:' + customUtil.settings.headerStatus);


      prevScroTop = scroTop;
    }

    function updateHeaderPosition(scrollPos) {
      var navPosition = shyNav.getBoundingClientRect().top;
      longScroll = Math.abs(scrollDownPosition - scrollUpPosition) > navHeight;
      if (scrollPos < 0) shyNav.style.top = 0;

      if (scrollPos > scrollPosition) {
        // SCROLLING DOWN
        scrollDownPosition = currentlyScrollingDown ? scrollPos : scrollDownPosition;

        if (!currentlyScrollingDown && isStuck) {
          shyNav.style.position = 'absolute';
          shyNav.style.top = "".concat(scrollUpPosition, "px");
        }

        currentlyScrollingDown = true;
        isStuck = false;
      } else {
        // SCROLLING UP
        currentlyScrollingDown = false;
        scrollUpPosition = currentlyScrollingDown ? scrollUpPosition : scrollPos;

        if (navPosition >= 0) {
          // STUCK HEADER
          shyNav.style.position = 'fixed';
          shyNav.style.top = 0;
          isStuck = true;
          scrollPosition = scrollPos;
          return;
        } else {
          isStuck = false;
        } // EDGE CASE - Header


        if (navPosition >= scrollPos) {
          // shyNav.style.position = 'fixed';
          shyNav.style.top = 0;
        } else {
          if (shyNav.style.position == 'fixed') return;
          shyNav.style.position = 'absolute';

          if (longScroll) {
            shyNav.style.top = "".concat(scrollDownPosition - navHeight, "px");
          }
        }
      }

      scrollPosition = scrollPos;
    }

    window.addEventListener('scroll', function (e) {
      var newScrollPosition = window.scrollY || document.documentElement.scrollTop;
      e.preventDefault();

      if (!ticking) {
        window.requestAnimationFrame(function () {
          //debugger;
          updateHeaderPositionWhenScroll();
          ticking = false;
        });
        ticking = true;
      }
    });
    window.addEventListener('resize', function () {
      /*let shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));
      if (customUtil.screenIs == 'isMobile') {
        search.style.top = shytop + mobildRow.clientHeight + 'px';
      } else {
        search.style.top = shytop + secondaryNav.clientHeight + 'px';
      }*/
      customUtil.initCheckScreen();
      updateElementsWithAlert();
      customUtil.updateStickyElements();
    }, false);
    window.addEventListener('hashchange', function () {
      scrollDownPosition = window.scrollY || document.documentElement.scrollTop;
    }, false);

    if (document.location.hash != undefined && document.location.hash != '') {
      scrollDownPosition = window.scrollY || document.documentElement.scrollTop;
      currentlyScrollingDown = true;
    }
  }
}

/* harmony default export */ var modules_PrimaryNav = (PrimaryNav);
;// CONCATENATED MODULE: ./stories/js/modules/Quote/index.js


function Quote() {
  revealElements();
}

/* harmony default export */ var modules_Quote = (Quote);
;// CONCATENATED MODULE: ./stories/js/modules/SecondaryNav/index.js
function SecondaryNav() {
  console.log('SecondaryNav');
}

/* harmony default export */ var modules_SecondaryNav = (SecondaryNav);
;// CONCATENATED MODULE: ./stories/js/modules/VerticalSlider/index.js


function VerticalSlider() {
  console.log('VerticalSlider');
  var sliderContainer = document.getElementsByClassName('VerticalSlider')[0];

  if (sliderContainer) {
    var sliders = document.getElementsByClassName('VerticalSlider-item');

    if (sliders && sliders.length > 0) {
      var activeSlider = document.querySelector('.VerticalSlider-item.active');
      var indicatorContainer = document.getElementsByClassName('VerticalSlider-indicator')[0];
      var indicators = document.getElementsByClassName('VerticalSlider-indicator-item');
      var activeIndicator = document.querySelector('.VerticalSlider-indicator-item.active');
      var prevScroTop = 0;
      var ticking = false;
      utilities_CustomUtil.updateSettings();
      var sliderAllHeight = sliderContainer.offsetTop + sliderContainer.clientHeight;

      var updateStatus = function updateStatus(i, opt) {
        if (opt == 'remove') {
          //sliders[i].classList.remove('active');
          if (indicators[i] && indicators[i].classList.contains('active')) {
            indicators[i].classList.remove('active');
          }
        } else if (opt = 'add') {
          sliders[i].classList.add('active');

          if (indicators[i]) {
            indicators[i].classList.add('active');
          }
        }
      };

      var visibleAnimationElement = function visibleAnimationElement() {
        var showIndexArr = [];
        var showPreHeightArr = [];
        var activeIndex = null;
        var activeHeight = 0;
        var clientHeight = window.innerHeight - utilities_CustomUtil.settings.headerFixedHeight;
        var scroTop = document.documentElement.scrollTop - sliderContainer.offsetTop + utilities_CustomUtil.getAllStickyTop();
        var totalHeight = 0;

        for (var i = 0; i < sliders.length; i++) {
          var pageHeight = sliders[i].clientHeight;
          var preHeight = totalHeight;
          totalHeight = totalHeight + pageHeight;

          if (scroTop < totalHeight && scroTop + clientHeight >= preHeight) {
            showIndexArr.push(i);
            showPreHeightArr.push(preHeight); //console.log('Page show: ' + i);
          } else {
            //console.log('Page hide: ' + i);
            updateStatus(i, 'remove');
          }
        }

        for (var _i = 0; _i < showIndexArr.length; _i++) {
          var _pageHeight = sliders[showIndexArr[_i]].clientHeight;
          var xTop = scroTop - showPreHeightArr[_i];
          var xBottom = _pageHeight + showPreHeightArr[_i] - scroTop - clientHeight;
          xTop = xTop > 0 ? xTop : 0;
          xBottom = xBottom > 0 ? xBottom : 0;

          if (xTop > 0 && xBottom > 0 || xTop === 0 && xBottom === 0) {
            activeIndex = showIndexArr[_i];
            break;
          } else {
            var viewPageHeight = _pageHeight - xTop - xBottom;

            if (viewPageHeight > activeHeight) {
              activeHeight = viewPageHeight;
              activeIndex = showIndexArr[_i];
            }
          }
        }

        if (activeIndex != null) {
          console.log('Page active: ' + activeIndex);
          updateStatus(activeIndex, 'add');

          for (var k = 0; k < showIndexArr.length; k++) {
            if (activeIndex != showIndexArr[k]) {
              updateStatus(showIndexArr[k], 'remove');
            }
          }
        }
      };

      var bindClick = function bindClick() {
        indicators.forEach(function (indicator, i) {
          indicator.addEventListener('click', function (e) {
            var currentTarget = e.currentTarget;
            var target = e.target;
            var parent = target.parentNode;
            var relatorTarget;

            if (target.getAttribute('href') && target.getAttribute('href').indexOf('#') != -1) {
              relatorTarget = target.getAttribute('href').slice(1);
            } else {
              relatorTarget = parent;
            }

            var currIndex = Number(currentTarget.dataset['indicate']); //debugger;

            scrollToPosition(sliders[currIndex], currIndex);
          });
        });
      };

      var scrollToPosition = function scrollToPosition(element, index) {
        var top = sliderContainer.offsetTop;

        for (var i = 0; i < index; i++) {
          top = top + sliders[i].clientHeight;
        }

        var eleTop = utilities_CustomUtil.getAllStickyTop();
        var scrollTo = top;

        if (top > prevScroTop) {
          scrollTo = top - eleTop;
        } else {
          scrollTo = top - eleTop - utilities_CustomUtil.settings.headerFixedHeight;
        }

        if (history.replaceState != null) {
          history.replaceState({}, '', window.location.pathname + '#' + element.getAttribute('id'));
        }

        window.scrollTo(0, scrollTo);
      };

      var initLoad = function initLoad() {
        var observerConfig = {
          rootMargin: '0px 0px -58% 0px',
          threshold: 0
        };
        var observer = new IntersectionObserver(function (elements, self) {
          elements.forEach(function (element) {
            if (element.isIntersecting) {
              // Add class and stop watching
              updateStatus(0, 'add');

              if (indicatorContainer && indicatorContainer.classList.contains('hide')) {
                indicatorContainer.classList.remove('hide');
              }

              self.unobserve(element.target);
            }
          });
        }, observerConfig);
        observer.observe(sliderContainer);
      };

      initLoad();
      bindClick();
      window.addEventListener('scroll', function (e) {
        //console.log('Scroll start ...');
        if (!ticking) {
          window.requestAnimationFrame(function () {
            utilities_CustomUtil.updateSettings();
            var scroTop = window.scrollY || document.documentElement.scrollTop;
            var min = sliderContainer.offsetTop - utilities_CustomUtil.settings.headerFixedHeight - 1;
            var max = sliderContainer.offsetTop + sliderContainer.clientHeight - utilities_CustomUtil.settings.headerFixedHeight;

            if (scroTop < prevScroTop) {
              min = sliderContainer.offsetTop - utilities_CustomUtil.settings.headerFixedHeight - 1 - utilities_CustomUtil.getAllStickyTop();
            }

            if (scroTop >= min && scroTop < max) {
              if (indicatorContainer.classList.contains('hide')) {
                indicatorContainer.classList.remove('hide');
              }

              visibleAnimationElement();
            } else {
              for (var i = 0; i < sliders.length; i++) {
                updateStatus(i, 'remove');
              }

              indicatorContainer.classList.add('hide');
            }

            prevScroTop = scroTop;
            ticking = false;
          });
          ticking = true;
        } //console.log('Scroll end ...');

      });
      window.addEventListener('resize', function (e) {});
    }
  }
}

/* harmony default export */ var modules_VerticalSlider = (VerticalSlider);
;// CONCATENATED MODULE: ./stories/js/components/MFTable.js

var MFTable = {
  updateDropDownStatus: function updateDropDownStatus(tabColumn, bodyColumnSum, settings) {
    var columnLength = tabColumn.length; // / 2;

    for (var i = 0; i < columnLength; i++) {
      if (utilities_CustomUtil.screenIs == 'isLaptop') {
        this.compareColumns(tabColumn, bodyColumnSum, settings.maxLapTop, i);
      } else if (utilities_CustomUtil.screenIs == 'isTablet') {
        this.compareColumns(tabColumn, bodyColumnSum, settings.maxTablet, i);
      } else if (utilities_CustomUtil.screenIs == 'isMobile') {
        this.compareColumns(tabColumn, bodyColumnSum, settings.maxMobile, i);
      }
    }
  },
  compareColumns: function compareColumns(tabColumn, bodyColumnSum, max, i) {
    //var columnLength = tabColumn.length / 2;
    if (tabColumn[i].querySelector('.dropdown-toggle')) {
      if (bodyColumnSum > max) {
        tabColumn[i].querySelector('.dropdown-toggle').classList.remove('toggle-link');
        tabColumn[i].querySelector('.dropdown-toggle').classList.remove('toggle-link');
      } else {
        tabColumn[i].querySelector('.dropdown-toggle').classList.add('toggle-link');
        tabColumn[i].querySelector('.dropdown-toggle').classList.add('toggle-link');
      }
    }
  },
  bindDropDownEvent: function bindDropDownEvent(dropToggle) {
    dropToggle.forEach(function (trigger, index) {
      trigger.addEventListener('click', function (e) {
        if (!trigger.classList.contains('toggle-link')) {
          var dropContainer = e.currentTarget.parentElement.parentElement;
          dropContainer.classList.toggle('open');
          var k = [].indexOf.call(dropToggle, e.currentTarget);

          for (var i = 0; i < dropToggle.length; i++) {
            if (i != k) {
              dropToggle[i].parentElement.parentElement.classList.remove('open');
            }
          }
        }
      });
    });
  },
  bindDropDownClearEvent: function bindDropDownClearEvent(target, dropContainer) {
    if (!(target.classList && target.classList.contains('dropdown-toggle'))) {
      dropContainer.forEach(function (drop) {
        drop.classList.remove('open');
      });
    }
  },
  bindTableRowHoverEvent: function bindTableRowHoverEvent(tabBody, column, cell) {
    tabBody.querySelectorAll(cell).forEach(function (trigger, index) {
      trigger.addEventListener('mouseover', function (e) {
        var cells = e.currentTarget.parentElement.querySelectorAll(cell);
        var k = [].indexOf.call(cells, e.currentTarget);
        tabBody.querySelectorAll(column).forEach(function (col) {
          col.querySelectorAll(cell)[k].classList.add('active');
        });
      });
      trigger.addEventListener('mouseout', function (e) {
        var cells = e.currentTarget.parentElement.querySelectorAll(cell);
        var k = [].indexOf.call(cells, e.currentTarget);
        tabBody.querySelectorAll(column).forEach(function (col) {
          col.querySelectorAll(cell)[k].classList.remove('active');
        });
      });
    });
  },
  bindTableColumnHoverEvent: function bindTableColumnHoverEvent(tab, tabHeader, tabBody, column) {
    tab.querySelectorAll(column).forEach(function (trigger, index) {
      trigger.addEventListener('mouseover', function (e) {
        var columns = e.currentTarget.parentElement.querySelectorAll(column);
        var k = [].indexOf.call(columns, e.currentTarget);
        tabHeader.querySelectorAll(column)[k].classList.add('active');
        tabBody.querySelectorAll(column)[k].classList.add('active');
      });
      trigger.addEventListener('mouseout', function (e) {
        var columns = e.currentTarget.parentElement.querySelectorAll(column);
        var k = [].indexOf.call(columns, e.currentTarget);
        tabHeader.querySelectorAll(column)[k].classList.remove('active');
        tabBody.querySelectorAll(column)[k].classList.remove('active');
      });
    });
  },
  bindTableScrollFixedEvent: function bindTableScrollFixedEvent(tab, prevScroTop) {
    var eleTop = utilities_CustomUtil.getInStickyTop(tab.tabHeader);
    var tab_min = tab.tabContainer.offsetTop - eleTop;
    var tab_max = tab.tabContainer.offsetTop + tab.tabContainer.clientHeight - tab.tabHeader.clientHeight - eleTop;

    if (tab.tab != null && tab.tab.closest('.ContentLayoutBackground') != null) {
      tab_min += tab.tab.closest('.ContentLayoutBackground').offsetTop;
      tab_max += tab.tab.closest('.ContentLayoutBackground').offsetTop;
    }

    utilities_CustomUtil.updateSettings();
    var scroTop = window.scrollY || document.documentElement.scrollTop;
    var condition = scroTop > tab_min && scroTop < tab_max;
    var ele = tab.tabHeader;
    utilities_CustomUtil.bindStickyEvent(condition, ele);
    prevScroTop = scroTop;
  },
  generateFixedTableHeader: function generateFixedTableHeader(toContainer, cell) {
    for (var i = 0; i < cell.length; i++) {
      var column = document.createElement('div');
      column.className = 'MFTable-table-column';
      column.innerHTML = cell[i].outerHTML;
      toContainer.querySelector('.Container').appendChild(column);
    }
  },
  generateFixedTableHeaderForTableS: function generateFixedTableHeaderForTableS(toContainer, row) {
    if (toContainer && row) {
      var headerRow = document.createElement('div');
      headerRow.className = 'MFTable-table-row row-header';
      headerRow.innerHTML = row.innerHTML;
      toContainer.querySelector('.Container').appendChild(headerRow);
    }
  },
  setPaddingToFixedTableHeader: function setPaddingToFixedTableHeader(tab) {
    var container = tab.closest('.Container');

    if (container) {
      var value = window.getComputedStyle(container).marginLeft; //tab.querySelector('.MFTable-table-header').style.paddingLeft = value;
      //tab.querySelector('.MFTable-table-header').style.paddingRight = value;

      var headerCells = tab.querySelector('.MFTable-table-header').querySelectorAll('.MFTable-table-cell');
      var bodyColumns = tab.querySelector('.MFTable-table-body').querySelectorAll('.MFTable-table-column');
      headerCells.forEach(function (cell, index) {//cell.style.width = bodyColumns[index].clientWidth + 'px';
      });
    }
  },
  updateTableVars: function updateTableVars(index, tabDom, tab) {
    tabDom.tab = tab;
    tabDom.tabContainer = tab.querySelector('.MFTable-table');
    tabDom.tabHeader = tab.querySelector('.MFTable-table-header');
    tabDom.tabBody = tab.querySelector('.MFTable-table-body');
    tabDom.tabCellHeader = tabDom.tabBody.querySelectorAll('.MFTable-table-cell.cell-header');
    tabDom.tabColumn = tabDom.tabBody.querySelectorAll('.MFTable-table-column');
    tabDom.tabBodyColumn = tabDom.tabBody.querySelectorAll('.MFTable-table-column');
    tabDom.tabHeaderColumn = tabDom.tabHeader.querySelectorAll('.MFTable-table-column');
    tabDom.dropContainer = tab.querySelectorAll('.dropdown');
    tabDom.dropToggle = tab.querySelectorAll('.dropdown-toggle');
    tabDom.bodyColumnSum = Number(tabDom.tabBody.getAttribute('data-products-size'));
  }
};
/* harmony default export */ var components_MFTable = (MFTable);
;// CONCATENATED MODULE: ./stories/js/modules/ComparisonTable/index.js





core_class.use([navigation]);

function ComparisonTable() {
  console.log('ComparisonTable');
  var c_tabs = document.querySelectorAll('.ComparisonTable');

  if (c_tabs && c_tabs.length > 0) {
    var c_tabDoms = {};
    var c_settings = {
      maxLapTop: 4,
      maxTablet: 3,
      maxMobile: 2
    };
    var ticking = false;
    var prevScroTop = 0;

    for (var t = 0; t < c_tabs.length; t++) {
      c_tabDoms[t] = {};
      utilities_CustomUtil.updateSettings();
      components_MFTable.updateTableVars(t, c_tabDoms[t], c_tabs[t]);

      if (utilities_CustomUtil.isNavFixed()) {
        c_tabDoms[t].tabHeader.style.top = utilities_CustomUtil.settings.headerFixedHeight + 'px';
      } else {
        c_tabDoms[t].tabHeader.style.top = 0;
      }

      utilities_CustomUtil.initCheckScreen();

      if (utilities_CustomUtil.isLocalhost() && !c_tabs[t].classList.contains('MFTable-carousel')) {
        components_MFTable.generateFixedTableHeader(c_tabDoms[t].tabHeader, c_tabDoms[t].tabCellHeader);
      }

      components_MFTable.updateTableVars(t, c_tabDoms[t], c_tabs[t]);

      if (utilities_CustomUtil.isLocalhost()) {
        components_MFTable.updateDropDownStatus(c_tabDoms[t].tabColumn, c_tabDoms[t].bodyColumnSum, c_settings);
      }

      if (!c_tabs[t].classList.contains('MFTable-v')) {
        components_MFTable.bindTableColumnHoverEvent(c_tabs[t], c_tabDoms[t].tabHeader, c_tabDoms[t].tabBody, '.MFTable-table-column');
      } else {
        components_MFTable.bindTableRowHoverEvent(c_tabDoms[t].tabBody, '.MFTable-table-column', '.MFTable-table-cell');
      }

      utilities_CustomUtil.setColumnCellHeight(c_tabDoms[t].tabBodyColumn, '.MFTable-table-cell', '.dropdown-header');
      utilities_CustomUtil.setColumnCellHeight(c_tabDoms[t].tabHeaderColumn, '.MFTable-table-cell', '.dropdown-header');
      components_MFTable.setPaddingToFixedTableHeader(c_tabs[t]);
    }

    document.addEventListener('click', function (e) {
      var dropContainer = document.querySelectorAll('.ComparisonTable .dropdown');
      components_MFTable.bindDropDownClearEvent(e.target, dropContainer);
    });
    window.addEventListener('resize', function (e) {
      utilities_CustomUtil.initCheckScreen();

      for (var _t = 0; _t < c_tabs.length; _t++) {
        components_MFTable.updateTableVars(_t, c_tabDoms[_t], c_tabs[_t]);
        components_MFTable.updateDropDownStatus(c_tabDoms[_t].tabColumn, c_tabDoms[_t].bodyColumnSum, c_settings);
        utilities_CustomUtil.setColumnCellHeight(c_tabDoms[_t].tabBodyColumn, '.MFTable-table-cell', '.dropdown-header');
        utilities_CustomUtil.setColumnCellHeight(c_tabDoms[_t].tabHeaderColumn, '.MFTable-table-cell', '.dropdown-header');
        components_MFTable.setPaddingToFixedTableHeader(c_tabs[_t]);
      }
    });
    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          for (var _t2 = 0; _t2 < c_tabs.length; _t2++) {
            components_MFTable.updateTableVars(_t2, c_tabDoms[_t2], c_tabs[_t2]);
            components_MFTable.bindTableScrollFixedEvent(c_tabDoms[_t2], prevScroTop);
          }

          ticking = false;
        });
        ticking = true;
      }
    });

    if (utilities_CustomUtil.isLocalhost()) {
      var dropToggle = document.querySelectorAll('.ComparisonTable .dropdown-toggle');
      components_MFTable.bindDropDownEvent(dropToggle);
    }
  }
}

function ComparisonTableCarousel() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    selector: '.ComparisonTableCarousel-contentPanel'
  },
      el = _ref.el;

  var transitionSpeed = 300;
  var leftButtonEl = el.closest('.ComparisonTableCarousel-contentPanel').querySelector('.ComparisonTableCarousel-navArrowButton-left');
  var rightButtonEl = el.closest('.ComparisonTableCarousel-contentPanel').querySelector('.ComparisonTableCarousel-navArrowButton-right');
  var cardsSwiper = new core_class(el, {
    effect: 'slide',
    speed: transitionSpeed,
    slidesPerView: 'auto',
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    watchOverflow: true,
    loop: false,
    simulateTouch: false,
    allowTouchMove: false,
    navigation: {
      nextEl: rightButtonEl,
      prevEl: leftButtonEl
    } //on: {
    //slideChange: function (swiper) {
    //console.log('swiper slideChange' + swiper);
    //},
    //},

  });
  revealElements();
  rightButtonEl.addEventListener('click', function (e) {
    var container = e.currentTarget.parentElement.parentElement;

    if (e.currentTarget.classList.contains('swiper-button-disabled')) {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.add('last-visible');
      });
    } else {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }

    if (e.pointerType == 'mouse' || e.pointerType == 'touch') {
      var root = container.closest('.ComparisonTableCarousel');

      if (container.classList.contains('MFTable-table-header') || container.parentElement.classList.contains('MFTable-table-header') || container.parentElement.parentElement.classList.contains('MFTable-table-header')) {
        root.querySelector('.MFTable-table-body .ComparisonTableCarousel-navArrowButton-right').click();
      } else {
        root.querySelector('.MFTable-table-header .ComparisonTableCarousel-navArrowButton-right').click();
      }
    }
  });
  leftButtonEl.addEventListener('click', function (e) {
    var container = e.currentTarget.parentElement.parentElement;
    var lastVisibles = container.querySelectorAll('.last-visible');

    if (lastVisibles) {
      lastVisibles.forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }

    if (e.pointerType == 'mouse' || e.pointerType == 'touch') {
      var root = container.closest('.ComparisonTableCarousel');

      if (container.classList.contains('MFTable-table-header') || container.parentElement.classList.contains('MFTable-table-header') || container.parentElement.parentElement.classList.contains('MFTable-table-header')) {
        root.querySelector('.MFTable-table-body .ComparisonTableCarousel-navArrowButton-left').click();
      } else {
        root.querySelector('.MFTable-table-header .ComparisonTableCarousel-navArrowButton-left').click();
      }
    }
  });
  return {
    destroy: function destroy() {
      cardsSwiper.detachEvents();
      cardsSwiper.destroy();
    }
  };
} //export default ComparisonTable;



;// CONCATENATED MODULE: ./stories/js/modules/SpecsTable/index.js



function SpecsTable() {
  console.log('SpecsTable');
  var s_tabs = document.querySelectorAll('.SpecsTable');

  if (s_tabs && s_tabs.length > 0) {
    var s_tabDoms = {};
    var s_settings = {
      maxLapTop: 6,
      maxTablet: 3,
      maxMobile: 2
    };
    var ticking = false;
    var prevScroTop = 0;

    for (var t = 0; t < s_tabs.length; t++) {
      s_tabDoms[t] = {};
      utilities_CustomUtil.updateSettings();
      components_MFTable.updateTableVars(t, s_tabDoms[t], s_tabs[t]);

      if (utilities_CustomUtil.isNavFixed()) {
        s_tabDoms[t].tabHeader.style.top = utilities_CustomUtil.settings.headerFixedHeight + 'px';
      } else {
        s_tabDoms[t].tabHeader.style.top = 0;
      }

      utilities_CustomUtil.initCheckScreen(); //if (CustomUtil.isLocalhost()) {

      components_MFTable.generateFixedTableHeader(s_tabDoms[t].tabHeader, s_tabDoms[t].tabCellHeader); //}

      components_MFTable.updateTableVars(t, s_tabDoms[t], s_tabs[t]);

      if (utilities_CustomUtil.isLocalhost()) {
        components_MFTable.updateDropDownStatus(s_tabDoms[t].tabColumn, s_tabDoms[t].bodyColumnSum, s_settings);
      }

      components_MFTable.bindTableColumnHoverEvent(s_tabs[t], s_tabDoms[t].tabHeader, s_tabDoms[t].tabBody, '.MFTable-table-column');
      utilities_CustomUtil.setColumnCellHeight(s_tabDoms[t].tabBodyColumn, '.MFTable-table-cell', '.dropdown-header');
      utilities_CustomUtil.setColumnCellHeight(s_tabDoms[t].tabHeaderColumn, '.MFTable-table-cell', '.dropdown-header');
      utilities_CustomUtil.setColumnCellHeight(s_tabDoms[t].tabBodyColumn, '.MFTable-table-cell', '.col-value');
      utilities_CustomUtil.setColumnCellHeight(s_tabDoms[t].tabBodyColumn, '.MFTable-table-cell', '.col-group-item .col-value');
    }

    document.addEventListener('click', function (e) {
      var dropContainer = document.querySelectorAll('.SpecsTable .dropdown');
      components_MFTable.bindDropDownClearEvent(e.target, dropContainer);
    });
    window.addEventListener('resize', function (e) {
      utilities_CustomUtil.initCheckScreen();

      for (var _t = 0; _t < s_tabs.length; _t++) {
        components_MFTable.updateTableVars(_t, s_tabDoms[_t], s_tabs[_t]);
        components_MFTable.updateDropDownStatus(s_tabDoms[_t].tabColumn, s_tabDoms[_t].bodyColumnSum, s_settings);
        utilities_CustomUtil.setColumnCellHeight(s_tabDoms[_t].tabBodyColumn, '.MFTable-table-cell', '.dropdown-header');
        utilities_CustomUtil.setColumnCellHeight(s_tabDoms[_t].tabHeaderColumn, '.MFTable-table-cell', '.dropdown-header');
        utilities_CustomUtil.setColumnCellHeight(s_tabDoms[_t].tabBodyColumn, '.MFTable-table-cell', '.col-value');
        utilities_CustomUtil.setColumnCellHeight(s_tabDoms[_t].tabBodyColumn, '.MFTable-table-cell', '.col-group-item .col-value');
      }
    });
    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          for (var _t2 = 0; _t2 < s_tabs.length; _t2++) {
            components_MFTable.updateTableVars(_t2, s_tabDoms[_t2], s_tabs[_t2]);
            components_MFTable.bindTableScrollFixedEvent(s_tabDoms[_t2], prevScroTop);
          }

          ticking = false;
        });
        ticking = true;
      }
    });

    if (utilities_CustomUtil.isLocalhost()) {
      var dropToggle = document.querySelectorAll('.SpecsTable .dropdown-toggle');
      components_MFTable.bindDropDownEvent(dropToggle);
    }
  }
}

/* harmony default export */ var modules_SpecsTable = (SpecsTable);
;// CONCATENATED MODULE: ./stories/js/modules/TabbedInfo/index.js



function TabbedInfo() {
  revealElements();
  bindMFTab();
}

function bindMFTab() {
  var tabElement = document.getElementById('TabbedInfoTab');

  if (tabElement) {
    var tab = components_MFTab('TabbedInfoTab');
    tabElement.addEventListener('hidden.mf.tab', function (event) {
      console.log('hidden:' + event.detail.relatedTarget);
    });
    tabElement.addEventListener('shown.mf.tab', function (event) {
      console.log('show:' + event.detail.relatedTarget);
    });
  }
}

/* harmony default export */ var modules_TabbedInfo = (TabbedInfo);
;// CONCATENATED MODULE: ./stories/js/utilities/clampValue.js
/* harmony default export */ var clampValue = (function (_ref) {
  var _ref$val = _ref.val,
      val = _ref$val === void 0 ? 0 : _ref$val,
      _ref$range = _ref.range,
      range = _ref$range === void 0 ? [0, 0] : _ref$range;

  if (val < range[0]) {
    return range[0];
  }

  if (val > range[1]) {
    return range[1];
  }

  return val;
});
;// CONCATENATED MODULE: ./stories/js/utilities/convertValueToRange.js

/* harmony default export */ var convertValueToRange = (function (_ref) {
  var _ref$fromValue = _ref.fromValue,
      fromValue = _ref$fromValue === void 0 ? 0 : _ref$fromValue,
      _ref$fromRange = _ref.fromRange,
      fromRange = _ref$fromRange === void 0 ? [0, 0] : _ref$fromRange,
      _ref$toRange = _ref.toRange,
      toRange = _ref$toRange === void 0 ? [0, 0] : _ref$toRange,
      _ref$isClamped = _ref.isClamped,
      isClamped = _ref$isClamped === void 0 ? true : _ref$isClamped;
  var value = (fromValue - fromRange[0]) / (fromRange[1] - fromRange[0]) * (toRange[1] - toRange[0]) + toRange[0];
  return isClamped ? clampValue({
    val: value,
    range: toRange
  }) : value;
});
;// CONCATENATED MODULE: ./stories/js/modules/ContentLayoutScrollZoom/index.js


function ContentLayoutScrollZoom() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    selector: '.ContentLayoutScrollZoom'
  },
      rootEl = _ref.rootEl;

  var tabletWidth = 768;
  var maxSiteWidth = 1440;
  var yObserver;

  var init = function init() {
    if (rootEl.classList.contains('ContentLayoutScrollZoom--withTransitions')) {
      yObserver = new IntersectionObserver(handleObserverChange, {
        threshold: [0]
      });
    }

    addEventListeners();
  };

  var addEventListeners = function addEventListeners() {
    var _yObserver;

    (_yObserver = yObserver) === null || _yObserver === void 0 ? void 0 : _yObserver.observe(rootEl);
  };

  var removeEventListeners = function removeEventListeners() {
    var _yObserver2;

    (_yObserver2 = yObserver) === null || _yObserver2 === void 0 ? void 0 : _yObserver2.disconnect();
    window.removeEventListener('scroll', handleScroll);
  };

  var handleObserverChange = function handleObserverChange(changes) {
    if (changes[0].isIntersecting) {
      window.addEventListener('scroll', handleScroll);
    } else {
      rootEl.classList.remove('is-revealed');
      window.removeEventListener('scroll', handleScroll);
    }
  };

  var handleScroll = function handleScroll() {
    var windowWidth = window.innerWidth;
    var rect = rootEl.getBoundingClientRect(); // NOTE: Only show progressive padding for >= tablet size.

    var paddingRange = windowWidth >= tabletWidth ? [0, convertValueToRange({
      fromValue: windowWidth,
      fromRange: [tabletWidth, maxSiteWidth],
      toRange: [40, 64]
    })] : [0, 0];
    var padding = convertValueToRange({
      fromValue: rect.top,
      fromRange: [rect.height * 0.8, rect.height * 0.2],
      toRange: paddingRange
    });
    rootEl.style.padding = "".concat(padding, "px");

    if (rect.top < rect.height * 0.2) {
      rootEl.classList.add('is-revealed');
    }
  };

  var destroy = function destroy() {
    removeEventListeners();
  };

  return {
    init: init,
    destroy: destroy
  };
}

/* harmony default export */ var modules_ContentLayoutScrollZoom = (ContentLayoutScrollZoom);
;// CONCATENATED MODULE: ./stories/js/modules/InPageNav/index.js


function InPageNav() {
  console.log('InPageNav');
  var inPageNav = document.querySelector('.InPageNav');

  if (inPageNav) {
    var needAnchors = document.querySelectorAll('[data-anchor]');
    var inPageNavList = inPageNav.querySelector('.InPageNav-links');
    var inPageNavContainer = inPageNav.querySelector('.InPageNav-linksContainer');
    var inPageNavLinks = inPageNavList.querySelectorAll('.InPageNav-link');
    var trigger = inPageNav.querySelector('[data-InPagenav-menu-trigger]');
    var triggerText = inPageNav.querySelector('.InPageNav-menu-trigger-inner-text');
    var anchorLink = document.querySelectorAll('.with-anchor');
    var anchorActiveLink = document.querySelector('.with-anchor.active');
    var nav_top = inPageNav.offsetTop;
    var nav_height = inPageNav.clientHeight;
    var ticking = false;
    var prevScroTop = 0;
    var toEnd = false; //ScrollDown End sticky to avoid flash

    var toStart = false; //ScrollUp Start  sticky to avoid flash

    if (needAnchors && needAnchors.length > 0) {
      generateAnchors(needAnchors);
      resetElements();
    }

    if (document.location.hash) {
      var hashStr = document.location.hash.slice(1);
      var hashTarget = inPageNav.querySelector('[data-target="' + hashStr + '"]');

      if (hashTarget) {
        anchorActiveLink = hashTarget;
        anchorActiveLink.classList.add('active');
      }
    }

    if (anchorActiveLink) {
      triggerText.innerHTML = anchorActiveLink.innerHTML;
    }

    trigger.addEventListener('click', function () {
      //debugger;
      inPageNav.classList.toggle('open');
    });
    anchorLink.forEach(function (link) {
      link.addEventListener('click', function (e) {
        e.preventDefault();
        var container = inPageNav;
        anchorActiveLink = document.querySelector('.with-anchor.active');

        if (anchorActiveLink) {
          anchorActiveLink.classList.remove('active');
        }

        e.currentTarget.classList.add('active');
        triggerText.innerHTML = e.currentTarget.innerHTML;

        if (e.currentTarget.classList.contains('with-anchor')) {
          var targetID = e.currentTarget.getAttribute('data-target');
          var target = document.getElementById(targetID);

          if (!target) {
            target = document.querySelector('[data-hash="' + targetID + '"]');
          }

          if (target) {
            if (target.closest('.VerticalSliderNew')) {
              target = target.closest('.VerticalSliderNew');
            }

            window.location.hash = targetID; //updateScrollPosition(container, target, false);
          }

          inPageNav.classList.remove('open');
        }
      });
    });

    function resetElements() {
      inPageNavLinks = inPageNavList.querySelectorAll('.InPageNav-link');
      anchorLink = document.querySelectorAll('.with-anchor');
      anchorActiveLink = document.querySelector('.with-anchor.active');
    }

    function generateAnchors(needAnchors) {
      for (var i = 0; i < needAnchors.length; i++) {
        var needAnchor = needAnchors[i];

        if (needAnchor.querySelector('.anchor-title')) {
          var targetValue = needAnchor.id;
          var anchor = document.createElement('a');
          anchor.href = '#' + targetValue;
          anchor.innerText = needAnchor.querySelector('.anchor-title').textContent;
          anchor.className = 'InPageNav-link with-anchor';

          if (i == 0) {
            anchor.className = 'InPageNav-link with-anchor active';
          }

          anchor.setAttribute('data-target', targetValue);
          inPageNavContainer.append(anchor);
        }
      }
    }

    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          bindNavFixedEvent();
          ticking = false;
        });
        ticking = true;
      }
    });

    function updateAnchorByHash() {
      var container = inPageNav;

      if (container) {
        var str = document.location.hash.slice(1);
        var target = document.getElementById(str);

        var _anchorLink = container.querySelectorAll('.with-anchor');

        var _anchorActiveLink = container.querySelector('[data-target="' + str + '"]');

        _anchorLink.forEach(function (link) {
          if (link.classList.contains('active')) {
            link.classList.remove('active');
          }
        });

        if (_anchorActiveLink) {
          _anchorActiveLink.classList.add('active');
        }
      }
    }

    ;
    window.addEventListener('load', function (e) {
      e.preventDefault();
      updateAnchorByHash();
    }, false);
    window.addEventListener('hashchange', function (e) {
      //debugger;
      e.preventDefault();
      updateAnchorByHash();
    }, false);

    function bindNavFixedEvent() {
      var top = nav_top;
      var customUtil = utilities_CustomUtil.initSettings();
      var scroTop = window.scrollY || document.documentElement.scrollTop;
      var condition = scroTop > top;
      var ele = inPageNav;
      var maxTop = customUtil.getStickyMaxTop();

      if (scroTop < prevScroTop) {//scroll up
        //maxTop = maxTop - customUtil.settings.headerFixedHeight;
      } //ele.setAttribute("data-stickyEnd", maxTop);


      if (scroTop > prevScroTop) {
        //down
        condition = scroTop > top && scroTop < maxTop;
        toStart = false;

        if (toEnd) {
          condition = false;
        }
      } else {
        //up
        var minTop = 0;

        if (!customUtil.checkNavigationSection() && !customUtil.checkInPageNav()) {
          minTop = top - nav_height - customUtil.settings.headerFixedHeight;

          if (minTop < 0) {
            minTop = 0;
          }

          condition = scroTop > minTop && scroTop < maxTop;
        } else {
          minTop = top - nav_height;

          if (minTop < 0) {
            minTop = 0;
          }

          condition = scroTop > minTop && scroTop < maxTop;
        }

        toEnd = false;

        if (toStart) {
          condition = scroTop > minTop && true;
        }
      }

      if (scroTop >= maxTop) {
        toEnd = true;
      } else {
        toStart = true;
      }

      utilities_CustomUtil.bindStickyEvent(condition, ele);
      prevScroTop = scroTop;
    }
  }
}

/* harmony default export */ var modules_InPageNav = (InPageNav);
;// CONCATENATED MODULE: ./stories/js/modules/FormTabs/index.js


function FormTabs() {
  var tabs = document.querySelectorAll('.Tab');

  if (tabs && tabs.length > 0) {
    //const dropdownItems = document.querySelectorAll('.FormTabs-dropdownItem');
    //const formLink = document.getElementById('nav-option');
    //const formDropdown = document.getElementById('nav-dropdown');
    //const formIcon = document.getElementById('nav-icon');
    //let formTab = document.querySelector('.FormTabs');
    //let formTabBar = document.querySelector('.FormTabs-bar');
    //let ticking = false;
    //let tab_top = formTab.offsetTop;
    //let tabHeight = formTabBar.clientHeight;
    //let prevScroTop = 0;
    tabs.forEach(function (tab) {
      tab.addEventListener('click', function (e) {
        var curTab = e.currentTarget;
        var container = curTab.closest('.FormTabs');
        var activeTab = container.querySelectorAll('.Tab--active');
        activeTab[0].classList.remove('Tab--active');
        tab.classList.add('Tab--active');
        var relatedContentBodyShown = container.querySelectorAll('.RelatedContent-shown')[0];
        var relatedContentBodyHidden = container.querySelector('#' + tab.dataset.target);
        relatedContentBodyShown.classList.add('RelatedContent-hidden');
        relatedContentBodyShown.classList.remove('RelatedContent-shown');
        relatedContentBodyHidden.classList.remove('RelatedContent-hidden');
        relatedContentBodyHidden.classList.add('RelatedContent-shown');
      });
    });
    /*dropdownItems.forEach((dropdownItem) => {
      dropdownItem.addEventListener('click', () => {
        let activeItem = document.querySelectorAll('.FormTabs-dropdownHeaderActive');
        activeItem.forEach((item) => {
          item.classList.remove('FormTabs-dropdownHeaderActive');
        });
        let dropdownItemHeader = dropdownItem.querySelector('.FormTabs-dropdownHeader');
        dropdownItemHeader.classList.add('FormTabs-dropdownHeaderActive');
        let newTitle = dropdownItemHeader.dataset.title;
        let navHeader = document.getElementById('form-nav-header');
        navHeader.innerText = newTitle;
        let relatedContentBodyShown = document.querySelectorAll('.RelatedContent-shown')[0];
        let relatedContentBodyHidden = document.getElementById(dropdownItem.dataset.target);
        relatedContentBodyShown.classList.add('RelatedContent-hidden');
        relatedContentBodyShown.classList.remove('RelatedContent-shown');
        relatedContentBodyHidden.classList.remove('RelatedContent-hidden');
        relatedContentBodyHidden.classList.add('RelatedContent-shown');
        formLink.classList.remove('FormTabsNav-active');
        formLink.classList.add('FormTabsNav-inactive');
        formDropdown.classList.remove('FormTabs-dropdownActive');
        formIcon.src = '/ww/redesign/assets/icons/expand-more.svg';
         formTabBar.classList.remove('open');
        updateScrollPosition(formTabBar, formTab);
      });
    });
     formLink.addEventListener('click', () => {
      if (formLink.classList.contains('FormTabsNav-inactive')) {
        formLink.classList.remove('FormTabsNav-inactive');
        formLink.classList.add('FormTabsNav-active');
        formDropdown.classList.add('FormTabs-dropdownActive');
        formIcon.src = '/ww/redesign/assets/icons/close.svg';
      } else {
        formLink.classList.remove('FormTabsNav-active');
        formLink.classList.add('FormTabsNav-inactive');
        formDropdown.classList.remove('FormTabs-dropdownActive');
        formIcon.src = '/ww/redesign/assets/icons/expand-more.svg';
      }
       formTabBar.classList.toggle('open');
    });
     function updateScrollPosition(container, target) {
      if (container.classList.contains('sticky-fixed')) {
        let eleTop = CustomUtil.getInStickyTop(container);
        let top = target.offsetTop;
        let scrollTo = top - eleTop - CustomUtil.settings.headerFixedHeight;
        window.scrollTo(0, scrollTo);
      }
    }
     window.addEventListener('scroll', (e) => {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          bindTabFixedEvent();
          ticking = false;
        });
        ticking = true;
      }
    });
     function bindTabFixedEvent() {
      let eleTop = CustomUtil.getInStickyTop(formTabBar);
      //console.log("top:" + tab_top + " offset:" + formTab.offsetTop);
      CustomUtil.updateSettings();
      let scroTop = window.scrollY || document.documentElement.scrollTop;
      let min = formTab.offsetTop - tabHeight - eleTop;
      let max = min + formTab.clientHeight - tabHeight;
      if (scroTop <= prevScroTop) {
        min = formTab.offsetTop - tabHeight - eleTop - CustomUtil.settings.headerFixedHeight;
      }
       let condition = scroTop > min && scroTop < max;
      let ele = formTabBar;
       //Condition when down after fixedtab disappear
      if (condition) {
        ele.classList.add('has-fixed');
      }
       CustomUtil.bindStickyEvent(condition, ele);
       //Condition when up to original tab
      if (scroTop <= min) {
        ele.classList.remove('has-fixed');
      }
       prevScroTop = scroTop;
    }*/
  }
}

/* harmony default export */ var modules_FormTabs = (FormTabs);
;// CONCATENATED MODULE: ./stories/js/modules/AlertBar/index.js
function AlertBar_toConsumableArray(arr) { return AlertBar_arrayWithoutHoles(arr) || AlertBar_iterableToArray(arr) || AlertBar_unsupportedIterableToArray(arr) || AlertBar_nonIterableSpread(); }

function AlertBar_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function AlertBar_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AlertBar_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AlertBar_arrayLikeToArray(o, minLen); }

function AlertBar_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function AlertBar_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AlertBar_arrayLikeToArray(arr); }

function AlertBar_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





core_class.use([navigation]);

function AlertBar() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      el = _ref.el;

  console.log('AlertBar');
  var AlertBar = document.querySelectorAll('.AlertBar.AlertBarNew');
  var transitionSpeed = 1200;
  var delaySpeed = 5000;
  var swiperTarget = el.getAttribute('id');
  var swiperContainer = document.getElementById(swiperTarget);
  var leftButtonEl = document.getElementById('control-left-' + swiperTarget);
  var rightButtonEl = document.getElementById('control-right-' + swiperTarget);
  var singleSlideClass = 'AlertBar--singleSlide';
  var singleClass = 'AlertBar--single';
  var swiperLength = swiperContainer.querySelectorAll('.swiper-slide').length;

  var isSingleSlide = function isSingleSlide(swiperEl) {
    if (el.classList.contains(singleSlideClass) || swiperEl.querySelector('.swiper-wrapper').children.length < 2) {
      el.classList.add(singleSlideClass);
      el.closest('.AlertBar').classList.add(singleClass);
      return true;
    }
  };

  var clicked = false;
  var paused = false;
  var isAutoplayRunning = true;
  var loopIndex = 0;
  var alertSwiper = new core_class(el, {
    effect: 'slide',
    speed: transitionSpeed,
    delay: delaySpeed,
    autoplay: isSingleSlide(el) ? false : true,
    disableOnInteraction: true,
    //stopOnLastSlide: true,  //won't work when loop is
    slidesPerView: 'auto',
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    watchOverflow: true,
    loop: isSingleSlide(el) ? false : true,
    navigation: {
      nextEl: rightButtonEl,
      prevEl: leftButtonEl
    }
  });
  AlertBar.forEach(function (alert) {
    var close = alert.querySelector('.AlertBar-close');

    if (close) {
      close.addEventListener('click', function () {
        if (!utilities_CustomUtil.isLocalhost()) {
          www.setSessionCookie("showAlertBar", "false");
        }

        alert.classList.add('hide-bar');
        updateRelatedElements();
      });
    }
  });

  function updateRelatedElements() {
    var shyPlaceholderHeight = utilities_CustomUtil.screenIs == 'isMobile' ? 76 : 143;

    if (document.querySelector('.NavigationSiteSection') != null) {
      shyPlaceholderHeight = utilities_CustomUtil.screenIs == 'isMobile' ? 104 : 128;
    } else if (document.querySelector('.PrimaryNavEComm') != null) {
      shyPlaceholderHeight = utilities_CustomUtil.screenIs == 'isMobile' || utilities_CustomUtil.screenIs == 'isTablet' ? 68 : 120;
    }

    var shyNav = document.querySelector('[data-shy-nav]');
    var shyPlaceholder = document.querySelector('.ShyNav-shim');
    var search = document.querySelector('[data-search]');
    var secondaryNav = document.querySelector('.SecondaryNav');
    var submenus = document.querySelectorAll('[data-navigationmenu]');
    var mobildRow = document.querySelector('.PrimaryNav >.Container--row');

    if (shyNav) {
      shyPlaceholder.style.height = shyPlaceholderHeight + 'px';
      shyNav.style.height = shyPlaceholder.clientHeight + 'px'; // submenus.forEach((menu) => {
      //   menu.style.top = shyNav.clientHeight + 'px';
      // });

      search.removeAttribute('style');
    }
  }

  function setMargin() {
    if (!el.classList.contains(singleSlideClass)) {
      var alertHeight = swiperContainer ? swiperContainer.clientHeight : 0;
      var alertWidth = swiperContainer ? swiperContainer.clientWidth : 0;
      var alertSlides = swiperContainer.querySelectorAll('.slide-item');
      alertSlides.forEach(function (slide) {
        var slideHeight = slide.clientHeight + 8;
        var slideMarginTop = (alertHeight - slideHeight - 8) / 2;
        var slideWidth = slide.clientWidth + 8;
        var slideMarginLeft = (alertWidth - slideWidth - 8) / 2;
        slide.style.top = slideMarginTop + 'px';
        slide.style.left = slideMarginLeft + 'px';
      });
    }
  } //setMargin();


  window.addEventListener('load', function (e) {//setMargin();
  });
  window.addEventListener('resize', function (e) {//setMargin();
  });
  rightButtonEl.addEventListener('click', function (e) {
    clicked = true;
    alertSwiper.autoplay.stop();
  });
  leftButtonEl.addEventListener('click', function (e) {
    clicked = true;
    alertSwiper.autoplay.stop();
  });
  swiperContainer.addEventListener('mouseenter', function (e) {
    if (!clicked && loopIndex < 1) {
      alertSwiper.autoplay.stop();
      paused = true;
    }
  });
  swiperContainer.addEventListener('mouseleave', function (e) {
    if (!clicked && paused && loopIndex < 1) {
      alertSwiper.autoplay.start();
    }
  });
  alertSwiper.on('autoplayStop', function () {
    return isAutoplayRunning = false;
  });
  alertSwiper.on('autoplayStart', function () {
    return isAutoplayRunning = true;
  });
  alertSwiper.on('slideChange', function () {
    console.log(alertSwiper.realIndex);

    if (isAutoplayRunning) {
      if (alertSwiper.realIndex == swiperLength - 1) {
        loopIndex = 1;
      }

      if (loopIndex == 1) {
        if (alertSwiper.realIndex == 0) {
          alertSwiper.autoplay.stop();
        }
      }
    }
  });
  return {
    destroy: function destroy() {
      alertSwiper.detachEvents();
      alertSwiper.destroy();
    }
  };
}

AlertBar.defaultSelector = '.AlertBar .swiper-container';

AlertBar.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? AlertBar.defaultSelector : _ref2$selector;

  return AlertBar_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return AlertBar({
      el: el
    });
  });
};

/* harmony default export */ var modules_AlertBar = (AlertBar);
;// CONCATENATED MODULE: ./stories/js/components/MFCarousel.js
var MFCarousel = function MFCarousel(container, options) {
  var container = document.querySelectorAll(container);

  if (container && container.length > 0) {
    return container.forEach(function (c) {
      new MFCarousel()._init(c, options);
    });
  }
};

MFCarousel.fn = MFCarousel.prototype = {
  constructor: MFCarousel,
  _defaults: {
    images: [],
    innerClass: 'MFCarousel-inner',
    itemClass: 'MFCarousel-item',
    arrowControlClass: 'MFCarousel-control--arrows',
    prevClass: 'prev',
    nextClass: 'next',
    indicatorControlClass: 'MFCarousel-control--indicators',
    indicatorClass: 'indicator-item',
    activeClass: 'active',
    disabledClass: 'disabled',
    control: 'data-slide',
    auto: false,
    direction: 'left'
  },
  _init: function _init(container, options) {
    var that = this;

    this._setElements(container, options);

    var images = [];

    if (that.items && that.items.length > 0) {
      that.items.forEach(function (item) {
        var img = item.querySelector('img');

        if (img) {
          images.push(img.getAttribute('src'));
        }
      });
    }

    this._preloadImages(images);

    this._setInnerHeight();

    this._bindEvents();

    return this;
  },
  _setElements: function _setElements(container, options) {
    var _this = this;

    this.opts = Object.assign({}, this._defaults, options);
    this.container = container;
    this.containerString = '#' + container + ' ';
    this.inner = this.container.getElementsByClassName(this.opts.innerClass)[0];
    this.items = this.container.getElementsByClassName(this.opts.itemClass);
    this.controls = this.container.querySelectorAll('[' + this.opts.control + ']');
    this.arrowPrev = this.container.querySelector('[' + this.opts.control + '="prev"]');
    this.arrowNext = this.container.querySelector('[' + this.opts.control + '="next"]');
    this.controls.forEach(function (item, i) {
      var key = item.getAttribute(_this.opts.control);
      _this.controlObj[key] = item;
    });
    this.arrowControl = this.container.getElementsByClassName(this.opts.arrowControlClass);
    this.indicatorControl = this.container.getElementsByClassName(this.opts.indicatorControlClass);
    this.indicatorItems = this.container.getElementsByClassName(this.opts.indicatorClass);
    this.length = this.items.length;
  },
  _preloadImages: function _preloadImages(imgs) {
    var that = this;

    for (var i = 0; i < imgs.length; i++) {
      that.opts.images[i] = new Image();
      that.opts.images[i].src = imgs[i];

      if (i == imgs.length - 1) {
        that.opts.images[imgs.length - 1].onload = function () {
          that._setInnerHeight();
        };
      }
    }
  },
  _setInnerHeight: function _setInnerHeight() {
    var height = 0;
    this.items.forEach(function (item) {
      item.style.height = 'auto';

      if (item.clientHeight > height) {
        height = item.clientHeight;
      }
    });

    if (this.inner && height != 0) {
      this.inner.style.height = height + 'px';
    }

    this.items.forEach(function (item) {
      item.style.height = '100%';
    });
  },
  _bindEvents: function _bindEvents() {
    var _this2 = this;

    var that = this;
    that.controls.forEach(function (trigger, i) {
      trigger.addEventListener('click', function (e) {
        e.preventDefault();
        var target = e.currentTarget;
        var parent = target.parentNode;
        var currentTarget;

        if (target.getAttribute(that.opts.control) != null) {
          currentTarget = target;
        } else if (parent.getAttribute(that.opts.control) != null) {
          currentTarget = parent;
        }

        var slide = currentTarget.getAttribute(that.opts.control);

        if (slide != null) {
          if (isNaN(slide)) {
            if (slide.toLowerCase() === 'prev') {
              that.prev();
            } else if (slide.toLowerCase() === 'next') {
              that.next();
            }
          } else {
            //[].indexOf.call(that.indicatorItems, currentTarget)
            that.index = Number(slide);

            that._update();

            that._updateStatus();
          }
        } else {}
      });
    });
    window.addEventListener('resize', function () {
      _this2._setInnerHeight();
    });
  },
  first: function first() {
    this.index = 0;

    this._update();
  },
  last: function last() {
    this.index = this.length - 1;

    this._update();
  },
  prev: function prev() {
    if (this.index-- > 0) {
      this._update();
    } else {
      this.index = 0;
      console.log('This is already first one');
    }

    if (this.container.classList.contains('MFCarousel-slide')) {
      var pIndex = this.index + 1;
      this.items[pIndex].style.transform = 'translateX(' + 100 + '%)';
      this.items[this.index].style.transform = 'translateX(0)';
    }
  },
  next: function next() {
    if (++this.index < this.length) {
      this._update();
    } else {
      this.index = this.length - 1;
      console.log('This is already last one');
    }

    if (this.container.classList.contains('MFCarousel-slide')) {
      var pIndex = this.index - 1;
      this.items[pIndex].style.transform = 'translateX(' + -100 + '%)';
      this.items[this.index].style.transform = 'translateX(0)';
    }
  },
  get: function get(num) {
    this.index = num >= 0 && num < this.length ? num : 0;

    this._update();
  },
  _update: function _update() {
    var that = this;

    that._updateStatus();
  },
  _updateStatus: function _updateStatus() {
    var that = this;
    that.items.forEach(function (item, i) {
      if (that.index != i) {
        item.classList.remove(that.opts.activeClass);
      } else {
        item.classList.add(that.opts.activeClass);
      }
    });

    if (this.indicatorControl.length) {
      that.indicatorItems.forEach(function (item, i) {
        if (that.index != i) {
          item.classList.remove(that.opts.activeClass);
        } else {
          item.classList.add(that.opts.activeClass);
        }
      });
    }

    if (this.arrowControl.length) {
      if (that.index < 1) {
        that.arrowNext.classList.remove(that.opts.disabledClass);
        that.arrowPrev.classList.add(that.opts.disabledClass);
      } else if (that.index >= this.length - 1) {
        that.arrowPrev.classList.remove(that.opts.disabledClass);
        that.arrowNext.classList.add(that.opts.disabledClass);
      } else {
        that.arrowPrev.classList.remove(that.opts.disabledClass);
        that.arrowNext.classList.remove(that.opts.disabledClass);
      }
    }
  },
  controlObj: {},
  index: 0,
  length: 0,
  push: [].push,
  sort: [].sort,
  splice: [].splice
};
/* harmony default export */ var components_MFCarousel = (MFCarousel);
;// CONCATENATED MODULE: ./stories/js/modules/AlertBarOld/index.js




function AlertBarOld() {
  console.log('AlertBarOld');
  var alert = document.querySelectorAll('.AlertBarOld');

  if (alert && alert.length > 0) {
    bindMFCarousel();

    function bindMFCarousel() {
      var alertBar = components_MFCarousel('.AlertBarOld-carousel');
      alert.forEach(function (al) {
        var close = al.querySelector('.MFCarousel-close');

        if (close) {
          close.addEventListener('click', function () {
            if (!utilities_CustomUtil.isLocalhost()) {
              www.setSessionCookie("showAlertBar", "false");
            }

            al.classList.add('hide-bar');
            updateRelatedElements();
          });
        }
      });
    }

    function updateRelatedElements() {
      var shyPlaceholderHeight = utilities_CustomUtil.screenIs == 'isMobile' ? 76 : 143;

      if (document.querySelector('.NavigationSiteSection') != null) {
        shyPlaceholderHeight = utilities_CustomUtil.screenIs == 'isMobile' ? 104 : 128;
      } else if (document.querySelector('.PrimaryNavEComm') != null) {
        shyPlaceholderHeight = utilities_CustomUtil.screenIs == 'isMobile' || utilities_CustomUtil.screenIs == 'isTablet' ? 68 : 120;
      }

      var shyNav = document.querySelector('[data-shy-nav]');
      var shyPlaceholder = document.querySelector('.ShyNav-shim');
      var search = document.querySelector('[data-search]');
      var secondaryNav = document.querySelector('.SecondaryNav');
      var submenus = document.querySelectorAll('[data-navigationmenu]');
      var mobildRow = document.querySelector('.PrimaryNav >.Container--row');

      if (shyNav) {
        shyPlaceholder.style.height = shyPlaceholderHeight + 'px';
        shyNav.style.height = shyPlaceholder.clientHeight + 'px'; // submenus.forEach((menu) => {
        //   menu.style.top = shyNav.clientHeight + 'px';
        // });

        search.removeAttribute('style');
      }
    }
  }
}

/* harmony default export */ var modules_AlertBarOld = (AlertBarOld);
;// CONCATENATED MODULE: ./stories/js/modules/ArticleDetail/index.js
function ArticleDetail() {
  console.log('ArticleDetail');
  var ArticleDetail = document.querySelector('.ArticleDetail');
  setContentImageOverlay();

  function setContentImageOverlay() {
    if (ArticleDetail) {
      var contentImage = ArticleDetail.querySelector('.content-image');
      var overlay = ArticleDetail.querySelector('.content-overlay');

      if (contentImage && overlay) {
        overlay.style.width = ArticleDetail.clientWidth + 'px';
        overlay.style.height = contentImage.clientHeight / 2 + 'px';
        overlay.style.top = -contentImage.clientHeight / 2 + 'px';
      }
    }
  }

  window.addEventListener('resize', function (e) {
    setContentImageOverlay();
  });
}

/* harmony default export */ var modules_ArticleDetail = (ArticleDetail);
;// CONCATENATED MODULE: ./stories/js/modules/CardLayoutOffer/index.js
function CardLayoutOffer() {
  var cardLayoutOffer = document.querySelectorAll('.CardLayoutOffer');

  if (cardLayoutOffer) {
    var card = '.CardLayoutOffer-cards';
    var cardTitle = '.card-title';
    var cardDes = '.card-des';
    var cardOffer = '.card-offer';
    var cardBtn = '.CardLayoutOffer-buttonsContainer';
    setSameElementHeight(card, cardTitle);
    setSameElementHeight(card, cardDes);
    setSameElementHeight(card, cardOffer);
    setSameElementHeight(card, cardBtn);
    window.addEventListener('resize', function (e) {
      setSameElementHeight(card, cardTitle);
      setSameElementHeight(card, cardDes);
      setSameElementHeight(card, cardOffer);
      setSameElementHeight(card, cardBtn);
    });
  }

  function setSameElementHeight(parent, child) {
    var boxes = document.querySelectorAll(parent);
    boxes.forEach(function (box) {
      var tallest = 0;
      var elements = box.querySelectorAll(child);
      elements.forEach(function (element) {
        element.style.height = 'auto';

        if (element.clientHeight > tallest) {
          tallest = element.clientHeight;
        }
      });
      elements.forEach(function (element) {
        element.style.height = tallest + 'px';
      });
    });
  }
}

/* harmony default export */ var modules_CardLayoutOffer = (CardLayoutOffer);
;// CONCATENATED MODULE: ./stories/js/modules/ContentLayoutFaq/index.js
//import MFCollapse from '../../components/MFCollapse';
function ContentLayoutFaq() {
  console.log('ContentLayoutFaq');

  var _isTransitioning;

  var ContentLayoutFaqs = document.querySelectorAll('.ContentLayoutFaq');

  if (ContentLayoutFaqs) {
    /*var accordion = MFCollapse('.ContentLayoutFaq', {MULTI_COLLAPSE:true});
    var accordionElement = document.querySelector('.ContentLayoutFaq');
    accordionElement.addEventListener('hidden.mf.collapse', function (event) {
      debugger;
      console.log('hidden:' + event.detail.ele);
    });
    accordionElement.addEventListener('shown.mf.collapse', function (event) {
      debugger;
      console.log('shown:' + event.detail.ele);
    });*/
    ContentLayoutFaqs.forEach(function (ContentLayoutFaq) {
      var accordionToggles = ContentLayoutFaq.querySelectorAll('[data-toggle="collapse"]');
      var accordionCollapses = ContentLayoutFaq.querySelectorAll('.collapse');
      accordionCollapses.forEach(function (collapse) {
        var dimission = collapse.getBoundingClientRect().height;
        collapse.addEventListener('transitionend', function (e) {
          collapse.classList.remove('collapsing');

          if (collapse.style.height == '') {
            collapse.classList.remove('show');
          }
        });
      });
      accordionToggles.forEach(function (toggle) {
        var target = toggle.getAttribute('data-target');
        var collapse = ContentLayoutFaq.querySelector(target);
        collapse.style.height = collapse.clientHeight + 'px';
        toggle.addEventListener('click', function () {
          if (collapse.classList.contains('show')) {
            toggle.classList.add('collapsed');
            toggle.setAttribute('aria-expanded', 'false');
            collapse.classList.add('collapsing');
            collapse.style.height = '';
          } else {
            toggle.classList.remove('collapsed');
            toggle.setAttribute('aria-expanded', 'true');
            collapse.classList.add('show');
            collapse.classList.add('collapsing');
            collapse.style.height = collapse.querySelector('.accordion-content').clientHeight + 'px';
          }
        });
      });
      window.addEventListener('resize', function () {
        var showCollapses = ContentLayoutFaq.querySelectorAll('.collapse.show');
        showCollapses.forEach(function (collapse) {
          collapse.style.height = collapse.querySelector('.accordion-content').clientHeight + 'px';
        });
      });
    });
  }
}

/* harmony default export */ var modules_ContentLayoutFaq = (ContentLayoutFaq);
;// CONCATENATED MODULE: ./stories/js/modules/Chatbot/index.js
function Chatbot() {
  console.log('Chatbot');
  var chatbot = document.querySelector('.Chatbot');

  if (chatbot) {
    var trigger = document.getElementById('all');
    trigger.addEventListener('click', function () {
      chatbot.classList.toggle('open');
    });
  }
}

/* harmony default export */ var modules_Chatbot = (Chatbot);
;// CONCATENATED MODULE: ./stories/js/modules/NavigationProductTour/index.js
function NavigationProductTour() {
  console.log('NavigationProductTour');
  var body = document.body;
  var navigationProductTour = document.querySelector('.NavigationProductTour');

  if (navigationProductTour) {
    var navigationProductTourMenu = document.querySelector('[data-navigationproducttour]');
    var navigationProductTourTriggers = document.querySelectorAll('[data-navigationproducttour-trigger]');
    var navigationProductTourSubmenus = document.querySelectorAll('[data-submenu]');
    var submenuTriggers = document.querySelectorAll('[data-submenu-trigger]');
    navigationProductTourTriggers.forEach(function (trigger) {
      trigger.addEventListener('click', function () {
        navigationProductTourTriggers.forEach(function () {
          return trigger.classList.toggle('is-active');
        });
        document.body.classList.toggle('is-navigationProductTourOpen');
        navigationProductTourMenu.classList.toggle('is-open');
        navigationProductTourMenu.querySelector('.NavigationProductTour-subMenus-menu').classList.remove('is-open');
        body.classList.remove('is-submenuOpen');
        body.classList.remove('is-submenuChildOpen');
      });
    });
    submenuTriggers.forEach(function (trigger) {
      var submenuName = trigger.dataset.submenuTrigger;
      trigger.addEventListener('click', function () {
        navigationProductTourSubmenus.forEach(function (submenu) {
          submenu.classList.remove('is-open');
        });

        if (submenuName) {
          var submenu = document.querySelector("[data-submenu=\"".concat(submenuName, "\"]"));
          submenu.classList.add('is-open');
          body.classList.add('is-submenuOpen');

          if (submenu.dataset.submenuChild) {
            body.classList.add('is-submenuChildOpen');
          } else {
            body.classList.remove('is-submenuChildOpen');
          }
        } else {
          var openSubmenu = document.querySelector('[data-submenu].is-open');

          if (openSubmenu) {
            openSubmenu.classList.remove('is-open');
          }

          body.classList.remove('is-submenuOpen');
          body.classList.remove('is-submenuChildOpen');
        }
      });
    });
  }
}

/* harmony default export */ var modules_NavigationProductTour = (NavigationProductTour);
;// CONCATENATED MODULE: ./stories/js/modules/ContentLayoutProductTour/index.js
function ContentLayoutProductTour_toConsumableArray(arr) { return ContentLayoutProductTour_arrayWithoutHoles(arr) || ContentLayoutProductTour_iterableToArray(arr) || ContentLayoutProductTour_unsupportedIterableToArray(arr) || ContentLayoutProductTour_nonIterableSpread(); }

function ContentLayoutProductTour_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ContentLayoutProductTour_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ContentLayoutProductTour_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ContentLayoutProductTour_arrayLikeToArray(o, minLen); }

function ContentLayoutProductTour_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function ContentLayoutProductTour_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return ContentLayoutProductTour_arrayLikeToArray(arr); }

function ContentLayoutProductTour_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable no-param-reassign,no-return-assign */




core_class.use([autoplay, effect_fade]);

function ContentLayoutProductTour() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      el = _ref.el;

  console.log('ContentLayoutProductTour'); //el = document.querySelector('.ContentLayoutProductTour');

  var defaultDuration = 6;
  var autoplayDelay = 6; //5000;

  var transitionSpeed = 0.3; //300;

  var singleSlideClass = 'ContentLayoutProductTour--singleSlide';
  var contentPanelEl = el.querySelector('.ContentLayoutProductTour-contentPanel');
  var contentSwiperEl = el.querySelector('.ContentLayoutProductTour-contentPanel .swiper-container');
  var videoSwiperEl = el.querySelector('.ContentLayoutProductTour-contentPanel .video-container');
  var video = el.querySelector('video');
  var videoList = el.querySelectorAll('.ContentLayoutProductTour-video');
  var SwiperEl = el.querySelector('.ContentLayoutProductTour-contentPanel .ContentLayoutProductTour-container');
  var SliderSwiperEl = el.querySelector('.ContentLayoutProductTour-contentPanel .swiper-wrapper');
  var SliderActiveEl = el.querySelector('.ContentLayoutProductTour-contentPanel .swiper-slide-active');
  var leftButtonEl = el.querySelector('.ContentLayoutProductTour-navArrowButton-left');
  var paginationContainerEl = el.querySelector('.ContentLayoutProductTour-paginationContainer');
  var rightButtonEl = el.querySelector('.ContentLayoutProductTour-navArrowButton-right');
  var calloutsEls = SwiperEl.querySelectorAll('.ContentLayoutProductTour-callout');
  var calloutsMobileEl = contentPanelEl.querySelector('.ContentLayoutProductTour-callouts-mobile');
  var expandEl = el.querySelector('.ContentLayoutProductTour-expand');
  var ModalEl = document.getElementById(expandEl.dataset.micromodalTrigger);
  var ModalImagesEls = ModalEl.querySelectorAll('.ContentLayoutProductTour-modalImage');
  var ModalCalloutsEls = ModalEl.querySelectorAll('.ContentLayoutProductTour-callouts');
  var ModalVideo = ModalEl.querySelector('video');
  var browserInfo = new (ua_parser_default())().getBrowser();
  var isAutoplayRunning = true;
  var isVideoAuto = true;
  var timeArry = [];
  var isVideoPlaying = true;
  var videoActiveIndex = 0;
  var videoCurrentIndex = 0;
  var isImagesReady = false;
  var isMobile = getComputedStyle(calloutsMobileEl).display == 'none' ? false : true;
  var isVideo = video ? true : false;

  var revealCustomElements = function revealCustomElements(ele, timer, speed) {
    if (ele) {
      var revealCEls = ele.querySelectorAll('[data-creveal]');
      var revealCEvent = new CustomEvent('isCRevealed', {
        detail: {
          isCRevealed: true
        }
      });
      var observerConfig = {
        rootMargin: '0px 0px -9% 0px',
        threshold: 0
      };
      var observer = new IntersectionObserver(function (elements, self) {
        elements.forEach(function (element) {
          if (element.isIntersecting) {
            // Add class and stop watching
            element.target.classList.add('is-revealed');
            element.target.dispatchEvent(revealCEvent);
            self.unobserve(element.target);
          }
        });
      }, observerConfig);
      revealCEls.forEach(function (element) {
        var delay = parseInt(element.dataset.creveal, 10) || 0; //element.style.transitionDelay = `${timer * delay - delay * speed}s`;

        element.style.transitionDelay = "".concat(timer * delay, "s");
        observer.observe(element);
      });
    }
  };

  var showCallouts = function showCallouts() {
    var activeEl;
    var activeElDuration;
    var imageWidth;
    var boxWidth;
    var boxEl;

    if (contentSwiperEl) {
      activeEl = contentSwiperEl.querySelector('.swiper-slide-active');
      activeElDuration = parseInt(activeEl.getAttribute('data-swiper-autoplay')) / 1000;
      boxEl = activeEl;
      imageWidth = activeEl.querySelector('.ContentLayoutProductTour-frontground-large').clientWidth;
    } else {
      activeEl = videoList[videoCurrentIndex];
      activeElDuration = parseInt(activeEl.getAttribute('data-duration'));
      boxEl = videoSwiperEl;
      imageWidth = video.clientWidth;
    }

    boxWidth = (boxEl.clientWidth - imageWidth) / 2 - 30;
    var calloutsType = activeEl.dataset.calloutType;
    var calloutsEl = activeEl.querySelectorAll('.ContentLayoutProductTour-callout');
    var calloutLen = calloutsEl.length;
    var transitionDuration = activeElDuration / calloutLen;
    var calloutsMobileIndex = calloutsEl[0].parentElement.dataset.index;
    var calloutsMobileActiveEl = calloutsMobileEl.querySelector('.ContentLayoutProductTour-callouts[data-index= "' + calloutsMobileIndex + '"]');
    revealCustomElements(activeEl, transitionDuration, transitionSpeed);
    calloutsEl.forEach(function (cEl, i) {
      var cElAlign = cEl.dataset.align;
      var width = cEl.offsetLeft + 30;

      if (cElAlign.toLowerCase() == 'right') {
        width = imageWidth - cEl.offsetLeft + 30;
        cEl.querySelector('i').style.left = 0;
        cEl.querySelector('div').style.left = "".concat(width, "px");
      } else {
        width = cEl.offsetLeft + 30;
        cEl.querySelector('i').style.right = '100%';
        cEl.querySelector('div').style.right = "calc(100% + ".concat(width, "px)");
      }

      var transitionDelay = cEl.querySelector('i').style.transitionDelay;

      if (calloutsType.toLowerCase() == 'immediate') {
        isMobile = getComputedStyle(calloutsMobileEl).display == 'none' ? false : true;

        if (!isMobile) {
          //cEl.querySelector('span').style.transition =`opacity ${transitionSpeed}s linear`;
          cEl.querySelector('i').style.transition = "width ".concat(transitionSpeed, "s linear ").concat(transitionSpeed, "s");
          cEl.querySelector('div').style.transition = "opacity ".concat(transitionSpeed, "s linear ").concat(transitionSpeed, "s,transform ").concat(transitionSpeed, "s linear ").concat(transitionSpeed, "s");
        } else {
          cEl.querySelector('span').style.transition = "opacity ".concat(transitionSpeed, "s linear ").concat(transitionDelay);
        }
      } else {
        cEl.querySelector('span').style.transition = "opacity ".concat(transitionSpeed, "s linear ").concat(transitionDelay);
        cEl.querySelector('i').style.transition = "width ".concat(transitionSpeed, "s linear ").concat(transitionDelay);
        cEl.querySelector('div').style.transition = "opacity ".concat(transitionSpeed, "s linear ").concat(transitionDelay, ", transform ").concat(transitionSpeed, "s linear ").concat(transitionDelay);
      }

      cEl.querySelector('span').style.opacity = 1;
      cEl.querySelector('i').style.width = "".concat(width, "px");
      cEl.querySelector('div').style.width = "".concat(boxWidth, "px");
      cEl.querySelector('div').style.opacity = 1;
      cEl.querySelector('div').style.transform = 'translateY(0)';
      var cElIndex = cEl.dataset.index;
      var transitionEl = cEl.querySelector('span');
      transitionEl.addEventListener('transitionstart', function (e) {
        var p = e.currentTarget.parentElement;
        var pIndex = parseInt(p.dataset.index);
        calloutsEl.forEach(function (el) {
          if (parseInt(el.dataset.index) < pIndex) {
            el.querySelector('span').style.opacity = 0;
            el.querySelector('span').style.transition = 'none';
            el.querySelector('i').style.width = 0;
            el.querySelector('i').style.transition = 'none';
            el.querySelector('div').style.opacity = 0;
            el.querySelector('div').style.transform = 'translateY(5px)';
            el.querySelector('div').style.transition = 'none';
          }
        });
      }); //For Mobile

      if (isMobile) {
        var mobileCEl = calloutsMobileActiveEl.querySelectorAll('.ContentLayoutProductTour-callout');
        var mobileActiveCEl = calloutsMobileActiveEl.querySelector('.ContentLayoutProductTour-callout[data-index= "' + cElIndex + '"]');
        mobileActiveCEl.querySelector('div').style.opacity = 1;
        mobileActiveCEl.querySelector('div').style.transition = "opacity ".concat(transitionSpeed, "s linear ").concat(transitionDelay);
        var mobileTransitionEl = mobileActiveCEl.querySelector('div');
        mobileTransitionEl.addEventListener('transitionstart', function (e) {
          var p = e.currentTarget.parentElement;
          var pp = p.parentElement;
          var pIndex = parseInt(p.dataset.index);
          calloutsEl.forEach(function (el) {
            if (parseInt(el.dataset.index) < pIndex) {
              el.querySelector('span').style.opacity = 0;
              el.querySelector('span').style.transition = 'none';
            }
          });
          mobileCEl.forEach(function (cel) {
            if (cel.dataset.index < pIndex) {
              cel.querySelector('div').style.opacity = 0;
              cel.querySelector('div').style.transition = 'none';
            }
          });
        });
      }
    });
  };

  var resetCalloutsForSingle = function resetCalloutsForSingle() {
    if (isSingleSlide) {
      var activeEl = contentSwiperEl.querySelector('.swiper-slide-active');
      var calloutsEl = activeEl.querySelectorAll('.ContentLayoutProductTour-callout');
      calloutsEl.forEach(function (el) {
        if (parseInt(el.dataset.index) > 0) {
          el.querySelector('span').style.opacity = 0;
          el.querySelector('span').style.transition = 'none';
          el.querySelector('i').style.width = 0;
          el.querySelector('i').style.transition = 'none';
          el.querySelector('div').style.opacity = 0;
          el.querySelector('div').style.transform = 'translateY(5px)';
          el.querySelector('div').style.transition = 'none';
        }
      });

      if (isMobile) {
        var calloutsMobileIndex = calloutsEl[0].parentElement.dataset.index;
        var calloutsMobileActiveEl = calloutsMobileEl.querySelector('.ContentLayoutProductTour-callouts[data-index= "' + calloutsMobileIndex + '"]');
        var mobileCEl = calloutsMobileActiveEl.querySelectorAll('.ContentLayoutProductTour-callout');
        mobileCEl.forEach(function (cel) {
          cel.querySelector('div').style.opacity = 0;
          cel.querySelector('div').style.transition = 'none';
        });
      }
    }
  };

  var setCalloutsPosition = function setCalloutsPosition(children) {
    var pWidth = 640;
    var pHeight = 360;
    children.forEach(function (child) {
      var cX = parseInt(child.dataset.hotspotx);
      var cY = parseInt(child.dataset.hotspoty);
      var cLeft = (cX / pWidth).toFixed(2) * 100;
      var cTop = (cY / pHeight).toFixed(2) * 100;
      child.style.left = cLeft + '%';
      child.style.top = cTop + '%';
    });
  };

  var resetCallouts = function resetCallouts(els) {
    els.forEach(function (el) {
      el.querySelectorAll('.ContentLayoutProductTour-callout').forEach(function (cEl, i) {
        cEl.querySelector('span').style.opacity = 0;
        cEl.querySelector('i').style.width = 0;
        cEl.querySelector('div').style.opacity = 0;
        cEl.querySelector('div').style.transform = 'translateY(5px)';
        cEl.querySelector('span').style.transition = 'none';
        cEl.querySelector('div').style.transition = 'none';
        cEl.querySelector('i').style.transition = 'none';
      });
    });
    calloutsMobileEl.querySelectorAll('.ContentLayoutProductTour-callout').forEach(function (cEl, i) {
      cEl.querySelector('div').style.opacity = 0;
      cEl.querySelector('div').style.transition = 'none';
    });
  };

  var updateProgressBars = function updateProgressBars(index) {
    paginationContainerEl.querySelectorAll('.ContentLayoutProductTour-paginationButton-progressBar').forEach(function (barEl, i) {
      var isActiveIndex = i === index;
      var pageDuration = parseInt(barEl.dataset.duration);
      var autoPlay = contentSwiperEl ? isAutoplayRunning : isVideoAuto; //barEl.style.transition =
      //  isActiveIndex && isAutoplayRunning ? `width ${pageDuration + transitionSpeed}s linear` : 'none';

      barEl.style.transition = isActiveIndex && autoPlay ? "width ".concat(pageDuration, "s linear") : 'none';
      barEl.style.width = isActiveIndex ? '100%' : 0;
    });
  };

  var isSingleSlide = function () {
    if (contentSwiperEl) {
      if (el.classList.contains(singleSlideClass) || contentSwiperEl.querySelector('.swiper-wrapper').children.length < 2) {
        el.classList.add(singleSlideClass);
        return true;
      }
    }
  }();

  var contentSwiper = contentSwiperEl ? new core_class(contentSwiperEl, {
    // NOTE: Auto height does not work on IE11.
    allowTouchMove: !isSingleSlide,
    autoHeight: !(browserInfo.name === 'IE' && /^11/.test(browserInfo.version)),
    //autoplay: isSingleSlide ? false : { delay: autoplayDelay*1000, disableOnInteraction: false, },
    effect: 'fade',
    fadeEffect: {
      crossFade: true
    },
    loop: true,
    speed: transitionSpeed * 1000,
    on: {
      imagesReady: function imagesReady() {
        console.log('images ready.');
        isImagesReady = true;
      }
    }
  }) : null;
  var old = 0;

  var setSwiperHeightForIE = function setSwiperHeightForIE() {
    if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version) && !isSingleSlide) {
      SliderActiveEl = contentSwiperEl.querySelector('.swiper-slide-active');

      if (SliderActiveEl) {
        SliderActiveEl.style.height = 'auto';
        SliderSwiperEl.style.height = 'auto';

        if (old != contentSwiper.realIndex) {
          SliderSwiperEl.style.height = SliderActiveEl.clientHeight + 'px';
          old = contentSwiper.realIndex;
        }
      }
    }
  };

  if (contentSwiperEl) {
    contentSwiper.on('slideChange', function () {
      //bgSwiper.slideTo(contentSwiper.realIndex);
      var SliderEls = contentSwiperEl.querySelectorAll('.swiper-slide');
      resetCallouts(SliderEls);
      updateProgressBars(contentSwiper.realIndex);
    });
    contentSwiper.on('transitionEnd', function () {
      //console.log('*** contentSwiper.realIndex', contentSwiper.realIndex);
      setSwiperHeightForIE();
      showCallouts();
    });
    contentSwiper.on('autoplayStop', function () {
      return isAutoplayRunning = false;
    });
    setSwiperHeightForIE();
  } else {
    var before = Date.now();
    var timer;
    videoList.forEach(function (v) {
      var videoIndex = parseInt(v.dataset.index);
      var videoDuration = parseInt(v.dataset.duration);
      var videoTime = parseInt(v.dataset.pauseTime);
      var time = parseInt(videoTime + videoDuration * videoIndex);
      timeArry.push(videoTime);
    });
    var currentStopTime = timeArry[videoActiveIndex];
    video.addEventListener('timeupdate', function (e) {
      // check whether we have passed N minutes,
      // current time is given in seconds
      updateVideoTime(video);

      function pauseToPlay() {
        timer = requestAnimationFrame(pauseToPlay);
        var now = Date.now();
        var interval = videoList[videoCurrentIndex].dataset.duration * 1000;

        if (now - before >= interval) {
          if (video.paused && !video.ended && !isVideoPlaying && isVideoAuto) {
            //console.log('delay:' + videoList[videoCurrentIndex].dataset.duration * 1000);
            //console.log('play:' + videoActiveIndex);
            video.play();
            resetCallouts(videoList);

            if (videoCurrentIndex < timeArry.length - 1) {
              videoCurrentIndex++;
            }
          }
        }
      }

      pauseToPlay();
      /*setTimeout(()=>{
      if(video.paused && !video.ended && !isVideoPlaying && isVideoAuto){
        console.log("delay:" + videoList[videoCurrentIndex].dataset.duration* 1000);
        console.log("play:" + videoActiveIndex);
        video.play();
        resetCallouts(videoList);
        if(videoCurrentIndex < timeArry.length - 1){
          videoCurrentIndex++;
        }
      }
      },videoList[videoCurrentIndex].dataset.duration* 1000);*/
    });
    video.addEventListener('ended', function () {
      console.log("It's over!");
      timer = 0;
      isVideoPlaying = false;
      videoActiveIndex = 0;
      videoCurrentIndex = 0;
      currentStopTime = timeArry[videoActiveIndex];
      video.currentTime = 0;
      video.play();
      isVideoPlaying = true;
    });

    var updateVideoTime = function updateVideoTime(video) {
      if (video.currentTime >= timeArry[videoActiveIndex]) {
        if (!video.paused) {
          console.log('pause:' + videoActiveIndex);
          video.pause();
          before = Date.now();
          currentStopTime = timeArry[videoActiveIndex];
          video.currentTime = currentStopTime;
          isVideoPlaying = false;
          updateProgressBars(videoCurrentIndex);
          showCallouts();
        }

        if (timeArry.length > ++videoActiveIndex) {
          // increase index and get next time
          currentStopTime = timeArry[videoActiveIndex];
        }
      }
    };

    var setVideoHeightForIE = function setVideoHeightForIE() {
      if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
        //alert(video.clientHeight)
        videoSwiperEl.style.height = 360 + 'px';
      }
    };

    setVideoHeightForIE();
  } //External function for click callout to display info

  /*if(calloutsEls && calloutsEls.length > 0){
  calloutsEls.forEach(function(el){
    el.addEventListener(
      'click',
      (el.handleClick = (e) => {
        let elIndex = 0;
        if(contentSwiper) {
          contentSwiper.autoplay.stop();
          SliderActiveEl = contentSwiperEl.querySelector('.swiper-slide-active');
          elIndex = parseInt(SliderActiveEl.querySelectorAll('.ContentLayoutProductTour-callouts')[0].dataset.index);
        }else {
          video.pause();
          elIndex = videoCurrentIndex;
        }
        let calloutIndex = parseInt(e.currentTarget.dataset.index);
        let mobileCallout = calloutsMobileEl.querySelectorAll('.ContentLayoutProductTour-callouts')[elIndex].querySelectorAll('.ContentLayoutProductTour-callout')[calloutIndex];
        calloutsMobileEl.querySelectorAll('.ContentLayoutProductTour-callout').forEach((cEl, i) => {
          cEl.querySelector('div').style.opacity = 0;
          cEl.querySelector('div').style.transition = 'none';
        });
        mobileCallout.querySelector('div').style.opacity = 1;
        mobileCallout.querySelector('div').style.transitionDelay = '0s';
      })
    );
  });
  }*/


  expandEl.addEventListener('click', expandEl.handleClick = function (e) {
    if (contentSwiperEl) {
      contentSwiper.autoplay.stop();
      SliderActiveEl = contentSwiperEl.querySelector('.swiper-slide-active');
      var sliderIndex = parseInt(SliderActiveEl.querySelectorAll('.ContentLayoutProductTour-callouts')[0].dataset.index);
      ModalImagesEls.forEach(function (el) {
        el.style.display = 'none';
      });
      ModalImagesEls[sliderIndex].style.display = 'flex';
    } else {
      isVideoAuto = false;
      video.pause();
      ModalVideo.setAttribute('src', video.getAttribute('src'));
    }
  });
  leftButtonEl.addEventListener('click', leftButtonEl.handleClick = function () {
    if (contentSwiperEl) {
      contentSwiper.autoplay.stop();
      contentSwiper.slidePrev();
    } else {
      isVideoAuto = false;
      resetCallouts(videoList);
      video.pause();
      videoCurrentIndex -= 1;

      if (videoCurrentIndex < 0) {
        videoCurrentIndex = timeArry.length - 1;
      }

      video.currentTime = timeArry[videoCurrentIndex];
      updateProgressBars(videoCurrentIndex);
      showCallouts();
    }
  });
  rightButtonEl.addEventListener('click', rightButtonEl.handleClick = function () {
    if (contentSwiperEl) {
      contentSwiper.autoplay.stop();
      contentSwiper.slideNext();
    } else {
      isVideoAuto = false;
      resetCallouts(videoList);
      video.pause();
      videoCurrentIndex += 1;

      if (videoCurrentIndex > timeArry.length - 1) {
        videoCurrentIndex = 0;
      }

      video.currentTime = timeArry[videoCurrentIndex];
      updateProgressBars(videoCurrentIndex);
      showCallouts();
    }
  });
  paginationContainerEl.children.forEach(function (child, i) {
    return child.addEventListener('click', child.handleClick = function (e) {
      if (contentSwiperEl) {
        contentSwiper.autoplay.stop();
        contentSwiper.slideToLoop(i);
      } else {
        isVideoAuto = false;
        resetCallouts(videoList);
        video.pause();
        videoCurrentIndex = parseInt(e.currentTarget.dataset.index);
        video.currentTime = timeArry[videoCurrentIndex];
        updateProgressBars(videoCurrentIndex);
        showCallouts();
      }
    });
  });

  var revealProductTour = function revealProductTour() {
    var revealPEvent = new CustomEvent('isPRevealed', {
      detail: {
        isPRevealed: true
      }
    });
    var observerConfig = {
      rootMargin: '0px 0px -50% 0px',
      threshold: 0
    };
    var observer = new IntersectionObserver(function (elements, self) {
      elements.forEach(function (element) {
        if (element.isIntersecting) {
          // Add class and stop watching
          element.target.classList.add('is-prevealed');

          if (contentSwiperEl) {
            if (isImagesReady) {
              window.requestAnimationFrame(function () {
                if (!isSingleSlide) {
                  if (isAutoplayRunning) {
                    contentSwiper.autoplay.start();
                    updateProgressBars(contentSwiper.realIndex);
                  }
                }

                showCallouts();

                if (isSingleSlide) {
                  var activeEl = contentSwiperEl.querySelector('.swiper-slide-active');

                  if (activeEl) {
                    var activeElDuration = parseInt(activeEl.getAttribute('data-swiper-autoplay'));
                    var calloutsType = activeEl.dataset.calloutType;

                    if (calloutsType.toLowerCase() == 'sequential') {
                      setInterval(function () {
                        resetCalloutsForSingle();
                        showCallouts();
                      }, activeElDuration);
                    }
                  }
                }
              });
            }
          } else {
            if (isVideoAuto) {
              video.play();
            }
          }

          element.target.dispatchEvent(revealPEvent);
          self.unobserve(element.target);
        }
      });
    }, observerConfig);
    observer.observe(el);
  };

  revealElements();
  calloutsEls = SwiperEl.querySelectorAll('.ContentLayoutProductTour-callout');
  setCalloutsPosition(calloutsEls);
  revealProductTour();
  window.addEventListener('load', function () {
    calloutsEls = SwiperEl.querySelectorAll('.ContentLayoutProductTour-callout');
    setCalloutsPosition(calloutsEls);
    revealProductTour();
  });
  window.addEventListener('resize', function () {
    isMobile = getComputedStyle(calloutsMobileEl).display == 'none' ? false : true;

    if (contentSwiperEl) {
      contentSwiper.autoplay.stop();
    } else {
      isVideoAuto = false;
      video.pause();
    }
  });
  return {
    destroy: function destroy() {
      if (contentSwiperEl) {
        contentSwiper.detachEvents();
        contentSwiper.destroy();
      }

      leftButtonEl.removeEventListener('click', leftButtonEl.handleClick);
      rightButtonEl.removeEventListener('click', rightButtonEl.handleClick);
      expandEl.removeEventListener('click', expandEl.handleClick);
      paginationContainerEl.children.forEach(function (child) {
        return child.removeEventListener('click', child.handleClick);
      });
      calloutsEls.forEach(function (child) {
        return child.removeEventListener('click', child.handleClick);
      });
    }
  };
}

ContentLayoutProductTour.defaultSelector = '.ContentLayoutProductTour';

ContentLayoutProductTour.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? ContentLayoutProductTour.defaultSelector : _ref2$selector;

  return ContentLayoutProductTour_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return ContentLayoutProductTour({
      el: el
    });
  });
};

/* harmony default export */ var modules_ContentLayoutProductTour = (ContentLayoutProductTour);
;// CONCATENATED MODULE: ./stories/js/modules/ContentLayoutArticleTemplate/index.js


function ContentLayoutArticleTemplate() {
  var AT = document.querySelector('.ContentLayoutArticleTemplate');
  var DocHeight = document.body.offsetHeight || document.documentElement.scrollHeight;
  var WindowHeight = window.innerHeight || document.documentElement.offsetHeight;
  var stickyATHeader_Height = 64; //let lab = {
  //  read_time: CustomUtil.isLocalhost? 'minute read' : "${'minute read' @ i18n, context='unsafe'}"
  //};

  if (AT) {
    var ATHeader = AT.querySelector('.AT-header');
    var ATBody = AT.querySelector('.AT-body');
    var ATMain = AT.querySelector('.AT-main');
    var ATSiderBar = AT.querySelector('.AT-sidebar');
    var ATContentTable = AT.querySelector('.AT-ContentTable');
    var ATPromo = AT.querySelector('.AT-promo');
    var ATRelatedArticles = AT.querySelector('.AT-relatedArticles');
    var ATToggle = AT.querySelector('.AT-toggle');
    var ATSidebarClose = AT.querySelector('.AT-sidebar-close');
    var ATIndicatorLinks = AT.querySelectorAll('.AT-indicator-link');
    var ATIndicatorTargets = AT.querySelectorAll('.AT-body h2');
    var ATProgressContainer = AT.querySelector('.progress-container');
    var ATProgressBar = AT.querySelector('.progress-bar');
    var AT_Height = AT.clientHeight;
    var AT_Top = AT.offsetTop;
    var ATHeader_Height = ATHeader ? ATHeader.clientHeight : 0;
    var ATMain_Height = ATMain ? ATMain.clientHeight : 0;
    var ATBody_Height = ATBody ? ATBody.clientHeight : 0;
    var ATSide_Height = ATSiderBar ? ATSiderBar.clientHeight : 0;
    var ATRelatedArticles_Height = ATRelatedArticles ? ATRelatedArticles.clientHeight : 0;
    var ATMain_Top = ATMain ? ATMain.offsetTop : 0;
    var startPointFlag = AT.querySelector('.start-point-flag');
    var endPointFlag = AT.querySelector('.end-point-flag');
    var lastPointFlag = AT.querySelector('.last-point-flag');
    var startPointTop = (ATMain_Height + ATMain_Top) * 0.75; //(AT_Height + AT_Top)*0.75;

    var topFlag = AT.querySelector('.top-flag');
    var bottomFlag = AT.querySelector('.bottom-flag');
    var pLeft = ATSiderBar ? (AT.clientWidth - ATSiderBar.parentElement.clientWidth) / 2 : 0;
    var fixedPointTop;
    var marginPointTop;
    var prevScroTop = 0;
    var ticking = false;
    var endSticky = false;
    var scrollToButton = false;
    var scrollToPoint = false;
    var scrollToLast = false;
    var scrollShort = false;
    var isLongEnough = ATBody_Height > ATSide_Height;

    if (!ATSiderBar) {
      ATToggle.classList.add('hidden');
      ATHeader.querySelector('AT-header-left').classList.add('no-toggle');
    }

    generateContentTable();
    appendATRelatedArticles();
    resetElements();
    setFlag();
    revealElements();
    setReadingTime();
    window.addEventListener('resize', function (e) {
      appendATRelatedArticles();
      resetElements();
    });
    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          bindProgressBarScrollEvent();
          bindATScrollEvent();
          ticking = false;
        });
        ticking = true;
      }
    });

    if (ATSiderBar) {
      //Related Event with siderbar
      ATToggle.addEventListener('click', function (e) {
        ATSiderBar.classList.toggle('opened');
      });
      ATSidebarClose.addEventListener('click', function (e) {
        ATSiderBar.classList.remove('opened');
      });
      ATIndicatorLinks.forEach(function (indicator, i) {
        indicator.addEventListener('click', function (e) {
          ATIndicatorLinks.forEach(function (ind) {
            ind.parentElement.classList.remove('active');
          });
          e.currentTarget.parentElement.classList.add('active');
          var target = ATIndicatorTargets[i];
          scrollToPosition(ATHeader, target);
          ATSiderBar.classList.remove('opened');
        });
      });
    }

    function checkSidebarEmpty() {
      if (ATContentTable == null && ATPromo == null && ATRelatedArticles == null) {
        ATSiderBar.remove();
        ATToggle.classList.add('hidden');
        ATHeader.querySelector('.AT-header-left').classList.add('no-toggle');
      }

      if (ATContentTable != null && ATPromo == null && ATRelatedArticles != null) {
        ATContentTable.style.minHeight = 'calc(100vh - 60px - 64px)';
      }
    }

    function generateContentTable() {
      var tables = AT.querySelector('.AT-indicator');

      if (tables) {
        var h2s = AT.querySelectorAll('.body-content h2');
        var html = '';
        h2s.forEach(function (h2, index) {
          var className = index == 0 ? '' : '';
          html += '<li class="AT-indicator-item ' + className + '">';
          html += '<a class="AT-indicator-link" data-indicate="' + index + '">' + h2.innerHTML + '</a>';
          html += '</li>';
        });
        tables.innerHTML = html;

        if (html == '') {
          AT.querySelector('.AT-ContentTable').remove();
          ATContentTable = AT.querySelector('.AT-ContentTable');
        }

        ATIndicatorLinks = AT.querySelectorAll('.AT-indicator-link');
      }

      if (ATContentTable != null) {
        ATToggle.classList.remove('hidden');
        ATHeader.classList.remove('no-toggle');
      } else {
        ATToggle.classList.add('hidden');
        ATHeader.classList.add('no-toggle');
      }

      checkSidebarEmpty();
    }

    function setReadingTime() {
      if (AT.querySelector('.body-content')) {
        var txt = AT.querySelector('.body-content').textContent;
        var wordCount = txt.replace(/[^\w ]/g, '').split(/\s+/).length;
        var readingTimeInMinutes = Math.floor(wordCount / 200) + 1; //let readingTimeAsString = readingTimeInMinutes + ' ' + lab.read_time;

        var readingTimeAsString = readingTimeInMinutes + " minute read";

        if (typeof labels != "undefined") {
          if (typeof labels.minute_read != "undefined") {
            readingTimeAsString = labels.minute_read.replace('{0}', readingTimeInMinutes);
          }
        }

        AT.querySelector('.AT-time').innerHTML = readingTimeAsString;
      }
    }

    function resetElements() {
      ATSiderBar = AT.querySelector('.AT-sidebar');
      AT_Height = AT.clientHeight;
      AT_Top = AT.offsetTop;
      ATHeader_Height = ATHeader ? ATHeader.clientHeight : 0;
      ATMain_Height = ATMain ? ATMain.clientHeight : 0;
      ATBody_Height = ATBody ? ATBody.clientHeight : 0;
      ATSide_Height = ATSiderBar ? ATSiderBar.clientHeight : 0;
      ATRelatedArticles_Height = ATRelatedArticles ? ATRelatedArticles.clientHeight : 0;
      ATMain_Top = ATMain.offsetTop;
      pLeft = ATSiderBar ? (AT.clientWidth - ATSiderBar.parentElement.clientWidth) / 2 : 0;
      isLongEnough = ATBody_Height > ATSide_Height;
    }

    function bindProgressBarScrollEvent() {
      utilities_CustomUtil.updateSettings();
      utilities_CustomUtil.initCheckScreen();
      var scroTop = window.scrollY || document.documentElement.scrollTop;
      var realATHeight = AT_Top + AT.clientHeight + utilities_CustomUtil.settings.headerFixedHeight - stickyATHeader_Height;
      var value = 1 - scroTop / (realATHeight - WindowHeight);
      ATProgressBar.style.transform = 'translateX(-' + parseInt(value * 100) + '%)'; //Scroll to article bottom

      var scrollTopValue = scroTop + WindowHeight;

      if (scrollTopValue >= realATHeight) {
        ATProgressBar.style.transform = 'translateX(0%)';
      }
    }

    function scrollToPosition(container, target) {
      var eleTop = utilities_CustomUtil.getInStickyTop(container);
      var top = target.offsetTop;
      utilities_CustomUtil.updateSettings();
      var scrollTo = top;

      if (top > prevScroTop) {
        if (container.classList.contains('sticky-fixed')) {
          scrollTo = top - eleTop - container.clientHeight + utilities_CustomUtil.settings.headerFixedHeight;
        } else {
          scrollTo = top - eleTop - container.clientHeight + ATHeader_Height - stickyATHeader_Height + utilities_CustomUtil.settings.headerFixedHeight - 80;
        }
      } else {
        if (container.classList.contains('sticky-fixed')) {
          scrollTo = top - eleTop - container.clientHeight;
        } else {
          scrollTo = top - eleTop - container.clientHeight - stickyATHeader_Height + utilities_CustomUtil.settings.headerFixedHeight;
        }
      }

      window.scrollTo(0, scrollTo);
    }

    function appendATRelatedArticles() {
      if (ATRelatedArticles) {
        utilities_CustomUtil.initCheckScreen();

        if (utilities_CustomUtil.screenIs == 'isLaptop') {
          ATSiderBar.querySelector('.AT-sidebar-inner').appendChild(ATRelatedArticles);
        } else {
          ATBody.appendChild(ATRelatedArticles);
        }
      }
    }

    function getStyle(ele) {
      return window.getComputedStyle(ele) || ATSiderBar.parentElement.currentStyle;
    }

    function revealElements() {
      var erevealEls = document.querySelectorAll('[data-ereveal]');
      var erevealEvent = new CustomEvent('isERevealed', {
        detail: {
          isERevealed: true
        }
      });
      var observerConfig = {
        rootMargin: '0px 0px 0px 0px',
        threshold: 0
      };
      var observer = new IntersectionObserver(function (elements, self) {
        elements.forEach(function (element) {
          if (element.isIntersecting) {
            // Add class and stop watching
            element.target.classList.add('is-erevealed'); //element.target.dispatchEvent(erevealEvent);
            //self.unobserve(element.target);
          } else {
            element.target.classList.remove('is-erevealed'); //element.target.dispatchEvent(erevealEvent);
            //self.unobserve(element.target);
          }
        });
      }, observerConfig);
      erevealEls.forEach(function (element) {
        var delay = parseInt(element.dataset.ereveal, 10) || 0;
        element.style.transitionDelay = "".concat(0.0625 * delay, "s");
        observer.observe(element);
      });
    }

    function setFlag() {
      utilities_CustomUtil.updateSettings();

      if (ATSiderBar) {
        if (topFlag) {
          topFlag.style.top = -(utilities_CustomUtil.settings.headerFixedHeight + 60) + 'px';
        }

        if (lastPointFlag == null) {
          var node = document.createElement('div');
          node.className = 'last-point-flag';
          node.setAttribute('data-ereveal', '');
          ATBody.appendChild(node);
          lastPointFlag = AT.querySelector('.last-point-flag');

          if (!ATRelatedArticles) {
            startPointTop = lastPointFlag.offsetTop - utilities_CustomUtil.settings.headerFixedHeight;
          }
        }

        if (startPointFlag == null) {
          var node = document.createElement('div');
          node.className = 'start-point-flag';
          node.setAttribute('data-ereveal', '');
          node.style.top = startPointTop + 'px';
          AT.appendChild(node);
          startPointFlag = AT.querySelector('.start-point-flag');
        }

        if (endPointFlag == null) {
          var node = document.createElement('div');
          node.className = 'end-point-flag';
          node.setAttribute('data-ereveal', '');
          node.style.top = startPointTop + ATRelatedArticles_Height + 'px';
          AT.appendChild(node);
          endPointFlag = AT.querySelector('.end-point-flag');
        }

        if (!ATSiderBar.getAttribute('fixedPoint')) {
          //ATSiderBar.setAttribute('fixedPoint', ATSiderBar.style.top.slice(0, ATSiderBar.style.top.length - 2));
          fixedPointTop = -(ATSide_Height + 20 - ATRelatedArticles_Height - WindowHeight + 30);
          ATSiderBar.setAttribute('fixedPoint', fixedPointTop);
        }

        if (!ATSiderBar.getAttribute('marginPoint')) {
          marginPointTop = startPointTop - ATHeader_Height - (ATSiderBar.clientHeight - ATRelatedArticles_Height) + ATHeader.clientHeight; //alert("startPointTop=" + (startPointTop-ATHeader_Height) + ";scroTop=" + scroTop)
          //ATSiderBar.setAttribute('marginPoint', marginPointTop + fixedPointTop - CustomUtil.settings.headerFixedHeight);

          ATSiderBar.setAttribute('marginPoint', marginPointTop);
        }
      }
    }

    var observer;

    var watchSidebar = function watchSidebar() {
      observer = new MutationObserver(function (mutationRecords) {
        //console.log(mutationRecords);
        resetSidebarWidth();
      });
      var node = ATSiderBar;
      var config = {
        attributes: true,
        attributeFilter: ['class']
      };

      if (node) {
        observer.observe(node, config);
      }
    };

    function resetSidebarWidth() {
      utilities_CustomUtil.updateSettings();
      utilities_CustomUtil.initCheckScreen();
      var isLaptop = utilities_CustomUtil.screenIs == 'isLaptop' ? true : false;

      if (ATSiderBar && ATBody) {
        //desktop set same width as relative condition in fixed condition
        if (isLaptop) {
          if (ATSiderBar.classList.contains('sticky-fixed')) {//ATSiderBar.style.width = (pLeft + parseInt(getStyle(ATBody).marginLeft)) + 'px';
          } else {//ATSiderBar.style.width = '35%';
          }
        }
      }
    }

    function bindATScrollEvent() {
      var bodyMarginTop = parseInt(getStyle(ATBody).marginTop);
      var top = AT_Top + AT_Height + bodyMarginTop - ATHeader_Height - ATSide_Height - utilities_CustomUtil.settings.headerFixedHeight; //*0.75;

      var mainTop = ATMain_Top;
      utilities_CustomUtil.updateSettings();
      utilities_CustomUtil.initCheckScreen();
      var scroTop = window.scrollY || document.documentElement.scrollTop;
      var headerFixedCondiotion = scroTop > mainTop;
      top = startPointTop;
      var showRelatedArticlesCondition = utilities_CustomUtil.screenIs == 'isLaptop'; //&& scroTop > top;

      var sideBarFixedCondiotion = headerFixedCondiotion; //&& showRelatedArticlesCondition;

      utilities_CustomUtil.bindStickyEvent(headerFixedCondiotion, ATHeader);
      watchSidebar();

      if (ATSiderBar) {
        if (isLongEnough) {
          //Long engough
          var ATSiderBarTop = utilities_CustomUtil.getInStickyTop(ATSiderBar);

          if (showRelatedArticlesCondition) {
            //Laptop
            if (sideBarFixedCondiotion) {
              //CustomUtil.setStickyElementTop(ATSiderBar, ATSiderBarTop);
              var initialFixedTop;

              if (utilities_CustomUtil.settings.headerStatus == 2) {
                initialFixedTop = utilities_CustomUtil.settings.headerFixedHeight + ATSiderBarTop;
              } else if (utilities_CustomUtil.settings.headerStatus == 1) {
                initialFixedTop = utilities_CustomUtil.settings.headerFixedHeight + utilities_CustomUtil.settings.headerTop + ATSiderBarTop;
              } else {
                initialFixedTop = ATSiderBarTop;
              }

              if (!ATSiderBar.getAttribute('data-top')) {
                ATSiderBar.setAttribute('data-top', initialFixedTop);
                ATSiderBar.style.top = initialFixedTop + 'px';
              }

              if (scroTop > prevScroTop) {
                // Scroll Down
                //To Button
                if (!bottomFlag.classList.contains('is-erevealed')) {
                  //if(!scrollShort){
                  var styleTop = parseInt(ATSiderBar.style.top.slice(0, ATSiderBar.style.top.length - 2)); //if not in ending

                  if (!(!topFlag.classList.contains('is-erevealed') && styleTop == 0)) {
                    if (!scrollToButton || styleTop > fixedPointTop) {
                      ATSiderBar.classList.add('sticky-fixed');
                      ATSiderBar.style.paddingLeft = pLeft + 'px';
                      var sideBarTop1 = styleTop;
                      var fixedTop1 = sideBarTop1 - (scroTop - prevScroTop);
                      ATSiderBar.style.top = fixedTop1 + 'px';

                      if (fixedTop1 < fixedPointTop) {
                        ATSiderBar.style.top = fixedPointTop + 'px';
                      }
                    }

                    if (styleTop < fixedPointTop) {
                      ATSiderBar.style.top = fixedPointTop + 'px';
                    }
                  } //}

                } else {
                  //if topflag and bottomflag both show in viewport.
                  if (topFlag.classList.contains('is-erevealed') && bottomFlag.classList.contains('is-erevealed')) {
                    scrollShort = true;

                    if (!scrollToPoint) {
                      var styleTop2 = parseInt(ATSiderBar.style.top.slice(0, ATSiderBar.style.top.length - 2));
                      ATSiderBar.classList.add('sticky-fixed');
                      ATSiderBar.style.paddingLeft = pLeft + 'px';
                      ATSiderBar.style.top = styleTop2 - (scroTop - prevScroTop) + 'px';

                      if (styleTop2 < fixedPointTop) {
                        ATSiderBar.style.top = initialFixedTop + 'px';
                      }
                    }
                  } else {
                    if (bottomFlag.classList.contains('is-erevealed')) {
                      //if no related articles
                      if (!ATRelatedArticles) {
                        //to page end
                        if (lastPointFlag && lastPointFlag.classList.contains('is-erevealed')) {
                          scrollToPoint = true;
                          ATSiderBar.classList.remove('sticky-fixed');
                          ATSiderBar.style.top = 0;
                          ATSiderBar.style.marginTop = marginPointTop + 'px';
                          ATSiderBar.style.paddingLeft = '64px';
                        } //not to page end
                        else {
                          if (scrollShort) {
                            var _styleTop = parseInt(ATSiderBar.style.top.slice(0, ATSiderBar.style.top.length - 2)); //alert("fixedPointTop:"+ fixedPointTop+";styleTop:"+ styleTop)


                            ATSiderBar.style.top = _styleTop - (scroTop - prevScroTop) + 'px';

                            if (_styleTop < fixedPointTop) {
                              ATSiderBar.style.top = initialFixedTop + 'px';
                            }
                          }
                        }
                      }
                    }
                  }

                  scrollToButton = true;
                } //To RelatedArticles


                if (ATRelatedArticles) {
                  if (startPointFlag && startPointFlag.classList.contains('is-erevealed') || scroTop > startPointTop) {
                    AT.classList.add('RA--show');
                    ATSiderBar.classList.remove('sticky-fixed');
                    ATSiderBar.style.top = 0;
                    ATSiderBar.style.marginTop = marginPointTop + 'px';
                    ATSiderBar.style.paddingLeft = '64px';
                    scrollToPoint = true;
                  } else {
                    if (scrollToPoint) {
                      AT.classList.add('RA--show');
                      scrollToPoint = true;
                    }
                  }
                }
              } else {
                // Scroll Up
                //To RelatedArticles
                if (ATRelatedArticles) {
                  if (startPointFlag && startPointFlag.classList.contains('is-erevealed')) {
                    AT.classList.remove('RA--show');
                    scrollToPoint = true;
                    scrollToButton = true;
                  }
                }

                if (!topFlag.classList.contains('is-erevealed')) {
                  var sideBarTop2 = parseInt(ATSiderBar.style.top.slice(0, ATSiderBar.style.top.length - 2));
                  var fixedTop2 = sideBarTop2 + (prevScroTop - scroTop);

                  if (scroTop < marginPointTop && prevScroTop > marginPointTop) {
                    ATSiderBar.classList.add('sticky-fixed');
                    ATSiderBar.style.marginTop = 0;
                    ATSiderBar.style.paddingLeft = pLeft + 'px';
                  } else {
                    ATSiderBar.style.top = 0;
                  }

                  if (prevScroTop > marginPointTop) {
                    scrollToPoint = false;
                    scrollToButton = false;
                  }

                  if (fixedTop2 >= initialFixedTop) {
                    fixedTop2 = initialFixedTop;
                  }

                  if (ATSiderBar.classList.contains('sticky-fixed')) {
                    ATSiderBar.style.top = fixedTop2 + 'px';
                  }
                } else {
                  scrollToPoint = false;
                  scrollToButton = false;
                  ATSiderBar.classList.add('sticky-fixed');
                  ATSiderBar.style.top = initialFixedTop + 'px';
                  ATSiderBar.style.paddingLeft = pLeft + 'px';
                  ATSiderBar.style.marginTop = 0;
                }
              }
            } else {
              ATSiderBar.classList.remove('sticky-fixed');
              ATSiderBar.style.top = '0';
              ATSiderBar.style.marginTop = '0';
              ATSiderBar.style.paddingLeft = '64px';
            }
          } else {
            //Tablet, Mobile
            //CustomUtil.bindStickyEvent(sideBarFixedCondiotion, ATSiderBar);
            ATSiderBar.classList.add('sticky-fixed');

            if (headerFixedCondiotion) {
              var initialMobileFixedTop;

              if (utilities_CustomUtil.settings.headerStatus == 2) {
                initialMobileFixedTop = utilities_CustomUtil.settings.headerFixedHeight + 60;
              } else if (utilities_CustomUtil.settings.headerStatus == 1) {
                initialMobileFixedTop = utilities_CustomUtil.settings.headerFixedHeight + utilities_CustomUtil.settings.headerTop + 60;
              } else {
                initialMobileFixedTop = 60;
              }

              if (!ATSiderBar.classList.contains('opened')) {
                ATSiderBar.style.top = initialMobileFixedTop + 'px';
              }

              var maxHeight = WindowHeight - stickyATHeader_Height;

              if (ATSiderBar.classList.contains('sticky-fixed') && ATSiderBar.clientHeight > maxHeight) {
                var sideBarTop3 = parseInt(ATSiderBar.style.top.slice(0, ATSiderBar.style.top.length - 2));
                var fixedTop3;

                if (scroTop > prevScroTop) {
                  // Scroll Down
                  if (!bottomFlag.classList.contains('is-erevealed')) {
                    fixedTop3 = sideBarTop3 - (scroTop - prevScroTop);
                  }
                } else {
                  if (!topFlag.classList.contains('is-erevealed')) {
                    fixedTop3 = sideBarTop3 + (prevScroTop - scroTop);
                  } else {
                    fixedTop3 = initialMobileFixedTop;
                  }
                }

                ATSiderBar.style.top = fixedTop3 + 'px';
              }
            } else {
              ATSiderBar.classList.remove('opened');
            }
          }

          if (!headerFixedCondiotion) {
            //Add marginTop to body to make UI look better
            ATSiderBar.style.paddingLeft = '64px';
            ATBody.style.marginTop = 0;
          } else {
            ATBody.style.marginTop = ATHeader_Height - utilities_CustomUtil.settings.headerFixedHeight + stickyATHeader_Height + 'px';
          }
        } else {
          //Not long engough
          AT.classList.add('RA--show');

          if (headerFixedCondiotion) {
            ATMain.style.marginTop = utilities_CustomUtil.settings.headerFixedHeight + ATHeader.clientHeight + 60 + 'px';
          } else {
            ATMain.style.marginTop = 0;
          }
        }
      } else {
        if (headerFixedCondiotion) {
          //When no siderbar, update fixedheader to 100%
          var fixedHeaderRight = AT.querySelector('.AT-header.sticky-fixed .AT-header-right');

          if (fixedHeaderRight.style.width != '100%') {
            fixedHeaderRight.style.width = '100%';
          }
        }
      }

      prevScroTop = scroTop;
    }
  }
}

/* harmony default export */ var modules_ContentLayoutArticleTemplate = (ContentLayoutArticleTemplate);
;// CONCATENATED MODULE: ./stories/js/modules/FeatureContentLayoutCarousel/index.js
function FeatureContentLayoutCarousel_toConsumableArray(arr) { return FeatureContentLayoutCarousel_arrayWithoutHoles(arr) || FeatureContentLayoutCarousel_iterableToArray(arr) || FeatureContentLayoutCarousel_unsupportedIterableToArray(arr) || FeatureContentLayoutCarousel_nonIterableSpread(); }

function FeatureContentLayoutCarousel_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function FeatureContentLayoutCarousel_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FeatureContentLayoutCarousel_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FeatureContentLayoutCarousel_arrayLikeToArray(o, minLen); }

function FeatureContentLayoutCarousel_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function FeatureContentLayoutCarousel_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return FeatureContentLayoutCarousel_arrayLikeToArray(arr); }

function FeatureContentLayoutCarousel_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable no-param-reassign,no-return-assign */





core_class.use([autoplay, effect_fade, navigation]);

var FeatureContentLayoutCarousel = function FeatureContentLayoutCarousel() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      el = _ref.el;

  var autoplayDelay = 6000;
  var transitionSpeed = 300;
  var singleSlideClass = 'FeatureContentLayoutCarousel--singleSlide';
  var twoSlideClass = 'FeatureContentLayoutCarousel--twoSlide';
  var bgSwiperEl = el.querySelector('.FeatureContentLayoutCarousel-backgroundContainer .swiper-container');
  var contentSwiperEl = el.querySelector('.FeatureContentLayoutCarousel-contentPanel .swiper-container');
  var SliderSwiperEl = el.querySelector('.FeatureContentLayoutCarousel-contentPanel .swiper-wrapper');
  var SliderActiveEl = el.querySelector('.FeatureContentLayoutCarousel-contentPanel .swiper-slide-active');
  var SliderEl = el.querySelectorAll('.FeatureContentLayoutCarousel-contentPanel .swiper-slide');
  var leftButtonEl = el.querySelector('.FeatureContentLayoutCarousel-navArrowButton-left');
  var paginationContainerEl = el.querySelector('.FeatureContentLayoutCarousel-paginationContainer');
  var rightButtonEl = el.querySelector('.FeatureContentLayoutCarousel-navArrowButton-right');
  var browserInfo = new (ua_parser_default())().getBrowser();
  var isAutoplayRunning = true;

  var isSingleSlide = function isSingleSlide(swiperEl) {
    if (el.classList.contains(singleSlideClass) || swiperEl.querySelector('.swiper-wrapper').children.length < 2) {
      el.classList.add(singleSlideClass);
      return true;
    }
  };

  var checkSlideToAddClass = function checkSlideToAddClass() {
    if (contentSwiperEl && bgSwiperEl) {
      if (bgSwiperEl.querySelector('.swiper-wrapper').children.length == 2) {
        el.classList.add(twoSlideClass);
      }
    }
  };

  var bgSwiper;
  var contentSwiper;

  var checkSwiper = function checkSwiper() {
    if (bgSwiper != undefined) {
      bgSwiper.destroy();
    }

    if (contentSwiper != undefined) {
      //contentSwiper.detachEvents();
      contentSwiper.destroy();
    }
  };

  var old = 0;

  var setSwiperHeightForIE = function setSwiperHeightForIE(swiperEl, swiper) {
    if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version) && !isSingleSlide(swiperEl)) {
      SliderActiveEl = swiperEl.querySelector('.swiper-slide-active');

      if (SliderActiveEl) {
        SliderActiveEl.style.height = 'auto';
        SliderSwiperEl.style.height = 'auto';

        if (old != swiperEl.realIndex) {
          swiperEl.style.height = SliderActiveEl.clientHeight + 'px';
          old = swiper.realIndex;
        }
      }
    }
  };

  var updateSwiperHeight = function updateSwiperHeight() {
    var tabContainer = el.querySelector('.FeatureContentLayoutCarousel-tabContainer');
    var contentContainers = el.querySelectorAll('.FeatureContentLayoutSimple-contentContainer');
    var contentContainerPadding = 128;
    var contentContainerPaddingLaptop = 160;
    var cMax = 0;
    var c = el.querySelector('.swiper-slide-active .FeatureContentLayoutSimple-contentContainer');

    if (c) {
      //contentContainers.forEach((c) => {
      var copyContainer = c.querySelector('.FeatureContentLayoutSimple-copyContainer');
      var imageContainer = c.querySelector('.FeatureContentLayoutSimple-imageContainer');
      var copyContainerHeight = copyContainer ? copyContainer.clientHeight : 0;
      var imageContainerHeight = imageContainer ? 328 : 0;
      var cHeight = copyContainerHeight + imageContainerHeight + contentContainerPadding;

      if (utilities_CustomUtil.screenIs == 'isMobile') {
        cMax = cHeight;
      } else {
        imageContainerHeight = imageContainer ? 416 : 0;
        cMax = Math.max(copyContainerHeight, imageContainerHeight) + contentContainerPaddingLaptop;
      } //});

    }

    if (tabContainer) {
      el.style.height = 'auto';
      var tcHeight = tabContainer.clientHeight;
      el.style.height = cMax + tcHeight + 'px';
    }
  };

  utilities_CustomUtil.initCheckScreen();

  var initSwiper = function initSwiper() {
    if (utilities_CustomUtil.screenIs != 'isMobile') {
      checkSwiper();
      bgSwiper = new core_class(bgSwiperEl, {
        allowTouchMove: !isSingleSlide(bgSwiperEl),
        autoplay: isSingleSlide(bgSwiperEl) ? false : {
          delay: autoplayDelay
        },
        fadeEffect: {
          crossFade: true
        },
        loop: true,
        speed: transitionSpeed,
        effect: 'fade'
      });
      SliderEl[0].classList.add('active--laptop');

      if (!isSingleSlide(bgSwiperEl)) {
        updateSwiperHeight();
      }

      SliderEl.forEach(function (el) {
        el.addEventListener('click', function (e) {
          if (utilities_CustomUtil.screenIs != 'isMobile') {
            var index = Array.prototype.slice.call(SliderEl).indexOf(e.currentTarget);

            if (index != -1) {
              index = index + 1;
            }

            bgSwiper.slideTo(index);
            bgSwiper.autoplay.stop();
          }
        });
      });
      bgSwiper.on('slideChange', function () {
        updateStoryTabs();
      });
      bgSwiper.on('transitionEnd', function () {
        //console.log(bgSwiper.realIndex);
        updateSwiperHeight();
      });
      bgSwiper.on('autoplayStop', function () {
        return isAutoplayRunning = false;
      });
    } else {
      checkSwiper();
      bgSwiper = new core_class(bgSwiperEl, {
        effect: 'fade',
        fadeEffect: {
          crossFade: true
        }
      });
      contentSwiper = new core_class(contentSwiperEl, {
        // NOTE: Auto height does not work on IE11.
        allowTouchMove: !isSingleSlide(contentSwiperEl),
        autoHeight: !(browserInfo.name === 'IE' && /^11/.test(browserInfo.version)),
        autoplay: isSingleSlide(contentSwiperEl) ? false : {
          delay: autoplayDelay
        },
        fadeEffect: {
          crossFade: true
        },
        loop: true,
        speed: transitionSpeed,
        effect: 'slide',
        slidesPerView: 'auto',
        watchSlidesProgress: true,
        watchSlidesVisibility: true,
        watchOverflow: true,
        navigation: {
          nextEl: rightButtonEl,
          prevEl: leftButtonEl
        }
      });

      if (!isSingleSlide(bgSwiperEl)) {
        updateSwiperHeight();
      }

      contentSwiper.on('slideChange', function () {
        bgSwiper.slideTo(contentSwiper.realIndex);
      });
      contentSwiper.on('transitionEnd', function () {
        //console.log(contentSwiper.realIndex);
        updateSwiperHeight();
      });
      contentSwiper.on('autoplayStop', function () {
        return isAutoplayRunning = false;
      });
      paginationContainerEl.children.forEach(function (child, i) {
        return child.addEventListener('click', child.handleClick = function () {
          contentSwiper.autoplay.stop();
          contentSwiper.slideToLoop(i);
        });
      });
    }
  };

  checkSlideToAddClass();
  initSwiper();
  revealElements();
  var oldScreen = utilities_CustomUtil.screenIs;
  var resizeId;
  window.addEventListener('resize', function () {
    utilities_CustomUtil.initCheckScreen();

    if (utilities_CustomUtil.screenIs != oldScreen) {
      clearTimeout(resizeId);
      resizeId = setTimeout(function () {
        initSwiper();
      }, 500);
    }

    oldScreen = utilities_CustomUtil.screenIs;
  });

  var updateStoryTabs = function updateStoryTabs() {
    SliderEl.forEach(function (tabEl, i) {
      var isActiveIndex = i === bgSwiper.realIndex;
      console.log(bgSwiper.realIndex);

      if (isActiveIndex) {
        tabEl.classList.add('active--laptop');
      } else {
        tabEl.classList.remove('active--laptop');
      } //let barEl = tabEl.querySelector('.FeatureContentLayoutCarousel-paginationButton-progressBar');
      //barEl.style.transition = isActiveIndex && isAutoplayRunning ? `width ${autoplayDelay + transitionSpeed}ms linear` : 'none';
      //barEl.style.width = isActiveIndex ? '100%' : 0;

    });
  };

  leftButtonEl.addEventListener('click', leftButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slidePrev();
  });
  rightButtonEl.addEventListener('click', rightButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slideNext();
  });
  return {
    destroy: function destroy() {
      if (bgSwiper != undefined) {
        bgSwiper.destroy();
      }

      if (contentSwiper != undefined) {
        contentSwiper.detachEvents();
        contentSwiper.destroy();
      }

      leftButtonEl.removeEventListener('click', leftButtonEl.handleClick);
      rightButtonEl.removeEventListener('click', rightButtonEl.handleClick);
      paginationContainerEl.children.forEach(function (child) {
        return child.removeEventListener('click', child.handleClick);
      });
    }
  };
};

FeatureContentLayoutCarousel.defaultSelector = '.FeatureContentLayoutCarousel';

FeatureContentLayoutCarousel.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? FeatureContentLayoutCarousel.defaultSelector : _ref2$selector;

  return FeatureContentLayoutCarousel_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return FeatureContentLayoutCarousel({
      el: el
    });
  });
};

/* harmony default export */ var modules_FeatureContentLayoutCarousel = (FeatureContentLayoutCarousel);
;// CONCATENATED MODULE: ./stories/js/modules/MediaKitList/index.js



function MediaKitList() {
  var mediaKitContainer = document.querySelector(".MediaKit__container");
  var sortBox = document.getElementById("mkSort");
  var sortDropItems = mediaKitContainer && mediaKitContainer.querySelectorAll(".MediaKitList__order .MFDropdown-item");
  var searchInputBox = document.getElementById("mkSearch");
  var searchButton = document.querySelector(".mkSearch-button");
  var mediaKitList = document.querySelector(".MediaKitList__items");
  var noSearchElement = document.getElementById("result-error");
  var reset = true;
  searchButton && searchButton.addEventListener("click", function (event) {
    reset = false;
    event.preventDefault();
    mediaKitAjax();
  });
  searchInputBox && searchInputBox.addEventListener("keydown", function (event) {
    if (event.keyCode == 13) {
      reset = false;
      event.preventDefault();
      mediaKitAjax();
    }
  });
  sortBox && sortBox.addEventListener("change", function () {//mediaKitAjax();
  });
  var observer;

  var watchDrop = function watchDrop() {
    observer = new MutationObserver(function (mutationRecords) {
      //console.log(mutationRecords);
      mediaKitAjax();
    });
    var nodes = sortDropItems;
    var config = {
      attributes: true,
      attributeFilter: ['class']
    };
    nodes && nodes.forEach(function (node) {
      observer.observe(node, config);
    });
  };

  function resetPlaceholder(sort) {
    var droBox = mediaKitContainer.querySelector(".MediaKitList__order .MFDropdown-btn");
    var labels = {
      sort_by: utilities_CustomUtil.isLocalhost ? 'Sort by: ' : "${'Sort by: ' @ i18n, context='unsafe'}"
    };
    droBox.innerHTML = '<strong>' + labels.sort_by + '</strong>' + sort;
  }

  function mediaKitAjax() {
    var searchUrl = "";
    var pageLocale = Object.hasOwn(window, "eCommerceConfig") ? eCommerceConfig.pageLocale.toLowerCase() : "en_us";
    var language = pageLocale;
    var keyword = searchInputBox.value;
    var selected = mediaKitContainer.querySelector(".MediaKitList__order .MFDropdown-item.selected").querySelector('.MFDropdown-link');
    var sort = selected.getAttribute('data-value'); //sortBox.value;

    resetPlaceholder(selected.innerHTML);

    if (!reset) {
      var locale = language.split("_")[0];
      searchUrl = "/ww/mediaKitSearch?reset=" + reset + "&language=" + language + "&sort=" + sort + "&collection=media_kit&indent=true&q=" + keyword + "&fq=brand:(seagate OR lacie)&q.op=OR&fl=title_" + locale + ",publicationDate,imagePath,url&rows=1000&df=text_" + locale + "&fq=seaLocale:" + language;
    } else {
      searchUrl = "/ww/mediaKitSearch?keyword=" + keyword + "&reset=" + reset + "&currentPage=" + mediaKitContainer.getAttribute("data-currentpage") + "&language=" + language + "&sort=" + sort;
    }

    fetch(searchUrl, {
      method: 'GET'
    }).then(function (response) {
      return response.text();
    }).then(function (html) {
      if (html.trim()) {
        mediaKitList.innerHTML = html;
        noSearchElement.style.display = "none";
      } else {
        mediaKitList.innerHTML = "";
        noSearchElement.style.display = "block";
      }

      revealElements();
    });
  }

  function bindSearchEvent() {
    var mkSearch = document.getElementById('mkSearch');
    var mkSearchClear = document.getElementById('mkSearch-clear');

    if (mkSearch && mkSearchClear) {
      mkSearch.addEventListener('keyup', function (e) {
        if (e.currentTarget.value.trim() != "") {
          mkSearchClear.classList.remove('hidden');
        } else {
          mkSearchClear.classList.add('hidden');
          reset = true;
          mediaKitAjax();
        }
      });
      mkSearchClear.addEventListener('click', function (e) {
        mkSearchClear.classList.add('hidden');
        mkSearch.value = '';
        reset = true;
        mediaKitAjax();
      });
    }
  }

  var selected = mediaKitContainer && mediaKitContainer.querySelector("#mkSort option[selected]");

  if (selected) {
    resetPlaceholder(selected.innerHTML);
  }

  watchDrop();
  bindSearchEvent();
}

;
/* harmony default export */ var modules_MediaKitList = (MediaKitList);
;// CONCATENATED MODULE: ./stories/js/components/MFCollapse.js
var MFCollapse = function MFCollapse(container, options) {
  var container = container ? document.querySelectorAll(container) : document;

  if (container && container.length > 0) {
    return container.forEach(function (c) {
      new MFCollapse()._init(c, options);
    });
  }
};

MFCollapse.fn = MFCollapse.prototype = {
  constructor: MFCollapse,
  _defaults: {
    CLASS_NAME_SHOW: 'show',
    CLASS_NAME_COLLAPSE: 'collapse',
    CLASS_NAME_COLLAPSING: 'collapsing',
    CLASS_NAME_COLLAPSED: 'collapsed',
    CLASS_NAME_MULTI_COLLAPSE: 'multi-collapse',
    DIMENSION_WIDTH: 'width',
    DIMENSION_HEIGHT: 'height',
    SELECTOR_ACTIVES: '.show, .collapsing',
    SELECTOR_DATA_TOGGLE: '[data-toggle="mf-collapse"]',
    SELECTOR_COLLAPSE_CONTENT: '.accordion-content',
    SELECTOR_EXPANDED: '[aria-expanded="true"]',
    SELECTOR_COLLAPSE: '[aria-expanded="false"]',
    ARIA_EXPANDED: 'aria-expanded',
    RELATED_SELECTOR: 'data-accordion-open',
    //attribute
    MULTI_COLLAPSE: false
  },
  _init: function _init(container, options) {
    this._setElements(container, options);

    this._setHeight();

    this._bindEvents();

    return this;
  },
  _setElements: function _setElements(container, options) {
    this.opts = Object.assign({}, this._defaults, options);
    this.container = container;
    this.containerString = '#' + container + ' ';
    this.toggles = this.container.querySelectorAll(this.opts.SELECTOR_DATA_TOGGLE);
    this.collapses = this.container.querySelectorAll('.' + this.opts.CLASS_NAME_COLLAPSE);
    this.length = this.toggles.length;
    this.firedElement = null;
    this.targetElement = null;
  },
  _setHeight: function _setHeight() {
    var that = this;
    var showCollapses = this.container.querySelectorAll('.collapse.show');
    showCollapses.forEach(function (collapse) {
      collapse.style.height = collapse.querySelector(that.opts.SELECTOR_COLLAPSE_CONTENT).clientHeight + 'px';
    });
  },
  _updateParentHeight: function _updateParentHeight(currentCollapse, flag) {
    var that = this;
    var parentID = currentCollapse.getAttribute('data-parent');

    while (document.querySelector(parentID)) {
      var parentCollapse = document.querySelector(parentID);
      var cheight = currentCollapse.getAttribute('data-cheight') != null ? parseInt(currentCollapse.getAttribute('data-cheight')) : 0;
      parentCollapse.classList.add(that.opts.CLASS_NAME_COLLAPSING);
      var bodyHeight = currentCollapse.querySelector(that.opts.SELECTOR_COLLAPSE_CONTENT).clientHeight;

      if (flag == 0) {
        parentCollapse.style.height = parentCollapse.clientHeight - bodyHeight + 'px';
      } else {
        parentCollapse.style.height = parentCollapse.clientHeight + bodyHeight + 'px';
      }

      parentID = parentCollapse.getAttribute('data-parent');
    }
  },
  _getChildrenHeight: function _getChildrenHeight(currentCollapse, flag) {
    var that = this;
    var sum = 0;
    var childrenCollapses = currentCollapse.querySelectorAll('.' + that.opts.CLASS_NAME_COLLAPSE);
    childrenCollapses.forEach(function (collapse) {
      if (collapse.classList.contains('show')) {
        if (collapse.style.height == '0px') {
          collapse.style.height = collapse.querySelector(that.opts.SELECTOR_COLLAPSE_CONTENT).clientHeight + 'px';

          if (collapse.getAttribute('data-cheight') == '0') {
            collapse.setAttribute('data-cheight', parseInt(collapse.style.height));
          }

          sum += parseInt(collapse.style.height);
        }
      }
    });
    return sum;
  },
  _bindEvents: function _bindEvents() {
    var _this = this;

    var that = this;
    that.collapses.forEach(function (collapse) {
      var dimission = collapse.getBoundingClientRect();

      if (collapse.classList.contains('show')) {
        var cheight = collapse.getAttribute('data-cheight') != null ? parseInt(collapse.getAttribute('data-cheight')) : collapse.clientHeight;
        collapse.setAttribute('data-cheight', cheight);
      }

      collapse.addEventListener('transitionend', function (e) {
        collapse.classList.remove(that.opts.CLASS_NAME_COLLAPSING);

        if (collapse.style.height == '0px') {
          collapse.classList.remove(that.opts.CLASS_NAME_SHOW);
        }

        that.targetElement = collapse;

        that._complete();
      });
    });
    that.toggles.forEach(function (toggle, i) {
      var target = toggle.getAttribute('data-target');
      var collapse = that.container.querySelector(target);
      collapse.style.height = collapse.clientHeight + 'px';
      toggle.addEventListener('click', function () {
        if (!collapse.classList.contains(that.opts.CLASS_NAME_COLLAPSING)) {
          that.firedElement = toggle;
          var c_height = 0;

          if (collapse.classList.contains(that.opts.CLASS_NAME_SHOW)) {
            toggle.classList.add(that.opts.CLASS_NAME_COLLAPSED);
            toggle.setAttribute(that.opts.ARIA_EXPANDED, 'false');
            collapse.classList.add(that.opts.CLASS_NAME_COLLAPSING);

            that._updateParentHeight(collapse, 0);

            collapse.style.height = c_height;
          } else {
            if (!collapse.classList.contains(that.opts.CLASS_NAME_MULTI_COLLAPSE)) {
              var elseToggle = that.container.querySelectorAll('[' + that.opts.ARIA_EXPANDED + '="true"]');

              if (elseToggle && elseToggle.length > 0) {
                elseToggle.forEach(function (toggle, i) {
                  toggle.click();
                });
              }
            }

            toggle.classList.remove(that.opts.CLASS_NAME_COLLAPSED);
            toggle.setAttribute(that.opts.ARIA_EXPANDED, 'true');
            collapse.classList.add(that.opts.CLASS_NAME_SHOW);
            collapse.classList.add(that.opts.CLASS_NAME_COLLAPSING);
            c_height = collapse.querySelector(that.opts.SELECTOR_COLLAPSE_CONTENT).clientHeight;
            collapse.setAttribute('data-cheight', c_height);

            that._updateParentHeight(collapse, 1);

            var sumHeight = parseInt(c_height) + parseInt(that._getChildrenHeight(collapse, 1));
            collapse.style.height = sumHeight + 'px';
          }
        }
      });
    });
    document.querySelectorAll('[' + that.opts.RELATED_SELECTOR + ']').forEach(function (relator) {
      relator.addEventListener('click', function (e) {
        var targetID = relator.getAttribute(that.opts.RELATED_SELECTOR);
        var target = document.querySelector('[data-target="#' + targetID + '"]');

        if (target) {//target.click();
        }
      });
    });
    window.addEventListener('resize', function () {
      var that = _this;

      if (that.container.dataset.collapseRole != 'single') {
        that._setHeight();

        that.collapses.forEach(function (collapse, i) {
          var c_height = collapse.querySelector(that.opts.SELECTOR_COLLAPSE_CONTENT).clientHeight;
          collapse.setAttribute('data-cheight', c_height);
          collapse.style.height = c_height + 'px'; //that._getChildrenHeight(collapse, 1);
        });
      }
    });
  },
  _complete: function _complete(callback) {
    var that = this;
    var collapseEvent = new CustomEvent('mf.collapse', {
      detail: {
        ele: that
      }
    });

    if (window.dispatchEvent) {
      that.container.dispatchEvent(collapseEvent);
    } else {
      that.container.fireEvent(collapseEvent);
    }

    callback && callback();
  },
  controlObj: {},
  index: 0,
  length: 0,
  push: [].push,
  sort: [].sort,
  splice: [].splice
};
/* harmony default export */ var components_MFCollapse = (MFCollapse);
;// CONCATENATED MODULE: ./stories/js/modules/SupportPDP/index.js
function SupportPDP_toConsumableArray(arr) { return SupportPDP_arrayWithoutHoles(arr) || SupportPDP_iterableToArray(arr) || SupportPDP_unsupportedIterableToArray(arr) || SupportPDP_nonIterableSpread(); }

function SupportPDP_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function SupportPDP_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return SupportPDP_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return SupportPDP_arrayLikeToArray(o, minLen); }

function SupportPDP_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function SupportPDP_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return SupportPDP_arrayLikeToArray(arr); }

function SupportPDP_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





 //import Json from '../../../assets/json/supportpdp.json';

core_class.use([navigation]);

function SupportPDP() {
  console.log('SupportPDP'); //console.log(Json);

  var initialJsonData;
  var jsonData;
  var supportPDPArray = [];
  var labels = {
    view_less: utilities_CustomUtil.isLocalhost() || typeof supportPDPKnowledgeBase == "undefined" ? 'View Less' : supportPDPKnowledgeBase.viewLess,
    view_more: utilities_CustomUtil.isLocalhost() || typeof supportPDPKnowledgeBase == "undefined" ? 'View More' : supportPDPKnowledgeBase.viewMore
  };

  var bindViewEvents = function bindViewEvents() {
    var views = document.querySelectorAll('.SupportPDP-list .view');
    views.forEach(function (view) {
      view.addEventListener('click', function (e) {
        e.preventDefault();
        var target = e.currentTarget;

        if (target.getAttribute('data-parent')) {
          var more_height = 0;
          var less_height = 0;
          var parent = document.getElementById(target.getAttribute('data-parent'));
          var items = parent.querySelectorAll('.item');
          var length = parent.querySelectorAll('.item').length;
          var cheight = parseInt(parent.getAttribute('data-cheight'));

          for (var i = 10; i < length; i++) {
            more_height += items[i].clientHeight;
          }

          target.parentElement.classList.toggle('opened');

          if (target.parentElement.classList.contains('opened')) {
            target.querySelector('span').innerHTML = labels.view_less;
            less_height = cheight;
          } else {
            target.querySelector('span').innerHTML = labels.view_more;
            less_height = cheight - more_height;
          }

          if (target.getAttribute('data-lheight') == null) {
            target.setAttribute('data-lheight', less_height);
          }

          var height = parseInt(target.getAttribute('data-lheight'));

          for (var _i = 10; _i < length; _i++) {
            height += items[_i].clientHeight;
          }

          parent.style.height = height + 'px';
        } else {
          target.parentElement.classList.toggle('opened');

          if (target.parentElement.classList.contains('opened')) {
            target.querySelector('span').innerHTML = labels.view_less;
          } else {
            target.querySelector('span').innerHTML = labels.view_more;
          }
        }
      });
    });
  };

  function sortBy(index, order) {
    return function (x, y) {
      var nameA = x['features'][index].order; //.toString().toLowerCase();

      var nameB = y['features'][index].order; //.toString().toLowerCase();

      if (x['features'][index].order == '') {
        nameA = '0';
      }

      if (y['features'][index].order == '') {
        nameB = '0';
      }

      if (!isNaN(parseFloat(x['features'][index].order)) && !isNaN(parseFloat(y['features'][index].order))) {
        nameA = parseFloat(nameA);
        nameB = parseFloat(nameB);
      }

      if (order == 'asc') {
        if (nameA < nameB) //sort string ascending
          return -1;
        if (nameA > nameB) return 1;
        return 0;
      } else {
        if (nameA > nameB) //sort string descending
          return -1;
        if (nameA < nameB) return 1;
        return 0;
      }
    };
  }

  var getTableData = function getTableData() {
    var jsonUrl = '';

    if (utilities_CustomUtil.isLocalhost()) {
      jsonUrl = '/assets/json/supportpdp.json';
      fetch(jsonUrl, {
        method: 'GET'
      }).then(function (response) {
        return response.json();
      }).then(function (jsondata) {
        console.log(jsondata);
        initialJsonData = jsondata;
        jsonData = initialJsonData;
      });
    } else {
      if (typeof supportSpecsData !== 'undefined') {
        supportPDPArray = supportSpecsData;
        var jsondata = {};
        jsondata['models'] = supportPDPArray;
        initialJsonData = jsondata;
        jsonData = initialJsonData;
        console.log(jsonData);
      }
    }
  };

  var updateSortedHTML = function updateSortedHTML(newJsonData) {
    var body = document.querySelector('.SupportPDP__specsTable .MFTable-table-body');
    updateSortedModelHTML(newJsonData);
    updateSortedFeaturesHTML(newJsonData);
  };

  var createSortedModelHTML = function createSortedModelHTML(model) {
    var html = '';

    if (model.title && model.title != '') {
      html += '<div class="model-name">' + model.title + '</div>';
    }

    if (model.skuNumber && model.skuNumber != '') {
      html += '<div class="model-sku">' + model.skuNumber + '</div>';
    }

    if (model.warrantyYears && model.warrantyYears != '') {
      html += '<div class="model-year"><span>' + model.warrantyYears + '</span>-year limited warranty</div>';
    }

    if (model.datasheet && model.datasheet != '' || model.productManual && model.productManual != '') {
      html += '<div class="model-links">';

      if (model.datasheet && model.datasheet != '') {
        html += '<a href="' + model.datasheet + '" title="Data Sheet" class="Button Button-tertiary Button-download"><span>' + 'Data Sheet' + '<i class="Button-arrow"><em></em></i></span></a>';
      }

      if (model.productManual && model.productManual != '') {
        html += '<a href="' + model.productManual + '" title="User Manual" class="Button Button-tertiary Button-download"><span>' + 'User Manual' + '<i class="Button-arrow"><em></em></i></span></a>';
      }

      html += '</div>';
    }

    return html;
  };

  var updateSortedModelHTML = function updateSortedModelHTML(newJsonData) {
    var body = document.querySelector('.SupportPDP__specsTable .MFTable-table-body');
    var column = body.querySelectorAll('.MFTable-table-column')[0];
    var cells = column.querySelectorAll('.MFTable-table-cell');
    newJsonData.forEach(function (model, index) {
      cells[index + 1].innerHTML = createSortedModelHTML(model);
    });
  };

  var updateSortedFeaturesHTML = function updateSortedFeaturesHTML(newJsonData) {
    var body = document.querySelector('.SupportPDP__specsTable .MFTable-table-body');
    var columns = body.querySelectorAll('.swiper-wrapper .MFTable-table-column');
    newJsonData.forEach(function (model, index) {
      columns.forEach(function (column, cindex) {
        var cells = column.querySelectorAll('.MFTable-table-cell');

        if (model.features[cindex].value != undefined) {
          cells[index + 1].querySelector('span').innerHTML = model.features[cindex].value;
        } else {
          cells[index + 1].querySelector('span').innerHTML = '';
        }
      });
    });
  };

  var sortTableData = function sortTableData(index, order) {
    var newJsonData = jsonData.models.sort(sortBy(index, order));
    console.log(newJsonData);
    updateSortedHTML(newJsonData);
  };

  var bindSortEvents = function bindSortEvents() {
    if (document.querySelector('.SupportPDP__specsTable')) {
      var sortBtns = document.querySelectorAll('.SupportPDP__specsTable .sort');
      var sorts = document.querySelectorAll('.SupportPDP__specsTable .sort > i');
      var header = document.querySelector('.SupportPDP__specsTable .MFTable-table-header');
      var body = document.querySelector('.SupportPDP__specsTable .MFTable-table-body');
      var cellHeaders = document.querySelectorAll('.SupportPDP__specsTable .cell-header');
      /*sortBtns.forEach((sortBtn) => {
        sortBtn.addEventListener('click', (e) => {
          e.preventDefault();
          let target = e.target;
          let parent = target.parentElement;
          let cell = target.closest('.cell-header');
          let label = cell.getAttribute('data-label');
          let findex = cell.getAttribute('data-findex');
          let row = cell.closest('.MFTable-table-row');
          if(!cell.classList.contains('asc') && !cell.classList.contains('desc')){
            cell.classList.remove('desc');
            cell.classList.add('asc');
            let relatedCell = row.classList.contains('MFTable-table-header')
              ? body.querySelector(".cell-header[data-label='" + label + "']")
              : header.querySelector(".cell-header[data-label='" + label + "']");
            if (relatedCell) {
              relatedCell.classList.remove('desc');
              relatedCell.classList.add('asc');
            }
            sortTableData(findex, 'desc');
          }else {
            if (cell.classList.contains('desc')) {
              cell.classList.remove('desc');
              cell.classList.add('asc');
              let relatedCell = row.classList.contains('MFTable-table-header')
                ? body.querySelector(".cell-header[data-label='" + label + "']")
                : header.querySelector(".cell-header[data-label='" + label + "']");
              if (relatedCell) {
                relatedCell.classList.remove('desc');
                relatedCell.classList.add('asc');
              }
              sortTableData(findex, 'desc');
            }
            else {
              cell.classList.remove('asc');
              cell.classList.add('desc');
              let relatedCell = row.classList.contains('MFTable-table-header')
                ? body.querySelector(".cell-header[data-label='" + label + "']")
                : header.querySelector(".cell-header[data-label='" + label + "']");
              if (relatedCell) {
                relatedCell.classList.remove('asc');
                relatedCell.classList.add('desc');
              }
              sortTableData(findex, 'asc');
            }
          }
          cellHeaders.forEach((ch) => {
            if (ch.getAttribute('data-label') != label) {
              ch.classList.remove('asc');
              ch.classList.remove('desc');
            }
          });
        });
      });*/

      sorts.forEach(function (sort) {
        sort.addEventListener('click', function (e) {
          e.preventDefault();
          var target = e.currentTarget;
          var parent = target.parentElement;
          var cell = target.closest('.cell-header');
          var label = cell.getAttribute('data-label');
          var findex = cell.getAttribute('data-findex');
          var row = cell.closest('.MFTable-table-row');

          if (target.classList.contains('up')) {
            if (!cell.classList.contains('asc')) {
              cell.classList.remove('desc');
              cell.classList.add('asc');
              var relatedCell = row.classList.contains('MFTable-table-header') ? body.querySelector(".cell-header[data-label='" + label + "']") : header.querySelector(".cell-header[data-label='" + label + "']");

              if (relatedCell) {
                relatedCell.classList.remove('desc');
                relatedCell.classList.add('asc');
              }

              sortTableData(findex, 'asc');
            }
          } else {
            if (!cell.classList.contains('desc')) {
              cell.classList.remove('asc');
              cell.classList.add('desc');

              var _relatedCell = row.classList.contains('MFTable-table-header') ? body.querySelector(".cell-header[data-label='" + label + "']") : header.querySelector(".cell-header[data-label='" + label + "']");

              if (_relatedCell) {
                _relatedCell.classList.remove('asc');

                _relatedCell.classList.add('desc');
              }

              sortTableData(findex, 'desc');
            }
          }

          cellHeaders.forEach(function (ch) {
            if (ch.getAttribute('data-label') != label) {
              ch.classList.remove('asc');
              ch.classList.remove('desc');
            }
          });
        });
      });
    }
  };

  var observer; //watch to update arrow position

  var watch = function watch() {
    observer = new MutationObserver(function (mutationRecords) {
      //console.log(mutationRecords);
      setTableArrowPosition();
    });
    var node = document.querySelectorAll('.SupportPDP__specsTable .cell-header')[0];
    var config = {
      attributes: true,
      attributeFilter: ['style']
    };

    if (node) {
      observer.observe(node, config);
    }
  };

  var observer_sort; //watch to update height when sort.

  var watchSort = function watchSort() {
    observer_sort = new MutationObserver(function (mutationRecords) {
      //console.log(mutationRecords);
      var bodyColumn = document.querySelectorAll('.SupportPDP__specsTable .MFTable-table-body .MFTable-table-column');

      if (bodyColumn) {
        utilities_CustomUtil.setColumnCellHeight(bodyColumn, '.MFTable-table-cell', '.dropdown-header');
      }
    });
    var firstColumn = document.querySelectorAll('.SupportPDP__specsTable .MFTable-table-body .MFTable-table-column')[0];
    var nodes = firstColumn ? firstColumn.querySelectorAll('.MFTable-table-cell') : [];
    var config = {
      childList: true,
      characterData: true
    };
    nodes.forEach(function (node) {
      observer_sort.observe(node, config);
    });
  };

  var setTableArrowPosition = function setTableArrowPosition() {
    var isLaptop = document.querySelector('.SupportPDP__specsTable--mobile') && window.getComputedStyle(document.querySelector('.SupportPDP__specsTable--mobile')).display == 'none' ? true : false;
    var arrows = document.querySelectorAll('.SupportPDP__specsTable .ComparisonTableCarousel-controlsPanel');

    if (arrows.length > 0 && isLaptop) {
      var cellHeight = parseInt(document.querySelectorAll('.SupportPDP__specsTable .cell-header')[0].style.height);
      arrows.forEach(function (arrow) {
        arrow.style.top = cellHeight / 2 - 16 + 'px';
      });
    }
  };

  var resetTableColumnWidth = function resetTableColumnWidth() {
    var tables = document.querySelectorAll('.SupportPDP__specsTable--laptop');

    if (tables) {
      tables.forEach(function (table) {
        var columns = table.querySelectorAll('.MFTable-table-body .ComparisonTableCarousel-contentPanel .MFTable-table-column');
        table.setAttribute('data-cslider', columns.length);
      });
    }
  };

  components_MFCollapse('.SupportPDP-accordion');
  bindViewEvents();
  resetTableColumnWidth();
  getTableData();
  bindSortEvents();
  watch();
  watchSort();
  setTableArrowPosition(); //Do when page load.

  window.addEventListener('resize', function () {
    var views = document.querySelectorAll('.SupportPDP-list .view');
    views.forEach(function (view) {
      if (view.getAttribute('data-parent')) {
        view.removeAttribute('data-lheight');
      }
    });
  });
  return {
    destroy: function destroy() {
      observer.disconnect();
    }
  };
}

SupportPDP.VideoCarousel = function (_ref) {
  var el = _ref.el;
  var transitionSpeed = 300;
  var swiperTarget = el.getAttribute('id');
  var leftButtonEl = document.getElementById('control-left-' + swiperTarget);
  var rightButtonEl = document.getElementById('control-right-' + swiperTarget);
  var ticking = false;

  var setSlideWidth = function setSlideWidth() {
    var sPDPStarted = document.querySelector('.SupportPDP__getStarted');

    if (sPDPStarted) {
      var container = sPDPStarted.querySelectorAll('.SupportPDP__container')[0];
      var list = sPDPStarted.querySelectorAll('.SupportPDP-list')[0];
      var isLaptop = window.getComputedStyle(container).overflow == 'hidden' ? true : false;
      var control = leftButtonEl.parentElement;
      var cMargin = parseInt(window.getComputedStyle(container).marginRight);

      if (isLaptop) {
        var num = 4;
        var slides = el.querySelectorAll('.swiper-slide');
        var slideMargin = parseInt(window.getComputedStyle(slides[0]).marginRight);
        var width = container.clientWidth / num - slideMargin + slideMargin / num;
        slides.forEach(function (slide) {
          slide.style.width = width + 'px';
        });
      }
    }
  };

  setSlideWidth();
  Modal();
  var videoSwiper = new core_class(el, {
    effect: 'slide',
    speed: transitionSpeed,
    slidesPerView: 'auto',
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    watchOverflow: true,
    loop: false,
    navigation: {
      nextEl: rightButtonEl,
      prevEl: leftButtonEl
    }
  });
  window.addEventListener('resize', function () {
    if (!ticking) {
      window.requestAnimationFrame(function () {
        setSlideWidth();
        ticking = false;
      });
      ticking = true;
    }
  });
  rightButtonEl.addEventListener('click', function (e) {
    var container = e.currentTarget.parentElement.parentElement;

    if (e.currentTarget.classList.contains('swiper-button-disabled')) {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.add('last-visible');
      });
    } else {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }
  });
  leftButtonEl.addEventListener('click', function (e) {
    var container = e.currentTarget.parentElement.parentElement;
    var lastVisibles = container.querySelectorAll('.last-visible');

    if (lastVisibles) {
      lastVisibles.forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }
  });
  return {
    destroy: function destroy() {
      videoSwiper.detachEvents();
      videoSwiper.destroy();
    }
  };
};

SupportPDP.defaultVideoCarouselSelector = '.SupportPDP-videoCarousel .swiper-container';

SupportPDP.initAllVideoCarousel = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? SupportPDP.defaultVideoCarouselSelector : _ref2$selector;

  return SupportPDP_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return SupportPDP.VideoCarousel({
      el: el
    });
  });
};

/* harmony default export */ var modules_SupportPDP = (SupportPDP);
;// CONCATENATED MODULE: ./stories/js/modules/CardLayoutPerson4Up/index.js
function CardLayoutPerson4Up_toConsumableArray(arr) { return CardLayoutPerson4Up_arrayWithoutHoles(arr) || CardLayoutPerson4Up_iterableToArray(arr) || CardLayoutPerson4Up_unsupportedIterableToArray(arr) || CardLayoutPerson4Up_nonIterableSpread(); }

function CardLayoutPerson4Up_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function CardLayoutPerson4Up_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CardLayoutPerson4Up_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CardLayoutPerson4Up_arrayLikeToArray(o, minLen); }

function CardLayoutPerson4Up_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function CardLayoutPerson4Up_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return CardLayoutPerson4Up_arrayLikeToArray(arr); }

function CardLayoutPerson4Up_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function CardLayoutPerson4Up() {
  var CardLayoutPerson4Up = document.querySelectorAll('.CardLayoutPerson4Up');

  if (CardLayoutPerson4Up) {
    var card = '.CardLayoutPerson4Up-card';
    var cardEyebrow = '.card-eyebrow';
    var cardInfo = '.info';
    var cardName = '.info .name';
    var cardJob = '.info .job';
    var cardSMS = '.card-sms';
    var cardDes = '.card-des';
    window.addEventListener('load', function (e) {
      resetPersonCard();
    });
    window.addEventListener('resize', function (e) {
      watchPerson();
    });
    var observerPerson;

    var watchPerson = function watchPerson() {
      observerPerson = new MutationObserver(function (mutationRecords) {
        //console.log(mutationRecords);
        resetPersonCard();
      });
      var node = document.querySelector('body');
      var config = {
        attributes: true,
        attributeFilter: ['data-viewport']
      };

      if (node) {
        observerPerson.observe(node, config);
      }
    };
  }

  function resetPersonCard() {
    var body = document.querySelector('body');
    var view = body.getAttribute('data-viewport');
    var num = 4; //view == 'isLaptop'?4:view == 'isTablet'?2:1;

    CardLayoutPerson4Up.forEach(function (c) {
      setSameCardHeight(c, card, cardEyebrow, num);
      setSameCardHeight(c, card, cardInfo, num);
      setSameCardHeight(c, card, cardName, num);
      setSameCardHeight(c, card, cardJob, num);
      setSameCardHeight(c, card, cardSMS, num);
      setSameCardHeight(c, card, cardDes, num);
    });
  }

  function setSameCardHeight(container, parent, child, num) {
    var boxes = container.querySelectorAll(parent);
    var all = boxes.length;
    var rows = Math.ceil(all / num);
    var heightFlag = '0px';

    if (num > 1) {
      for (var i = 0; i < rows; i++) {
        var row_boxes = CardLayoutPerson4Up_toConsumableArray(boxes).filter(function (b, index) {
          return index >= i * num && index < (i + 1) * num;
        });

        var tallest = 0;
        row_boxes.forEach(function (box, index) {
          var elements = box.querySelectorAll(child);
          elements.forEach(function (element) {
            element.style.height = 'auto';

            if (element.clientHeight > tallest) {
              tallest = element.clientHeight;
            }
          });
        });
        row_boxes.forEach(function (box, index) {
          var elements = box.querySelectorAll(child);
          elements.forEach(function (element) {
            element.style.height = tallest + 'px';
          });
        });
      }
    } else {
      boxes.forEach(function (box) {
        var elements = box.querySelectorAll(child);
        elements.forEach(function (element) {
          element.style.height = 'auto';
        });
      });
      heightFlag = 'auto';
    }

    if (child == '.card-eyebrow') {
      var bc = container.querySelectorAll(child);

      var noEle = CardLayoutPerson4Up_toConsumableArray(bc).every(function (element) {
        return element.style.height === heightFlag;
      });

      if (noEle) {
        boxes.forEach(function (box) {
          var elements = box.querySelectorAll(child);
          elements.forEach(function (element) {
            element.remove();
          });
        });
      }
    }
  }
}

/* harmony default export */ var modules_CardLayoutPerson4Up = (CardLayoutPerson4Up);
;// CONCATENATED MODULE: ./stories/js/modules/NavigationLeft/index.js


function NavigationLeft() {
  console.log('NavigationLeft');
  var body = document.body;
  var NavigationLeft = document.querySelector('.NavigationLeft');

  if (NavigationLeft) {
    var navigationLeftMenu = NavigationLeft.querySelector('[data-navigationleft]');
    var navigationLeftTrigger = NavigationLeft.querySelector('[data-navigationleft-trigger]');
    var navigationLeftSubmenusContainer = NavigationLeft.querySelector('.NavigationLeft-subMenus');
    var navigationLeftSubmenus = NavigationLeft.querySelectorAll('[data-navigationleft-submenu]');
    var submenuTriggers = NavigationLeft.querySelectorAll('[data-navigationleft-submenu-trigger]');
    var navigationleftContainer = NavigationLeft.querySelector('.NavigationLeft-menu-container');
    var navigationleftBody = NavigationLeft.querySelector('.NavigationLeft-menu-body');
    var mainHeight = navigationLeftMenu.clientHeight;
    var isLaptop = window.getComputedStyle(navigationLeftTrigger).display == 'none' ? true : false; //ForTest

    var hashs = document.querySelectorAll('.hash');
    hashs.forEach(function (hash) {
      hash.addEventListener('click', function (e) {
        e.preventDefault();
        updateNavigationStatus(e.currentTarget.innerHTML);
      });
    });

    var updateNavigationStatus = function updateNavigationStatus(hash) {
      var activeLink = NavigationLeft.querySelector('[data-trigger="' + hash + '"]');
      var ptrigger = activeLink.getAttribute('data-parent-trigger');
      activeLink.classList.add('is-active');
      var levels = [];
      var levelEle = activeLink;

      if (activeLink.parentElement.classList.contains('accordion-header')) {
        levelEle = activeLink.parentElement.parentElement.parentElement;
      }

      while (levelEle.classList && !levelEle.classList.contains('NavigationLeft--accordion')) {
        if (levelEle.classList.contains('accordion-item')) {
          levels.unshift(levelEle);
        }

        levelEle = levelEle.parentNode;
      }

      if (!activeLink.parentElement.getAttribute('data-navigationleft-submenu-trigger')) {
        if (levels.length == 0) {
          var rootLink = NavigationLeft.querySelector('[data-navigationleft-submenu-trigger="' + ptrigger + '"]'); //level2

          if (rootLink) {
            rootLink.querySelector('.NavigationLeft-arrow').click();
          }
        } else {
          // > level 2
          var rootTrigger = levels[0].querySelector('.accordion-header .nav-link').getAttribute('data-parent-trigger');

          var _rootLink = NavigationLeft.querySelector('[data-navigationleft-submenu-trigger="' + rootTrigger + '"]');

          if (_rootLink) {
            _rootLink.querySelector('.NavigationLeft-arrow').click();
          }

          for (var i = 0; i < levels.length; i++) {
            var levelLink = levels[i].querySelector('.accordion-header .collapse-trigger');

            if (levelLink) {
              levelLink.click();
            }
          }
        }
      }
    };

    var observer;

    var watchSubMenu = function watchSubMenu() {
      observer = new MutationObserver(function (mutationRecords) {
        console.log(mutationRecords);
        setTimeout(function () {
          updateMenuHeight();
        }, 300);
      });
      var nodes = NavigationLeft.querySelectorAll('.NavigationLeft-subMenus-menu.is-open .accordion-collapse');
      var node = nodes[0];
      var config = {
        attributes: true,
        attributeFilter: ['style']
      };

      if (node) {
        observer.observe(node, config);
      }
    };

    var updateMenuHeight = function updateMenuHeight() {
      var openSubMenu = NavigationLeft.querySelector('.NavigationLeft-subMenus-menu.is-open');
      var space = 30;

      if (openSubMenu) {
        var height = openSubMenu.clientHeight;

        if (height >= mainHeight) {
          navigationleftBody.style.height = height + 'px';
        } else {
          navigationleftBody.style.height = '100%';
        }
      } else {
        navigationleftBody.style.height = '100%';
      }

      if (isLaptop) {
        var navHeight = navigationleftBody.clientHeight + 128;

        var _body = document.querySelector('.Legal-main');

        if (_body && _body.clientHeight > navHeight) {
          navHeight = _body.clientHeight;
        }

        NavigationLeft.style.height = navHeight + 'px';
      } else {
        NavigationLeft.style.height = 'auto';
      }
    };

    navigationLeftTrigger.addEventListener('click', function (e) {
      e.preventDefault();
      navigationLeftTrigger.classList.toggle('is-active');
      navigationleftContainer.classList.toggle('is-open');
      updateMenuHeight();
      watchSubMenu();
    });
    submenuTriggers.forEach(function (trigger) {
      var submenuName = trigger.dataset.navigationleftSubmenuTrigger;

      if (trigger.querySelector('.NavigationLeft-arrow')) {
        trigger.querySelector('.NavigationLeft-arrow').addEventListener('click', function (e) {
          e.preventDefault();
          navigationLeftSubmenus.forEach(function (submenu) {
            submenu.classList.remove('is-open');
          });

          if (submenuName) {
            var submenu = NavigationLeft.querySelector("[data-navigationleft-submenu=\"".concat(submenuName, "\"]"));
            submenu.classList.add('is-open');
            NavigationLeft.classList.add('is-submenuOpen');
          } else {
            var openSubmenu = NavigationLeft.querySelector('[data-navigationleft-submenu].is-open');

            if (openSubmenu) {
              openSubmenu.classList.remove('is-open');
            }

            NavigationLeft.classList.remove('is-submenuOpen');
          }

          updateMenuHeight();
          watchSubMenu();
        });
      }
    });
    window.addEventListener('resize', function () {
      isLaptop = window.getComputedStyle(navigationLeftTrigger).display == 'none' ? true : false;
      updateMenuHeight();
      var openSubmenu = NavigationLeft.querySelector('[data-navigationleft-submenu].is-open');

      if (openSubmenu) {
        var showCollapses = openSubmenu.querySelectorAll('.collapse.show');
        showCollapses.forEach(function (collapse) {
          collapse.style.height = collapse.querySelector('.accordion-content').clientHeight + 'px';
        });
      }
    });
    components_MFCollapse('.NavigationLeft');

    if (isLaptop) {
      updateMenuHeight();
    }

    watchSubMenu();
  }
}

/* harmony default export */ var modules_NavigationLeft = (NavigationLeft);
;// CONCATENATED MODULE: ./stories/js/modules/ProductFinderNew/index.js


function ProductFinderNew() {
  console.log('ProductFinderNew');
  var container = document.querySelector('.ProductFinder');

  if (container) {
    components_MFCollapse('.ProductFinder');
  }
}

/* harmony default export */ var modules_ProductFinderNew = (ProductFinderNew);
;// CONCATENATED MODULE: ./stories/js/modules/NavigationSiteSection/index.js



function NavigationSiteSection() {
  console.log('NavigationSiteSection');
  var container = document.querySelector('.NavigationSiteSection');

  if (container) {
    var shyNav = document.querySelector('[data-shy-nav]');
    var shyPlaceholder = document.querySelector('.ShyNav-shim');
    var navLinks = document.querySelectorAll('[data-navigationmenu-section]');
    var submenus = document.querySelectorAll('[data-navigationmenu]');
    var search = document.querySelector('[data-search]');
    var secondaryNav = document.querySelector('.SecondaryNav');
    var activeMenu = document.querySelector('.NavigationMenu.is-active');
    var mobildRow = document.querySelector('.PrimaryNav >.Container--row');
    var alertBanner = document.querySelector('.AlertBar');
    var alertHeight = 0;
    var shyPlaceholderHeight = shyPlaceholder ? shyPlaceholder.clientHeight : 0;
    var uaResult = new (ua_parser_default())().getResult();
    var browserInfo = new (ua_parser_default())().getBrowser();
    var customUtil = utilities_CustomUtil.initSettings();
    customUtil.initCheckScreen();
    updateElementsWithAlert();

    function updateElementsWithAlert() {
      shyPlaceholderHeight = customUtil.screenIs == 'isMobile' ? 104 : 128;

      if (alertBanner) {
        if (customUtil.screenIs == 'isMobile') {
          shyNav.appendChild(alertBanner);
        } else {
          shyNav.insertBefore(alertBanner, search);
        }

        shyPlaceholder.style.height = shyPlaceholderHeight + alertBanner.clientHeight + 'px';
        shyNav.style.height = shyPlaceholder.clientHeight + 'px';

        if (customUtil.screenIs == 'isMobile') {
          search.style.top = secondaryNav.clientHeight + mobildRow.clientHeight + alertBanner.clientHeight + 'px';
        } else {
          search.style.top = secondaryNav.clientHeight + alertBanner.clientHeight + 'px';
        }

        submenus.forEach(function (menu) {
          if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
            menu.style.top = shyNav.clientHeight + 'px';
          }

          if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
            menu.style.top = shyNav.clientHeight + 'px';
          }
        });
      }
    }

    var timeoutMouseenter = {};
    var timeoutMouseleave = {};
    var delay = 250;
    navLinks.forEach(function (link) {
      var linkSubmenu = document.querySelector("[data-navigationmenu=\"".concat(link.dataset.navigationmenuSection, "\"]"));

      if (linkSubmenu) {
        var id = link.getAttribute('data-navigationmenu-section');
        link.addEventListener('mouseenter', function () {
          if (typeof timeoutMouseleave[id] != 'undefined') {
            clearTimeout(timeoutMouseleave[id]);
          }

          timeoutMouseenter[id] = setTimeout(function () {
            linkSubmenu.classList.add('is-active'); //reset submenu top

            var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

            if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
              linkSubmenu.style.top = shytop + shyNav.clientHeight + 'px';
            }

            if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
              linkSubmenu.style.top = shytop + shyNav.clientHeight + 'px';
            }
          }, delay);
        });
        link.addEventListener('mouseleave', function () {
          if (typeof timeoutMouseenter[id] != 'undefined') {
            clearTimeout(timeoutMouseenter[id]);
          }

          timeoutMouseleave[id] = setTimeout(function () {
            linkSubmenu.classList.remove('is-active');
          }, delay);
        });
      }
    });
    submenus.forEach(function (submenu) {
      var id = submenu.getAttribute('data-navigationmenu');
      submenu.addEventListener('mouseenter', function (e) {
        if (typeof timeoutMouseleave[id] != 'undefined') {
          clearTimeout(timeoutMouseleave[id]);
        } //submenu.classList.add('is-active');

      });
      submenu.addEventListener('mouseleave', function () {
        timeoutMouseleave[id] = setTimeout(function () {
          submenu.classList.remove('is-active');
          var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

          if (0 - shytop > shyNav.clientHeight) {
            shyNav.style.top = -parseInt(shyNav.clientHeight) + 'px';
            customUtil.settings.headerStatus = 0;
            customUtil.updateStickyElements();
          }
        }, delay);
      });
    });

    if (shyNav) {
      var scrollPosition = 0;
      var scrollUpPosition = 0;
      var scrollDownPosition = 0;
      var currentlyScrollingDown = false;
      var ticking = false;
      var isStuck = false;
      var longScroll = false;
      var navHeight = parseInt(shyNav.clientHeight);
      var prevScroTop = 0;
      var directionSwitch = false;
      var activeMenuHeight = 0;
      submenus.forEach(function (menu) {
        if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
          menu.style.top = shyNav.clientHeight + 'px';
        }

        if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
          menu.style.top = shyNav.clientHeight + 'px';
        }
      });

      function updateHeaderPositionWhenScroll() {
        var scroTop = window.scrollY || document.documentElement.scrollTop;
        navHeight = shyNav.clientHeight;

        if (alertBanner) {
          alertHeight = alertBanner.clientHeight;
        }

        if (shyNav.clientHeight == 0) {
          navHeight = customUtil.screenIs == 'isMobile' ? 104 + alertHeight : 128 + alertHeight;
        }

        activeMenu = document.querySelector('.NavigationMenu.is-active');

        if (search && search.classList.contains('is-touched')) {
          //Condition when searchbox opened.
          navHeight = shyNav.clientHeight + search.clientHeight;
        }

        if (activeMenu) {
          //Condition when submenu opened.
          navHeight = shyNav.clientHeight + activeMenu.clientHeight;
          activeMenuHeight = activeMenu.clientHeight;
        } else {
          if (search && !search.classList.contains('is-touched')) {
            if (scroTop <= prevScroTop) {
              //Condition when submenu opened and scroll outside, then scrollup, firstly reset primarynav top.
              if (!directionSwitch) {
                var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

                if (0 - parseInt(shytop) > parseInt(shyNav.clientHeight)) {
                  shyNav.style.top = -parseInt(shyNav.clientHeight) + 'px';
                  directionSwitch = true;
                }
              }
            }
          }
        }

        var navTopPX = shyNav.style.top;
        var navTop = parseInt(navTopPX.slice(0, navTopPX.length - 2));
        var setTop = 0;

        if (scroTop > prevScroTop) {
          // Scroll Down
          document.querySelector('body').setAttribute('data-direction', 'down');
          var topValue = navTop > -navHeight ? parseInt(navTop - (scroTop - prevScroTop)) : -navHeight;

          if (-topValue > navHeight) {
            //long scroll as anchor
            setTop = -navHeight;
          } else {
            setTop = scroTop > navHeight ? topValue : -(0 - scroTop) < shyPlaceholder.clientHeight ? 0 - scroTop : topValue;
          }

          shyNav.style.top = setTop + 'px';

          if (search) {
            if (customUtil.screenIs == 'isMobile') {
              search.style.top = setTop + secondaryNav.clientHeight + mobildRow.clientHeight + alertHeight + 'px';
            } else {
              search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
            }
          }

          if (activeMenu) {
            if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
              activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
            }

            if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
              activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
            }
          }

          directionSwitch = false;
        } else {
          // Scroll Up
          document.querySelector('body').setAttribute('data-direction', 'up');

          if (customUtil.checkNavigationSection() && customUtil.checkInPageNav()) {
            if (scroTop > navHeight) {
              //When not fetch the shynav position, hide shynav
              setTop = 0;
            } else {
              //When fetch the shynav position, show shynav as before
              var _topValue = parseInt(navTop - (scroTop - prevScroTop)) > 0 ? 0 : parseInt(navTop - (scroTop - prevScroTop));

              setTop = navTop >= 0 ? 0 : _topValue;
              shyNav.style.top = setTop + 'px';

              if (search) {
                if (customUtil.screenIs == 'isMobile') {
                  search.style.top = setTop + secondaryNav.clientHeight + mobildRow.clientHeight + alertHeight + 'px';
                } else {
                  search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
                }
              }

              if (activeMenu) {
                if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
                  activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
                }

                if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
                  activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
                }
              }
            }
          } else {
            var _topValue2 = parseInt(navTop - (scroTop - prevScroTop)) > 0 ? 0 : parseInt(navTop - (scroTop - prevScroTop));

            setTop = navTop >= 0 ? 0 : _topValue2;
            shyNav.style.top = setTop + 'px';

            if (search) {
              if (customUtil.screenIs == 'isMobile') {
                search.style.top = setTop + secondaryNav.clientHeight + mobildRow.clientHeight + alertHeight + 'px';
              } else {
                search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
              }
            }

            if (activeMenu) {
              if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version)) {
                activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
              }

              if (browserInfo.name === 'Safari' || uaResult.device.type === 'tablet') {
                activeMenu.style.top = setTop + shyNav.clientHeight + 'px';
              }
            }
          }
        } // 0 = hide, 1 = show part, 2 = show all


        if (setTop == 0) {
          customUtil.settings.headerStatus = 2;
        } else if (setTop == -navHeight) {
          customUtil.settings.headerStatus = 0;
        } else {
          customUtil.settings.headerStatus = 1;
        } //console.log('headerStatus:' + customUtil.settings.headerStatus);


        prevScroTop = scroTop;
      }

      function updateHeaderPosition(scrollPos) {
        var navPosition = shyNav.getBoundingClientRect().top;
        longScroll = Math.abs(scrollDownPosition - scrollUpPosition) > navHeight;
        if (scrollPos < 0) shyNav.style.top = 0;

        if (scrollPos > scrollPosition) {
          // SCROLLING DOWN
          scrollDownPosition = currentlyScrollingDown ? scrollPos : scrollDownPosition;

          if (!currentlyScrollingDown && isStuck) {
            shyNav.style.position = 'absolute';
            shyNav.style.top = "".concat(scrollUpPosition, "px");
          }

          currentlyScrollingDown = true;
          isStuck = false;
        } else {
          // SCROLLING UP
          currentlyScrollingDown = false;
          scrollUpPosition = currentlyScrollingDown ? scrollUpPosition : scrollPos;

          if (navPosition >= 0) {
            // STUCK HEADER
            shyNav.style.position = 'fixed';
            shyNav.style.top = 0;
            isStuck = true;
            scrollPosition = scrollPos;
            return;
          } else {
            isStuck = false;
          } // EDGE CASE - Header


          if (navPosition >= scrollPos) {
            // shyNav.style.position = 'fixed';
            shyNav.style.top = 0;
          } else {
            if (shyNav.style.position == 'fixed') return;
            shyNav.style.position = 'absolute';

            if (longScroll) {
              shyNav.style.top = "".concat(scrollDownPosition - navHeight, "px");
            }
          }
        }

        scrollPosition = scrollPos;
      }

      window.addEventListener('scroll', function (e) {
        var newScrollPosition = window.scrollY || document.documentElement.scrollTop;

        if (!ticking) {
          window.requestAnimationFrame(function () {
            updateHeaderPositionWhenScroll(); //updateHeaderPosition(newScrollPosition);

            ticking = false;
          });
          ticking = true;
        }
      });
      window.addEventListener('resize', function () {
        /*let shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));
        if (customUtil.screenIs == 'isMobile') {
          search.style.top = shytop + mobildRow.clientHeight + 'px';
        } else {
          search.style.top = shytop + secondaryNav.clientHeight + 'px';
        }*/
        customUtil.initCheckScreen();
        updateElementsWithAlert();
        customUtil.updateStickyElements();
      }, false);
      window.addEventListener('hashchange', function () {
        scrollDownPosition = window.scrollY || document.documentElement.scrollTop;
      }, false);

      if (document.location.hash != undefined && document.location.hash != '') {
        scrollDownPosition = window.scrollY || document.documentElement.scrollTop;
        currentlyScrollingDown = true;
      }
    }
  }
}

function SMobileMenu() {
  var body = document.body;
  var mobileMenu = document.querySelector('[data-mobilemenu]');
  var mobileMenuTriggers = document.querySelectorAll('[data-mobilemenu-trigger]');
  var mobileSubmenus = document.querySelectorAll('[data-submenu]');
  var submenuTriggers = document.querySelectorAll('[data-submenu-trigger]');
  mobileMenuTriggers.forEach(function (trigger) {
    trigger.addEventListener('click', function () {
      mobileMenuTriggers.forEach(function () {
        return trigger.classList.toggle('is-active');
      });
      document.body.classList.toggle('is-mobileMenuOpen');
      mobileMenu.classList.toggle('is-open');
      mobileMenu.querySelector('.MobileMenu-subMenus-menu').classList.remove('is-open');
      body.classList.remove('is-submenuOpen');
      body.classList.remove('is-submenuChildOpen');
    });
  });
  submenuTriggers.forEach(function (trigger) {
    var submenuName = trigger.dataset.submenuTrigger;
    trigger.addEventListener('click', function () {
      mobileSubmenus.forEach(function (submenu) {
        submenu.classList.remove('is-open');
      });

      if (submenuName) {
        var submenu = document.querySelector("[data-submenu=\"".concat(submenuName, "\"]"));
        submenu.classList.add('is-open');
        body.classList.add('is-submenuOpen');

        if (submenu.dataset.submenuChild) {
          body.classList.add('is-submenuChildOpen');
        } else {
          body.classList.remove('is-submenuChildOpen');
        }
      } else {
        var openSubmenu = document.querySelector('[data-submenu].is-open');

        if (openSubmenu) {
          openSubmenu.classList.remove('is-open');
        }

        body.classList.remove('is-submenuOpen');
        body.classList.remove('is-submenuChildOpen');
      }
    });
  });
}

function SNavigationMenu() {
  console.log('NavigationMenu');
  var timeoutMouseenter = {};
  var delay = 250;
  var navMenus = document.querySelectorAll('[data-navigationmenu]');
  navMenus.forEach(function (navMenu) {
    var wideCallout = navMenu.querySelector('.NavigationMenu-wideCallout');
    var navMenuTabs = navMenu.querySelectorAll('[data-navigationmenu-tab]');
    var navMenuContents = navMenu.querySelectorAll('[data-navigationmenu-content]');
    var navMenuCallouts = navMenu.querySelectorAll('[data-navigationmenu-callout]');
    navMenuTabs.forEach(function (tab) {
      var connectedContent = navMenu.querySelector("[data-navigationmenu-content=\"".concat(tab.dataset.navigationmenuTab, "\"]"));
      var connectedCallout = navMenu.querySelector("[data-navigationmenu-callout=\"".concat(tab.dataset.navigationmenuTab, "\"]"));
      var id = tab.getAttribute("data-navigationmenu-tab");
      tab.addEventListener('mouseenter', function () {
        timeoutMouseenter[id] = setTimeout(function () {
          navMenuTabs.forEach(function (otherTab) {
            return otherTab.classList.remove('is-active');
          });
          tab.classList.add('is-active');
          navMenuContents.forEach(function (content) {
            content.classList.remove('is-active');
            connectedContent.classList.add('is-active');
          });
          navMenuCallouts.forEach(function (callout) {
            callout.classList.remove('is-active');

            if (connectedCallout != undefined) {
              connectedCallout.classList.add('is-active');
              wideCallout.removeAttribute("style");
            } else {
              wideCallout.style.display = "none";
            }
          });
        }, delay);
      });
      tab.addEventListener('mouseleave', function () {
        if (typeof timeoutMouseenter[id] != "undefined") {
          clearTimeout(timeoutMouseenter[id]);
        }
      });
    });
  });
} //export { NavigationSiteSection, SMobileMenu, SNavigationMenu};


/* harmony default export */ var modules_NavigationSiteSection = (NavigationSiteSection);
;// CONCATENATED MODULE: ./stories/js/modules/FeatureContentLayoutOverview/index.js
function FeatureContentLayoutOverview_toConsumableArray(arr) { return FeatureContentLayoutOverview_arrayWithoutHoles(arr) || FeatureContentLayoutOverview_iterableToArray(arr) || FeatureContentLayoutOverview_unsupportedIterableToArray(arr) || FeatureContentLayoutOverview_nonIterableSpread(); }

function FeatureContentLayoutOverview_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function FeatureContentLayoutOverview_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FeatureContentLayoutOverview_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FeatureContentLayoutOverview_arrayLikeToArray(o, minLen); }

function FeatureContentLayoutOverview_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function FeatureContentLayoutOverview_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return FeatureContentLayoutOverview_arrayLikeToArray(arr); }

function FeatureContentLayoutOverview_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




core_class.use([navigation]);

function FeatureContentLayoutOverview() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    /*selector: '.FeatureContentLayoutOverview-contentPanel'*/
  },
      el = _ref.el;

  revealElements();

  if (el) {
    var transitionSpeed = 300;
    var swiperTarget = el.getAttribute('id');
    var leftButtonEl = document.getElementById('control-left-' + swiperTarget);
    var rightButtonEl = document.getElementById('control-right-' + swiperTarget);
    var cardsSwiper = new core_class(el, {
      effect: 'slide',
      speed: transitionSpeed,
      slidesPerView: 'auto',
      watchSlidesProgress: true,
      watchSlidesVisibility: true,
      watchOverflow: true,
      loop: false,
      navigation: {
        nextEl: rightButtonEl,
        prevEl: leftButtonEl
      }
    });
    rightButtonEl.addEventListener('click', function (e) {
      var container = e.currentTarget.parentElement.parentElement;

      if (e.currentTarget.classList.contains('swiper-button-disabled')) {
        container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
          element.classList.add('last-visible');
        });
      } else {
        container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
          element.classList.remove('last-visible');
        });
      }
    });
    leftButtonEl.addEventListener('click', function (e) {
      var container = e.currentTarget.parentElement.parentElement;
      var lastVisibles = container.querySelectorAll('.last-visible');

      if (lastVisibles) {
        lastVisibles.forEach(function (element) {
          element.classList.remove('last-visible');
        });
      }
    });
    return {
      destroy: function destroy() {
        cardsSwiper.detachEvents();
        cardsSwiper.destroy();
      }
    };
  }
}

FeatureContentLayoutOverview.defaultSelector = '.FeatureContentLayoutOverview-bg--video .swiper-container';

FeatureContentLayoutOverview.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? FeatureContentLayoutOverview.defaultSelector : _ref2$selector;

  return FeatureContentLayoutOverview_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return FeatureContentLayoutOverview({
      el: el
    });
  });
};

/* harmony default export */ var modules_FeatureContentLayoutOverview = (FeatureContentLayoutOverview);
;// CONCATENATED MODULE: ./stories/js/modules/TableFeatureComparison/index.js



function TableFeatureComparison() {
  console.log('TableFeatureComparison');
  var tables = document.querySelectorAll('.TableFeatureComparison.MFTable-s');
  var ticking = false;
  var prevScroTop = 0;
  var c_tabDoms = {};
  tables.forEach(function (table, t) {
    utilities_CustomUtil.updateSettings();
    c_tabDoms[t] = {};
    components_MFTable.updateTableVars(t, c_tabDoms[t], table);
    var tabContainer = table.querySelector('.MFTable-table');
    var tabHeader = table.querySelector('.MFTable-table-header');
    var tabBody = table.querySelector('.MFTable-table-body');
    var tabRows = table.querySelectorAll('.MFTable-table-row');
    var tabRowHeader = tabBody.querySelector('.MFTable-table-row.row-header');
    var cellColums = tabRowHeader.querySelectorAll('.MFTable-table-cell').length;

    if (cellColums == 2) {
      table.setAttribute('data-col', '1');
    } else if (cellColums == 3) {
      table.setAttribute('data-col', '2');
    } else if (cellColums == 4) {
      table.setAttribute('data-col', '3');
    }

    if (utilities_CustomUtil.isNavFixed()) {
      tabHeader.style.top = utilities_CustomUtil.settings.headerFixedHeight + 'px';
    } else {
      tabHeader.style.top = 0;
    }

    utilities_CustomUtil.initCheckScreen(); //if (CustomUtil.isLocalhost()) {

    components_MFTable.generateFixedTableHeaderForTableS(tabHeader, tabRowHeader); //}
  });
  window.addEventListener('resize', function (e) {
    utilities_CustomUtil.initCheckScreen();
    tables.forEach(function (table, t) {
      components_MFTable.updateTableVars(t, c_tabDoms[t], table);
    });
  });
  window.addEventListener('scroll', function (e) {
    if (!ticking) {
      window.requestAnimationFrame(function () {
        tables.forEach(function (table, t) {
          components_MFTable.updateTableVars(t, c_tabDoms[t], table);
          components_MFTable.bindTableScrollFixedEvent(c_tabDoms[t], prevScroTop);
        });
        ticking = false;
      });
      ticking = true;
    }
  });
} //export default ComparisonTable;


/* harmony default export */ var modules_TableFeatureComparison = (TableFeatureComparison);
;// CONCATENATED MODULE: ./stories/js/modules/CardLayoutFilters/index.js
function CardLayoutFilters_toConsumableArray(arr) { return CardLayoutFilters_arrayWithoutHoles(arr) || CardLayoutFilters_iterableToArray(arr) || CardLayoutFilters_unsupportedIterableToArray(arr) || CardLayoutFilters_nonIterableSpread(); }

function CardLayoutFilters_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function CardLayoutFilters_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return CardLayoutFilters_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return CardLayoutFilters_arrayLikeToArray(o, minLen); }

function CardLayoutFilters_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function CardLayoutFilters_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return CardLayoutFilters_arrayLikeToArray(arr); }

function CardLayoutFilters_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




function CardLayoutFilters(ele) {
  var containers = document.querySelectorAll('.CardLayoutFilters');
  var cid = ele.el.id;
  var container = document.getElementById(cid);
  var main = container.querySelector('.CardLayoutFilters-main');
  var pannel = container.querySelector('.CardLayoutFilters-panel');
  var filters = container.querySelector('.CardLayoutFilters-filters');
  var selectedFiltersBanner = container.querySelector('.selectedFilters');
  var cardsResult = container.querySelector('.CardLayoutFilters-results-cards');

  if (container && container.classList.contains('CardLayoutFilters--resources')) {
    if (cardsResult.classList.contains('repeat-None')) {
      cardsResult.classList.add('repeat-4');
      cardsResult.setAttribute('data-repeat', 4);
    }
  }

  var repeat = Number(cardsResult.getAttribute('data-repeat'));
  var show = Number(cardsResult.getAttribute('data-show'));
  var more = Number(cardsResult.getAttribute('data-more'));
  var number = Number(cardsResult.getAttribute('data-number'));
  var count = Number(cardsResult.getAttribute('data-count'));
  var showMore = 0;
  var cards = container.querySelectorAll('.CardLayoutFilters-card');
  var r_cards = container.querySelectorAll('.regular-card');
  var f_cards = container.querySelectorAll('.feature-card');
  var c_length = cards.length;
  var f_length = f_cards.length;
  var r_length = r_cards.length;
  var group = repeat != 0 ? parseInt(r_length / repeat) : 0;
  var left = repeat != 0 ? r_length % repeat : 0;
  var loadButton = container.querySelector('.CardLayoutFilters--buttongroup');
  var pannelOpenToggle = main.querySelector('.filters-button');
  var pannelCloseToggle = pannel.querySelector('.filters-button');
  var mobileCollapse = false;
  utilities_CustomUtil.initCheckScreen();
  pannelOpenToggle.addEventListener('click', function (e) {
    e.preventDefault();
    container.classList.add('opened');

    if (!mobileCollapse) {
      components_MFCollapse('.CardLayoutFilters-accordion');
      mobileCollapse = true;
    }

    updateState();
  });
  pannelCloseToggle.addEventListener('click', function (e) {
    e.preventDefault();
    container.classList.remove('opened');
    mobileCollapse = false;
    updateState();
  });
  /*var checkboxes = filters.querySelectorAll('.Form-checkbox');
  checkboxes.forEach((checkbox)=>{
      var input = checkbox.querySelector('input');
      input.addEventListener('click',()=>{
          var checked = input.checked;
          if(checked){
              input.setAttribute('checked','checked');
          }else {
              input.removeAttribute('checked');
          }
      })
  });
  var selectedFilters = selectedFiltersBanner.querySelectorAll('li');
  selectedFilters.forEach((selectedFilter)=>{
      var id = selectedFilter.getAttribute('data-id');
      var checkbox = document.getElementById(id);
      var btn = selectedFilter.querySelector('.filter-remove');
      btn.addEventListener('click',()=>{
          var input = checkbox.querySelector('input');
          input.removeAttribute('checked');
      })
  });*/

  updateRepeatClass();
  resetMobilePanel();
  resetElements();
  showCards();
  resetOrder();
  updateState();

  function resetElements() {
    number = Number(cardsResult.getAttribute('data-number'));
    count = Number(cardsResult.getAttribute('data-count'));
    cards = container.querySelectorAll('.CardLayoutFilters-card');
    c_length = cards.length;

    if (container.classList.contains('CardLayoutFilters--resources')) {
      r_cards = container.querySelectorAll('.regular-card');
      f_cards = container.querySelectorAll('.feature-card');
      f_length = f_cards.length;
      r_length = r_cards.length;
      group = repeat != 0 ? parseInt(r_length / repeat) : 0;
      left = repeat != 0 ? r_length % repeat : 0;
    }
  }

  function resetOrder() {
    cards.forEach(function (card, index) {
      card.style.order = index;
    });

    if (f_cards && f_cards.length > 0) {
      f_cards[f_cards.length - 1].classList.add('last');
    }
  } //To make panel closed by defautl on mobile


  function resetMobilePanel() {
    if (utilities_CustomUtil.screenIs == 'isMobile') {
      container.classList.remove('opened');
    } else {
      mobileCollapse = true;
    }
  }

  function updateState() {
    var isOpened = container.classList.contains('opened') ? true : false;
    utilities_CustomUtil.initCheckScreen();

    if (repeat == 4) {
      if (r_cards && r_cards.length % repeat == 3) {
        var r_card = r_cards[r_cards.length - 1];
        var r_card_order = r_card.style.order;
        var next_f_card = r_card.nextElementSibling;

        if (next_f_card) {
          next_f_card.classList.add('order');
          var next_f_card_order = next_f_card.style.order;
          r_card.style.order = next_f_card_order;
          next_f_card.style.order = r_card_order;
        }
      }
    }

    if (repeat == 8) {
      if (isOpened && utilities_CustomUtil.screenIs == 'isLaptop') {
        resetOrderTo7();
      } else {
        resetOrder();
      }
    }

    resetPadding();
  }

  function resetOrderSingle(r, n) {
    var r_order = Number(r.style.order);
    r.style.order = r_order + 1;
    var f_order = Number(n.style.order);
    n.style.order = f_order - 1;
  }

  function resetOrderTo7() {
    var new_repeat = 7;

    if (r_length < repeat) {
      var last_card = r_cards[r_cards.length - 1].nextElementSibling;

      if (last_card) {
        var isFeature = last_card.classList.contains('feature-card') ? true : false;

        if (isFeature) {
          if (r_length == 3 || r_length == 6 || r_length == 8) {
            resetOrderSingle(r_cards[r_cards.length - 1], last_card);
          }
        }
      }
    } else {
      for (var i = 1; i <= group; i++) {
        var next_card = r_cards[repeat * i - 1].nextElementSibling;
        var isFeature = false;

        if (next_card) {
          isFeature = next_card.classList.contains('feature-card') ? true : false;

          if (isFeature) {
            var r_order_card_array = [];

            for (var j = 0; j < i; j++) {
              r_order_card_array.push(r_cards[repeat * i - 1 - j]);
            }

            r_order_card_array.forEach(function (r_order_card, index) {
              var r_order = Number(r_order_card.style.order);
              r_order_card.style.order = r_order + 1;
            });
            var f_order = Number(next_card.style.order);
            next_card.style.order = f_order - i;
          }
        }
      }

      var new_group = parseInt(r_length / new_repeat);
      var new_left = r_length - group * new_repeat;
      var last_r_card = r_cards[r_cards.length - 1];
      var next_card = last_r_card.nextElementSibling;

      if (next_card) {
        var isFeature = next_card.classList.contains('feature-card') ? true : false;

        if (isFeature) {
          if (new_left > new_repeat) {
            var r_order_card_array = [];
            var start_gap = new_repeat;
            var order_gap = new_repeat;

            if (new_left - new_repeat < 7) {
              order_gap = new_left - new_repeat;
              start_gap = 1;
            }

            var r_order_index = group * new_repeat - 1 + start_gap;

            for (var k = r_order_index; k < r_length; k++) {
              r_order_card_array.push(r_cards[k]);
            }

            r_order_card_array.forEach(function (r_order_card, index) {
              var r_order = Number(r_order_card.style.order);
              r_order_card.style.order = r_order + 1;
            });
            var f_order = Number(next_card.style.order);
            next_card.style.order = f_order - order_gap;
          } else {
            if (new_left == 3 || new_left == 6) {
              resetOrderSingle(r_cards[r_cards.length - 1], next_card);
            }
          }
        }
      }
    }
  }

  function showCards() {
    var showNumber = show + more * showMore;

    for (var i = 0; i < showNumber; i++) {
      if (cards[i]) {
        cards[i].style.display = 'flex';
      }
    }

    for (var i = showNumber; i < count; i++) {
      if (cards[i]) {
        cards[i].style.display = 'none';
      }
    }
  }

  function addSelectedFilter(checkbox) {
    var li = document.createElement('li');
    var html = '';
    var id = checkbox.id;
    li.setAttribute('data-id', id);
    var value = checkbox.querySelector('span > span').innerHTML;
    html += '<span>' + value + '</span>';
    html += '<span class="filter-remove"></span>';
    li.innerHTML = html;
    selectedFiltersBanner.appendChild(li);
    var btn = li.querySelector('.filter-remove');
    btn.addEventListener('click', function () {
      var input = checkbox.querySelector('input');
      input.click();
    });
  }

  function removeSelectedFilter(checkbox) {
    var id = checkbox.id;
    var selectedFilter = selectedFiltersBanner.querySelector("li[data-id='" + id + "']");
    selectedFilter.outerHTML = '';
  }

  function updateRepeatClass() {
    if (container && container.classList.contains('CardLayoutFilters--resources')) {
      f_cards = container.querySelectorAll('.feature-card');

      if (f_cards.length == 0) {
        cardsResult.classList.add('repeat-None');
      } else {
        cardsResult.classList.remove('repeat-None');
      }
    }
  }

  function updateCardResults(record) {
    var checkbox = record.target.parentElement;

    if (record.target.checked) {
      addSelectedFilter(checkbox);
    } else {
      removeSelectedFilter(checkbox);
    }

    if (record.target && record.target.parentElement) {
      var recordID = record.target.parentElement.id;
      updateCardData(recordID);
    }
  }

  function updateCardData(recordID) {
    if (typeof cardLayoutFilters != "undefined") {
      cardLayoutFilters.updateCards(recordID);
    }
  }

  function checkUndefined(e) {
    if (e == null || e == undefined || e == '' || e.length == 0) {
      return '';
    } else {
      return e;
    }
  }

  function NotUndefined(e) {
    if (e == null || e == undefined || e == '' || e.length == 0) {
      return false;
    } else {
      return true;
    }
  }

  function resetPadding() {
    cards = container.querySelectorAll('.CardLayoutFilters-card');
    r_cards = container.querySelectorAll('.regular-card'); //var f_cards_length = container.querySelectorAll('.feature-card:not(.hidden)').length;

    var f_cards_length = container.querySelectorAll('.feature-card').length;
    var last_f_card = container.querySelector('.feature-card.last');

    if (!cardsResult.classList.contains('repeat-None')) {
      if (repeat == 4) {
        if (utilities_CustomUtil.screenIs == 'isLaptop') {
          if (f_cards_length % 2 != 0) {
            var i = (f_cards_length - 1) * repeat + f_cards_length + 2 - 1;
            var g = parseInt(Math.ceil((cards.length - (i + 1)) / 4));

            for (var k = 0; k <= g; k++) {
              i = (f_cards_length - 1) * repeat + f_cards_length + 2 + 4 * k - 1;

              if (cards[i]) {
                cards[i].style.marginRight = 0;
              }
            }
          } else {
            var i = f_cards_length * repeat + f_cards_length - 1;
            var g = parseInt(Math.ceil((cards.length - (i + 1)) / 4));

            for (var k = 0; k <= g; k++) {
              i = f_cards_length * repeat + f_cards_length + 4 * k - 1;

              if (cards[i]) {
                cards[i].style.marginRight = 0;
              }
            }
          }
        } else {
          if (utilities_CustomUtil.screenIs == 'isTablet') {
            var i = (f_cards_length - 1) * repeat + f_cards_length - 1;
            var g = parseInt(Math.ceil((cards.length - (i + 1)) / 2));

            for (var k = 0; k <= g; k++) {
              i = (f_cards_length - 1) * repeat + f_cards_length + 2 + 2 * k - 1;

              if (cards[i]) {
                cards[i].style.marginRight = 0;
              }
            }
          }
        }
      }

      if (repeat == 8) {
        if (utilities_CustomUtil.screenIs == 'isLaptop') {
          if (f_cards_length % 2 != 0) {
            var ii = (f_cards_length - 1) * repeat + f_cards_length + 2 - 1;
            var gg = parseInt(Math.ceil((cards.length - (ii + 1)) / 4));

            for (var w = 0; w <= gg; w++) {
              ii = (f_cards_length - 1) * repeat + f_cards_length + 2 + 4 * w - 1;

              if (cards[ii]) {
                cards[ii].style.marginRight = 0;
              }
            }
          } else {
            var ii = (f_cards_length - 1) * repeat + f_cards_length + 2 - 1;
            var gg = parseInt(Math.ceil((cards.length - (ii + 1)) / 4));

            for (var w = 0; w <= gg; w++) {
              ii = (f_cards_length - 1) * repeat + f_cards_length + 4 + 4 * w - 1;

              if (cards[ii]) {
                cards[ii].style.marginRight = 0;
              }
            }
          }
        } else {
          if (utilities_CustomUtil.screenIs == 'isTablet') {
            var ii = (f_cards_length - 1) * repeat + f_cards_length - 1;
            var gg = parseInt(Math.ceil((cards.length - (ii + 1)) / 2));

            for (var w = 0; w <= gg; w++) {
              ii = (f_cards_length - 1) * repeat + f_cards_length + 2 + 2 * w - 1;

              if (cards[ii]) {
                cards[ii].style.marginRight = 0;
              }
            }
          }
        }
      }
    }
  }

  var observer_data; //watch data

  var watchData = function watchData() {
    observer_data = new MutationObserver(function (mutationRecords) {
      //console.log(mutationRecords);
      updateRepeatClass();
      resetElements();
      showCards();
      resetOrder();
      updateState();
    });
    var nodes = container.querySelectorAll('.CardLayoutFilters-results-cards');
    var config = {
      childList: true,
      characterData: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['data-number']
    };
    nodes.forEach(function (node) {
      observer_data.observe(node, config);
    });
  };
  /*let observer_filter; //watch filters
  const watchFilter = () => {
      observer_filter = new MutationObserver((mutationRecords) => {
      //console.log(mutationRecords);
      updateCardResults(mutationRecords[0]);
    });
    var nodes = filters.querySelectorAll('.Form-checkbox > input');
    let config = {
      attributes: true,
      attributeFilter: ['checked'],
    };
    nodes.forEach((node)=>{
      observer_filter.observe(node, config);
    });
  };*/


  watchData(); //watchFilter();

  if (utilities_CustomUtil.screenIs != 'isMobile') {
    components_MFCollapse('.CardLayoutFilters-accordion');
  }

  var loadMore = loadButton.querySelector('.CardLayoutFilters-loadMore');

  if (loadMore) {
    loadMore.addEventListener('click', function (e) {
      e.preventDefault();
      var showNumber = show + more * showMore;

      if (showNumber < count) {
        showMore++;
        showNumber = show + more * showMore;
        cardsResult.setAttribute('data-number', showNumber);

        if (utilities_CustomUtil.isLocalhost()) {
          /** Test: This is for test when data updated, will auto update order to fit layout*/
          var test = document.getElementById('test');
          cardsResult = container.querySelector('.CardLayoutFilters-results-cards'); //cardsResult.innerHTML = cardsResult.innerHTML + test.innerHTML;
        } else {
          updateCardData();
          resetPadding();
        }
      } else {
        loadButton.classList.add('hiden');
      }
    });
  }

  window.addEventListener("resize", function () {
    updateState();
  });
}

;
CardLayoutFilters.defaultSelector = '.CardLayoutFilters';

CardLayoutFilters.initAll = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$selector = _ref.selector,
      selector = _ref$selector === void 0 ? CardLayoutFilters.defaultSelector : _ref$selector;

  return CardLayoutFilters_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return CardLayoutFilters({
      el: el
    });
  });
};

/* harmony default export */ var modules_CardLayoutFilters = (CardLayoutFilters);
;// CONCATENATED MODULE: ./node_modules/jarallax/dist/jarallax.esm.js
/*!
 * Jarallax v2.0.4 (https://github.com/nk-o/jarallax)
 * Copyright 2022 nK <https://nkdev.info>
 * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)
 */
function ready(callback) {
  if ('complete' === document.readyState || 'interactive' === document.readyState) {
    // Already ready or interactive, execute callback
    callback();
  } else {
    document.addEventListener('DOMContentLoaded', callback, {
      capture: true,
      once: true,
      passive: true
    });
  }
}

/* eslint-disable import/no-mutable-exports */

/* eslint-disable no-restricted-globals */
let win$1;

if ('undefined' !== typeof window) {
  win$1 = window;
} else if ('undefined' !== typeof __webpack_require__.g) {
  win$1 = __webpack_require__.g;
} else if ('undefined' !== typeof self) {
  win$1 = self;
} else {
  win$1 = {};
}

var global$2 = win$1;

const {
  navigator: jarallax_esm_navigator
} = global$2;
const isMobile = /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(jarallax_esm_navigator.userAgent);
let $deviceHelper;
/**
 * The most popular mobile browsers changes height after page scroll and this generates image jumping.
 * We can fix it using this workaround with vh units.
 */

function getDeviceHeight() {
  if (!$deviceHelper && document.body) {
    $deviceHelper = document.createElement('div');
    $deviceHelper.style.cssText = 'position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;';
    document.body.appendChild($deviceHelper);
  }

  return ($deviceHelper ? $deviceHelper.clientHeight : 0) || global$2.innerHeight || document.documentElement.clientHeight;
} // Window height data


let wndH;

function updateWndVars() {
  if (isMobile) {
    wndH = getDeviceHeight();
  } else {
    wndH = global$2.innerHeight || document.documentElement.clientHeight;
  }
}

updateWndVars();
global$2.addEventListener('resize', updateWndVars);
global$2.addEventListener('orientationchange', updateWndVars);
global$2.addEventListener('load', updateWndVars);
ready(() => {
  updateWndVars();
}); // list with all jarallax instances
// need to render all in one scroll/resize event

const jarallaxList = []; // get all parents of the element.

function getParents(elem) {
  const parents = [];

  while (null !== elem.parentElement) {
    elem = elem.parentElement;

    if (1 === elem.nodeType) {
      parents.push(elem);
    }
  }

  return parents;
}

function updateParallax() {
  if (!jarallaxList.length) {
    return;
  }

  jarallaxList.forEach((data, k) => {
    const {
      instance,
      oldData
    } = data;
    const clientRect = instance.$item.getBoundingClientRect();
    const newData = {
      width: clientRect.width,
      height: clientRect.height,
      top: clientRect.top,
      bottom: clientRect.bottom,
      wndW: global$2.innerWidth,
      wndH
    };
    const isResized = !oldData || oldData.wndW !== newData.wndW || oldData.wndH !== newData.wndH || oldData.width !== newData.width || oldData.height !== newData.height;
    const isScrolled = isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;
    jarallaxList[k].oldData = newData;

    if (isResized) {
      instance.onResize();
    }

    if (isScrolled) {
      instance.onScroll();
    }
  });
  global$2.requestAnimationFrame(updateParallax);
}

let instanceID = 0; // Jarallax class

class Jarallax {
  constructor(item, userOptions) {
    const self = this;
    self.instanceID = instanceID;
    instanceID += 1;
    self.$item = item;
    self.defaults = {
      type: 'scroll',
      // type of parallax: scroll, scale, opacity, scale-opacity, scroll-opacity
      speed: 0.5,
      // supported value from -1 to 2
      imgSrc: null,
      imgElement: '.jarallax-img',
      imgSize: 'cover',
      imgPosition: '50% 50%',
      imgRepeat: 'no-repeat',
      // supported only for background, not for <img> tag
      keepImg: false,
      // keep <img> tag in it's default place
      elementInViewport: null,
      zIndex: -100,
      disableParallax: false,
      disableVideo: false,
      // video
      videoSrc: null,
      videoStartTime: 0,
      videoEndTime: 0,
      videoVolume: 0,
      videoLoop: true,
      videoPlayOnlyVisible: true,
      videoLazyLoading: true,
      // events
      onScroll: null,
      // function(calculations) {}
      onInit: null,
      // function() {}
      onDestroy: null,
      // function() {}
      onCoverImage: null // function() {}

    }; // prepare data-options

    const dataOptions = self.$item.dataset || {};
    const pureDataOptions = {};
    Object.keys(dataOptions).forEach(key => {
      const loweCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);

      if (loweCaseOption && 'undefined' !== typeof self.defaults[loweCaseOption]) {
        pureDataOptions[loweCaseOption] = dataOptions[key];
      }
    });
    self.options = self.extend({}, self.defaults, pureDataOptions, userOptions);
    self.pureOptions = self.extend({}, self.options); // prepare 'true' and 'false' strings to boolean

    Object.keys(self.options).forEach(key => {
      if ('true' === self.options[key]) {
        self.options[key] = true;
      } else if ('false' === self.options[key]) {
        self.options[key] = false;
      }
    }); // fix speed option [-1.0, 2.0]

    self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed))); // prepare disableParallax callback

    if ('string' === typeof self.options.disableParallax) {
      self.options.disableParallax = new RegExp(self.options.disableParallax);
    }

    if (self.options.disableParallax instanceof RegExp) {
      const disableParallaxRegexp = self.options.disableParallax;

      self.options.disableParallax = () => disableParallaxRegexp.test(jarallax_esm_navigator.userAgent);
    }

    if ('function' !== typeof self.options.disableParallax) {
      self.options.disableParallax = () => false;
    } // prepare disableVideo callback


    if ('string' === typeof self.options.disableVideo) {
      self.options.disableVideo = new RegExp(self.options.disableVideo);
    }

    if (self.options.disableVideo instanceof RegExp) {
      const disableVideoRegexp = self.options.disableVideo;

      self.options.disableVideo = () => disableVideoRegexp.test(jarallax_esm_navigator.userAgent);
    }

    if ('function' !== typeof self.options.disableVideo) {
      self.options.disableVideo = () => false;
    } // custom element to check if parallax in viewport


    let elementInVP = self.options.elementInViewport; // get first item from array

    if (elementInVP && 'object' === typeof elementInVP && 'undefined' !== typeof elementInVP.length) {
      [elementInVP] = elementInVP;
    } // check if dom element


    if (!(elementInVP instanceof Element)) {
      elementInVP = null;
    }

    self.options.elementInViewport = elementInVP;
    self.image = {
      src: self.options.imgSrc || null,
      $container: null,
      useImgTag: false,
      // 1. Position fixed is needed for the most of browsers because absolute position have glitches
      // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75
      // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'
      position: 'fixed'
    };

    if (self.initImg() && self.canInitParallax()) {
      self.init();
    }
  } // add styles to element
  // eslint-disable-next-line class-methods-use-this


  css(el, styles) {
    if ('string' === typeof styles) {
      return global$2.getComputedStyle(el).getPropertyValue(styles);
    }

    Object.keys(styles).forEach(key => {
      el.style[key] = styles[key];
    });
    return el;
  } // Extend like jQuery.extend
  // eslint-disable-next-line class-methods-use-this


  extend(out, ...args) {
    out = out || {};
    Object.keys(args).forEach(i => {
      if (!args[i]) {
        return;
      }

      Object.keys(args[i]).forEach(key => {
        out[key] = args[i][key];
      });
    });
    return out;
  } // get window size and scroll position. Useful for extensions
  // eslint-disable-next-line class-methods-use-this


  getWindowData() {
    return {
      width: global$2.innerWidth || document.documentElement.clientWidth,
      height: wndH,
      y: document.documentElement.scrollTop
    };
  } // Jarallax functions


  initImg() {
    const self = this; // find image element

    let $imgElement = self.options.imgElement;

    if ($imgElement && 'string' === typeof $imgElement) {
      $imgElement = self.$item.querySelector($imgElement);
    } // check if dom element


    if (!($imgElement instanceof Element)) {
      if (self.options.imgSrc) {
        $imgElement = new Image();
        $imgElement.src = self.options.imgSrc;
      } else {
        $imgElement = null;
      }
    }

    if ($imgElement) {
      if (self.options.keepImg) {
        self.image.$item = $imgElement.cloneNode(true);
      } else {
        self.image.$item = $imgElement;
        self.image.$itemParent = $imgElement.parentNode;
      }

      self.image.useImgTag = true;
    } // true if there is img tag


    if (self.image.$item) {
      return true;
    } // get image src


    if (null === self.image.src) {
      self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
      self.image.bgImage = self.css(self.$item, 'background-image');
    }

    return !(!self.image.bgImage || 'none' === self.image.bgImage);
  }

  canInitParallax() {
    return !this.options.disableParallax();
  }

  init() {
    const self = this;
    const containerStyles = {
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      overflow: 'hidden'
    };
    let imageStyles = {
      pointerEvents: 'none',
      transformStyle: 'preserve-3d',
      backfaceVisibility: 'hidden'
    };

    if (!self.options.keepImg) {
      // save default user styles
      const curStyle = self.$item.getAttribute('style');

      if (curStyle) {
        self.$item.setAttribute('data-jarallax-original-styles', curStyle);
      }

      if (self.image.useImgTag) {
        const curImgStyle = self.image.$item.getAttribute('style');

        if (curImgStyle) {
          self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);
        }
      }
    } // set relative position and z-index to the parent


    if ('static' === self.css(self.$item, 'position')) {
      self.css(self.$item, {
        position: 'relative'
      });
    }

    if ('auto' === self.css(self.$item, 'z-index')) {
      self.css(self.$item, {
        zIndex: 0
      });
    } // container for parallax image


    self.image.$container = document.createElement('div');
    self.css(self.image.$container, containerStyles);
    self.css(self.image.$container, {
      'z-index': self.options.zIndex
    }); // it will remove some image overlapping
    // overlapping occur due to an image position fixed inside absolute position element
    // needed only when background in fixed position

    if ('fixed' === this.image.position) {
      self.css(self.image.$container, {
        '-webkit-clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',
        'clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)'
      });
    }

    self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);
    self.$item.appendChild(self.image.$container); // use img tag

    if (self.image.useImgTag) {
      imageStyles = self.extend({
        'object-fit': self.options.imgSize,
        'object-position': self.options.imgPosition,
        'max-width': 'none'
      }, containerStyles, imageStyles); // use div with background image
    } else {
      self.image.$item = document.createElement('div');

      if (self.image.src) {
        imageStyles = self.extend({
          'background-position': self.options.imgPosition,
          'background-size': self.options.imgSize,
          'background-repeat': self.options.imgRepeat,
          'background-image': self.image.bgImage || `url("${self.image.src}")`
        }, containerStyles, imageStyles);
      }
    }

    if ('opacity' === self.options.type || 'scale' === self.options.type || 'scale-opacity' === self.options.type || 1 === self.options.speed) {
      self.image.position = 'absolute';
    } // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)
    //    discussion - https://github.com/nk-o/jarallax/issues/9
    // 2. Check if parents have overflow scroll


    if ('fixed' === self.image.position) {
      const $parents = getParents(self.$item).filter(el => {
        const styles = global$2.getComputedStyle(el);
        const parentTransform = styles['-webkit-transform'] || styles['-moz-transform'] || styles.transform;
        const overflowRegex = /(auto|scroll)/;
        return parentTransform && 'none' !== parentTransform || overflowRegex.test(styles.overflow + styles['overflow-y'] + styles['overflow-x']);
      });
      self.image.position = $parents.length ? 'absolute' : 'fixed';
    } // add position to parallax block


    imageStyles.position = self.image.position; // insert parallax image

    self.css(self.image.$item, imageStyles);
    self.image.$container.appendChild(self.image.$item); // set initial position and size

    self.onResize();
    self.onScroll(true); // call onInit event

    if (self.options.onInit) {
      self.options.onInit.call(self);
    } // remove default user background


    if ('none' !== self.css(self.$item, 'background-image')) {
      self.css(self.$item, {
        'background-image': 'none'
      });
    }

    self.addToParallaxList();
  } // add to parallax instances list


  addToParallaxList() {
    jarallaxList.push({
      instance: this
    });

    if (1 === jarallaxList.length) {
      global$2.requestAnimationFrame(updateParallax);
    }
  } // remove from parallax instances list


  removeFromParallaxList() {
    const self = this;
    jarallaxList.forEach((data, key) => {
      if (data.instance.instanceID === self.instanceID) {
        jarallaxList.splice(key, 1);
      }
    });
  }

  destroy() {
    const self = this;
    self.removeFromParallaxList(); // return styles on container as before jarallax init

    const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');
    self.$item.removeAttribute('data-jarallax-original-styles'); // null occurs if there is no style tag before jarallax init

    if (!originalStylesTag) {
      self.$item.removeAttribute('style');
    } else {
      self.$item.setAttribute('style', originalStylesTag);
    }

    if (self.image.useImgTag) {
      // return styles on img tag as before jarallax init
      const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');
      self.image.$item.removeAttribute('data-jarallax-original-styles'); // null occurs if there is no style tag before jarallax init

      if (!originalStylesImgTag) {
        self.image.$item.removeAttribute('style');
      } else {
        self.image.$item.setAttribute('style', originalStylesTag);
      } // move img tag to its default position


      if (self.image.$itemParent) {
        self.image.$itemParent.appendChild(self.image.$item);
      }
    } // remove additional dom elements


    if (self.image.$container) {
      self.image.$container.parentNode.removeChild(self.image.$container);
    } // call onDestroy event


    if (self.options.onDestroy) {
      self.options.onDestroy.call(self);
    } // delete jarallax from item


    delete self.$item.jarallax;
  } // Fallback for removed function.
  // Does nothing now.
  // eslint-disable-next-line class-methods-use-this


  clipContainer() {}

  coverImage() {
    const self = this;
    const rect = self.image.$container.getBoundingClientRect();
    const contH = rect.height;
    const {
      speed
    } = self.options;
    const isScroll = 'scroll' === self.options.type || 'scroll-opacity' === self.options.type;
    let scrollDist = 0;
    let resultH = contH;
    let resultMT = 0; // scroll parallax

    if (isScroll) {
      // scroll distance and height for image
      if (0 > speed) {
        scrollDist = speed * Math.max(contH, wndH);

        if (wndH < contH) {
          scrollDist -= speed * (contH - wndH);
        }
      } else {
        scrollDist = speed * (contH + wndH);
      } // size for scroll parallax


      if (1 < speed) {
        resultH = Math.abs(scrollDist - wndH);
      } else if (0 > speed) {
        resultH = scrollDist / speed + Math.abs(scrollDist);
      } else {
        resultH += (wndH - contH) * (1 - speed);
      }

      scrollDist /= 2;
    } // store scroll distance


    self.parallaxScrollDistance = scrollDist; // vertical center

    if (isScroll) {
      resultMT = (wndH - resultH) / 2;
    } else {
      resultMT = (contH - resultH) / 2;
    } // apply result to item


    self.css(self.image.$item, {
      height: `${resultH}px`,
      marginTop: `${resultMT}px`,
      left: 'fixed' === self.image.position ? `${rect.left}px` : '0',
      width: `${rect.width}px`
    }); // call onCoverImage event

    if (self.options.onCoverImage) {
      self.options.onCoverImage.call(self);
    } // return some useful data. Used in the video cover function


    return {
      image: {
        height: resultH,
        marginTop: resultMT
      },
      container: rect
    };
  }

  isVisible() {
    return this.isElementInViewport || false;
  }

  onScroll(force) {
    const self = this;
    const rect = self.$item.getBoundingClientRect();
    const contT = rect.top;
    const contH = rect.height;
    const styles = {}; // check if in viewport

    let viewportRect = rect;

    if (self.options.elementInViewport) {
      viewportRect = self.options.elementInViewport.getBoundingClientRect();
    }

    self.isElementInViewport = 0 <= viewportRect.bottom && 0 <= viewportRect.right && viewportRect.top <= wndH && viewportRect.left <= global$2.innerWidth; // stop calculations if item is not in viewport

    if (force ? false : !self.isElementInViewport) {
      return;
    } // calculate parallax helping variables


    const beforeTop = Math.max(0, contT);
    const beforeTopEnd = Math.max(0, contH + contT);
    const afterTop = Math.max(0, -contT);
    const beforeBottom = Math.max(0, contT + contH - wndH);
    const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));
    const afterBottom = Math.max(0, -contT + wndH - contH);
    const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH)); // calculate on how percent of section is visible

    let visiblePercent = 1;

    if (contH < wndH) {
      visiblePercent = 1 - (afterTop || beforeBottom) / contH;
    } else if (beforeTopEnd <= wndH) {
      visiblePercent = beforeTopEnd / wndH;
    } else if (beforeBottomEnd <= wndH) {
      visiblePercent = beforeBottomEnd / wndH;
    } // opacity


    if ('opacity' === self.options.type || 'scale-opacity' === self.options.type || 'scroll-opacity' === self.options.type) {
      styles.transform = 'translate3d(0,0,0)';
      styles.opacity = visiblePercent;
    } // scale


    if ('scale' === self.options.type || 'scale-opacity' === self.options.type) {
      let scale = 1;

      if (0 > self.options.speed) {
        scale -= self.options.speed * visiblePercent;
      } else {
        scale += self.options.speed * (1 - visiblePercent);
      }

      styles.transform = `scale(${scale}) translate3d(0,0,0)`;
    } // scroll


    if ('scroll' === self.options.type || 'scroll-opacity' === self.options.type) {
      let positionY = self.parallaxScrollDistance * fromViewportCenter; // fix if parallax block in absolute position

      if ('absolute' === self.image.position) {
        positionY -= contT;
      }

      styles.transform = `translate3d(0,${positionY}px,0)`;
    }

    self.css(self.image.$item, styles); // call onScroll event

    if (self.options.onScroll) {
      self.options.onScroll.call(self, {
        section: rect,
        beforeTop,
        beforeTopEnd,
        afterTop,
        beforeBottom,
        beforeBottomEnd,
        afterBottom,
        visiblePercent,
        fromViewportCenter
      });
    }
  }

  onResize() {
    this.coverImage();
  }

} // global definition


const jarallax$1 = function (items, options, ...args) {
  // check for dom element
  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
  if ('object' === typeof HTMLElement ? items instanceof HTMLElement : items && 'object' === typeof items && null !== items && 1 === items.nodeType && 'string' === typeof items.nodeName) {
    items = [items];
  }

  const len = items.length;
  let k = 0;
  let ret;

  for (k; k < len; k += 1) {
    if ('object' === typeof options || 'undefined' === typeof options) {
      if (!items[k].jarallax) {
        items[k].jarallax = new Jarallax(items[k], options);
      }
    } else if (items[k].jarallax) {
      // eslint-disable-next-line prefer-spread
      ret = items[k].jarallax[options].apply(items[k].jarallax, args);
    }

    if ('undefined' !== typeof ret) {
      return ret;
    }
  }

  return items;
};

jarallax$1.constructor = Jarallax;

/*!
 * Name    : Video Worker
 * Version : 2.0.0
 * Author  : nK <https://nkdev.info>
 * GitHub  : https://github.com/nk-o/video-worker
 */

/* eslint-disable import/no-mutable-exports */

/* eslint-disable no-restricted-globals */
let win;

if (typeof window !== 'undefined') {
  win = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  win = __webpack_require__.g;
} else if (typeof self !== 'undefined') {
  win = self;
} else {
  win = {};
}

var global$1 = win; // Deferred
// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery

function Deferred() {
  this.doneCallbacks = [];
  this.failCallbacks = [];
}

Deferred.prototype = {
  execute(list, args) {
    let i = list.length; // eslint-disable-next-line no-param-reassign

    args = Array.prototype.slice.call(args);

    while (i) {
      i -= 1;
      list[i].apply(null, args);
    }
  },

  resolve(...args) {
    this.execute(this.doneCallbacks, args);
  },

  reject(...args) {
    this.execute(this.failCallbacks, args);
  },

  done(callback) {
    this.doneCallbacks.push(callback);
  },

  fail(callback) {
    this.failCallbacks.push(callback);
  }

};
let ID = 0;
let YoutubeAPIadded = 0;
let VimeoAPIadded = 0;
let loadingYoutubePlayer = 0;
let loadingVimeoPlayer = 0;
const loadingYoutubeDefer = /*#__PURE__*/new Deferred();
const loadingVimeoDefer = /*#__PURE__*/new Deferred();

class VideoWorker {
  constructor(url, options) {
    const self = this;
    self.url = url;
    self.options_default = {
      autoplay: false,
      loop: false,
      mute: false,
      volume: 100,
      showControls: true,
      accessibilityHidden: false,
      // start / end video time in seconds
      startTime: 0,
      endTime: 0
    };
    self.options = self.extend({}, self.options_default, options); // Fix wrong option name.
    // Thanks to https://github.com/nk-o/video-worker/issues/13.

    if (typeof self.options.showContols !== 'undefined') {
      self.options.showControls = self.options.showContols;
      delete self.options.showContols;
    } // check URL


    self.videoID = self.parseURL(url); // init

    if (self.videoID) {
      self.ID = ID;
      ID += 1;
      self.loadAPI();
      self.init();
    }
  } // Extend like jQuery.extend
  // eslint-disable-next-line class-methods-use-this


  extend(...args) {
    const out = args[0] || {};
    Object.keys(args).forEach(i => {
      if (!args[i]) {
        return;
      }

      Object.keys(args[i]).forEach(key => {
        out[key] = args[i][key];
      });
    });
    return out;
  }

  parseURL(url) {
    // parse youtube ID
    function getYoutubeID(ytUrl) {
      // eslint-disable-next-line no-useless-escape
      const regExp = /.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#\&\?]*).*/;
      const match = ytUrl.match(regExp);
      return match && match[1].length === 11 ? match[1] : false;
    } // parse vimeo ID


    function getVimeoID(vmUrl) {
      // eslint-disable-next-line no-useless-escape
      const regExp = /https?:\/\/(?:www\.|player\.)?vimeo.com\/(?:channels\/(?:\w+\/)?|groups\/([^/]*)\/videos\/|album\/(\d+)\/video\/|video\/|)(\d+)(?:$|\/|\?)/;
      const match = vmUrl.match(regExp);
      return match && match[3] ? match[3] : false;
    } // parse local string


    function getLocalVideos(locUrl) {
      // eslint-disable-next-line no-useless-escape
      const videoFormats = locUrl.split(/,(?=mp4\:|webm\:|ogv\:|ogg\:)/);
      const result = {};
      let ready = 0;
      videoFormats.forEach(val => {
        // eslint-disable-next-line no-useless-escape
        const match = val.match(/^(mp4|webm|ogv|ogg)\:(.*)/);

        if (match && match[1] && match[2]) {
          // eslint-disable-next-line prefer-destructuring
          result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];
          ready = 1;
        }
      });
      return ready ? result : false;
    }

    const Youtube = getYoutubeID(url);
    const Vimeo = getVimeoID(url);
    const Local = getLocalVideos(url);

    if (Youtube) {
      this.type = 'youtube';
      return Youtube;
    }

    if (Vimeo) {
      this.type = 'vimeo';
      return Vimeo;
    }

    if (Local) {
      this.type = 'local';
      return Local;
    }

    return false;
  }

  isValid() {
    return !!this.videoID;
  } // events


  on(name, callback) {
    this.userEventsList = this.userEventsList || []; // add new callback in events list

    (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);
  }

  off(name, callback) {
    if (!this.userEventsList || !this.userEventsList[name]) {
      return;
    }

    if (!callback) {
      delete this.userEventsList[name];
    } else {
      this.userEventsList[name].forEach((val, key) => {
        if (val === callback) {
          this.userEventsList[name][key] = false;
        }
      });
    }
  }

  fire(name, ...args) {
    if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {
      this.userEventsList[name].forEach(val => {
        // call with all arguments
        if (val) {
          val.apply(this, args);
        }
      });
    }
  }

  play(start) {
    const self = this;

    if (!self.player) {
      return;
    }

    if (self.type === 'youtube' && self.player.playVideo) {
      if (typeof start !== 'undefined') {
        self.player.seekTo(start || 0);
      }

      if (global$1.YT.PlayerState.PLAYING !== self.player.getPlayerState()) {
        self.player.playVideo();
      }
    }

    if (self.type === 'vimeo') {
      if (typeof start !== 'undefined') {
        self.player.setCurrentTime(start);
      }

      self.player.getPaused().then(paused => {
        if (paused) {
          self.player.play();
        }
      });
    }

    if (self.type === 'local') {
      if (typeof start !== 'undefined') {
        self.player.currentTime = start;
      }

      if (self.player.paused) {
        self.player.play();
      }
    }
  }

  pause() {
    const self = this;

    if (!self.player) {
      return;
    }

    if (self.type === 'youtube' && self.player.pauseVideo) {
      if (global$1.YT.PlayerState.PLAYING === self.player.getPlayerState()) {
        self.player.pauseVideo();
      }
    }

    if (self.type === 'vimeo') {
      self.player.getPaused().then(paused => {
        if (!paused) {
          self.player.pause();
        }
      });
    }

    if (self.type === 'local') {
      if (!self.player.paused) {
        self.player.pause();
      }
    }
  }

  mute() {
    const self = this;

    if (!self.player) {
      return;
    }

    if (self.type === 'youtube' && self.player.mute) {
      self.player.mute();
    }

    if (self.type === 'vimeo' && self.player.setVolume) {
      self.player.setVolume(0);
    }

    if (self.type === 'local') {
      self.$video.muted = true;
    }
  }

  unmute() {
    const self = this;

    if (!self.player) {
      return;
    }

    if (self.type === 'youtube' && self.player.mute) {
      self.player.unMute();
    }

    if (self.type === 'vimeo' && self.player.setVolume) {
      self.player.setVolume(self.options.volume);
    }

    if (self.type === 'local') {
      self.$video.muted = false;
    }
  }

  setVolume(volume = false) {
    const self = this;

    if (!self.player || !volume) {
      return;
    }

    if (self.type === 'youtube' && self.player.setVolume) {
      self.player.setVolume(volume);
    }

    if (self.type === 'vimeo' && self.player.setVolume) {
      self.player.setVolume(volume);
    }

    if (self.type === 'local') {
      self.$video.volume = volume / 100;
    }
  }

  getVolume(callback) {
    const self = this;

    if (!self.player) {
      callback(false);
      return;
    }

    if (self.type === 'youtube' && self.player.getVolume) {
      callback(self.player.getVolume());
    }

    if (self.type === 'vimeo' && self.player.getVolume) {
      self.player.getVolume().then(volume => {
        callback(volume);
      });
    }

    if (self.type === 'local') {
      callback(self.$video.volume * 100);
    }
  }

  getMuted(callback) {
    const self = this;

    if (!self.player) {
      callback(null);
      return;
    }

    if (self.type === 'youtube' && self.player.isMuted) {
      callback(self.player.isMuted());
    }

    if (self.type === 'vimeo' && self.player.getVolume) {
      self.player.getVolume().then(volume => {
        callback(!!volume);
      });
    }

    if (self.type === 'local') {
      callback(self.$video.muted);
    }
  }

  getImageURL(callback) {
    const self = this;

    if (self.videoImage) {
      callback(self.videoImage);
      return;
    }

    if (self.type === 'youtube') {
      const availableSizes = ['maxresdefault', 'sddefault', 'hqdefault', '0'];
      let step = 0;
      const tempImg = new Image();

      tempImg.onload = function () {
        // if no thumbnail, youtube add their own image with width = 120px
        if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {
          // ok
          self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;
          callback(self.videoImage);
        } else {
          // try another size
          step += 1;
          this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;
        }
      };

      tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;
    }

    if (self.type === 'vimeo') {
      let request = new XMLHttpRequest(); // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527

      request.open('GET', `https://vimeo.com/api/oembed.json?url=${self.url}`, true);

      request.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status >= 200 && this.status < 400) {
            // Success!
            const response = JSON.parse(this.responseText);

            if (response.thumbnail_url) {
              self.videoImage = response.thumbnail_url;
              callback(self.videoImage);
            }
          }
        }
      };

      request.send();
      request = null;
    }
  } // fallback to the old version.


  getIframe(callback) {
    this.getVideo(callback);
  }

  getVideo(callback) {
    const self = this; // return generated video block

    if (self.$video) {
      callback(self.$video);
      return;
    } // generate new video block


    self.onAPIready(() => {
      let hiddenDiv;

      if (!self.$video) {
        hiddenDiv = document.createElement('div');
        hiddenDiv.style.display = 'none';
      } // Youtube


      if (self.type === 'youtube') {
        self.playerOptions = {
          // GDPR Compliance.
          host: 'https://www.youtube-nocookie.com',
          videoId: self.videoID,
          playerVars: {
            autohide: 1,
            rel: 0,
            autoplay: 0,
            // autoplay enable on mobile devices
            playsinline: 1
          }
        }; // hide controls

        if (!self.options.showControls) {
          self.playerOptions.playerVars.iv_load_policy = 3;
          self.playerOptions.playerVars.modestbranding = 1;
          self.playerOptions.playerVars.controls = 0;
          self.playerOptions.playerVars.showinfo = 0;
          self.playerOptions.playerVars.disablekb = 1;
        } // events


        let ytStarted;
        let ytProgressInterval;
        self.playerOptions.events = {
          onReady(e) {
            // mute
            if (self.options.mute) {
              e.target.mute();
            } else if (self.options.volume) {
              e.target.setVolume(self.options.volume);
            } // autoplay


            if (self.options.autoplay) {
              self.play(self.options.startTime);
            }

            self.fire('ready', e); // For seamless loops, set the endTime to 0.1 seconds less than the video's duration
            // https://github.com/nk-o/video-worker/issues/2

            if (self.options.loop && !self.options.endTime) {
              const secondsOffset = 0.1;
              self.options.endTime = self.player.getDuration() - secondsOffset;
            } // volumechange


            setInterval(() => {
              self.getVolume(volume => {
                if (self.options.volume !== volume) {
                  self.options.volume = volume;
                  self.fire('volumechange', e);
                }
              });
            }, 150);
          },

          onStateChange(e) {
            // loop
            if (self.options.loop && e.data === global$1.YT.PlayerState.ENDED) {
              self.play(self.options.startTime);
            }

            if (!ytStarted && e.data === global$1.YT.PlayerState.PLAYING) {
              ytStarted = 1;
              self.fire('started', e);
            }

            if (e.data === global$1.YT.PlayerState.PLAYING) {
              self.fire('play', e);
            }

            if (e.data === global$1.YT.PlayerState.PAUSED) {
              self.fire('pause', e);
            }

            if (e.data === global$1.YT.PlayerState.ENDED) {
              self.fire('ended', e);
            } // progress check


            if (e.data === global$1.YT.PlayerState.PLAYING) {
              ytProgressInterval = setInterval(() => {
                self.fire('timeupdate', e); // check for end of video and play again or stop

                if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {
                  if (self.options.loop) {
                    self.play(self.options.startTime);
                  } else {
                    self.pause();
                  }
                }
              }, 150);
            } else {
              clearInterval(ytProgressInterval);
            }
          },

          onError(e) {
            self.fire('error', e);
          }

        };
        const firstInit = !self.$video;

        if (firstInit) {
          const div = document.createElement('div');
          div.setAttribute('id', self.playerID);
          hiddenDiv.appendChild(div);
          document.body.appendChild(hiddenDiv);
        }

        self.player = self.player || new global$1.YT.Player(self.playerID, self.playerOptions);

        if (firstInit) {
          self.$video = document.getElementById(self.playerID); // add accessibility attributes

          if (self.options.accessibilityHidden) {
            self.$video.setAttribute('tabindex', '-1');
            self.$video.setAttribute('aria-hidden', 'true');
          } // get video width and height


          self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;
          self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;
        }
      } // Vimeo


      if (self.type === 'vimeo') {
        self.playerOptions = {
          // GDPR Compliance.
          dnt: 1,
          id: self.videoID,
          autopause: 0,
          transparent: 0,
          autoplay: self.options.autoplay ? 1 : 0,
          loop: self.options.loop ? 1 : 0,
          muted: self.options.mute ? 1 : 0
        };

        if (self.options.volume) {
          self.playerOptions.volume = self.options.volume;
        } // hide controls


        if (!self.options.showControls) {
          self.playerOptions.badge = 0;
          self.playerOptions.byline = 0;
          self.playerOptions.portrait = 0;
          self.playerOptions.title = 0;
          self.playerOptions.background = 1;
        }

        if (!self.$video) {
          let playerOptionsString = '';
          Object.keys(self.playerOptions).forEach(key => {
            if (playerOptionsString !== '') {
              playerOptionsString += '&';
            }

            playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;
          }); // we need to create iframe manually because when we create it using API
          // js events won't triggers after iframe moved to another place

          self.$video = document.createElement('iframe');
          self.$video.setAttribute('id', self.playerID);
          self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);
          self.$video.setAttribute('frameborder', '0');
          self.$video.setAttribute('mozallowfullscreen', '');
          self.$video.setAttribute('allowfullscreen', '');
          self.$video.setAttribute('title', 'Vimeo video player'); // add accessibility attributes

          if (self.options.accessibilityHidden) {
            self.$video.setAttribute('tabindex', '-1');
            self.$video.setAttribute('aria-hidden', 'true');
          }

          hiddenDiv.appendChild(self.$video);
          document.body.appendChild(hiddenDiv);
        }

        self.player = self.player || new global$1.Vimeo.Player(self.$video, self.playerOptions); // set current time for autoplay

        if (self.options.startTime && self.options.autoplay) {
          self.player.setCurrentTime(self.options.startTime);
        } // get video width and height


        self.player.getVideoWidth().then(width => {
          self.videoWidth = width || 1280;
        });
        self.player.getVideoHeight().then(height => {
          self.videoHeight = height || 720;
        }); // events

        let vmStarted;
        self.player.on('timeupdate', e => {
          if (!vmStarted) {
            self.fire('started', e);
            vmStarted = 1;
          }

          self.fire('timeupdate', e); // check for end of video and play again or stop

          if (self.options.endTime) {
            if (self.options.endTime && e.seconds >= self.options.endTime) {
              if (self.options.loop) {
                self.play(self.options.startTime);
              } else {
                self.pause();
              }
            }
          }
        });
        self.player.on('play', e => {
          self.fire('play', e); // check for the start time and start with it

          if (self.options.startTime && e.seconds === 0) {
            self.play(self.options.startTime);
          }
        });
        self.player.on('pause', e => {
          self.fire('pause', e);
        });
        self.player.on('ended', e => {
          self.fire('ended', e);
        });
        self.player.on('loaded', e => {
          self.fire('ready', e);
        });
        self.player.on('volumechange', e => {
          self.fire('volumechange', e);
        });
        self.player.on('error', e => {
          self.fire('error', e);
        });
      } // Local


      function addSourceToLocal(element, src, type) {
        const source = document.createElement('source');
        source.src = src;
        source.type = type;
        element.appendChild(source);
      }

      if (self.type === 'local') {
        if (!self.$video) {
          self.$video = document.createElement('video'); // show controls

          if (self.options.showControls) {
            self.$video.controls = true;
          } // mute


          if (self.options.mute) {
            self.$video.muted = true;
          } else if (self.$video.volume) {
            self.$video.volume = self.options.volume / 100;
          } // loop


          if (self.options.loop) {
            self.$video.loop = true;
          } // autoplay enable on mobile devices


          self.$video.setAttribute('playsinline', '');
          self.$video.setAttribute('webkit-playsinline', ''); // add accessibility attributes

          if (self.options.accessibilityHidden) {
            self.$video.setAttribute('tabindex', '-1');
            self.$video.setAttribute('aria-hidden', 'true');
          }

          self.$video.setAttribute('id', self.playerID);
          hiddenDiv.appendChild(self.$video);
          document.body.appendChild(hiddenDiv);
          Object.keys(self.videoID).forEach(key => {
            addSourceToLocal(self.$video, self.videoID[key], `video/${key}`);
          });
        }

        self.player = self.player || self.$video;
        let locStarted;
        self.player.addEventListener('playing', e => {
          if (!locStarted) {
            self.fire('started', e);
          }

          locStarted = 1;
        });
        self.player.addEventListener('timeupdate', function (e) {
          self.fire('timeupdate', e); // check for end of video and play again or stop

          if (self.options.endTime) {
            if (self.options.endTime && this.currentTime >= self.options.endTime) {
              if (self.options.loop) {
                self.play(self.options.startTime);
              } else {
                self.pause();
              }
            }
          }
        });
        self.player.addEventListener('play', e => {
          self.fire('play', e);
        });
        self.player.addEventListener('pause', e => {
          self.fire('pause', e);
        });
        self.player.addEventListener('ended', e => {
          self.fire('ended', e);
        });
        self.player.addEventListener('loadedmetadata', function () {
          // get video width and height
          self.videoWidth = this.videoWidth || 1280;
          self.videoHeight = this.videoHeight || 720;
          self.fire('ready'); // autoplay

          if (self.options.autoplay) {
            self.play(self.options.startTime);
          }
        });
        self.player.addEventListener('volumechange', e => {
          self.getVolume(volume => {
            self.options.volume = volume;
          });
          self.fire('volumechange', e);
        });
        self.player.addEventListener('error', e => {
          self.fire('error', e);
        });
      }

      callback(self.$video);
    });
  }

  init() {
    const self = this;
    self.playerID = `VideoWorker-${self.ID}`;
  }

  loadAPI() {
    const self = this;

    if (YoutubeAPIadded && VimeoAPIadded) {
      return;
    }

    let src = ''; // load Youtube API

    if (self.type === 'youtube' && !YoutubeAPIadded) {
      YoutubeAPIadded = 1;
      src = 'https://www.youtube.com/iframe_api';
    } // load Vimeo API


    if (self.type === 'vimeo' && !VimeoAPIadded) {
      VimeoAPIadded = 1; // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7

      if (typeof global$1.Vimeo !== 'undefined') {
        return;
      }

      src = 'https://player.vimeo.com/api/player.js';
    }

    if (!src) {
      return;
    } // add script in head section


    let tag = document.createElement('script');
    let head = document.getElementsByTagName('head')[0];
    tag.src = src;
    head.appendChild(tag);
    head = null;
    tag = null;
  }

  onAPIready(callback) {
    const self = this; // Youtube

    if (self.type === 'youtube') {
      // Listen for global YT player callback
      if ((typeof global$1.YT === 'undefined' || global$1.YT.loaded === 0) && !loadingYoutubePlayer) {
        // Prevents Ready event from being called twice
        loadingYoutubePlayer = 1; // Creates deferred so, other players know when to wait.

        global$1.onYouTubeIframeAPIReady = function () {
          global$1.onYouTubeIframeAPIReady = null;
          loadingYoutubeDefer.resolve('done');
          callback();
        };
      } else if (typeof global$1.YT === 'object' && global$1.YT.loaded === 1) {
        callback();
      } else {
        loadingYoutubeDefer.done(() => {
          callback();
        });
      }
    } // Vimeo


    if (self.type === 'vimeo') {
      if (typeof global$1.Vimeo === 'undefined' && !loadingVimeoPlayer) {
        loadingVimeoPlayer = 1;
        const vimeoInterval = setInterval(() => {
          if (typeof global$1.Vimeo !== 'undefined') {
            clearInterval(vimeoInterval);
            loadingVimeoDefer.resolve('done');
            callback();
          }
        }, 20);
      } else if (typeof global$1.Vimeo !== 'undefined') {
        callback();
      } else {
        loadingVimeoDefer.done(() => {
          callback();
        });
      }
    } // Local


    if (self.type === 'local') {
      callback();
    }
  }

}

function jarallaxVideo$1(jarallax = global$2.jarallax) {
  if ('undefined' === typeof jarallax) {
    return;
  }

  const Jarallax = jarallax.constructor; // append video after when block will be visible.

  const defOnScroll = Jarallax.prototype.onScroll;

  Jarallax.prototype.onScroll = function () {
    const self = this;
    defOnScroll.apply(self);
    const isReady = !self.isVideoInserted && self.video && (!self.options.videoLazyLoading || self.isElementInViewport) && !self.options.disableVideo();

    if (isReady) {
      self.isVideoInserted = true;
      self.video.getVideo(video => {
        const $parent = video.parentNode;
        self.css(video, {
          position: self.image.position,
          top: '0px',
          left: '0px',
          right: '0px',
          bottom: '0px',
          width: '100%',
          height: '100%',
          maxWidth: 'none',
          maxHeight: 'none',
          pointerEvents: 'none',
          transformStyle: 'preserve-3d',
          backfaceVisibility: 'hidden',
          margin: 0,
          zIndex: -1
        });
        self.$video = video; // add Poster attribute to self-hosted video

        if ('local' === self.video.type) {
          if (self.image.src) {
            self.$video.setAttribute('poster', self.image.src);
          } else if (self.image.$item && 'IMG' === self.image.$item.tagName && self.image.$item.src) {
            self.$video.setAttribute('poster', self.image.$item.src);
          }
        } // insert video tag


        self.image.$container.appendChild(video); // remove parent video element (created by VideoWorker)

        $parent.parentNode.removeChild($parent); // call onVideoInsert event

        if (self.options.onVideoInsert) {
          self.options.onVideoInsert.call(self);
        }
      });
    }
  }; // cover video


  const defCoverImage = Jarallax.prototype.coverImage;

  Jarallax.prototype.coverImage = function () {
    const self = this;
    const imageData = defCoverImage.apply(self);
    const node = self.image.$item ? self.image.$item.nodeName : false;

    if (imageData && self.video && node && ('IFRAME' === node || 'VIDEO' === node)) {
      let h = imageData.image.height;
      let w = h * self.image.width / self.image.height;
      let ml = (imageData.container.width - w) / 2;
      let mt = imageData.image.marginTop;

      if (imageData.container.width > w) {
        w = imageData.container.width;
        h = w * self.image.height / self.image.width;
        ml = 0;
        mt += (imageData.image.height - h) / 2;
      } // add video height over than need to hide controls


      if ('IFRAME' === node) {
        h += 400;
        mt -= 200;
      }

      self.css(self.$video, {
        width: `${w}px`,
        marginLeft: `${ml}px`,
        height: `${h}px`,
        marginTop: `${mt}px`
      });
    }

    return imageData;
  }; // init video


  const defInitImg = Jarallax.prototype.initImg;

  Jarallax.prototype.initImg = function () {
    const self = this;
    const defaultResult = defInitImg.apply(self);

    if (!self.options.videoSrc) {
      self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;
    }

    if (self.options.videoSrc) {
      self.defaultInitImgResult = defaultResult;
      return true;
    }

    return defaultResult;
  };

  const defCanInitParallax = Jarallax.prototype.canInitParallax;

  Jarallax.prototype.canInitParallax = function () {
    const self = this;
    let defaultResult = defCanInitParallax.apply(self);

    if (!self.options.videoSrc) {
      return defaultResult;
    } // Init video api


    const video = new VideoWorker(self.options.videoSrc, {
      autoplay: true,
      loop: self.options.videoLoop,
      showControls: false,
      accessibilityHidden: true,
      startTime: self.options.videoStartTime || 0,
      endTime: self.options.videoEndTime || 0,
      mute: self.options.videoVolume ? 0 : 1,
      volume: self.options.videoVolume || 0
    }); // call onVideoWorkerInit event

    if (self.options.onVideoWorkerInit) {
      self.options.onVideoWorkerInit.call(self, video);
    }

    function resetDefaultImage() {
      if (self.image.$default_item) {
        self.image.$item = self.image.$default_item;
        self.image.$item.style.display = 'block'; // set image width and height

        self.coverImage();
        self.onScroll();
      }
    }

    if (video.isValid()) {
      // Force enable parallax.
      // When the parallax disabled on mobile devices, we still need to display videos.
      // https://github.com/nk-o/jarallax/issues/159
      if (this.options.disableParallax()) {
        defaultResult = true;
        self.image.position = 'absolute';
        self.options.type = 'scroll';
        self.options.speed = 1;
      } // if parallax will not be inited, we can add thumbnail on background.


      if (!defaultResult) {
        if (!self.defaultInitImgResult) {
          video.getImageURL(url => {
            // save default user styles
            const curStyle = self.$item.getAttribute('style');

            if (curStyle) {
              self.$item.setAttribute('data-jarallax-original-styles', curStyle);
            } // set new background


            self.css(self.$item, {
              'background-image': `url("${url}")`,
              'background-position': 'center',
              'background-size': 'cover'
            });
          });
        } // init video

      } else {
        video.on('ready', () => {
          if (self.options.videoPlayOnlyVisible) {
            const oldOnScroll = self.onScroll;

            self.onScroll = function () {
              oldOnScroll.apply(self);

              if (!self.videoError && (self.options.videoLoop || !self.options.videoLoop && !self.videoEnded)) {
                if (self.isVisible()) {
                  video.play();
                } else {
                  video.pause();
                }
              }
            };
          } else {
            video.play();
          }
        });
        video.on('started', () => {
          self.image.$default_item = self.image.$item;
          self.image.$item = self.$video; // set video width and height

          self.image.width = self.video.videoWidth || 1280;
          self.image.height = self.video.videoHeight || 720;
          self.coverImage();
          self.onScroll(); // hide image

          if (self.image.$default_item) {
            self.image.$default_item.style.display = 'none';
          }
        });
        video.on('ended', () => {
          self.videoEnded = true;

          if (!self.options.videoLoop) {
            // show default image if Loop disabled.
            resetDefaultImage();
          }
        });
        video.on('error', () => {
          self.videoError = true; // show default image if video loading error.

          resetDefaultImage();
        });
        self.video = video; // set image if not exists

        if (!self.defaultInitImgResult) {
          // set empty image on self-hosted video if not defined
          self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

          if ('local' !== video.type) {
            video.getImageURL(url => {
              self.image.bgImage = `url("${url}")`;
              self.init();
            });
            return false;
          }
        }
      }
    }

    return defaultResult;
  }; // Destroy video parallax


  const defDestroy = Jarallax.prototype.destroy;

  Jarallax.prototype.destroy = function () {
    const self = this;

    if (self.image.$default_item) {
      self.image.$item = self.image.$default_item;
      delete self.image.$default_item;
    }

    defDestroy.apply(self);
  };
}

function jarallaxElement$1(jarallax = global$2.jarallax) {
  // eslint-disable-next-line no-console
  console.warn("Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).");

  if ('undefined' === typeof jarallax) {
    return;
  }

  const Jarallax = jarallax.constructor; // redefine default methods

  ['initImg', 'canInitParallax', 'init', 'destroy', 'coverImage', 'isVisible', 'onScroll', 'onResize'].forEach(key => {
    const def = Jarallax.prototype[key];

    Jarallax.prototype[key] = function (...args) {
      const self = this;

      if ('initImg' === key && null !== self.$item.getAttribute('data-jarallax-element')) {
        self.options.type = 'element';
        self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || '100';
      }

      if ('element' !== self.options.type) {
        return def.apply(self, args);
      }

      self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';

      switch (key) {
        case 'init':
          {
            const speedArr = `${self.pureOptions.speed}`.split(' ');
            self.options.speed = self.pureOptions.speed || 0;
            self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;
            self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;
            const thresholdArr = self.pureOptions.threshold.split(' ');
            self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;
            self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;
            def.apply(self, args); // restore background image if available.

            const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');

            if (originalStylesTag) {
              self.$item.setAttribute('style', originalStylesTag);
            }

            return true;
          }

        case 'onResize':
          {
            const defTransform = self.css(self.$item, 'transform');
            self.css(self.$item, {
              transform: ''
            });
            const rect = self.$item.getBoundingClientRect();
            self.itemData = {
              width: rect.width,
              height: rect.height,
              y: rect.top + self.getWindowData().y,
              x: rect.left
            };
            self.css(self.$item, {
              transform: defTransform
            });
            break;
          }

        case 'onScroll':
          {
            const wnd = self.getWindowData();
            const centerPercent = (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) / (wnd.height / 2);
            const moveY = centerPercent * self.options.speedY;
            const moveX = centerPercent * self.options.speedX;
            let my = moveY;
            let mx = moveX;
            if (null !== self.options.thresholdY && moveY > self.options.thresholdY) my = 0;
            if (null !== self.options.thresholdX && moveX > self.options.thresholdX) mx = 0;
            self.css(self.$item, {
              transform: `translate3d(${mx}px,${my}px,0)`
            });
            break;
          }

        case 'initImg':
        case 'isVisible':
        case 'coverImage':
          return true;
        // no default
      }

      return def.apply(self, args);
    };
  });
}

const jarallax = jarallax$1;
const jarallaxVideo = function jarallaxVideo() {
  return jarallaxVideo$1(jarallax);
};
const jarallaxElement = function jarallaxElement() {
  return jarallaxElement$1(jarallax);
};


//# sourceMappingURL=jarallax.esm.js.map

;// CONCATENATED MODULE: ./stories/js/modules/FeatureContentLayoutParallax/index.js
function FeatureContentLayoutParallax_toConsumableArray(arr) { return FeatureContentLayoutParallax_arrayWithoutHoles(arr) || FeatureContentLayoutParallax_iterableToArray(arr) || FeatureContentLayoutParallax_unsupportedIterableToArray(arr) || FeatureContentLayoutParallax_nonIterableSpread(); }

function FeatureContentLayoutParallax_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function FeatureContentLayoutParallax_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FeatureContentLayoutParallax_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FeatureContentLayoutParallax_arrayLikeToArray(o, minLen); }

function FeatureContentLayoutParallax_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function FeatureContentLayoutParallax_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return FeatureContentLayoutParallax_arrayLikeToArray(arr); }

function FeatureContentLayoutParallax_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




function FeatureContentLayoutParallax() {
  revealElements();
  jarallax(document.querySelectorAll(".jarallax"));
  jarallax(document.querySelectorAll(".jarallax-keep-img"), {
    keepImg: true
  }); //return {
  //destroy: () => {
  //}
  //};
}

FeatureContentLayoutParallax.defaultSelector = '.FeatureContentLayoutParallax';

FeatureContentLayoutParallax.initAll = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$selector = _ref.selector,
      selector = _ref$selector === void 0 ? FeatureContentLayoutParallax.defaultSelector : _ref$selector;

  return FeatureContentLayoutParallax_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return FeatureContentLayoutParallax({
      el: el
    });
  });
};

/* harmony default export */ var modules_FeatureContentLayoutParallax = (FeatureContentLayoutParallax);
;// CONCATENATED MODULE: ./stories/js/modules/LongFormContentImage/index.js
function LongFormContentImage_toConsumableArray(arr) { return LongFormContentImage_arrayWithoutHoles(arr) || LongFormContentImage_iterableToArray(arr) || LongFormContentImage_unsupportedIterableToArray(arr) || LongFormContentImage_nonIterableSpread(); }

function LongFormContentImage_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function LongFormContentImage_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LongFormContentImage_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LongFormContentImage_arrayLikeToArray(o, minLen); }

function LongFormContentImage_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function LongFormContentImage_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return LongFormContentImage_arrayLikeToArray(arr); }

function LongFormContentImage_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* eslint-disable no-param-reassign,no-return-assign */



core_class.use([autoplay, effect_fade]);

var LongFormContentImage = function LongFormContentImage() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      el = _ref.el;

  var autoplayDelay = 5000;
  var transitionSpeed = 300;
  var singleSlideClass = 'LongFormContentImage--singleSlide';
  var contentSwiperEl = el.querySelector('.LongFormContentImage-contentPanel .swiper-container');
  var SliderSwiperEl = el.querySelector('.LongFormContentImage-contentPanel .swiper-wrapper');
  var SliderActiveEl = el.querySelector('.LongFormContentImage-contentPanel .swiper-slide-active');
  var leftButtonEl = el.querySelector('.LongFormContentImage-navArrowButton-left');
  var paginationContainerEl = el.querySelector('.LongFormContentImage-paginationContainer');
  var paginationButtonsEl = el.querySelectorAll('.LongFormContentImage-paginationButton');
  var enlargeEl = el.querySelector('.LongFormContentImage-enlarge');
  var rightButtonEl = el.querySelector('.LongFormContentImage-navArrowButton-right');
  var imageModal = document.getElementById(enlargeEl.getAttribute("data-micromodal-trigger"));
  var modalImages = imageModal.querySelectorAll('.LongFormContentImage-modalImage');
  var control = el.querySelector('.LongFormContentImage-controlPanel');
  var browserInfo = new (ua_parser_default())().getBrowser();
  var isAutoplayRunning = true;

  var isSingleSlide = function () {
    if (el.classList.contains(singleSlideClass) || contentSwiperEl.querySelector('.swiper-wrapper').children.length < 2) {
      el.classList.add(singleSlideClass);
      return true;
    }
  }();

  var contentSwiper = new core_class(contentSwiperEl, {
    // NOTE: Auto height does not work on IE11.
    allowTouchMove: false,
    //!isSingleSlide,
    autoHeight: !(browserInfo.name === 'IE' && /^11/.test(browserInfo.version)),
    autoplay: isSingleSlide ? false : {
      delay: autoplayDelay
    },
    effect: 'fade',
    fadeEffect: {
      crossFade: true
    },
    loop: true,
    speed: transitionSpeed
  });

  var updateProgressBars = function updateProgressBars() {
    paginationContainerEl.querySelectorAll('.LongFormContentImage-paginationButton-progressBar').forEach(function (barEl, i) {
      var isActiveIndex = i === contentSwiper.realIndex;
      barEl.style.transition = isActiveIndex && isAutoplayRunning ? "width ".concat(autoplayDelay + transitionSpeed, "ms linear") : 'none';
      barEl.style.width = isActiveIndex ? '100%' : 0;
    });
  };

  var updatePaginationButton = function updatePaginationButton() {
    paginationButtonsEl.forEach(function (btnEl, i) {
      btnEl.style.width = paginationContainerEl.clientWidth / paginationButtonsEl.length + 'px';
    });
  };

  var old = 0;

  var setSwiperHeightForIE = function setSwiperHeightForIE() {
    if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version) && !isSingleSlide) {
      SliderActiveEl = contentSwiperEl.querySelector('.swiper-slide-active');

      if (SliderActiveEl) {
        SliderActiveEl.style.height = 'auto';
        SliderSwiperEl.style.height = 'auto';

        if (old != contentSwiper.realIndex) {
          SliderSwiperEl.style.height = SliderActiveEl.clientHeight + 'px';
          old = contentSwiper.realIndex;
        }
      }
    }
  };

  var setControlPosition = function setControlPosition() {
    SliderActiveEl = contentSwiperEl.querySelector('.swiper-slide-active');

    if (SliderActiveEl) {
      var sliderContent = SliderActiveEl.querySelector('.swiper-slide-content').clientHeight + 20;
      control.style.transform = 'translateY(' + -sliderContent + 'px)';
    }
  };

  enlargeEl.addEventListener('click', enlargeEl.handleClick = function (e) {
    if (contentSwiperEl) {
      contentSwiper.autoplay.stop();
      SliderActiveEl = contentSwiperEl.querySelector('.swiper-slide-active');
      var sliderIndex = parseInt(SliderActiveEl.dataset.swiperSlideIndex) || contentSwiper.realIndex;
      modalImages.forEach(function (el) {
        el.style.display = 'none';
      });
      modalImages[sliderIndex].style.display = 'flex';
    }
  });
  leftButtonEl.addEventListener('click', leftButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slidePrev();
  });
  rightButtonEl.addEventListener('click', rightButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slideNext();
  });
  contentSwiper.on('slideChange', function () {
    updateProgressBars();
  });
  contentSwiper.on('transitionEnd', function () {
    //console.log('*** contentSwiper.realIndex', contentSwiper.realIndex);
    setSwiperHeightForIE();
    setControlPosition();
  });
  contentSwiper.on('autoplayStop', function () {
    return isAutoplayRunning = false;
  });
  paginationContainerEl.children.forEach(function (child, i) {
    return child.addEventListener('click', child.handleClick = function () {
      contentSwiper.autoplay.stop();
      contentSwiper.slideToLoop(i);
    });
  }); //For first load, image not show overall, to make swiper height auto

  if (contentSwiperEl && contentSwiperEl.querySelector('.swiper-slide-active')) {
    SliderSwiperEl.style.height = 'auto';
  }

  updatePaginationButton();
  window.addEventListener('resize', function () {
    updatePaginationButton();
    setControlPosition();
  });
  setSwiperHeightForIE();
  setControlPosition();
  updateProgressBars();
  return {
    destroy: function destroy() {
      contentSwiper.detachEvents();
      contentSwiper.destroy();
      leftButtonEl.removeEventListener('click', leftButtonEl.handleClick);
      rightButtonEl.removeEventListener('click', rightButtonEl.handleClick);
      paginationContainerEl.children.forEach(function (child) {
        return child.removeEventListener('click', child.handleClick);
      });
    }
  };
};

LongFormContentImage.defaultSelector = '.LongFormContentImage';

LongFormContentImage.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? LongFormContentImage.defaultSelector : _ref2$selector;

  return LongFormContentImage_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return LongFormContentImage({
      el: el
    });
  });
};

/* harmony default export */ var modules_LongFormContentImage = (LongFormContentImage);
;// CONCATENATED MODULE: ./stories/js/modules/NavigationSection/index.js


function NavigationSection() {
  console.log('NavigationSection');
  var body = document.body;
  var navigationSection = document.querySelector('.NavigationSection');

  if (navigationSection) {
    var navigationSectionMenu = document.querySelector('[data-navigationSection]');
    var navigationSectionTriggers = document.querySelectorAll('[data-navigationSection-trigger]');
    var navigationSectionSubmenus = document.querySelectorAll('[data-navigationSection-submenu]');
    var submenuTriggers = document.querySelectorAll('[data-navigationSection-submenu-trigger] ');
    var nav_top = utilities_CustomUtil.checkStickyPosition(navigationSection); //navigationSection.offsetTop;

    var nav_height = navigationSection.clientHeight;
    var ticking = false;
    var prevScroTop = 0;
    var max_top = 0;
    var hasInPageNav = false;
    var inPageNav = document.querySelector('.InPageNav');

    if (inPageNav) {
      hasInPageNav = true;
      max_top = utilities_CustomUtil.checkStickyPosition(inPageNav) - inPageNav.clientHeight;
      navigationSection.setAttribute("data-stickyEnd", max_top);
    } else {
      hasInPageNav = false;
    }

    navigationSectionTriggers.forEach(function (trigger) {
      trigger.addEventListener('click', function () {
        navigationSectionTriggers.forEach(function () {
          return trigger.classList.toggle('is-active');
        });
        navigationSection.classList.toggle('is-open');
      });
    });
    submenuTriggers.forEach(function (trigger) {
      var submenuName = trigger.dataset.navigationsectionSubmenuTrigger;
      trigger.addEventListener('click', function () {
        navigationSectionSubmenus.forEach(function (submenu) {
          var item = submenu.closest('.NavigationSection-mainMenu-item');

          if (item && submenuName != submenu.getAttribute('data-navigationSection-submenu')) {
            item.classList.remove('is-open');

            if (item.querySelector('[data-navigationsection-submenu-trigger]')) {
              item.querySelector('[data-navigationsection-submenu-trigger]').classList.remove('is-active');
            }
          }
        });
        trigger.classList.toggle('is-active');

        if (submenuName) {
          var submenu = document.querySelector("[data-navigationSection-submenu=\"".concat(submenuName, "\"]"));

          if (!trigger.classList.contains('is-active')) {
            submenu.closest('.NavigationSection-mainMenu-item').classList.remove('is-open');
          } else {
            submenu.closest('.NavigationSection-mainMenu-item').classList.add('is-open');
          }
        } else {
          var openSubmenu = document.querySelector('.NavigationSection-mainMenu-item.is-open');

          if (openSubmenu) {
            openSubmenu.classList.remove('is-open');
          }
        }
      });
    });
    body.addEventListener('click', function (e) {
      var c1 = !e.target.getAttribute('data-navigationSection-submenu-trigger') && !e.target.classList.contains('NavigationSection-subMenu-items');

      if (c1) {
        navigationSectionSubmenus.forEach(function (submenu) {
          submenuTriggers.forEach(function (trigger) {
            trigger.classList.remove('is-active');
          });
          submenu.closest('.NavigationSection-mainMenu-item').classList.remove('is-open');
        });
      }
    });

    function bindNavFixedEvent() {
      var top = nav_top;
      var customUtil = utilities_CustomUtil.initSettings();
      var scroTop = window.scrollY || document.documentElement.scrollTop;
      var condition = scroTop > top;
      var ele = navigationSection;
      var maxTop = customUtil.getStickyMaxTop();

      if (scroTop < prevScroTop) {//scroll up
        //maxTop = maxTop - customUtil.settings.headerFixedHeight;
      }

      if (scroTop > prevScroTop) {
        //down
        ele.setAttribute("data-direction", 'down');
        condition = scroTop > top && scroTop < maxTop;
        ;

        if (hasInPageNav) {//condition = scroTop > top && scroTop < max_top;
        }
      } else {
        //up
        ele.setAttribute("data-direction", 'up');

        if (scroTop == 0) {
          condition = false;
        } else {
          if (!customUtil.checkNavigationSection() && !customUtil.checkInPageNav()) {
            condition = scroTop > top - nav_height - customUtil.settings.headerFixedHeight && scroTop < maxTop;
            ;
          } else {
            //With NavigationSection and InPageNav
            if (customUtil.checkNavigationSection() && customUtil.checkInPageNav()) {
              if (ele.classList.contains('sticky-fixed')) {
                var breadcrumbs = document.querySelector('.Breadcrumbs');
                var gapH = breadcrumbs != null ? customUtil.settings.headerFixedHeight + breadcrumbs.clientHeight : customUtil.settings.headerFixedHeight;

                if (scroTop > gapH) {
                  //When not fetch the shynav position
                  condition = scroTop < top && scroTop < maxTop;
                  ;
                } else {
                  //When fetch the shynav position
                  condition = false; //scroTop > top - nav_height;
                }
              }
            } else {//When fetch the top, remove navigation section fixed class.
              //condition = scroTop > 0;
            }
          }
        }
      }

      utilities_CustomUtil.bindStickyEvent(condition, ele);
      prevScroTop = scroTop;
    }

    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          bindNavFixedEvent();
          ticking = false;
        });
        ticking = true;
      }
    });
  }
}

/* harmony default export */ var modules_NavigationSection = (NavigationSection);
;// CONCATENATED MODULE: ./stories/js/modules/ContentLayoutBackground/index.js
function ContentLayoutBackground() {
  console.log('ContentLayoutBackground');
  var contentLayoutBackgrounds = document.querySelectorAll('.ContentLayoutBackground');

  var setHeightForBg = function setHeightForBg(el) {
    if (el) {
      var bg = el.querySelector('.ContentLayoutBackground-backgroundContainer');
      var content = el.querySelector('.ContentLayoutBackground-mainContainer');
      bg.style.height = content.clientHeight + 'px';
    }
  };

  contentLayoutBackgrounds.forEach(function (contentLayoutBackground) {
    setHeightForBg(contentLayoutBackground);
  });
  window.addEventListener('resize', function () {
    contentLayoutBackgrounds.forEach(function (contentLayoutBackground) {
      setHeightForBg(contentLayoutBackground);
    });
  });
  window.addEventListener('load', function () {
    contentLayoutBackgrounds.forEach(function (contentLayoutBackground) {
      setHeightForBg(contentLayoutBackground);
    });
  });
}

/* harmony default export */ var modules_ContentLayoutBackground = (ContentLayoutBackground);
;// CONCATENATED MODULE: ./stories/js/modules/LongFormContentCover/index.js


function LongFormContentCover() {
  var LFC = document.querySelector('.LongFormContent');
  var LFC_cover = document.querySelector('.LongFormContentCover');
  var LFC_coverHeader = LFC.querySelector('.LongFormContentCover-header');
  var LFC_coverBody = LFC.querySelector('.LongFormContentCover-body');
  var LFC_coverContent = LFC.querySelector('.LongFormContentCover-content');
  var LFC_primaryMedia = LFC.querySelector('.primary-media');
  var LFC_primaryText = LFC.querySelector('.primary-text');
  var LFC_secondaryMedia = LFC.querySelector('.secondary-media');
  var LFC_main = LFC.querySelector('.LongFormContentMain');
  var LFC_body = LFC.querySelectorAll('.LongFormContentBody');
  var LFC_bodyHeader = LFC.querySelectorAll('.LongFormContentBody-header');
  var LFC_bodyBody = LFC.querySelectorAll('.LongFormContentBody-body');
  var LFC_sidebar = LFC.querySelector('.LongFormContentCover-sidebar');
  var LFC_toggle = LFC.querySelector('.LongFormContentCover-toggle');
  var LFC_close = LFC.querySelector('.sidebar-close');
  var LFC_contentTable = LFC_sidebar.querySelector('.LongFormContentCover-contentTable');
  var LFC_keys = LFC_sidebar.querySelector('.LongFormContentCover-keys');
  var LFC_contentTableBody = LFC_coverBody.querySelector('.LongFormContentCover-contentTable');
  var LFC_indicatorLinks = LFC.querySelectorAll('.indicator-link');
  var LFC_indicatorTargets = LFC.querySelectorAll('.indicator-title'); //if(LFC_body[0]){

  LFC_indicatorTargets = LFC.querySelectorAll('.LongFormContentBody h2, .indicator-title'); //LFC_body[0].querySelectorAll('h2');
  //}

  var LFC_socialTag = LFC_sidebar.querySelector('.LongFormContentCover-socialTag');
  var LFC_contentSocialTag = LFC_coverContent.querySelector('.LongFormContentCover-socialTag');
  var stickyEndFlag = null;
  var LFC_Height = LFC.clientHeight;
  var LFC_Top;
  var LFC_coverHeader_Height;
  var LFC_coverBody_Height;
  var LFC_coverBody_Top;
  var LFC_main_Height;
  var LFC_sidebar_InitHeight;
  var LFC_sidebar_Height;
  var LFC_leftWidth;
  var LFC_containerMargin;
  var LFC_LeftMargin;
  var LFC_primaryMediaMargin;
  var LFC_coverContent_Height;
  var LFC_mainMargin; //bodyGap used for the height gap when sidebar sticky or not.

  var bodyGap;
  var isLaptop = true; //var lab = {
  //  read_time: CustomUtil.isLocalhost? 'minute read' : "${'minute read' @ i18n, context='unsafe'}"
  //};

  var prevScroTop = 0;
  var ticking = false;

  function getStyle(ele) {
    return window.getComputedStyle(ele);
  }

  function addStickyEndFlag() {
    if (document.querySelector('.sticky-end-tag') == null) {
      var flag = document.createElement('a');
      flag.className = 'sticky-end-tag with-sticky in-sticky';
      LFC.appendChild(flag);
      stickyEndFlag = document.querySelector('.sticky-end-tag');
    }
  }

  function initElements() {
    LFC_Height = LFC.clientHeight;
    LFC_Top = LFC.offsetTop;
    LFC_coverHeader_Height = LFC_coverHeader ? LFC_coverHeader.clientHeight : 0;
    LFC_coverBody_Height = LFC_coverBody ? LFC_coverBody.clientHeight : 0;
    LFC_coverBody_Top = LFC_coverBody ? LFC_coverBody.offsetTop : 0;
    LFC_main_Height = LFC_main ? LFC_main.clientHeight : 0;
    LFC_sidebar_Height = LFC_sidebar ? LFC_sidebar.clientHeight : 0;
    LFC_leftWidth = LFC_coverContent ? LFC_coverContent.clientWidth : 752;
    LFC_containerMargin = parseFloat(getStyle(LFC_coverBody.querySelector('.Container')).marginLeft);
    LFC_LeftMargin = LFC_sidebar ? parseFloat(getStyle(LFC_sidebar).marginLeft) : 0;
    LFC_primaryMediaMargin = LFC_primaryMedia ? parseFloat(getStyle(LFC_primaryMedia).marginBottom) : 0;
    LFC_coverContent_Height = LFC_coverContent.clientHeight + LFC_primaryMediaMargin; //bodyGap used for the height gap when sidebar sticky or not.

    bodyGap = LFC_sidebar_Height - LFC_coverContent_Height > 0 ? LFC_sidebar_Height - LFC_coverContent_Height : 0;
  }

  function setMarginValue() {
    isLaptop = utilities_CustomUtil.screenIs == 'isLaptop';

    if (isLaptop) {
      if (!LFC_sidebar.classList.contains('sticky-fixed')) {
        LFC_coverContent_Height = LFC_primaryMedia ? LFC_coverContent.clientHeight - 140 : LFC_coverContent.clientHeight;

        if (LFC_coverContent_Height < LFC_sidebar_InitHeight) {
          var margin = LFC_sidebar_InitHeight - LFC_coverContent_Height;

          if (LFC_primaryMedia == null) {
            margin = LFC_sidebar_InitHeight - LFC_coverContent_Height + 124;

            if (LFC_primaryText == null) {
              margin += 28; //P marginBottom
            }
          }

          LFC_mainMargin = -margin;
          LFC_main.style.marginTop = LFC_mainMargin + 'px';
        } else {
          LFC_main.style.marginTop = 0;
        }
      }
    } else {
      LFC_main.style.marginTop = 0;
    }
  }

  function setNegativeMarginForMain() {
    var LFC_primaryMediaImage;

    if (LFC_primaryMedia) {
      LFC_primaryMediaImage = LFC_primaryMedia.querySelector('img'); //alert(LFC_primaryMediaImage.complete);

      if (LFC_primaryMediaImage.complete) {
        LFC_sidebar.style.opacity = 1;
        LFC_sidebar.style.height = 'auto';
        setMarginValue();
      } else {
        LFC_sidebar.style.opacity = 0;
        LFC_sidebar.style.height = 0;
      }
    } else {
      LFC_sidebar.style.opacity = 1;
      LFC_sidebar.style.height = 'auto';
      setMarginValue();
    }
  }

  function checkStickyForHeader() {
    isLaptop = utilities_CustomUtil.screenIs == 'isLaptop';

    if (isLaptop) {
      LFC_coverHeader.classList.remove('in-sticky');
    } else {
      LFC_coverHeader.classList.add('in-sticky');
    }
  }

  var createTableofContent = function createTableofContent() {
    var tables = LFC.querySelector('.LongFormContentCover-indicators');

    if (tables) {
      var h2s = LFC.querySelectorAll('.indicator-title'); //if(LFC_body[0]){

      h2s = LFC.querySelectorAll('.LongFormContentBody h2, .indicator-title'); //LFC_body[0].querySelectorAll('h2');
      //}

      var html = '';
      h2s.forEach(function (h2, index) {
        var className = index == 0 ? 'active' : '';
        html += '<li class="indicator-item ' + className + '">';
        html += '<a class="indicator-link" data-indicate="' + index + '">' + h2.innerHTML + '</a>';
        html += '</li>';
      });
      LFC_sidebar.querySelector('.LongFormContentCover-indicators').innerHTML = html;
      LFC_coverBody.querySelector('.LongFormContentCover-indicators').innerHTML = html;

      if (html == '') {
        LFC_sidebar.querySelector('.LongFormContentCover-contentTable').remove();
        LFC_coverBody.querySelector('.LongFormContentCover-contentTable').remove();
        LFC_contentTable = LFC_sidebar.querySelector('.LongFormContentCover-contentTable');
        LFC_contentTableBody = LFC_coverBody.querySelector('.LongFormContentCover-contentTable');
      }

      LFC_indicatorLinks = LFC.querySelectorAll('.indicator-link');
      bindIndicator();
    }

    if (LFC_contentTable != null) {
      LFC_toggle.classList.remove('hidden');
    } else {
      LFC_toggle.classList.add('hidden');
    }

    LFC_sidebar_InitHeight = LFC_sidebar ? LFC_sidebar.clientHeight : 0;
  };

  var scrollToPosition = function scrollToPosition(container, target) {
    var eleTop = utilities_CustomUtil.getInStickyTop(container);
    var top = target.offsetTop;

    if (!target.classList.contains('indicator-title')) {
      top = target.offsetTop;
    } else {
      //top = target.parentElement.parentElement.parentElement.offsetTop;
      top = target.closest('.Container').parentElement.offsetTop;
    }

    utilities_CustomUtil.updateSettings();
    utilities_CustomUtil.initCheckScreen();
    isLaptop = utilities_CustomUtil.screenIs == 'isLaptop';
    var scrollTo = top;

    if (top > prevScroTop) {
      //scroll down
      if (container.classList.contains('sticky-fixed')) {
        //header not sticky on laptop
        scrollTo = top - eleTop - container.clientHeight;
      } else {
        if (isLaptop) {
          if (LFC_sidebar.classList.contains('sticky-fixed')) {
            scrollTo = top - eleTop;
          } else {
            scrollTo = top - eleTop - bodyGap;
          }
        } else {
          scrollTo = top - eleTop - container.clientHeight - utilities_CustomUtil.settings.headerFixedHeight;
        }
      }
    } else {
      //scroll up
      if (container.classList.contains('sticky-fixed')) {
        //header not sticky on laptop
        scrollTo = top - eleTop - container.clientHeight - utilities_CustomUtil.settings.headerFixedHeight;
      } else {
        if (isLaptop) {
          scrollTo = top - eleTop - utilities_CustomUtil.settings.headerFixedHeight;
        } else {
          scrollTo = top - eleTop - container.clientHeight + utilities_CustomUtil.settings.headerFixedHeight;
        }
      }
    }

    window.scrollTo(0, scrollTo);
  };

  var bindIndicator = function bindIndicator() {
    LFC_indicatorLinks.forEach(function (indicator, i) {
      indicator.addEventListener('click', function (e) {
        e.preventDefault();
        LFC_indicatorLinks.forEach(function (ind) {
          ind.parentElement.classList.remove('active');
        });
        e.currentTarget.parentElement.classList.add('active');
        var index = parseInt(indicator.getAttribute('data-indicate'));
        var target = LFC_indicatorTargets[index];
        scrollToPosition(LFC_coverHeader, target);
        LFC_sidebar.classList.remove('opened');
      });
    });
  };

  function setReadingTime() {
    if (LFC) {
      var txt = LFC.textContent;
      var wordCount = txt.replace(/[^\w ]/g, '').split(/\s+/).length;
      var readingTimeInMinutes = Math.floor(wordCount / 200) + 1; //let readingTimeAsString = readingTimeInMinutes + ' ' + lab.read_time;

      var readingTimeAsString = readingTimeInMinutes + " minute read";

      if (typeof labels != "undefined") {
        if (typeof labels.minute_read != "undefined") {
          readingTimeAsString = labels.minute_read.replace('{0}', readingTimeInMinutes);
        }
      }

      LFC.querySelector('.cover-time').innerHTML = readingTimeAsString;
    }
  }

  function bindLFCScrollEvent() {
    var bodyMarginTop = parseFloat(getStyle(LFC_coverBody).marginTop);
    var top = LFC_Top + LFC_Height + bodyMarginTop - LFC_coverHeader_Height - utilities_CustomUtil.settings.headerFixedHeight; //*0.75;

    var mainTop = LFC_coverBody_Top;
    utilities_CustomUtil.updateSettings();
    utilities_CustomUtil.initCheckScreen();
    var scroTop = window.scrollY || document.documentElement.scrollTop;
    isLaptop = utilities_CustomUtil.screenIs == 'isLaptop'; //&& scroTop > top;
    //When to footer to display fixed sidebar

    var heightGap = LFC_Height - LFC.clientHeight;
    var scroGap = parseInt(window.innerHeight * (window.innerHeight / document.body.offsetHeight));
    var maxTop = LFC.clientHeight; // - LFC_coverHeader.clientHeight;

    if (scroTop < prevScroTop) {
      //scroll up
      maxTop = LFC.clientHeight - utilities_CustomUtil.settings.headerFixedHeight; //- LFC_coverHeader.clientHeight 
    }

    maxTop = maxTop - (window.innerHeight || document.body.clientHeight);
    stickyEndFlag = document.querySelector('.sticky-end-tag');
    var endTop = stickyEndFlag.offsetTop - LFC_sidebar.clientHeight;
    var eleTop = utilities_CustomUtil.getInStickyTop(LFC_sidebar);
    var headerFixedCondiotion = scroTop > mainTop && !isLaptop && LFC_contentTable != null;
    var sideBarFixedCondiotion = scroTop > mainTop && (LFC_contentTable != null || LFC_keys != null); //&& showRelatedArticlesCondition;

    LFC_sidebar.setAttribute("data-stickyEnd", maxTop);
    utilities_CustomUtil.bindStickyEvent(headerFixedCondiotion, LFC_coverHeader);
    utilities_CustomUtil.bindStickyEvent(sideBarFixedCondiotion, LFC_sidebar);
    var up_updated = scroTop > maxTop; // To ensure sidebar not overlap footer when scroll up

    if (isLaptop) {
      if (LFC_sidebar.classList.contains('sticky-fixed')) {
        /*if(scroTop < endTop){
          if(scroTop > prevScroTop){ 
            setSidebarHeight('down');
          }else {
            setSidebarHeight('up');
          }
        }else {
          LFC_sidebar.style.height = 'auto';
          if(LFC_contentTable){
            LFC_contentTable.style.height = 'auto';
          }
        }*/
        if (scroTop > prevScroTop) {
          setSidebarHeight('down', false);
        } else {
          setSidebarHeight('up', up_updated);
        }
      } else {
        if (scroTop < prevScroTop) {
          //scroll up to make height auto
          LFC_sidebar.style.height = 'auto';
        }

        LFC_sidebar.style.height = 'auto';
      }
    }

    prevScroTop = scroTop;
  }

  function resetSidebarStyle() {
    utilities_CustomUtil.updateSettings();
    utilities_CustomUtil.initCheckScreen();
    isLaptop = utilities_CustomUtil.screenIs == 'isLaptop' ? true : false;
    LFC_leftWidth = LFC_coverContent ? LFC_coverContent.clientWidth : 752;
    LFC_containerMargin = parseFloat(getStyle(LFC_coverBody.querySelector('.Container')).marginLeft);
    var LFC_gap1 = LFC_leftWidth + LFC_LeftMargin + LFC_containerMargin * 2;
    var LFC_gap2 = LFC_leftWidth + LFC_LeftMargin;

    if (LFC_sidebar) {
      //desktop set same width as relative condition in fixed condition
      if (isLaptop) {
        if (LFC_sidebar.classList.contains('sticky-fixed')) {
          LFC_sidebar.style.width = 'calc(100% - ' + LFC_gap1 + 'px)';
          LFC_sidebar.style.right = LFC_containerMargin + 'px';
          var otherHeight = LFC_socialTag.clientHeight;

          if (LFC_sidebar.querySelector('.LongFormContentCover-cta')) {
            otherHeight = LFC_socialTag.clientHeight + LFC_sidebar.querySelector('.LongFormContentCover-cta').clientHeight;
          }

          if (LFC_contentTable) {
            LFC_contentTable.style.height = 'calc(100% - ' + otherHeight + 'px)';
          }

          if (LFC_keys) {
            LFC_keys.style.height = 'calc(100% - ' + otherHeight + 'px)';
          }

          LFC_main.style.marginTop = 0;
        } else {
          LFC_sidebar.style.width = 'calc(100% - ' + LFC_gap2 + 'px)';
          LFC_sidebar.style.right = '0';
          LFC_main.style.marginTop = LFC_mainMargin + 'px';
        }
      }
    }
  }

  function setSidebarHeight(dir, flag) {
    utilities_CustomUtil.updateSettings();
    utilities_CustomUtil.initCheckScreen();
    isLaptop = utilities_CustomUtil.screenIs == 'isLaptop' ? true : false;

    if (isLaptop) {
      var sidebarTop = parseInt(LFC_sidebar.style.top);
      var top = sidebarTop + 'px';

      if (sidebarTop = 0) {
        top = 0;
      } else if (sidebarTop < 0) {
        top = -sidebarTop + 'px';
      }

      if (dir == 'up') {
        if (!flag) {
          LFC_sidebar.style.height = 'calc(100vh - ' + top + ')';
        } else {
          LFC_sidebar.style.height = 'calc(100vh)';
        }
      } else {
        LFC_sidebar.style.height = 'calc(100vh)';
      }
    }
  }

  function resetContentSocialTagsPosition() {
    //LFC_main.appendChild(LFC_contentSocialTag);
    //if(LFC_body && LFC_body[LFC_body.length - 1] && LFC_contentSocialTag){
    //  LFC_body[LFC_body.length - 1].after(LFC_contentSocialTag);
    //}
    var compRelatedResources = document.querySelector('.longFormContent_RelatedResources');
    var compRelatedProducts = document.querySelector('.longFormContent_RelatedProducts');

    if (LFC_contentSocialTag) {
      if (compRelatedResources) {
        compRelatedResources.before(LFC_contentSocialTag);
      } else {
        if (compRelatedProducts) {
          compRelatedProducts.before(LFC_contentSocialTag);
        } else {
          LFC_main.appendChild(LFC_contentSocialTag);
        }
      }
    }

    initElements();
  }

  function randPrimaryMedia() {
    if (LFC_primaryMedia) {
      var rand = Math.floor(Math.random() * 10000);
      var LFC_primaryMediaImage = LFC_primaryMedia.querySelector('img');
      LFC_primaryMediaImage.src = LFC_primaryMediaImage.src + '?' + rand;
    }
  }

  function resetElements() {
    LFC_Height = LFC.clientHeight;
    LFC_coverContent_Height = LFC_coverContent.clientHeight + LFC_primaryMediaMargin;
    bodyGap = LFC_sidebar_Height - LFC_coverContent_Height > 0 ? LFC_sidebar_Height - LFC_coverContent_Height : 0;
  }

  function initLoad() {
    if (LFC_primaryMedia == null) {
      LFC_cover.classList.add('no-primary-media');
    }

    if (LFC_secondaryMedia == null) {
      LFC_cover.classList.add('no-secondary-media');
    }
  }

  LFC_toggle.addEventListener('click', function (e) {
    LFC_sidebar.classList.add('opened');
  });
  LFC_close.addEventListener('click', function (e) {
    LFC_sidebar.classList.remove('opened');
  });
  window.addEventListener('scroll', function (e) {
    if (!ticking) {
      window.requestAnimationFrame(function () {
        bindLFCScrollEvent();
        ticking = false;
      });
      ticking = true;
    }
  });
  var observer;

  var watchSidebar = function watchSidebar() {
    observer = new MutationObserver(function (mutationRecords) {
      //console.log(mutationRecords);
      resetSidebarStyle();
    });
    var node = LFC_sidebar;
    var config = {
      attributes: true,
      attributeFilter: ['class']
    };

    if (node) {
      observer.observe(node, config);
    }
  };

  window.addEventListener('load', function (e) {
    resetElements();
    setNegativeMarginForMain();
  });
  window.addEventListener('resize', function (e) {
    utilities_CustomUtil.updateSettings();
    utilities_CustomUtil.initCheckScreen();
    initElements();
    checkStickyForHeader();
    resetSidebarStyle();
  });
  utilities_CustomUtil.updateSettings();
  utilities_CustomUtil.initCheckScreen();
  initLoad();
  addStickyEndFlag();
  checkStickyForHeader();
  createTableofContent(); //randPrimaryMedia();

  setNegativeMarginForMain();
  resetContentSocialTagsPosition();
  setReadingTime();
  resetSidebarStyle();
  watchSidebar();
}

/* harmony default export */ var modules_LongFormContentCover = (LongFormContentCover);
;// CONCATENATED MODULE: ./stories/js/modules/LongFormContentFeatureQuote/index.js
function LongFormContentFeatureQuote() {
  var FeatureQuote = document.querySelectorAll('.LongFormContentFeatureQuote');
  FeatureQuote.forEach(function (q, index) {
    var firstP = q.querySelector('.quote-text p:first-child');
    var lastP = q.querySelector('.quote-text p:last-child');

    if (q.querySelectorAll('.quote-text p').length == 1) {
      firstP.innerHTML = '<span class="quo">&ldquo;</span>' + firstP.innerHTML + '<span class="quo">&rdquo;</span>';
    } else {
      if (firstP && lastP) {
        firstP.innerHTML = '<span class="quo">&ldquo;</span>' + firstP.innerHTML;
        lastP.innerHTML = lastP.innerHTML + '<span class="quo">&rdquo;</span>';
      }
    }
  });
}

/* harmony default export */ var modules_LongFormContentFeatureQuote = (LongFormContentFeatureQuote);
;// CONCATENATED MODULE: ./stories/assets/json/ecom-6.json
var ecom_6_namespaceObject = JSON.parse('{"overview_label":"Overview","documentation_label":"Documentation","productinfo_label":"Product Info","msrp_label":"MSRP","modelno_label":"Model No: ","key_specs_label":"Key Specs","where_to_buy_label":"Where to buy","detail_label":"Detail","off_label":"% off","buynowbutton":"Buy Now","videocta":"Click to Play","currency_symbol":"$","site":"seagate","is_where_to_buy":true,"isPublishEnv":"false","locale":"en_US","country":"US","off_lb":"off","save_lb":"Save","saved_lb ":"Saved","product_saved_lb":"Product Saved","view_your_saved_items_lb":"View your Saved Items","support_lb":"Support","eCommerceLoginUrl":"","eCommerceUrl":"https://integration-5ojmyuq-uvehsuoy25bow.us-5.magentosite.cloud/wishlist/index/index/wishlist_id/","eCommerceWishlistUrl":"https://integration-5ojmyuq-uvehsuoy25bow.us-5.magentosite.cloud/wishlist/index/index/wishlist_id/","inContextLink":"","product_models":[{"category":"Portable","configurator_features_ordered":[{"display_type":"button","internal_name":"formattedCapacity","values":["24TB","20TB","16TB","12TB","10TB","8TB"]},{"display_type":"button","internal_name":"eCommerceDriveDesign","values":["Air","Helium"]},{"display_type":"button","internal_name":"cacheSizeMb","values":["256","512"]},{"display_type":"button","internal_name":"eCommerceRecordingTechnology","values":["CMR","SMR"]}],"ecommerceEnabled":true,"ecommerceProduct":"HDD","inContextLink":"","internal_name":"/one-touch-external-drives-content-hdd-layout-product-detail-master-prod","is_external":true,"name":"HDD","skus":[{"where_to_buy_popup":false,"addToCartWarn":false,"where_to_buy_label":"Where to Buy","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"24TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.1mm/1.028in  101.85mm/4.010in  147.0mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"685g/1.51lb"}],"enableProductReview":true,"addToCartLabel":"Add To Cart","msrp":"","wheretobuy":true,"brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-left.png/_jcr_content/renditions/1-1-small-192x192.png","large":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-left.png/_jcr_content/renditions/1-1-large-640x640.png","isvideo":false},{"small":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-front.png/_jcr_content/renditions/1-1-small-192x192.png","large":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-front.png/_jcr_content/renditions/1-1-large-640x640.png","isvideo":false},{"small":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-right.png/_jcr_content/renditions/1-1-small-192x192.png","large":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-right.png/_jcr_content/renditions/1-1-large-640x640.png","isvideo":false},{"small":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-back.png/_jcr_content/renditions/1-1-small-192x192.png","large":"/content/dam/seagate/assets/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai/images/skyhawk-ai-24tb-back.png/_jcr_content/renditions/1-1-large-640x640.png","isvideo":false}],"overview":" Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST24000VE002","name":"Capacity","comparevalue":"24000","title":"24TB","value":"24TB","class":"feature active","data_stock":"none"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST24000VE002","name":"Drive Design (Air or Helium)","comparevalue":"Helium","title":"Helium","value":"Helium","class":"feature active","data_stock":"none"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST24000VE002","name":"Cache (MB)","comparevalue":"512","title":"cacheSizeMb","value":"512","class":"feature active","data_stock":"none"},{"display_type":"button","internal_name":"eCommerceRecordingTechnology","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST24000VE002","name":"Recording Technology","comparevalue":"SMR","title":"SMR","value":"SMR","class":"feature active","data_stock":"none"}],"ecommerceEnabled":false,"where_to_buy_url":"","modelNo":"ST24000VE002","promotions":[{"promoTagTitle":"","color":"Blue","displayType":"bottom","description":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items- <a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","shortDescription":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items-&nbsp;<a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","displayOnCategoryPage":true,"promoCF":"/content/dam/seagate/en/promotions/promotion---deals","locale":"en_us","promoStartDate":"2024-08-10T05:40:00.000Z","promoEndDate":"2025-11-29T17:53:00.000Z","skus":["/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai-hm/st4000vx016-4tb-skyhawk-serv-hdd-master-sku","/content/dam/seagate/en/content-fragments/products/datasheets/han-solo-firecuda-hdd-amer/amer-han-solo-firecuda-hdd-stkl2000413-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr1000400-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr512400-512gb-sku-master","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st8000dm004-barracuda-3-5-hdd-8tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st6000dm003-barracuda-3-5-hdd-6tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/special-editions/darth-vader-tm-drive/amer-darth-vader-firecuda-hdd-stkk2000411-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/datasheets/ironwolf-pro-12tb/ironwolf-pro-st18000nt001-18-tb-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/playstation/game-drive-m-2-ssd-for-ps5/game-drive-ps5-nvme-ssd-amer-zp1000gp3a1011-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/creative-pro/lacie-d2-professional/d2-professional-stha4000800-4tb-master-sku"],"listofSKUs":["/content/dam/seagate/en/promotions/promotion-sku-list"],"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/creative-pro/lacie-d2-professional/d2-professional-support-master-prod\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>"}],"skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.&nbsp;</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.&nbsp;</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":""},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai-st24000ve002-24tb-prod-sku-master\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 24TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""}},{"where_to_buy_popup":false,"supportChatUrl":"/contacts/","addToCartWarn":false,"where_to_buy_label":"Where to Buy","review_count":"0","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"20TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.11mm/1.028in  101.85mm/4.01in  146.99mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"680g/1.499lb"}],"regular_price":"99.99","uid":"MTk5Ng==","enableProductReview":true,"final_price":"99.99","addToCartLabel":"Add To Cart","msrp":"","wheretobuy":true,"percent_off":"0","currency":"$","id":"1996","brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-left-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-left-image.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-front-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-front-image.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-right-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-right-image.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-back-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-back-image.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE002","name":"Capacity","comparevalue":"20000","title":"20TB","value":"20TB","class":"feature","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE002","name":"Drive Design (Air or Helium)","comparevalue":"Helium","title":"Helium","value":"Helium","class":"feature hide","data_stock":"in"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE002","name":"Cache (MB)","comparevalue":"256","title":"cacheSizeMb","value":"256","class":"feature","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceRecordingTechnology","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE002","name":"Recording Technology","comparevalue":"CMR","title":"CMR","value":"CMR","class":"feature","data_stock":"in"}],"ecommerceEnabled":true,"stock_status":"IN_STOCK","rating_summary":"0","supportChat":"Need help with buying a product? Chat with an Expert","where_to_buy_url":"","modelNo":"ST20000VE002","promotions":[{"promoTagTitle":"Sales","color":"Blue","displayType":"top","description":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items- <a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","shortDescription":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items-&nbsp;<a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","displayOnCategoryPage":true,"promoCF":"/content/dam/seagate/en/promotions/promotion---deals","locale":"en_us","promoStartDate":"2024-08-10T05:40:00.000Z","promoEndDate":"2025-11-29T17:53:00.000Z","skus":["/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai-hm/st4000vx016-4tb-skyhawk-serv-hdd-master-sku","/content/dam/seagate/en/content-fragments/products/datasheets/han-solo-firecuda-hdd-amer/amer-han-solo-firecuda-hdd-stkl2000413-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr1000400-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr512400-512gb-sku-master","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st8000dm004-barracuda-3-5-hdd-8tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st6000dm003-barracuda-3-5-hdd-6tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/special-editions/darth-vader-tm-drive/amer-darth-vader-firecuda-hdd-stkk2000411-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/datasheets/ironwolf-pro-12tb/ironwolf-pro-st18000nt001-18-tb-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/playstation/game-drive-m-2-ssd-for-ps5/game-drive-ps5-nvme-ssd-amer-zp1000gp3a1011-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/creative-pro/lacie-d2-professional/d2-professional-stha4000800-4tb-master-sku"],"listofSKUs":["/content/dam/seagate/en/promotions/promotion-sku-list"],"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/creative-pro/lacie-d2-professional/d2-professional-support-master-prod\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>"},{"promoTagTitle":"BackUp","color":"Green","displayType":"top","description":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items- <a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","shortDescription":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items-&nbsp;<a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","displayOnCategoryPage":true,"promoCF":"/content/dam/seagate/en/promotions/promotion---deals","locale":"en_us","promoStartDate":"2024-08-10T05:40:00.000Z","promoEndDate":"2025-11-29T17:53:00.000Z","skus":["/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai-hm/st4000vx016-4tb-skyhawk-serv-hdd-master-sku","/content/dam/seagate/en/content-fragments/products/datasheets/han-solo-firecuda-hdd-amer/amer-han-solo-firecuda-hdd-stkl2000413-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr1000400-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr512400-512gb-sku-master","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st8000dm004-barracuda-3-5-hdd-8tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st6000dm003-barracuda-3-5-hdd-6tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/special-editions/darth-vader-tm-drive/amer-darth-vader-firecuda-hdd-stkk2000411-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/datasheets/ironwolf-pro-12tb/ironwolf-pro-st18000nt001-18-tb-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/playstation/game-drive-m-2-ssd-for-ps5/game-drive-ps5-nvme-ssd-amer-zp1000gp3a1011-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/creative-pro/lacie-d2-professional/d2-professional-stha4000800-4tb-master-sku"],"listofSKUs":["/content/dam/seagate/en/promotions/promotion-sku-list"],"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/creative-pro/lacie-d2-professional/d2-professional-support-master-prod\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>"},{"promoTagTitle":"Calc","color":"Red","displayType":"Bottom","description":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items- <a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","shortDescription":"<p>Use Promo Code DADSGRADS to get 10% OFF on selected items-&nbsp;<a href=\\"/content/seagate/us/en/products.html\\">test link</a></p>","displayOnCategoryPage":true,"promoCF":"/content/dam/seagate/en/promotions/promotion---deals","locale":"en_us","promoStartDate":"2024-08-10T05:40:00.000Z","promoEndDate":"2025-11-29T17:53:00.000Z","skus":["/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai-hm/st4000vx016-4tb-skyhawk-serv-hdd-master-sku","/content/dam/seagate/en/content-fragments/products/datasheets/han-solo-firecuda-hdd-amer/amer-han-solo-firecuda-hdd-stkl2000413-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr1000400-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/gaming-drives/xbox/storage-expansion-for-xbox-series-x/xbox-expansion-card-series-stjr512400-512gb-sku-master","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st8000dm004-barracuda-3-5-hdd-8tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/internal-drives/barracuda-3-5/st6000dm003-barracuda-3-5-hdd-6tb-sata-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/special-editions/darth-vader-tm-drive/amer-darth-vader-firecuda-hdd-stkk2000411-2tb-sku-master","/content/dam/seagate/en/content-fragments/products/datasheets/ironwolf-pro-12tb/ironwolf-pro-st18000nt001-18-tb-master-sku","/content/dam/seagate/en/content-fragments/products/gaming-drives/playstation/game-drive-m-2-ssd-for-ps5/game-drive-ps5-nvme-ssd-amer-zp1000gp3a1011-1tb-sku-master","/content/dam/seagate/en/content-fragments/products/creative-pro/lacie-d2-professional/d2-professional-stha4000800-4tb-master-sku"],"listofSKUs":["/content/dam/seagate/en/promotions/promotion-sku-list"],"inContextLink":""}],"skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.&nbsp;</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.&nbsp;</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":"/content/dam/seagate/migrated-assets/www-content/product-content/skyhawk/en-us/docs/203249700a.pdf"},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/video-analytics-drives/skyhawk-ai-hdd/skyhawk-ai-st20000ve002-20tb-master-sku\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","stock_status_label":"In Stock","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 20TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""},"currencyCode":"USD","storeCode":"us"},{"where_to_buy_popup":false,"addToCartWarn":false,"where_to_buy_label":"Where to Buy","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"20TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.11mm/1.028in  101.85mm/4.01in  146.99mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"680g/1.499lb"}],"enableProductReview":true,"addToCartLabel":"Add To Cart","msrp":"","wheretobuy":true,"brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai-24-oem-chn-channel/skyhawk-ai-24-oem-chn-channel-ds"},"gallery":[],"overview":"","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE000","name":"Capacity","comparevalue":"20000","title":"20TB","value":"20TB","class":"feature hide","data_stock":"none"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE000","name":"Cache (MB)","comparevalue":"256","title":"cacheSizeMb","value":"256","class":"feature hide","data_stock":"none"}],"ecommerceEnabled":false,"where_to_buy_url":"","modelNo":"ST20000VE000","skuDetail":"","productManual":{"title":"Download User Manual","url":"/content/dam/seagate/migrated-assets/www-content/product-content/skyhawk/en-us/docs/203249700a.pdf"},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/video-analytics-drives/skyhawk-ai-hdd/skyhawk-ai-oem-st20000ve000-20tb-skyhawk-ai-master-sku\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI OEM 20TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""}},{"where_to_buy_popup":false,"addToCartWarn":false,"where_to_buy_label":"Where to Buy","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"20TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.1mm/1.028in  101.85mm/4.010in  147.0mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"685g/1.51lb"}],"enableProductReview":true,"addToCartLabel":"Add To Cart","msrp":"","wheretobuy":true,"brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-left-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-left-image.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-front-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-front-image.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-right-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-hero-right-image.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-back-image.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-20tb-back-image.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE003","name":"Capacity","comparevalue":"20000","title":"20TB","value":"20TB","class":"feature hide","data_stock":"none"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE003","name":"Drive Design (Air or Helium)","comparevalue":"Helium","title":"Helium","value":"Helium","class":"feature hide","data_stock":"none"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST20000VE003","name":"Cache (MB)","comparevalue":"512","title":"cacheSizeMb","value":"512","class":"feature hide","data_stock":"none"}],"ecommerceEnabled":false,"where_to_buy_url":"","modelNo":"ST20000VE003","skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":""},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai-st20000ve003-20tb-prod-sku-master\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 20TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""}},{"where_to_buy_popup":false,"supportChatUrl":"/contacts/","addToCartWarn":false,"where_to_buy_label":"Where to Buy","review_count":"0","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"16TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.11mm/1.028in  101.85mm/4.01in  146.99mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"670g/1.477lb"}],"regular_price":"0.99","uid":"MjEyNA==","enableProductReview":true,"final_price":"0.99","addToCartLabel":"Add To Cart","msrp":"472.99","wheretobuy":true,"percent_off":"0","currency":"$","id":"2124","brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-left-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-left-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-front-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-front-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-right-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-right-600x600.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST16000VE002","name":"Capacity","comparevalue":"16000","title":"16TB","value":"16TB","class":"feature","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST16000VE002","name":"Drive Design (Air or Helium)","comparevalue":"Helium","title":"Helium","value":"Helium","class":"feature hide","data_stock":"in"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST16000VE002","name":"Cache (MB)","comparevalue":"256","title":"cacheSizeMb","value":"256","class":"feature hide","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceRecordingTechnology","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST16000VE002","name":"Recording Technology","comparevalue":"CMR","title":"CMR","value":"CMR","class":"feature hide","data_stock":"in"}],"ecommerceEnabled":true,"stock_status":"IN_STOCK","rating_summary":"0","supportChat":"Need help with buying a product? Chat with an Expert","where_to_buy_url":"","modelNo":"ST16000VE002","skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.&nbsp;</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.&nbsp;</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":"/content/dam/seagate/migrated-assets/www-content/product-content/skyhawk/en-us/docs/200915600a.pdf"},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/video-analytics-drives/skyhawk-ai-hdd/skyhawk-ai-st16000ve002-16tb-master-sku\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","stock_status_label":"In Stock","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 16TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""},"currencyCode":"USD","storeCode":"us"},{"where_to_buy_popup":false,"addToCartWarn":false,"where_to_buy_label":"Where to Buy","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"16TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.1mm/1.028in  101.85mm/4.010in  147.0mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"685g/1.51lb"}],"enableProductReview":true,"addToCartLabel":"Add To Cart","msrp":"","wheretobuy":true,"brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-left-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-left-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-front-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-front-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-right-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-16tb-hero-right-600x600.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST16000VE004","name":"Capacity","comparevalue":"16000","title":"16TB","value":"16TB","class":"feature hide","data_stock":"none"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST16000VE004","name":"Drive Design (Air or Helium)","comparevalue":"Helium","title":"Helium","value":"Helium","class":"feature hide","data_stock":"none"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST16000VE004","name":"Cache (MB)","comparevalue":"512","title":"cacheSizeMb","value":"512","class":"feature hide","data_stock":"none"}],"ecommerceEnabled":false,"where_to_buy_url":"","modelNo":"ST16000VE004","skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":""},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai-st16000ve004-16tb-prod-sku-master\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 16TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""}},{"where_to_buy_popup":false,"supportChatUrl":"/contacts/","addToCartWarn":false,"where_to_buy_label":"Where to Buy","review_count":"0","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"12TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.11mm/1.028in  101.85mm/4.01in  146.99mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"670g/1.477lb"}],"regular_price":"0.99","uid":"MjEyMQ==","enableProductReview":true,"final_price":"0.99","addToCartLabel":"Add To Cart","msrp":"356.99","wheretobuy":true,"percent_off":"0","currency":"$","id":"2121","brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-left-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-left-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-front-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-front-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-right-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-right-600x600.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST12000VE001","name":"Capacity","comparevalue":"12000","title":"12TB","value":"12TB","class":"feature","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST12000VE001","name":"Drive Design (Air or Helium)","comparevalue":"Helium","title":"Helium","value":"Helium","class":"feature hide","data_stock":"in"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST12000VE001","name":"Cache (MB)","comparevalue":"256","title":"cacheSizeMb","value":"256","class":"feature hide","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceRecordingTechnology","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST12000VE001","name":"Recording Technology","comparevalue":"CMR","title":"CMR","value":"CMR","class":"feature hide","data_stock":"in"}],"ecommerceEnabled":true,"stock_status":"IN_STOCK","rating_summary":"0","supportChat":"Need help with buying a product? Chat with an Expert","where_to_buy_url":"","modelNo":"ST12000VE001","skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.&nbsp;</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.&nbsp;</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":"/content/dam/seagate/migrated-assets/www-content/product-content/skyhawk/en-us/docs/200915600a.pdf"},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/video-analytics-drives/skyhawk-ai-hdd/skyhawk-ai-st12000ve001-12tb-master-sku\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","stock_status_label":"In Stock","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 12TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""},"currencyCode":"USD","storeCode":"us"},{"where_to_buy_popup":false,"addToCartWarn":false,"where_to_buy_label":"Where to Buy","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"12TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.1mm/1.028in  101.85mm/4.010in  147.0mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"685g/1.51lb"}],"enableProductReview":true,"addToCartLabel":"Add To Cart","msrp":"","wheretobuy":true,"brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-left-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-left-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-front-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-front-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-right-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-12tb-hero-right-600x600.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST12000VE003","name":"Capacity","comparevalue":"12000","title":"12TB","value":"12TB","class":"feature hide","data_stock":"none"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST12000VE003","name":"Drive Design (Air or Helium)","comparevalue":"Helium","title":"Helium","value":"Helium","class":"feature hide","data_stock":"none"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST12000VE003","name":"Cache (MB)","comparevalue":"512","title":"cacheSizeMb","value":"512","class":"feature hide","data_stock":"none"}],"ecommerceEnabled":false,"where_to_buy_url":"","modelNo":"ST12000VE003","skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":""},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/surveillance-drives/skyhawk-hard-drive/skyhawk-ai-st12000ve003-12tb-prod-sku-master\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 12TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""}},{"where_to_buy_popup":false,"supportChatUrl":"/contacts/","addToCartWarn":false,"where_to_buy_label":"Where to Buy","review_count":"0","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"10TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.11mm/1.028in  101.85mm/4.01in  146.99mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"720g/1.59lb"}],"regular_price":"64.99","uid":"MjEzMw==","enableProductReview":true,"final_price":"64.99","addToCartLabel":"Add To Cart","msrp":"293.99","wheretobuy":true,"percent_off":"0","currency":"$","id":"2133","brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-10tb-hero-left-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-10tb-hero-left-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-10tb-front-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-10tb-front-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-10tb-hero-right-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-10tb-hero-right-600x600.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST10000VE001","name":"Capacity","comparevalue":"10000","title":"10TB","value":"10TB","class":"feature","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST10000VE001","name":"Drive Design (Air or Helium)","comparevalue":"Air","title":"Air","value":"Air","class":"feature","data_stock":"in"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST10000VE001","name":"Cache (MB)","comparevalue":"256","title":"cacheSizeMb","value":"256","class":"feature hide","data_stock":"in"},{"display_type":"button","internal_name":"eCommerceRecordingTechnology","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST10000VE001","name":"Recording Technology","comparevalue":"CMR","title":"CMR","value":"CMR","class":"feature hide","data_stock":"in"}],"ecommerceEnabled":true,"stock_status":"IN_STOCK","rating_summary":"0","supportChat":"Need help with buying a product? Chat with an Expert","where_to_buy_url":"","modelNo":"ST10000VE001","skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.&nbsp;</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.&nbsp;</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":"/content/dam/seagate/migrated-assets/www-content/product-content/skyhawk/en-us/docs/201195100b.pdf"},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/video-analytics-drives/skyhawk-ai-hdd/ds-ST10000VE001-10tb-skyhawk-ai-master-sku\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","stock_status_label":"In Stock","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 10TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""},"currencyCode":"USD","storeCode":"us"},{"where_to_buy_popup":false,"supportChatUrl":"/contacts/","addToCartWarn":false,"where_to_buy_label":"Where to Buy","review_count":"0","hideCTA":false,"hideSkuNumber":false,"key_specs":[{"internal_name":"capacity-ts-master-feat","name":"Capacity","value":"8TB"},{"internal_name":"dimensions-h-w-d-master-feat","name":"Dimensions: H x W x D","value":"26.11mm/1.028in  101.85mm/4.01in  146.99mm/5.787in"},{"internal_name":"weight-master-feat","name":"Weight","value":"720g/1.59lb"}],"regular_price":"63.99","uid":"MjEzMA==","enableProductReview":true,"final_price":"63.99","addToCartLabel":"Add To Cart","msrp":"230.99","wheretobuy":true,"percent_off":"0","currency":"$","id":"2130","brand":"seagate","datasheet":{"title":"Download Data Sheet","url":"/content/dam/seagate/en/content-fragments/products/datasheets/skyhawk-ai/skyhawk-ai-DS1960-15C-2310US-en_US.pdf"},"gallery":[{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-8tb-hero-left-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-8tb-hero-left-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-8tb-front-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-8tb-front-600x600.png","isvideo":false},{"small":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-8tb-hero-right-600x600.png","large":"/content/dam/seagate/migrated-assets/www-content/products/surveillance-drives/skyhawk-hard-drive/_shared/images/skyhawk-ai-8tb-hero-right-600x600.png","isvideo":false}],"overview":"Skyhawk AI is optimized for use in video analytics and imaging applications. Designed with advanced features, it is suitable for use with AI NVRs, servers, and appliances with AI analytics and deep learning capabilities. ","configurator_features":[{"display_type":"button","internal_name":"formattedCapacity","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST8000VE001","name":"Capacity","comparevalue":"8000","title":"8TB","value":"8TB","class":"feature","data_stock":"out"},{"display_type":"button","internal_name":"eCommerceDriveDesign","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST8000VE001","name":"Drive Design (Air or Helium)","comparevalue":"Air","title":"Air","value":"Air","class":"feature hide","data_stock":"out"},{"display_type":"button","internal_name":"cacheSizeMb","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST8000VE001","name":"Cache (MB)","comparevalue":"256","title":"cacheSizeMb","value":"256","class":"feature hide","data_stock":"out"},{"display_type":"button","internal_name":"eCommerceRecordingTechnology","data_name":"/skyhawk-hard-drive-skyhawk-ai-content-layout-product-detail-master-prod","data_model":"ST8000VE001","name":"Recording Technology","comparevalue":"CMR","title":"CMR","value":"CMR","class":"feature hide","data_stock":"out"}],"ecommerceEnabled":true,"stock_status":"OUT_OF_STOCK","rating_summary":"0","supportChat":"Need help with buying a product? Chat with an Expert","where_to_buy_url":"","modelNo":"ST8000VE001","skuDetail":"<ul>\\n<li>ImagePerfect AI: Delivers zero dropped frames while supporting heavier workloads.&nbsp;</li>\\n<li>Versatile Capabilities: Intelligently adapts to the scale of your AI environment, supporting up to 64 HD video streams and 32 AI streams.&nbsp;</li>\\n<li>SkyHawk Health Management: Actively helps protect your surveillance storage by focusing on prevention, intervention, and recovery options. Includes RAID RapidRebuildproviding 3 faster volume rebuilds over traditional RAID rebuilds.</li>\\n<li>Higher Reliability:&nbsp; Enterprise-class, with 2.5M hours MTBF and a 550TB/year workload rate for more than 3 that of standard surveillance HDDs.</li>\\n<li>Recovery Services &amp; Warranty: Five-year limited product warranty and three-year in-house Rescue Data Recovery Services included.</li>\\n</ul>\\n","productManual":{"title":"Download User Manual","url":"/content/dam/seagate/migrated-assets/www-content/product-content/skyhawk/en-us/docs/200915700c.pdf"},"inContextLink":"<a href=\'/editor.html/content/dam/seagate/en/content-fragments/products/video-analytics-drives/skyhawk-ai-hdd/skyhawk-ai-st8000ve001-8tb-master-sku\' class=\'editor-link\' target=\'_blank\'><img src=\'/etc.clientlibs/seagate/clientlibs/clientlib-resources/resources/assets/icons/editor.svg\' style=\'width: 15px; height: 15px;\'></a>","stock_status_label":"Out Of Stock","supportAnchorLink":"/content/seagate/language-masters/en/support/internal-hard-drives/consumer-electronics/skyhawk-ai.html","supportAnchorLabel":"Product Support","name":"SkyHawk AI 8TB","key_specs_column3":{"header":""},"key_specs_column2":{"header":""},"currencyCode":"USD","storeCode":"us"}]}]}');
;// CONCATENATED MODULE: ./stories/assets/json/ecom-ajax.json
var ecom_ajax_namespaceObject = JSON.parse('{"a":[{"sku":"ST20000VE002","id":"2068","uid":"MjA2OA==","deals":"1","ingram_part_number":"JJ7497","stock_status":"IN_STOCK","review_count":"0","rating_summary":"0","regular_price":"99.99","currency":"$","currencyCode":"USD","final_price":"69.99","percent_off":"30","stock_status_label":"In Stock"},{"sku":"ST16000VE002","id":"2065","uid":"MjA2NQ==","deals":"0","ingram_part_number":"7PN655","stock_status":"OUT_OF_STOCK","review_count":"0","rating_summary":"0","regular_price":"99.99","currency":"$","currencyCode":"USD","final_price":"99.99","percent_off":"0","stock_status_label":"Out Of Stock"}]}');
;// CONCATENATED MODULE: ./stories/js/modules/EcomProductDetail/index.js
function EcomProductDetail_toConsumableArray(arr) { return EcomProductDetail_arrayWithoutHoles(arr) || EcomProductDetail_iterableToArray(arr) || EcomProductDetail_unsupportedIterableToArray(arr) || EcomProductDetail_nonIterableSpread(); }

function EcomProductDetail_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function EcomProductDetail_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return EcomProductDetail_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return EcomProductDetail_arrayLikeToArray(o, minLen); }

function EcomProductDetail_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function EcomProductDetail_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return EcomProductDetail_arrayLikeToArray(arr); }

function EcomProductDetail_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// import '../../utilities/MF.js';








core_class.use([autoplay, effect_fade, navigation]);

function EcomProductDetail() {
  console.log('EcomProductDetail');
}

function getSkuFromQuery() {
  var params = new URLSearchParams(document.location.search);
  var hashMode = '';

  if (params.has('sku') && params.get('sku') != '') {
    hashMode = params.get('sku');
  }

  return hashMode;
}

EcomProductDetail.Init = function () {
  var EPD = document.querySelector('.EcomProductDetail');
  var pdpJson,
      result,
      pdpSkuArry = [],
      pdpEcomSkuArry = [];
  var hasEcomSkus = false;
  var pdpEcomSkuData;
  var currentModel = '';
  var currentStock = '';
  var country = 'US',
      site = 'seagate',
      locale = 'en_US',
      lang = 'en';

  if (EPD) {
    var ticking = false;
    var player; // var loading = EPD.querySelector('.loading');

    var pdpHeader = EPD.querySelector('.EcomProductDetail-header');
    var pdpMain = EPD.querySelector('.EcomProductDetail-main');
    var pdpSidebar = EPD.querySelector('.EcomProductDetail-sidebar');
    var pdpVideoModal = document.getElementById('EcomProductDetail-skuVideo-modal');
    var pdpCarousel = EPD.querySelector('.EcomProductDetail-carousels');
    var pdpCarouselMain = EPD.querySelector('.EcomProductDetail-carousels-mainContainer');
    var pdpCarouselThumb = EPD.querySelector('.EcomProductDetail-carousels-thumbContainer');
    var pdpCarouselThumbArrows = pdpCarouselThumb.querySelectorAll('.EcomProductDetail-carousels-navArrowButton');
    var pdpContent = pdpMain.querySelector('.ProductDetail-content');
    var pdpSkuInfos = pdpMain.querySelector('.ProductDetail-skuInfos');
    var pdpSkuFeatures = pdpMain.querySelector('.ProductDetail-skuFeatures');
    var pdpSkuWarranty = pdpMain.querySelector('.EcomProductDetail-warranty');
    var pdpSkuAccordion = pdpMain.querySelector('.EcomProductDetail-accordion');
    var pdpSkuBundle = pdpMain.querySelector('.EcomProductDetail-bundles');
    var pdpSkuCartHeader = pdpHeader.querySelector('.EcomProductDetail-cart');
    var pdpSkuAddToCartHeader;
    var pdpSkuAddToCart = pdpMain.querySelector('.EcomProductDetail-addToCart');
    var pdpSkuWCSW = pdpMain.querySelector('.ProductDetail-skuWCSW');
    var pdpSkuW = pdpMain.querySelector('.ProductDetail-skuW');
    var pdpSkuC = pdpMain.querySelector('.ProductDetail-skuC');
    var pdpSkuS = EPD.querySelectorAll('.ProductDetail-skuS');
    var pdpSkuWa = pdpMain.querySelector('.ProductDetail-skuWa');
    var pdpSkuAPI = pdpMain.querySelector('.EcomProductDetail-apiAlert');
    var pdpSkuAvailable = pdpMain.querySelector('.ProductDetail-available');
    var pdpShowAvailable = false;
    var pdpControl;
    var pdpPlus;
    var pdpMinus;
    var pdpInput;
    var pdpSkuPriceHeader = pdpHeader.querySelector('.product-price');
    var pdpInStock = false;
    var pdpEcommerceEnabled = false;
    var checkIngramAvailability = false;
    var pdpHideCTA = false;
    var isAPIOpen = false;
    var pdpReview = false;
    var bvLoader = false;
    var playIcons;
    var pdpSkuWhere;
    var pdpSkuName;
    var pdpSkuPrice;
    var pdpSkuPriceCurrent;
    var pdpSkuPriceOld;
    var pdpSkuPriceOff;
    var pdpSkuDes;
    var pdpSkuPromos;
    var pdpSkuRating;
    var pdpSkuStock;
    var pdpSkuFeature;
    var pdpSkuFeature_dropdown;
    var pdpSkuFeature_dropdown_toggle;
    var pdpSkuFeature_items;
    var pdpSkuFeature_color;
    var pdpSkuFeature_color_title;
    var pdpSkuModel;
    var pdpSkuNum;
    var pdpSkuCart;
    var pdpSkuCta;
    var EPD_warranty;
    var EPD_warranty_items;
    var comp;
    var pdpLabel_overview = 'Overview';
    var pdpLabel_price = 'MSRP';
    var pdpLabel_model = 'Model No: ';
    var pdpLabel_keySpecs = 'Key Specs';
    var pdpLabel_productInfo = 'Product Info';
    var pdpLabel_where = 'Where to Buy';
    var pdpLabel_documentInfo = 'Documentation';
    var pdpLabel_lifeCycleAssessment = 'Life Cycle Assessment';
    var pdpLabel_currencySymbol = '$';
    var pdpLabel_buyNow = 'Buy Now';
    var pdpLabel_detail = 'Detail';
    var pdpLabel_off = 'off';
    var videoLabel_cta = 'Click to Play';
    var pdpLabel_addToCart = 'add To Cart';
    var pdpLabel_save = 'save';
    var pdpLabel_saved = 'saved';
    var pdpLabel_productSave = 'Product Saved';
    var pdpLabel_viewSavedItems = 'View your Saved Items';
    var pdpLabel_support = 'Support';
    var pdpLabel_unavailable = 'Not Available with Current Selections';
    var pdpLabel_outStock = 'Out of Stock';
    var pdpLabel_showStoreProducts = 'Show products available on Seagate Store';
    var pdpLabel_addToSavedItems = 'Add to Saved Items';
    var pdpLabel_savedItems = 'saved items';
    var pdpLabel_ingramDownMessage = 'Ordering is unavailable at the moment, you can save a product in your [0] or visit after 1am PST to place an order.';
    var pdpLabel_ratingsReviews = 'Ratings & Reviews';
    var pdpLabel_currencyCode = '';
    var wishlistArray = [];
    var wishlistUrl = '';
    var eCommerceLoginUrl = '';
    var eCommerceSamlAction = '';
    var showProductView = true;
    var isPublishEnv = false;
    var cookieMaxAge = 60;
    var observerProductView;

    var watchProductView = function watchProductView() {
      observerProductView = new MutationObserver(function (mutationRecords) {
        console.log("productViewEvent:" + mutationRecords);

        if (mutationRecords && mutationRecords[0] && mutationRecords[0].target) {
          var model = mutationRecords[0].target.querySelector('.value');
          var modelID = EPD.dataset.model;

          if (pdpJson && pdpJson.product_models && pdpJson.product_models[0] && pdpJson.product_models[0].skus) {
            var result = pdpJson.product_models[0].skus.filter(function (sku) {
              return sku.modelNo == modelID;
            });
            checkEcommerceEnabled(result[0]);

            if (showProductView) {
              if (pdpEcommerceEnabled) {
                if (pdpEcomSkuData) {
                  productViewEvent(result[0]);
                }
              } else {
                productViewEvent(result[0]);
              }
            }
          }
        }
      });
      var node = EPD.querySelector('.ProductDetail-skuModel');
      var config = {
        childList: true,
        characterData: true,
        subtree: true
      };

      if (node) {
        observerProductView.observe(node, config);
      }
    };

    if (utilities_CustomUtil.isLocalhost()) {
      pdpJson = ecom_6_namespaceObject;
      initPD(pdpJson);
    } else {
      if (typeof pdpData !== 'undefined') {
        pdpJson = pdpData;
        initPD(pdpJson);
      }
    }

    function checkEcomSkus() {
      hasEcomSkus = pdpEcomSkuArry.length > 0 && pdpEcomSkuArry[0].skus.length > 0;
      return hasEcomSkus;
    }

    function getEcomSkus() {
      if (hasEcomSkus) {
        if (utilities_CustomUtil.isLocalhost()) {
          updatepdpJson(ecom_ajax_namespaceObject.a);
          bindPDP();
        }

        var url = '/ww/ecommerce';
        var action = 'get_product_info';
        var skus = pdpEcomSkuArry[0].skus.toString();
        var storeCode = pdpEcomSkuArry[0].storeCode;
        var locale = pdpEcomSkuArry[0].locale;
        var formGetEcomData = new FormData();
        formGetEcomData.append("action", action);
        formGetEcomData.append("locale", locale);
        formGetEcomData.append("storeCode", storeCode);
        formGetEcomData.append("skus", skus);
        fetch(url, {
          method: "POST",
          body: formGetEcomData
        }).then(function (response) {
          console.log(response);
          return response.json();
        }).then(function (data) {
          console.log(data);
          pdpEcomSkuData = data.data;
          updatepdpJson(pdpEcomSkuData);
          bindPDP(); //resetEcomSkuPriceForFirstLoading();
        }).catch(function (error) {
          console.log(error);
        });
      } else {
        bindPDP();
      }
    }

    function resetEcomSkuPriceForFirstLoading() {
      var priceHtml = '';
      var priceCurrentHtml = '';
      var priceOffHtml = '';
      var sitem = findEcomSku(currentModel, pdpEcomSkuData);

      if (sitem) {
        if (NotUndefined(sitem.final_price)) {
          priceCurrentHtml = priceFormat(lang, sitem.currencyCode, sitem.final_price);
        }

        priceOffHtml = '<span class="old-price"></span><span class="off-price"></span>';

        if (NotUndefined(sitem.final_price) && NotUndefined(sitem.regular_price) && Number(sitem.final_price) < Number(sitem.regular_price)) {
          priceOffHtml = '<span class="old-price">' + priceFormat(lang, sitem.currencyCode, sitem.regular_price) + '</span>' + '<span class="off-price">' + checkUndefined(sitem.percent_off) + pdpLabel_off + '</span>';
        }

        priceHtml = '<span class="current-price">' + priceCurrentHtml + '</span>' + priceOffHtml;

        if (pdpSkuPrice) {
          pdpSkuPrice.innerHTML = priceHtml;
        }

        if (pdpSkuPriceHeader) {
          pdpSkuPriceHeader.innerHTML = priceHtml;
        }

        var resultEcomSku = findEcomSku(currentModel, pdpJson.product_models[0].skus);
        productViewEvent(resultEcomSku);
      }
    }

    function updatepdpJson(pdpEcomSkuData) {
      if (NotUndefined(pdpJson.product_models) && pdpJson.product_models[0].skus.length > 0) {
        if (pdpEcomSkuData && Array.isArray(pdpEcomSkuData)) {
          pdpEcomSkuData.map(function (item) {
            var index = pdpJson.product_models[0].skus.findIndex(function (i2) {
              return i2.modelNo === item.sku;
            });

            if (index != -1) {
              pdpJson.product_models[0].skus[index].final_price = item.final_price;
              pdpJson.product_models[0].skus[index].regular_price = item.regular_price;
              pdpJson.product_models[0].skus[index].percent_off = item.percent_off;
              pdpJson.product_models[0].skus[index].stock_status = item.stock_status;
              pdpJson.product_models[0].skus[index].stock_status_label = item.stock_status_label;
              pdpJson.product_models[0].storeCode = pdpJson.product_models[0].skus[index].storeCode;
            }
          });
        }
      }
    }

    function initPD(data) {
      //loading.classList.add('hide');
      pdpJson = data;
      checkIngramAvailability = pdpJson.checkIngramAvailability;
      checkAPIOpen();
      checkEPD(); //Check if no sku remove EPD

      if (NotUndefined(pdpJson.product_models) && pdpJson.product_models[0].skus.length > 0) {
        newTempSkuArry(); //For Hash

        newTempEcomSkuArry(); //For Ecom

        checkEcomSkus();
        getEcomSkus(); //For Ecom

        document.querySelectorAll('a').forEach(function (link) {
          var href = link.getAttribute('href');

          if (href && href.indexOf('#pd-') != -1) {
            link.addEventListener('click', function (e) {
              e.preventDefault();
              var hashMode = link.getAttribute('href').split('#pd-')[1];
              switchSkuWithHash(hashMode);
              var linkTop = link.parentElement.offsetTop;
              var scrollTo = EPD.offsetTop;

              if (linkTop > scrollTo) {
                var skyNav = document.querySelector('.ShyNav');
                var inPageNav = document.querySelector('.InPageNav');

                if (skyNav) {
                  scrollTo -= skyNav.clientHeight;
                }

                if (inPageNav) {//scrollTo -= inPageNav.clientHeight;
                }
              }

              var tabTop = EPD.offsetTop;
              scrollTo += tabTop;
              window.scrollTo(0, scrollTo);
            });
          }
        });
        window.addEventListener('load', function (event) {//resetFeatureWithHash();
        });
        window.addEventListener('hashchange', function (e) {
          e.preventDefault();
          resetFeatureWithHash();
        }, false);
      }
    }

    function bindPDP() {
      setLabelAndValue();
      initBuildHtml();
      getElements();
      reMappingFeatures();
      checkHash();
      showPromoForDelay();
      bindSkuAvailableEvent();
      bindSkuFeaturesEvent();
      watchProductView();
    }

    function checkHash() {
      if (document.location.hash && document.location.hash.indexOf('pd-') != -1 && document.location.hash != '#pdpReviews' || getSkuFromQuery() != '') {
        resetFeatureWithHash();
      } else {
        reSetFirstFeatureActive();
      }
    }

    function newTempSkuArry() {
      pdpSkuArry.length = 1; //pdpJson.product_models.length;

      for (var j = 0; j < 1; j++) {
        pdpSkuArry[j] = {};
        pdpSkuArry[j].category = pdpJson.product_models[j].internal_name;
        pdpSkuArry[j].locale = pdpJson.locale;
        pdpSkuArry[j].skus = [];

        for (var i = 0; i < pdpJson.product_models[j].skus.length; i++) {
          if (pdpJson.product_models[j].skus[i].storeCode) {
            pdpSkuArry[j].storeCode = pdpJson.product_models[j].skus[i].storeCode;
          }

          pdpSkuArry[j].skus.push(pdpJson.product_models[j].skus[i].modelNo);
        }
      }
    }

    function newTempEcomSkuArry() {
      pdpEcomSkuArry.length = 1; //pdpJson.product_models.length;

      for (var j = 0; j < 1; j++) {
        pdpEcomSkuArry[j] = {};
        pdpEcomSkuArry[j].category = pdpJson.product_models[j].internal_name;
        pdpEcomSkuArry[j].locale = pdpJson.locale;
        pdpEcomSkuArry[j].skus = [];

        for (var i = 0; i < pdpJson.product_models[j].skus.length; i++) {
          if (pdpJson.product_models[j].skus[i].ecommerceEnabled) {
            if (pdpJson.product_models[j].skus[i].storeCode) {
              pdpEcomSkuArry[j].storeCode = pdpJson.product_models[j].skus[i].storeCode;
            }

            pdpEcomSkuArry[j].skus.push(pdpJson.product_models[j].skus[i].modelNo);
          }
        }
      }
    }

    function getCookie(name) {
      var dc = document.cookie;
      var prefix = name + "=";
      var begin = dc.indexOf("; " + prefix);

      if (begin == -1) {
        begin = dc.indexOf(prefix);
        if (begin != 0) return null;
      } else begin += 2;

      var end = document.cookie.indexOf(";", begin);
      if (end == -1) end = dc.length;
      return unescape(dc.substring(begin + prefix.length, end));
    }

    function setMinutesCookie(name, value, minutes) {
      var newDateObj = new Date(new Date().getTime() + minutes * 60000);
      var isoDateString = newDateObj.toUTCString();
      document.cookie = name + "=" + escape(value) + "; expires=" + isoDateString + "; path=/ ;domain=" + (window.location.hostname == "localhost" ? "localhost" : ".seagate.com");
    }

    function setSessionCookie(c_name, value) {
      document.cookie = c_name + "=" + escape(value) + "; path=/ ;domain=" + (window.location.hostname == "localhost" ? "localhost" : ".seagate.com");
    }

    function deleteCookie(c_name) {
      document.cookie = c_name + "=; path=/ ;domain=" + window.location.hostname + "; expires=" + new Date(0).toUTCString();
    }

    function alertSku(sku, quantity) {
      if (typeof miniCart !== 'undefined' && 'addNewSkuToCart' in miniCart) {
        miniCart.addNewSkuToCart(sku);
      }
    }

    function pushAdobeDataLayerEvent(data) {
      console.log(data);

      if (window.adobeDataLayer) {
        window.adobeDataLayer.push(data);
      }
    }

    function getAccountId() {
      var accountId = 'guest';
      var customerToken = getCookie('customer_token');
      var email = getCookie("customer_email_hash");

      if (!(customerToken == null || customerToken == "") && !(email == null || email == "")) {
        accountId = email;
      }

      return accountId;
    }

    function setMiniCartItemSessionStorage(name, value) {
      sessionStorage.setItem(name, value);
    }

    function getMiniCartItemSessionStorage(name) {
      if (sessionStorage.getItem(name)) {
        return sessionStorage.getItem(name);
      }

      return "{\"data\":{}}";
    }

    function showOpenCartEvent(name, openCartEvent, customerCartId) {
      var minicart_items = JSON.parse(getMiniCartItemSessionStorage(name));

      if (minicart_items == null || minicart_items == 'undefined' || !minicart_items['data'] || !minicart_items['data']['items'] || minicart_items['data']['items'].length == 0) {
        openCartEvent['cartID'] = customerCartId;
        pushAdobeDataLayerEvent(openCartEvent);
      }
    }

    function handleAddCartEvent(e) {
      checkAPIOpen();

      if (pdpEcommerceEnabled && pdpInStock) {
        if (isAPIOpen) {
          e.preventDefault();
          document.body.classList.add('PrimaryNavEComm-dropdown-opened');
          var button = e.currentTarget;
          console.log(button);
          var sku = button.getAttribute("data-model");
          var storeCode = button.getAttribute("data-storeCode");
          var quantity = button.getAttribute("data-quantity");
          var currencyCode = button.getAttribute("data-currencyCode");
          var modelName = button.getAttribute("data-modelName");
          var regularPrice = button.getAttribute("data-regularPrice");
          var finalPrice = button.getAttribute("data-finalPrice");
          var productId = button.getAttribute("data-productId");
          console.log(sku);
          var cartId = getCookie('guest_cart_id___' + storeCode);
          var customerToken = getCookie('customer_token');
          var customerCartId = getCookie('customer_cart_id___' + storeCode);
          var actionCreate = 'create_guest_cart_id';
          var actionAdd = 'add_to_guest_cart';
          var url = '/ww/ecommerce';
          var formCreateData = new FormData();
          formCreateData.append("action", actionCreate);
          formCreateData.append("storeCode", storeCode);
          var formAddData1 = new FormData();
          formAddData1.append("action", actionAdd);
          formAddData1.append("sku", sku);
          formAddData1.append("storeCode", storeCode);
          formAddData1.append("quantity", quantity);
          formAddData1.append("customerToken", customerToken);
          var formAddData2 = new FormData();
          formAddData2.append("action", actionAdd);
          formAddData2.append("guest_cart_id", cartId);
          formAddData2.append("sku", sku);
          formAddData2.append("storeCode", storeCode);
          formAddData2.append("quantity", quantity);
          formAddData2.append("customerToken", customerToken);
          var eventData = {
            "event": "add to cart",
            "accountID": getAccountId(),
            "cartID": cartId,
            "quantityAdded": quantity,
            "productInfo": {
              "productID": productId,
              "sku": sku,
              "currencyCode": currencyCode,
              "productName": modelName,
              "modelNum": sku,
              "regularPrice": regularPrice,
              "promoPrice": finalPrice
            }
          };
          var openCartEvent = {
            "event": "open cart",
            "accountID": getAccountId(),
            "cartID": cartId,
            "quantity": quantity,
            "productInfo": {
              "productID": productId,
              "sku": sku,
              "currencyCode": currencyCode,
              "productName": modelName,
              "modelNum": sku,
              "regularPrice": regularPrice,
              "promoPrice": finalPrice
            }
          };

          if (customerToken != null && customerCartId != null) {
            formAddData2.append("customer_cart_id", customerCartId);
            fetch(url, {
              method: "POST",
              body: formAddData2
            }).then(function (response) {
              console.log(response);
              return response.json();
            }).then(function (data) {
              console.log(data);

              if (data.data['errorMsg']) {
                console.log(data.data['errorMsg']);

                if (typeof miniCart !== 'undefined' && 'handleErrorMsg' in miniCart) {
                  miniCart.handleErrorMsg(data.data['errorMsg']);
                }
              } else {
                showOpenCartEvent('minicart_items___' + storeCode, openCartEvent, customerCartId);
                eventData['cartID'] = customerCartId;
                pushAdobeDataLayerEvent(eventData);
                setMiniCartItemSessionStorage('minicart_items___' + storeCode, JSON.stringify(data));
                updateCartCount(data.data);
                alertSku(sku, quantity);
              }
            }).catch(function (error) {
              console.log(error);
            });
          } else if (customerToken == null && customerCartId != null) {
            // if customer cart id is not null but customer token is expired, redirect to login page.

            /*window.location.assign(
                eCommerceLoginUrl
            );*/
            console.log('## customer token expired');

            if (typeof miniCart !== 'undefined' && 'handleErrorMsg' in miniCart) {
              miniCart.handleErrorMsg("Customer Session Expired");
            }

            return;
          } else if (cartId == undefined || cartId == null) {
            var minicart_items = JSON.parse(getMiniCartItemSessionStorage('minicart_items___' + storeCode));

            if (minicart_items != null && minicart_items['data'] && minicart_items['data']['cartId']) {
              cartId = minicart_items['data']['cartId'];
              setMinutesCookie('guest_cart_id___' + storeCode, cartId, cookieMaxAge);
              setMinutesCookie('cartId', cartId, cookieMaxAge);
              console.log("#guest cart id from minicart_items " + cartId);
              formAddData1.append("guest_cart_id", cartId);
              fetch(url, {
                method: "POST",
                body: formAddData1
              }).then(function (response) {
                console.log(response);
                return response.json();
              }).then(function (data) {
                console.log(data);

                if (data.data['errorMsg']) {
                  console.log(data.data['errorMsg']);

                  if (typeof miniCart !== 'undefined' && 'handleErrorMsg' in miniCart) {
                    miniCart.handleErrorMsg(data.data['errorMsg']);
                  }
                } else {
                  showOpenCartEvent('minicart_items___' + storeCode, openCartEvent, getCookie('cartId'));
                  eventData['cartID'] = getCookie('cartId');
                  pushAdobeDataLayerEvent(eventData);
                  setMiniCartItemSessionStorage('minicart_items___' + storeCode, JSON.stringify(data));
                  updateCartCount(data.data);
                  alertSku(sku, quantity);
                }
              }).catch(function (error) {
                console.log(error);
              });
            } else {
              fetch(url, {
                method: "POST",
                body: formCreateData
              }).then(function (response) {
                console.log(response);
                return response.json();
              }).then(function (data) {
                if (data.data['errorMsg']) {
                  console.log(data.data['errorMsg']);

                  if (typeof miniCart !== 'undefined' && 'handleErrorMsg' in miniCart) {
                    miniCart.handleErrorMsg(data.data['errorMsg']);
                  }
                } else {
                  setMinutesCookie('guest_cart_id___' + storeCode, data.data['cartId'], cookieMaxAge);
                  setMinutesCookie('cartId', data.data['cartId'], cookieMaxAge);
                  formAddData1.append("guest_cart_id", data.data['cartId']);
                  fetch(url, {
                    method: "POST",
                    body: formAddData1
                  }).then(function (response) {
                    console.log(response);
                    return response.json();
                  }).then(function (data) {
                    console.log(data);

                    if (data.data['errorMsg']) {
                      console.log(data.data['errorMsg']);

                      if (typeof miniCart !== 'undefined' && 'handleErrorMsg' in miniCart) {
                        miniCart.handleErrorMsg(data.data['errorMsg']);
                      }
                    } else {
                      showOpenCartEvent('minicart_items___' + storeCode, openCartEvent, getCookie('cartId'));
                      eventData['cartID'] = getCookie('cartId');
                      pushAdobeDataLayerEvent(eventData);
                      setMiniCartItemSessionStorage('minicart_items___' + storeCode, JSON.stringify(data));
                      updateCartCount(data.data);
                      alertSku(sku, quantity);
                    }
                  }).catch(function (error) {
                    console.log(error);
                  });
                }
              }).catch(function (error) {
                console.log(error);
              });
            }
          } else {
            fetch(url, {
              method: "POST",
              body: formAddData2
            }).then(function (response) {
              console.log(response);
              return response.json();
            }).then(function (data) {
              console.log(data);

              if (data.data['errorMsg']) {
                console.log(data.data['errorMsg']);

                if (typeof miniCart !== 'undefined' && 'handleErrorMsg' in miniCart) {
                  miniCart.handleErrorMsg(data.data['errorMsg']);
                }
              } else {
                showOpenCartEvent('minicart_items___' + storeCode, openCartEvent, getCookie('cartId'));
                eventData['cartID'] = getCookie('cartId');
                pushAdobeDataLayerEvent(eventData);
                setMiniCartItemSessionStorage('minicart_items___' + storeCode, JSON.stringify(data));
                updateCartCount(data.data);
                alertSku(sku, quantity);
              }
            }).catch(function (error) {
              console.log(error);
            });
          }
        } else {
          location.reload();
        }
      }
    }

    function bindCartEvent() {
      if (pdpSkuAddToCartHeader) {
        pdpSkuAddToCartHeader.removeEventListener('click', handleAddCartEvent);
      }

      document.querySelectorAll('.EcomProductDetail-skuAddToCart').forEach(function (button) {
        button.addEventListener('click', handleAddCartEvent);
      });
    }

    function updateCartCount(data) {
      var carts = document.querySelectorAll('.cart-count');

      if (data && data.total_quantity && carts) {
        carts.forEach(function (cart) {
          cart.innerHTML = data.total_quantity;
        });
      }
    }

    function callSkuSave() {
      var customerToken = getCookie('customer_token');
      var storeCode = EPD.getAttribute("data-storeCode");

      if (storeCode) {
        storeCode = pdpJson.product_models[0].storeCode;
      }

      var actionGetWishList = 'get_wishlist';
      var url = '/ww/ecommerce';
      var formGetWData = new FormData();
      formGetWData.append("action", actionGetWishList);
      formGetWData.append("storeCode", storeCode);
      formGetWData.append("customerToken", customerToken);

      if (customerToken != null) {
        fetch(url, {
          method: "POST",
          body: formGetWData
        }).then(function (response) {
          console.log(response);
          return response.json();
        }).then(function (data) {
          console.log(data);

          if (data.data['errorMsg']) {
            console.log(data.data['errorMsg']);

            if (typeof miniCart !== 'undefined' && 'handleErrorMsg' in miniCart) {
              miniCart.handleErrorMsg(data.data['errorMsg']);
            }
          } else {
            createWishListArray(data.data);
            updateSkuSaveStatus();
          }
        }).catch(function (error) {
          console.log(error);
        });
      } else {//Show Default Save
      }
    }

    function updateSkuSave(data) {
      buildSkuSave(data);
      callSkuSave();

      if (pdpEcommerceEnabled) {
        bindSaveEvent(data);
      }
    }

    function createWishListArray(data) {
      if (data && data.wishlist) {
        data.wishlist.forEach(function (w) {
          wishlistArray.push(w.sku);
        });
      }
    }

    function updateSkuSaveStatus() {
      var saveStatus = false;
      wishlistArray.forEach(function (w) {
        if (w == currentModel) {
          saveStatus = true;
        }
      });

      if (saveStatus) {
        pdpSkuS.forEach(function (item) {
          item.classList.add('saved');

          if (item.querySelector('span')) {
            if (isAPIOpen) {
              item.querySelector('span').innerHTML = pdpLabel_saved;
            } else {
              item.querySelector('span').innerHTML = pdpLabel_addToSavedItems;
              item.querySelector('.ProductDetail-skuSToggle').classList.add('Button-disabled');
            }
          }
        });
      } else {
        pdpSkuS.forEach(function (item) {
          item.classList.remove('saved');

          if (item.querySelector('span')) {
            if (isAPIOpen) {
              item.querySelector('span').innerHTML = pdpLabel_save;
            } else {
              item.querySelector('span').innerHTML = pdpLabel_addToSavedItems;
              item.querySelector('.ProductDetail-skuSToggle').classList.remove('Button-disabled');
            }
          }
        });
      }
    }

    function bindSaveEvent(result) {
      pdpSkuS.forEach(function (pdpSkuS_item) {
        if (pdpSkuS_item.querySelector('.ProductDetail-skuSToggle')) {
          pdpSkuS_item.querySelector('.ProductDetail-skuSToggle').addEventListener('click', function (e) {
            if (!pdpSkuS_item.classList.contains('saved')) {
              var customerToken = getCookie('customer_token');
              var storeCode = EPD.getAttribute("data-storeCode");
              var skuID = EPD.getAttribute("data-id");
              var sku = EPD.getAttribute("data-model");
              var cart = pdpSkuAddToCart.querySelector('.EcomProductDetail-skuAddToCart');
              var quantity = cart != null ? cart.getAttribute("data-quantity") : 1;
              var actionAddWishList = 'add_to_wishlist';
              var url = '/ww/ecommerce';
              var addWishListUrl = wishlistUrl + 'index/add?product=' + skuID;
              saveToWishlistEvent(result);

              if (customerToken != null) {
                window.location.assign(addWishListUrl);
              } else {
                //wishlist_login
                var base64Encoded = btoa(eCommerceSamlAction + wishlistUrl + 'index/add?product=' + skuID);
                var eCommerceWishlistLoginUrl = eCommerceLoginUrl + '/?RelayState=' + base64Encoded;
                window.location.assign(eCommerceWishlistLoginUrl);
              }
            } else {
              pdpSkuS_item.classList.toggle('opened');
            }
          });

          if (pdpSkuS_item.querySelector('.tooltip-close')) {
            pdpSkuS_item.querySelector('.tooltip-close').addEventListener('click', function (e) {
              pdpSkuS_item.classList.remove('opened');
            });
          }
        }
      });
    }

    function bindControlEvent() {
      if (pdpPlus && pdpMinus && pdpInput) {
        pdpPlus.addEventListener('click', function (e) {
          if (!pdpSkuAddToCart.classList.contains('inactive') && !pdpPlus.classList.contains('disabled')) {
            e.preventDefault();
            var inputValue = parseInt(pdpInput.value);

            if (pdpInput.value < 10) {
              pdpInput.value = inputValue + 1;
              updateCartQuantity(pdpInput.value);
            }

            if (pdpInput.value == 10) {
              pdpPlus.classList.add('disabled');
            }
          }
        });
        pdpMinus.addEventListener('click', function (e) {
          if (!pdpSkuAddToCart.classList.contains('inactive')) {
            e.preventDefault();
            var inputValue = parseInt(pdpInput.value);

            if (inputValue > 1) {
              pdpInput.value = inputValue - 1;
            }

            if (pdpInput.value < 10) {
              pdpPlus.classList.remove('disabled');
            }

            updateCartQuantity(pdpInput.value);
          }
        });
        pdpInput.addEventListener('click', function (e) {
          if (!pdpSkuAddToCart.classList.contains('inactive')) {
            updateCartQuantity(parseInt(pdpInput.value));
          }
        });
      }
    }

    function updateCartQuantity(value) {
      document.querySelectorAll('.EcomProductDetail-skuAddToCart').forEach(function (button) {
        button.setAttribute("data-quantity", value);
      });
    }

    function switchSkuWithHash(hashMode) {
      if (currentModel != hashMode) {
        //showProductView = false;
        var type;
        var isHashPDP = false;

        for (var j = 0; j < pdpSkuArry.length; j++) {
          if (pdpSkuArry[j].skus.indexOf(hashMode) !== -1) {
            type = pdpSkuArry[j].category;
            isHashPDP = true;
          }
        }

        if (isHashPDP) {
          currentModel = hashMode;
          updateFeatures(currentModel);
          updateSku(type, currentModel);
        }

        if (pdpJson && pdpJson.product_models && pdpJson.product_models[0] && pdpJson.product_models[0].skus) {
          var result = pdpJson.product_models[0].skus.filter(function (sku) {
            return sku.modelNo == hashMode;
          });

          if (showProductView) {
            productViewEvent(result[0]);
          }
        }

        switchAvailabelStatusWithHash();
      } else {
        reSetFirstFeatureActive();
      }
    }

    function checkHashStore() {
      var params = new URLSearchParams(document.location.search);
      var hashStore = '';

      if (params.has('store')) {
        if (params.get('store') == 1) {
          hashStore = true;
        } else {
          hashStore = false;
        }
      } else {
        hashStore = false;
      }

      return hashStore;
    }

    function switchAvailabelStatusWithHash() {
      var hashStore = checkHashStore();
      var a_checkbox = pdpSkuAvailable.querySelector('.checkbox-available');

      if (a_checkbox && hashStore) {
        var input = a_checkbox.querySelector('input');
        pdpShowAvailable = true;
        input.setAttribute('checked', 'checked');
        updateSkuFeaturesAvailableModel(1);
      }
    }

    function resetFeatureWithHash(hashMode) {
      if (document.location.hash && document.location.hash.indexOf('pd-') != -1 && document.location.hash != '#pdpReviews' || getSkuFromQuery() != '') {
        var hashMode;

        if (document.location.hash && document.location.hash.indexOf('pd-') != -1 && document.location.hash != '#pdpReviews') {
          hashMode = document.location.hash.slice(1);
        } else {
          hashMode = getSkuFromQuery();
        }

        switchSkuWithHash(hashMode);
        var scrollTo = EPD.offsetTop;
        var inPageNav = document.querySelector('.InPageNav');

        if (inPageNav) {
          scrollTo -= inPageNav.clientHeight;
        } ///var tabTop = EPD.offsetTop;
        ///scrollTo += tabTop;


        window.scrollTo(0, scrollTo);

        if (pdpJson && pdpJson.product_models && pdpJson.product_models[0] && pdpJson.product_models[0].skus) {
          var result = pdpJson.product_models[0].skus.filter(function (sku) {
            return sku.modelNo == hashMode;
          });

          if (showProductView) {
            checkEcommerceEnabled(result[0]);

            if (!pdpEcommerceEnabled) {//productViewEvent(result[0]);
            }
          }
        }
      }
    }

    function checkEPD() {
      if (pdpJson == undefined || pdpJson.product_models == undefined || pdpJson.product_models.length == 0 || pdpJson.product_models[0].skus == undefined || pdpJson.product_models[0].skus.length == 0) {
        EPD.parentElement.removeChild(EPD);
      }
    }

    function buildImgEditIcon(data) {
      var html = '';

      if (NotUndefined(data.inContextLink)) {
        html = data.inContextLink;
      }

      return html;
    }

    function setLabelAndValue() {
      country = NotUndefined(pdpJson.country) ? pdpJson.country : country;
      site = NotUndefined(pdpJson.site) ? pdpJson.site : site;
      locale = NotUndefined(pdpJson.locale) ? pdpJson.locale : locale;
      lang = NotUndefined(pdpJson.locale.split('_')[0]) ? pdpJson.locale.split('_')[0] : lang;
      pdpLabel_currencySymbol = NotUndefined(pdpJson.currency_symbol) ? pdpJson.currency_symbol : pdpLabel_currencySymbol;
      pdpLabel_overview = NotUndefined(pdpJson.overview_label) ? pdpJson.overview_label : pdpLabel_overview;
      pdpLabel_price = NotUndefined(pdpJson.msrp_label) ? pdpJson.msrp_label : pdpLabel_price;
      pdpLabel_model = NotUndefined(pdpJson.modelno_label) ? pdpJson.modelno_label : pdpLabel_model;
      pdpLabel_keySpecs = NotUndefined(pdpJson.key_specs_label) ? pdpJson.key_specs_label : pdpLabel_keySpecs;
      pdpLabel_productInfo = NotUndefined(pdpJson.productinfo_label) ? pdpJson.productinfo_label : pdpLabel_productInfo;
      pdpLabel_where = NotUndefined(pdpJson.where_to_buy_label) ? pdpJson.where_to_buy_label : pdpLabel_where;
      pdpLabel_documentInfo = NotUndefined(pdpJson.documentation_label) ? pdpJson.documentation_label : pdpLabel_documentInfo;
      pdpLabel_lifeCycleAssessment = NotUndefined(pdpJson.lifeCycleAssessment) ? pdpJson.lifeCycleAssessment : pdpLabel_lifeCycleAssessment;
      pdpLabel_buyNow = NotUndefined(pdpJson.buynowbutton) ? pdpJson.buynowbutton : pdpLabel_buyNow;
      videoLabel_cta = NotUndefined(pdpJson.videocta) ? pdpJson.videocta : videoLabel_cta;
      pdpLabel_detail = NotUndefined(pdpJson.detail_label) ? pdpJson.detail_label : pdpLabel_detail;
      pdpLabel_off = NotUndefined(pdpJson.off_lb) ? '% ' + pdpJson.off_lb : '% ' + pdpLabel_off;
      pdpLabel_save = NotUndefined(pdpJson.save_lb) ? pdpJson.save_lb : pdpLabel_save;
      pdpLabel_saved = NotUndefined(pdpJson.saved_lb) ? pdpJson.saved_lb : pdpLabel_saved;
      pdpLabel_productSave = NotUndefined(pdpJson.product_save_lb) ? pdpJson.product_save_lb : pdpLabel_productSave;
      pdpLabel_viewSavedItems = NotUndefined(pdpJson.view_your_saved_items_lb) ? pdpJson.view_your_saved_items_lb : pdpLabel_viewSavedItems;
      pdpLabel_addToCart = NotUndefined(pdpJson.addToCartLabel) ? pdpJson.addToCartLabel : pdpLabel_addToCart;
      pdpLabel_support = NotUndefined(pdpJson.support_lb) ? pdpJson.support_lb : pdpLabel_support;
      pdpLabel_unavailable = NotUndefined(pdpJson.not_available_selections_label) ? pdpJson.not_available_selections_label : pdpLabel_unavailable;
      pdpLabel_outStock = NotUndefined(pdpJson.out_of_stock_label) ? pdpJson.out_of_stock_label : pdpLabel_outStock;
      pdpLabel_showStoreProducts = NotUndefined(pdpJson.show_store_products_label) ? pdpJson.show_store_products_label : pdpLabel_showStoreProducts;
      pdpLabel_addToSavedItems = NotUndefined(pdpJson.add_to_saved_items) ? pdpJson.add_to_saved_items : pdpLabel_addToSavedItems;
      pdpLabel_savedItems = NotUndefined(pdpJson.saved_items) ? pdpJson.saved_items : pdpLabel_savedItems;
      pdpLabel_ingramDownMessage = NotUndefined(pdpJson.ingram_down_message) ? pdpJson.ingram_down_message : pdpLabel_ingramDownMessage;
      pdpLabel_ratingsReviews = NotUndefined(pdpJson.ratings_reviews_label) ? pdpJson.ratings_reviews_label : pdpLabel_ratingsReviews;
      pdpLabel_currencyCode = NotUndefined(pdpJson.currencyCode) ? pdpJson.currencyCode : pdpLabel_currencyCode;
      isPublishEnv = NotUndefined(pdpJson.isPublishEnv) ? pdpJson.isPublishEnv == 'false' ? false : true : false;
      wishlistUrl = pdpJson.eCommerceWishlistUrl;
      eCommerceLoginUrl = pdpJson.eCommerceLoginUrl;
      eCommerceSamlAction = pdpJson.eCommerceSamlAction;
      cookieMaxAge = NotUndefined(pdpJson.cookieMaxAge) ? Number.parseInt(pdpJson.cookieMaxAge) : cookieMaxAge;
    }

    function getElements() {
      pdpSkuName = pdpMain.querySelector('.ProductDetail-skuName');
      pdpSkuPriceHeader = pdpHeader.querySelector('.product-price');
      pdpSkuPrice = pdpMain.querySelector('.ProductDetail-skuPrice');
      pdpSkuPriceCurrent = pdpMain.querySelector('.ProductDetail-skuPrice .current-price');
      pdpSkuPriceOld = pdpMain.querySelector('.ProductDetail-skuPrice .old-price');
      pdpSkuPriceOff = pdpMain.querySelector('.ProductDetail-skuPrice .off-price');
      pdpSkuDes = pdpMain.querySelector('.ProductDetail-skuDes');
      pdpSkuPromos = pdpMain.querySelectorAll('.ProductDetail-skuPromos');
      pdpSkuRating = pdpMain.querySelector('.ProductDetail-skuRating');
      pdpSkuFeature = pdpMain.querySelectorAll('.ProductDetail-skuFeature');
      pdpSkuFeature_dropdown = pdpMain.querySelectorAll('.ProductDetail-skuFeature .sDropdown');
      pdpSkuFeature_dropdown_toggle = pdpMain.querySelectorAll('.ProductDetail-skuFeature .sDropdown-toggle');
      pdpSkuFeature_items = pdpMain.querySelectorAll('.ProductDetail-skuFeature  .feature');
      pdpSkuFeature_color = pdpMain.querySelector('.ProductDetail-skuFeature-color');
      pdpSkuFeature_color_title = pdpSkuFeature_color ? pdpSkuFeature_color.parentElement.querySelector('.color-title') : null;
      pdpSkuModel = pdpMain.querySelector('.ProductDetail-skuModel');
      pdpSkuWhere = pdpMain.querySelector('.ProductDetail-skuWhere');
      pdpSkuCta = pdpMain.querySelector('.ProductDetail-skuCta');
      pdpSkuStock = pdpMain.querySelector('.ProductDetail-skuStock');
      pdpControl = pdpMain.querySelector('.EcomProductDetail-control');
      pdpPlus = pdpControl ? pdpControl.querySelector('.control-plus') : null;
      pdpMinus = pdpControl ? pdpControl.querySelector('.control-minus') : null;
      pdpInput = pdpControl ? pdpControl.querySelector('.control-input') : null;
      EPD_warranty = EPD.querySelector('.EcomProductDetail-warranty');
      EPD_warranty_items = EPD_warranty ? EPD_warranty.querySelectorAll('.EcomProductDetail-media') : null;
      pdpSkuS = EPD.querySelectorAll('.ProductDetail-skuS');
      playIcons = EPD.querySelectorAll('.play-icon');
    }

    function checkUndefined(e) {
      if (e == null || e == undefined || e == '' || e.length == 0) {
        return '';
      } else {
        return e;
      }
    }

    function NotUndefined(e) {
      if (e == null || e == undefined || e == '' || e.length == 0) {
        return false;
      } else {
        return true;
      }
    }

    function reMappingFeatures() {
      //debugger;
      currentModel = EPD.getAttribute('data-model');

      if (NotUndefined(pdpSkuFeature)) {
        pdpSkuFeature.forEach(function (feature) {
          var items = feature.querySelectorAll('.feature');
          var items_hide = feature.querySelectorAll('.feature.hide');

          if (NotUndefined(items_hide)) {
            items_hide.forEach(function (item_hide) {
              items.forEach(function (item) {
                if (item_hide.getAttribute('data-val') == item.getAttribute('data-val')) {
                  var model_hide = item_hide.getAttribute('data-model');
                  var model = item.getAttribute('data-model');
                  model_hide.split(',').forEach(function (m) {
                    if (model.split(',').indexOf(m) === -1) {
                      model = model + ',' + m;
                    }
                  });
                  item.setAttribute('data-model', model);
                }
              });
              items_hide.forEach(function (item) {
                if (NotUndefined(item.parentNode)) {
                  item.parentNode.removeChild(item);
                }
              });
            });
          }

          items.forEach(function (item) {
            var model = item.getAttribute('data-model');
            var modelAvailable = '';
            model.split(',').forEach(function (m) {
              if (m.split('--')[1] == 'in' || m.split('--')[1] == 'out') {
                modelAvailable = modelAvailable == '' ? m : modelAvailable + ',' + m;
              }
            });
            item.setAttribute('data-model-available', modelAvailable);
          });
          items.forEach(function (item) {
            var model = item.getAttribute('data-model');
            var modelUnAvailable = '';
            model.split(',').forEach(function (m) {
              if (m.split('--')[1] == 'none') {
                modelUnAvailable = modelUnAvailable == '' ? m : modelUnAvailable + ',' + m;
              }
            });
            item.setAttribute('data-model-unavailable', modelUnAvailable);
          });

          if (feature.querySelector('select')) {
            items = feature.querySelectorAll('.feature');

            if (items.length == 1) {
              feature.querySelector('select').setAttribute('disabled', 'true');
            }
          }

          if (feature.querySelector('.sDropdown')) {
            items = feature.querySelectorAll('.feature');

            if (items.length == 1) {
              feature.querySelector('.sDropdown').setAttribute('disabled', 'true');
            }
          }
        });
      }
    }

    function reSetFirstFeatureActive() {
      if (NotUndefined(pdpSkuFeature)) {
        var feature = pdpSkuFeature[0].querySelectorAll('.feature');

        if (!feature[0].classList.contains('active')) {
          var first_model = feature[0].getAttribute('data-model').split(',')[0];
          currentModel = first_model.split('--')[0];
          currentStock = first_model.split('--')[1];
          EPD.setAttribute('data-model', currentModel);
          EPD.setAttribute('data-stock', currentStock);
          updateFeatures(first_model);
          var type = feature[0].getAttribute('data-type');
          updateSku(type, first_model);
        } else {
          updateFeaturesStatus();
          setSkuFeatureColorTitle();
        }

        if (checkHashStore()) {
          setTimeout(function () {
            switchAvailabelStatusWithHash();
          }, 100);
        } else {
          updateToFirstActive();
        }
      } else {
        if (getSkuFromQuery() == '') {
          if (pdpJson && pdpJson.product_models && pdpJson.product_models[0] && pdpJson.product_models[0].skus) {
            var result = pdpJson.product_models[0].skus[0];

            if (result) {
              productViewEvent(result);
            }
          }
        }
      }
    }

    function updateToFirstActive() {
      var isFirst = true;

      for (var i = 1; i < pdpSkuFeature.length; i++) {
        var feature = pdpSkuFeature[i].querySelectorAll('.feature:not(.feature-none)')[0];

        if (feature && !feature.classList.contains('active')) {
          isFirst = false;
          setTimeout(function () {
            feature.click();
          }, 100);
        } else {
          continue;
        }
      }

      setTimeout(function () {
        if (isFirst) {
          var model = currentModel;

          if (pdpJson && pdpJson.product_models && pdpJson.product_models[0] && pdpJson.product_models[0].skus) {
            var result = pdpJson.product_models[0].skus.filter(function (sku) {
              return sku.modelNo == model;
            });
            checkEcommerceEnabled(result[0]); //if(!pdpEcommerceEnabled){

            productViewEvent(result[0]); //}
          }
        }
      }, 200);
    }

    function updateFeaturesStatus() {
      if (NotUndefined(pdpSkuFeature)) {
        var feature1 = pdpSkuFeature[0].querySelectorAll('.feature');
        var feature1_active = pdpSkuFeature[0].querySelector('.feature.active');
        var active1Models = [];
        var active2Models = [];

        if (NotUndefined(feature1_active)) {
          active1Models = pdpShowAvailable ? feature1_active.getAttribute('data-model-available').split(',') : feature1_active.getAttribute('data-model').split(',');
          active2Models = feature1_active.getAttribute('data-model-unavailable').split(',');

          if (feature1_active.tagName.toLowerCase() == 'option') {
            feature1_active.selected = true;
          }
        }

        for (var i = 1; i < pdpSkuFeature.length; i++) {
          var feature = pdpSkuFeature[i].querySelectorAll('.feature');
          var feature_active = pdpSkuFeature[i].querySelector('.feature.active');
          var foundArry = [];
          var foundOutArry = [];
          var foundAll = false;
          var found = false;
          var foundOut = false;
          var foundNone = false;

          if (!NotUndefined(feature_active)) {
            found = false;
            foundAll = false;

            for (var k = 0; k < feature.length; k++) {
              feature[k].classList.add('feature-none');
            }
          } else {
            var activeModels = pdpShowAvailable ? feature_active.getAttribute('data-model-available').split(',') : feature_active.getAttribute('data-model').split(',');
            var activeNoneModels = feature_active.getAttribute('data-model-unavailable').split(',');

            if (active1Models.length == 0) {
              active1Models = activeModels;
            }

            if (active2Models.length == 0) {
              active2Models = activeNoneModels;
            }

            for (var j = 0; j < feature.length; j++) {
              var models = pdpShowAvailable ? feature[j].getAttribute('data-model-available').split(',') : feature[j].getAttribute('data-model').split(',');
              var nonemodels = feature[j].getAttribute('data-model-unavailable').split(',');
              found = models.some(function (r) {
                if (active1Models.indexOf(r) >= 0) {
                  return true;
                } else {
                  return false;
                }
              });
              foundOut = models.some(function (r) {
                if (active1Models.indexOf(r) >= 0 && r.indexOf('out') != -1) {
                  return true;
                } else {
                  return false;
                }
              });
              foundNone = nonemodels.some(function (r) {
                if (active2Models.indexOf(r) >= 0 && r.indexOf('none') != -1) {
                  return true;
                } else {
                  return false;
                }
              });

              if (found) {
                foundArry.push(j);

                if (feature[j].classList.contains('feature-none')) {
                  feature[j].classList.remove('feature-none');
                }

                if (foundOut) {
                  foundOutArry.push(j);

                  if (feature[j].classList.contains('feature-none')) {
                    feature[j].classList.remove('feature-none');
                  }
                }
              } else {
                if (!pdpShowAvailable) {
                  feature[j].classList.add('feature-none');
                } else {
                  if (!foundNone) {
                    feature[j].classList.add('feature-none'); //console.log('issue');
                  } else {
                    feature[j].classList.remove('feature-none');
                  }
                }

                if (feature[j].classList.contains('active')) {
                  feature[j].classList.remove('active');
                }
              }
            }

            if (foundArry.length == 0) {
              if (NotUndefined(pdpSkuFeature[i].querySelectorAll('select'))) {
                pdpSkuFeature[i].classList.add('none');
              }

              if (NotUndefined(pdpSkuFeature[i].querySelectorAll('.sDropdown'))) {
                pdpSkuFeature[i].classList.add('none');
              }
            } else {
              if (NotUndefined(pdpSkuFeature[i].querySelectorAll('select'))) {
                if (pdpSkuFeature[i].classList.contains('none')) {
                  pdpSkuFeature[i].classList.remove('none');
                }

                if (foundOutArry.length > 0) {
                  pdpSkuFeature[i].classList.add('none');
                }
              }

              if (NotUndefined(pdpSkuFeature[i].querySelectorAll('.sDropdown'))) {
                if (pdpSkuFeature[i].classList.contains('none')) {
                  pdpSkuFeature[i].classList.remove('none');
                }

                if (foundOutArry.length > 0) {
                  pdpSkuFeature[i].classList.add('none');
                }
              }

              foundArry.forEach(function (k) {
                if (feature[k].parentElement.querySelectorAll('.feature.active').length == 0) {
                  feature[k].classList.add('active');
                }

                if (feature[k].classList.contains('active')) {
                  if (feature[k].tagName.toLowerCase() == 'option') {
                    feature[k].selected = true;
                  } else {//feature[k].click();
                  }
                }

                if (feature[k].tagName.toLowerCase() == 'option' || feature[k].classList.contains('sDropdown-item')) {
                  if (feature[k].classList.contains('feature-out')) {
                    var text = feature[k].getAttribute('data-val');
                    feature[k].innerHTML = text + ' (' + pdpLabel_outStock + ')';
                  } else {
                    var text = feature[k].getAttribute('data-val');
                    feature[k].innerHTML = text;
                  }
                }
              });
              feature_active = pdpSkuFeature[i].querySelector('.feature.active');
              activeModels = pdpShowAvailable ? feature_active.getAttribute('data-model-available').split(',') : feature_active.getAttribute('data-model').split(',');
              active1Models = active1Models.filter(function (e) {
                return activeModels.indexOf(e) !== -1;
              });
            }
          }
        }

        updateOutFeaturesStatus();
        setcurrentModel();
        updatePrimaryUnavailableFeaturesStatus();
        updateOutFeaturesSelectStatus();
        updateSkuFeaturesAvailableModel(0);
        updateNoneFeaturesLabelStatus();
      }
    }

    function updatePrimaryUnavailableFeaturesStatus() {
      if (NotUndefined(pdpSkuFeature)) {
        var primary_features = pdpSkuFeature[0].querySelectorAll('.feature');

        if (pdpSkuFeature.length > 1) {
          for (var i = 1; i < 2; i++) {
            var last_feature_active = pdpSkuFeature[i].querySelector('.feature.active');

            if (last_feature_active) {
              var last_active_model = last_feature_active.getAttribute('data-model').split(',');
              primary_features.forEach(function (primary_feature) {
                var found = false;
                var primary_model = primary_feature.getAttribute('data-model').split(',');
                found = primary_model.some(function (r) {
                  if (last_active_model.indexOf(r) >= 0) {
                    return true;
                  } else {
                    return false;
                  }
                });

                if (!found) {
                  primary_feature.classList.add('feature-none');

                  if (primary_feature.tagName.toLowerCase() == 'option' || primary_feature.classList.contains('sDropdown-item')) {
                    var text = primary_feature.getAttribute('data-val');
                    primary_feature.innerHTML = text + ' (' + pdpLabel_unavailable + ')';
                  }
                } else {
                  primary_feature.classList.remove('feature-none');

                  if (primary_feature.tagName.toLowerCase() == 'option' || primary_feature.classList.contains('sDropdown-item')) {
                    var text = primary_feature.getAttribute('data-val');
                    primary_feature.innerHTML = text;
                  }
                }
              });
            }
          }
        }
      }
    }

    function updateOutFeaturesStatus() {
      if (NotUndefined(pdpSkuFeature)) {
        for (var i = 1; i < pdpSkuFeature.length; i++) {
          var features = pdpSkuFeature[i].querySelectorAll('.feature');
          var feature_active = pdpSkuFeature[i].querySelectorAll('.feature.active');
          features.forEach(function (feature) {
            feature.classList.remove('has-feature-out');
            feature.classList.remove('feature-out');
          });
        }

        var primary_features = pdpSkuFeature[0].querySelectorAll('.feature:not(.feature-none)');
        var primary_feature_active = pdpSkuFeature[0].querySelector('.feature.active');
        var primary_feature_active_model = pdpShowAvailable ? primary_feature_active.getAttribute('data-model-available').split(',') : primary_feature_active.getAttribute('data-model').split(',');
        var primary_feature_active_not_out_model = primary_feature_active_model.filter(function (r) {
          return r.indexOf('-in') != -1 || r.indexOf('-none') != -1;
        });
        primary_features.forEach(function (primary_feature) {
          var primary_feature_model = pdpShowAvailable ? primary_feature.getAttribute('data-model-available').split(',') : primary_feature.getAttribute('data-model').split(',');
          var primary_feature_not_out_model = primary_feature_model.filter(function (r) {
            return r.indexOf('-in') != -1 || r.indexOf('-none') != -1;
          });
          var hasnoavailable = primary_feature_model.length == 1 && primary_feature_model[0] == '';

          if (primary_feature_not_out_model.length == 0) {
            if (!hasnoavailable) {
              primary_feature.classList.add('feature-out');
            }
          } else {
            primary_feature.classList.remove('feature-out');
          }
        });

        if (primary_feature_active.classList.contains('feature-out')) {
          var pf_active_model = primary_feature_active.getAttribute('data-model').split(',');
          var pf_active_not_out_model = pf_active_model.filter(function (r) {
            return r.indexOf('-in') != -1 || r.indexOf('-none') != -1;
          });

          if (pf_active_not_out_model == 0) {
            for (var s = 1; s < pdpSkuFeature.length; s++) {
              var features = pdpSkuFeature[s].querySelectorAll('.feature');
              features.forEach(function (feature) {
                feature.classList.add('feature-out');
              });
            }
          }
        }

        for (var i = 1; i < pdpSkuFeature.length; i++) {
          var prev = i;
          var prev_active_feature_model;
          var prev_active_feature_out_model = primary_feature_active_model;
          var prev_active_feature_all_model = primary_feature_active_model; //To get prev rows active-feature out model array

          for (var t = 1; t < prev; t++) {
            var prev_active_feature = pdpSkuFeature[t].querySelector('.feature.active');
            prev_active_feature_model = pdpShowAvailable ? prev_active_feature.getAttribute('data-model-available').split(',') : prev_active_feature.getAttribute('data-model').split(',');
            prev_active_feature_out_model = prev_active_feature_out_model.filter(function (r) {
              return r.indexOf('-out') != -1 && prev_active_feature_model.indexOf(r) != -1;
            });
            prev_active_feature_all_model = prev_active_feature_all_model.filter(function (r) {
              return prev_active_feature_model.indexOf(r) != -1;
            });
          }

          var features = pdpSkuFeature[i].querySelectorAll('.feature:not(.feature-none)');

          for (var j = 0; j < features.length; j++) {
            var feature = features[j];
            var feature_model = pdpShowAvailable ? feature.getAttribute('data-model-available').split(',') : feature.getAttribute('data-model').split(',');
            var feature_out_model = prev_active_feature_out_model.filter(function (r) {
              return r.indexOf('-out') != -1 && feature_model.indexOf(r) != -1;
            });

            if (feature_out_model.length > 0) {
              feature.classList.add('has-feature-out');
            }
          }

          ;
        }

        var last_features = pdpSkuFeature[pdpSkuFeature.length - 1].querySelectorAll('.feature:not(.feature-none)');
        var last_active_feature = pdpSkuFeature[pdpSkuFeature.length - 1].querySelector('.feature.active');
        var last_active_feature_model;

        if (last_active_feature) {
          last_active_feature_model = pdpShowAvailable ? last_active_feature.getAttribute('data-model-available').split(',') : last_active_feature.getAttribute('data-model').split(',');
        }

        last_features.forEach(function (last_feature) {
          if (last_feature.classList.contains('has-feature-out')) {
            last_feature.classList.add('feature-out');
          }
        });

        for (var k = pdpSkuFeature.length - 2; k > 0; k--) {
          var prev = k - 1;
          var prev_active_feature_model;
          var prev_active_feature_out_model = primary_feature_active_model;
          var prev_active_feature_all_model = primary_feature_active_model; //To get prev rows active-feature out model array

          for (var t = 1; t < prev; t++) {
            var prev_active_feature = pdpSkuFeature[t].querySelector('.feature.active');
            prev_active_feature_model = pdpShowAvailable ? prev_active_feature.getAttribute('data-model-available').split(',') : prev_active_feature.getAttribute('data-model').split(',');
            prev_active_feature_out_model = prev_active_feature_out_model.filter(function (r) {
              return r.indexOf('-out') != -1 && prev_active_feature_model.indexOf(r) != -1;
            });
            prev_active_feature_all_model = prev_active_feature_all_model.filter(function (r) {
              return prev_active_feature_model.indexOf(r) != -1;
            });
          }

          var out_features = pdpSkuFeature[k].querySelectorAll('.feature.has-feature-out');
          var next_features = pdpSkuFeature[k + 1].querySelectorAll('.feature:not(.feature-none)');
          out_features.forEach(function (out_feature) {
            var out_feature_model = pdpShowAvailable ? out_feature.getAttribute('data-model-available').split(',') : out_feature.getAttribute('data-model').split(',');
            var out_feature_out_model = prev_active_feature_all_model.filter(function (r) {
              return out_feature_model.indexOf(r) != -1;
            });

            if (pdpShowAvailable) {
              out_feature_out_model = out_feature_out_model.filter(function (r) {
                return last_active_feature_model.indexOf(r) != -1;
              });
            }

            var out_model = false;

            if (out_feature_out_model.length > 0) {
              out_model = out_feature_out_model.every(function (r) {
                return r.split('--')[1] == 'out';
              });
            }

            if (out_model) {
              out_feature.classList.add('feature-out');
            }
          });
        }
      }
    }

    function updateOutFeaturesSelectStatus() {
      if (NotUndefined(pdpSkuFeature)) {
        if (EPD.getAttribute('data-stock') == 'out') {
          for (var i = 0; i < pdpSkuFeature.length; i++) {
            var feature_active = pdpSkuFeature[i].querySelector('.feature.active');

            if (feature_active) {
              feature_active.classList.add('feature-out');
            }
          }
        }

        for (var i = 0; i < pdpSkuFeature.length; i++) {
          var features = pdpSkuFeature[i].querySelectorAll('.feature');
          features.forEach(function (feature) {
            if (feature.tagName.toLowerCase() == 'option' || feature.classList.contains('sDropdown-item')) {
              if (feature.classList.contains('feature-out') || feature.classList.contains('out')) {
                var text = feature.getAttribute('data-val');
                feature.innerHTML = text + ' (' + pdpLabel_outStock + ')';

                if (feature.classList.contains('active')) {
                  pdpSkuFeature[i].classList.add('out');
                } else {
                  if (feature.classList.contains('feature-none')) {
                    if (i == 0) {
                      feature.innerHTML = text + ' (' + pdpLabel_unavailable + ')';
                    }
                  }
                }
              } else {
                if (feature.classList.contains('feature-none')) {
                  var text = feature.getAttribute('data-val');

                  if (i == 0) {
                    feature.innerHTML = text + ' (' + pdpLabel_unavailable + ')';
                  } else {
                    feature.innerHTML = text;
                  }

                  if (feature.classList.contains('active')) {
                    pdpSkuFeature[i].classList.add('none');
                  }
                } else {
                  var text = feature.getAttribute('data-val');
                  feature.innerHTML = text;

                  if (feature.classList.contains('active')) {
                    pdpSkuFeature[i].classList.remove('none');
                    pdpSkuFeature[i].classList.remove('out');
                  }
                }
              }
            }
          });

          if (pdpSkuFeature[i].querySelector('.sDropdown')) {
            var dropdownLabel = pdpSkuFeature[i].querySelector('.sDropdown-label');
            var dropdownActiveFeature = pdpSkuFeature[i].querySelector('.feature.active');
            dropdownLabel.innerHTML = dropdownActiveFeature.innerHTML;
          }
        }
      }
    }

    function bindSkuAvailableEvent() {
      var a_checkbox = pdpSkuAvailable.querySelector('.checkbox-available');

      if (a_checkbox) {
        var input = a_checkbox.querySelector('input');
        input.addEventListener('click', function () {
          var checked = input.checked;
          pdpShowAvailable = checked;

          if (checked) {
            input.setAttribute('checked', 'checked');
          } else {
            input.removeAttribute('checked');
          }

          updateSkuFeaturesAvailableModel(1);
        });
      }
    }

    function updateSkuFeaturesAvailableModel(flag) {
      if (NotUndefined(pdpSkuFeature)) {
        pdpSkuFeature_items = pdpMain.querySelectorAll('.ProductDetail-skuFeature  .feature');

        if (pdpShowAvailable) {
          pdpSkuFeature_items.forEach(function (item, index) {
            if (item.classList.contains('unavailable')) {
              item.classList.remove('unavailable');
            }

            if (item.classList.contains('has-unavailable')) {
              item.classList.remove('has-unavailable');
            }
          });
          pdpSkuFeature_items.forEach(function (item, index) {
            var modelNotAvailable = item.getAttribute('data-model-available');

            if (modelNotAvailable == null || modelNotAvailable == '') {
              item.classList.add('unavailable');
            }
          });
          var primary_features = pdpSkuFeature[0].querySelectorAll('.feature:not(.feature-none)');
          var primary_feature_active = pdpSkuFeature[0].querySelector('.feature.active');
          var primary_feature_active_model = primary_feature_active.getAttribute('data-model').split(',');

          if (primary_feature_active.classList.contains('unavailable')) {
            for (var s = 1; s < pdpSkuFeature.length; s++) {
              var features = pdpSkuFeature[s].querySelectorAll('.feature');
              features.forEach(function (feature) {//feature.classList.add('unavailable');
              });
            }

            var feature_new_active = pdpSkuFeature[0].querySelector('.feature:not(.unavailable)');

            if (feature_new_active.tagName.toLowerCase() != 'option') {
              feature_new_active.click();
            } else {
              var select = feature_new_active.parentElement;
              var selectIndex = parseInt(feature_new_active.getAttribute('data-index'));
              select.querySelector('option[data-index="' + selectIndex + '"]').selected = 'selected'; //select.options[selectIndex].selected = 'selected';

              select.dispatchEvent(new Event('change', {
                bubbles: true
              }));
            }
          }

          for (var i = 1; i < pdpSkuFeature.length; i++) {
            var prev = i;
            var prev_active_feature_model;
            var prev_active_feature_all_model = primary_feature_active_model; //To get prev rows active-feature out model array

            for (var t = 1; t < prev; t++) {
              var prev_active_feature = pdpSkuFeature[t].querySelector('.feature.active');
              prev_active_feature_model = prev_active_feature.getAttribute('data-model').split(',');
              prev_active_feature_all_model = prev_active_feature_all_model.filter(function (r) {
                return prev_active_feature_model.indexOf(r) != -1;
              });
            }

            var features = pdpSkuFeature[i].querySelectorAll('.feature:not(.feature-none)');

            for (var j = 0; j < features.length; j++) {
              var feature = features[j];
              var feature_model = feature.getAttribute('data-model').split(',');
              var feature_none_model = prev_active_feature_all_model.filter(function (r) {
                return r.indexOf('-none') != -1 && feature_model.indexOf(r) != -1;
              });

              if (feature_none_model.length > 0) {
                feature.classList.add('has-unavailable');
              }
            }

            ;
          }

          var last_features = pdpSkuFeature[pdpSkuFeature.length - 1].querySelectorAll('.feature:not(.feature-none)');
          last_features.forEach(function (last_feature) {
            if (last_feature.classList.contains('has-unavailable')) {
              last_feature.classList.remove('has-unavailable');
              last_feature.classList.add('unavailable');
            }
          });

          for (var k = pdpSkuFeature.length - 2; k > 0; k--) {
            var prev = k - 1;
            var prev_active_feature_model;
            var prev_active_feature_all_model = primary_feature_active_model; //To get prev rows active-feature out model array

            for (var t = 1; t < prev; t++) {
              var prev_active_feature = pdpSkuFeature[t].querySelector('.feature.active');
              prev_active_feature_model = prev_active_feature.getAttribute('data-model').split(',');
              prev_active_feature_all_model = prev_active_feature_all_model.filter(function (r) {
                return prev_active_feature_model.indexOf(r) != -1;
              });
            }

            var none_features = pdpSkuFeature[k].querySelectorAll('.feature.has-unavailable');
            var next_features = pdpSkuFeature[k + 1].querySelectorAll('.feature:not(.feature-none)');
            none_features.forEach(function (none_feature) {
              var none_feature_model = none_feature.getAttribute('data-model').split(',');
              var none_feature_none_model = prev_active_feature_all_model.filter(function (r) {
                return none_feature_model.indexOf(r) != -1;
              });
              var none_model = none_feature_none_model.every(function (r) {
                return r.split('--')[1] == 'none';
              });

              if (none_model) {
                none_feature.classList.add('unavailable');
              }
            });
          }

          if (primary_feature_active.classList.contains('unavailable')) {
            var feature_new_active = pdpSkuFeature[0].querySelector('.feature:not(.unavailable)');

            if (feature_new_active.tagName.toLowerCase() != 'option') {
              feature_new_active.click();
            } else {
              var select = feature_new_active.parentElement;
              var selectIndex = parseInt(feature_new_active.getAttribute('data-index'));
              select.querySelector('option[data-index="' + selectIndex + '"]').selected = 'selected'; //select.options[selectIndex].selected = 'selected';

              select.dispatchEvent(new Event('change', {
                bubbles: true
              }));
            }
          } else {
            for (var j = 1; j < pdpSkuFeature.length; j++) {
              var f_active = pdpSkuFeature[j].querySelector('.feature.active');
              var f_available = pdpSkuFeature[j].querySelector('.feature:not(.unavailable):not(.feature-none)');

              if (f_active.classList.contains('unavailable')) {
                if (f_available) {
                  if (f_available.tagName.toLowerCase() != 'option') {
                    f_available.click();
                  } else {
                    var select = f_available.parentElement;
                    var selectIndex = parseInt(f_available.getAttribute('data-index'));
                    select.querySelector('option[data-index="' + selectIndex + '"]').selected = 'selected'; //select.options[selectIndex].selected = 'selected';

                    select.dispatchEvent(new Event('change', {
                      bubbles: true
                    }));
                  }
                }
              } else {
                //when current selection is available
                //f_active.click();
                continue;
              }
            }
          }
        } else {
          pdpSkuFeature_items.forEach(function (item, index) {
            if (item.classList.contains('unavailable')) {
              item.classList.remove('unavailable');
            }

            if (item.classList.contains('has-unavailable')) {
              item.classList.remove('has-unavailable');
            }
          });
          var primary_features = pdpSkuFeature[0].querySelectorAll('.feature:not(.feature-none)');
          primary_features.forEach(function (primary_feature) {
            var primary_feature_model = pdpShowAvailable ? primary_feature.getAttribute('data-model-available').split(',') : primary_feature.getAttribute('data-model').split(',');
            var primary_feature_is_out = primary_feature_model.every(function (r) {
              return r.indexOf('-out') != -1;
            });

            if (primary_feature.classList.contains('feature-out')) {
              if (!primary_feature.classList.contains('active')) {
                if (!primary_feature_is_out) {
                  primary_feature.classList.remove('feature-out');
                }
              }
            }
          });
        }

        if (flag == 1) {
          //when check available, also update out status
          updateOutFeaturesStatus();
          updateOutFeaturesSelectStatus();
        }
      }
    }

    function updateNoneFeaturesLabelStatus() {
      if (NotUndefined(pdpSkuFeature)) {
        for (var i = 1; i < pdpSkuFeature.length; i++) {
          var featuresNone = pdpSkuFeature[i].querySelectorAll('.feature:not(.feature-none):not(.unavailable)');
          var featuresLabel = pdpSkuFeature[i].parentElement.querySelector('.ProductDetail-skuFeature-label');

          if (featuresNone.length == 0) {
            featuresLabel.classList.add('hidden');
          } else {
            featuresLabel.classList.remove('hidden');
          }
        }
      }
    }

    function updateFeatures(model) {
      switchFeatures(model);
      updateFeaturesStatus();
      setSkuFeatureColorTitle();
    }

    function setSkuFeatureColorTitle() {
      if (NotUndefined(pdpSkuFeature_color)) {
        var featuresColorActive = EPD.querySelector('.ProductDetail-skuFeature-color > .feature.active');

        if (NotUndefined(featuresColorActive)) {
          var colorItems = pdpSkuFeature_color_title.querySelectorAll('span');
          colorItems.forEach(function (e) {
            e.classList.remove('feature');

            if (e.classList.contains('hide')) {
              e.parentElement.removeChild(e);
            }
          });
          colorItems = pdpSkuFeature_color_title.querySelectorAll('span');
          colorItems.forEach(function (e) {
            if (e.getAttribute('data-val') == featuresColorActive.getAttribute('data-val')) {
              e.classList.add('active');
            } else {
              e.classList.remove('active');
            }
          });
        }
      }
    }

    function switchFeatures(model) {
      var models = model.split(',');

      for (var i = 0; i < pdpSkuFeature.length; i++) {
        var feature = pdpSkuFeature[i].querySelectorAll('.feature');
        var feature_active = pdpSkuFeature[i].querySelector('.feature.active');
        var found1 = false;

        if (!NotUndefined(feature_active)) {
          found1 = false;
        } else {
          var activeModels = pdpShowAvailable ? feature_active.getAttribute('data-model-available') : feature_active.getAttribute('data-model');

          if (model.indexOf('-none') == -1 && model.indexOf('-in') == -1 && model.indexOf('-out') == -1) {
            activeModels = activeModels.replaceAll('--none', '');
            activeModels = activeModels.replaceAll('--in', '');
            activeModels = activeModels.replaceAll('--out', '');
          }

          activeModels = activeModels.split(',');
          found1 = activeModels.some(function (r) {
            if (models.indexOf(r) >= 0) {
              return true;
            } else {
              return false;
            }
          });
        }

        if (found1) {
          models = models.filter(function (e) {
            return activeModels.indexOf(e) !== -1;
          });
          continue;
        } else {
          for (var a = 0; a < feature.length; a++) {
            var item = feature[a];
            var someModels = pdpShowAvailable ? item.getAttribute('data-model-available') : item.getAttribute('data-model');

            if (model.indexOf('-none') == -1 && model.indexOf('-in') == -1 && model.indexOf('-out') == -1) {
              someModels = someModels.replaceAll('--none', '');
              someModels = someModels.replaceAll('--in', '');
              someModels = someModels.replaceAll('--out', '');
            }

            someModels = someModels.split(',');
            var found2 = someModels.some(function (r) {
              if (models.indexOf(r) >= 0) {
                return true;
              } else {
                return false;
              }
            });

            if (found2) {
              models = models.filter(function (e) {
                return someModels.indexOf(e) !== -1;
              });

              if (NotUndefined(feature_active)) {
                if (feature_active.classList.contains('active')) {
                  feature_active.classList.remove('active');
                }
              }

              item.classList.add('active');

              if (item.tagName.toLowerCase() == 'option') {
                item.selected = true;
              }

              break;
            } else {
              continue;
            }
          }
        }
      }
    }

    function setcurrentModel() {
      if (NotUndefined(pdpSkuFeature)) {
        var tempModalArry = [];

        for (var j = 0; j < pdpSkuFeature.length; j++) {
          var feature_active = pdpSkuFeature[j].querySelector('.feature.active');

          if (NotUndefined(feature_active)) {
            tempModalArry.push(feature_active.getAttribute('data-model').split(','));
          }
        }

        var result = tempModalArry.shift().filter(function (v) {
          return tempModalArry.every(function (a) {
            return a.indexOf(v) !== -1;
          });
        });
        currentModel = result[0].split('--')[0];
        currentStock = result[0].split('--')[1];
        EPD.setAttribute('data-model', currentModel);
        EPD.setAttribute('data-stock', currentStock);
      }
    }

    function bindSkuFeaturesEvent() {
      pdpSkuFeature_dropdown_toggle.forEach(function (toggle, index) {
        toggle.addEventListener('click', function (e) {
          var elements = EcomProductDetail_toConsumableArray(pdpSkuFeature_dropdown_toggle);

          var otherElements = elements.filter(function (element) {
            return element !== toggle;
          });
          otherElements.forEach(function (otherToggle, index) {
            var otherDropdown = otherToggle.parentElement;
            otherDropdown.classList.remove('open');
          });
          var dropdown = toggle.parentElement;
          dropdown.classList.toggle('open');
        });
      });
      document.body.addEventListener('click', function (e) {
        var condition = !e.target.classList.contains('sDropdown-toggle') && !e.target.parentElement.classList.contains('sDropdown-toggle');

        if (condition) {
          pdpSkuFeature_dropdown_toggle.forEach(function (toggle, index) {
            var dropdown = toggle.parentElement;
            dropdown.classList.remove('open');
          });
        }
      });
      pdpSkuFeature_items.forEach(function (trigger, index) {
        if (trigger.tagName.toLowerCase() != 'option') {
          trigger.addEventListener('click', function (e) {
            var model = trigger.getAttribute('data-model');
            var type = trigger.getAttribute('data-type');
            updateFeatures(model);
            updateSku(type, currentModel);
          });
        } else {
          trigger = trigger.parentElement;

          if (NotUndefined(trigger)) {
            trigger.addEventListener('change', function (e) {
              var model = trigger.options[trigger.selectedIndex].getAttribute('data-model');
              var type = trigger.options[trigger.selectedIndex].getAttribute('data-type');
              updateFeatures(model);
              updateSku(type, currentModel);
            });
          }
        }
      });
    }

    function updateSku(type, model) {
      for (var j = 0; j < pdpJson.product_models.length; j++) {
        if (pdpJson.product_models[j].internal_name == type) {
          for (var i = 0; i < pdpJson.product_models[j].skus.length; i++) {
            if (pdpJson.product_models[j].skus[i].modelNo == model) {
              result = pdpJson.product_models[j].skus[i];
              EPD.setAttribute('data-model', result.modelNo);
              EPD.setAttribute('data-stock', setStockValue(result.stock_status));
              checkInStock(result);
              checkEcommerceEnabled(result);
              checkCTAHide(result);
              buildPDPHeader(result);
              updateSkuCarousel(result);
              updateSkuDetail(pdpJson.product_models[j], i); ///buildSkuWarranty(result);
              ///buildSkuBundle(result);

              buildSkuAccordionHtml(result); ////buildSkuCart(result);

              buildSkuSave(result);

              if (pdpEcommerceEnabled) {
                bindSaveEvent(result);
              }

              updateSkuSaveStatus();
            }
          }
        }
      }

      showPromoForDelay();
      EcomProductDetail.Sticky();
    }

    function showPromoForDelay() {
      setTimeout(function () {
        pdpSkuPromos = pdpMain.querySelectorAll('.ProductDetail-skuPromos');
        pdpSkuPromos.forEach(function (p) {
          p.style.opacity = 1;
        });
      }, 200);
    }

    function productViewEvent(result) {
      //var sitem = findEcomSku(result['modelNo'], pdpEcomSkuData);
      var regularPrice = '';
      var promoPrice = ''; //if(sitem){
      //  regularPrice = sitem['regular_price']!==undefined?sitem['regular_price']:"";
      //  promoPrice = sitem['final_price']!==undefined?sitem['final_price']:"";
      //}else {

      regularPrice = result['regular_price'] !== undefined ? result['regular_price'] : "";
      promoPrice = result['final_price'] !== undefined ? result['final_price'] : ""; //}

      var isOutofStock = "";

      if (pdpEcommerceEnabled && "OUT_OF_STOCK" === result['stock_status']) {
        isOutofStock = "yes";
      } else if (pdpEcommerceEnabled && "IN_STOCK" === result['stock_status']) {
        isOutofStock = "no";
      }

      var eventData = {
        "event": "product view",
        "accountID": getAccountId(),
        "productInfo": {
          "productID": result['uid'] !== undefined ? result['uid'] : "",
          "sku": result['modelNo'] !== undefined ? result['modelNo'] : "",
          "currencyCode": result['currencyCode'] !== undefined ? result['currencyCode'] : "",
          "isEcommerce": pdpEcommerceEnabled ? "yes" : "no",
          "productName": result['name'] !== undefined ? result['name'] : "",
          "regularPrice": regularPrice,
          "promoPrice": promoPrice,
          "isOutofStock": isOutofStock
        }
      };
      pushAdobeDataLayerEvent(eventData);
    }

    function saveToWishlistEvent(result) {
      var isOutofStock = "";

      if (pdpEcommerceEnabled && "OUT_OF_STOCK" === result['stock_status']) {
        isOutofStock = "yes";
      } else if (pdpEcommerceEnabled && "IN_STOCK" === result['stock_status']) {
        isOutofStock = "no";
      }

      var eventData = {
        "event": "Save to Wishlist",
        "accountID": getAccountId(),
        "productInfo": {
          "productID": result['uid'] !== undefined ? result['uid'] : "",
          "sku": result['modelNo'] !== undefined ? result['modelNo'] : "",
          "currencyCode": result['currencyCode'] !== undefined ? result['currencyCode'] : "",
          "isEcommerce": pdpEcommerceEnabled ? "yes" : "no",
          "productName": result['name'] !== undefined ? result['name'] : "",
          "regularPrice": result['regular_price'] !== undefined ? result['regular_price'] : "",
          "promoPrice": result['final_price'] !== undefined ? result['final_price'] : "",
          "isOutofStock": isOutofStock
        }
      };
      pushAdobeDataLayerEvent(eventData);
    }

    function checkInStock(data) {
      pdpInStock = NotUndefined(data.stock_status) && data.stock_status.toLowerCase() == "in_stock";
    }

    function checkEcommerceEnabled(data) {
      pdpEcommerceEnabled = data.ecommerceEnabled;

      if (pdpEcommerceEnabled) {
        EPD.classList.add('ecommerceEnabled');
      } else {
        EPD.classList.remove('ecommerceEnabled');
      }
    }

    function checkCTAHide(data) {
      pdpHideCTA = data.hideCTA ? true : false;
    }

    function getHourAtLoc(loc) {
      var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
      var f = new Intl.DateTimeFormat('en', {
        hour: '2-digit',
        hour12: false,
        timeZone: loc
      });
      return f.formatToParts(date)[0].value;
    }

    function checkAPIOpen() {
      var hour = getHourAtLoc('America/Los_Angeles');
      var isTimeOpen = hour < 22 && hour > 0;
      isAPIOpen = checkIngramAvailability == "true" ? !isTimeOpen ? false : true : true;

      if (!isAPIOpen) {
        EPD.classList.add('api-down');
      } else {
        EPD.classList.remove('api-down');
      }
    }

    function checkPDPReview(data) {
      pdpReview = data.enableProductReview ? data.enableProductReview : false;
    }

    function checkBVLoader() {
      if (typeof eCommerceConfig != "undefined") {
        bvLoader = eCommerceConfig.bvLoaderEnabled == 'true' ? true : false;
      }
    }

    function initBuildHtml() {
      //debugger;
      var pdp;

      if (NotUndefined(pdpJson.product_models)) {
        if (Array.isArray(pdpJson.product_models)) {
          pdp = pdpJson.product_models[0];
        } else {
          pdp = pdpJson.product_models;
        }

        var imageEditItem = document.createElement('span');
        imageEditItem.className = "imageEditItem";
        imageEditItem.innerHTML = buildImgEditIcon(pdp);
        pdpMain.parentElement.insertBefore(imageEditItem, pdpSidebar);
        checkBVLoader();
        checkPDPReview(pdp);
        checkInStock(pdp.skus[0]);
        checkEcommerceEnabled(pdp.skus[0]);
        checkCTAHide(pdp.skus[0]);
        buildPDPHeader(pdp.skus[0]);
        buildPDPCarousel(pdp.skus[0]);
        buildPDPReviews(pdp, 0);
        buildPDPContent(pdp, 0); ////buildSkuCart(pdp.skus[0]); 

        updateSkuSave(pdp.skus[0]);
        EcomProductDetail.Sticky();
      }
    }

    function buildPDPHeader(data) {
      if (NotUndefined(data)) {
        var item = data;
        var btnhtml = '';
        var modalClass = 'warn';

        if (item['addToCartWarn'] && item['addToCartWarn'] == true) {
          pdpHeader.querySelector('.product-modalNo').classList.add(modalClass);
        } else {
          if (pdpHeader.querySelector('.product-modalNo').classList.contains(modalClass)) {
            pdpHeader.querySelector('.product-modalNo').classList.remove(modalClass);
          }
        }

        pdpHeader.querySelector('.product-title').innerHTML = item.name;

        if (!item['hideSkuNumber'] && NotUndefined(item.modelNo)) {
          pdpHeader.querySelector('.product-modalNo').innerHTML = pdpLabel_model + '<span>' + item.modelNo + '</span>';
        } else {
          pdpHeader.querySelector('.product-modalNo').innerHTML = '';
        }

        var priceHtml = buildSkuPriceHtml(item);
        pdpSkuPriceHeader.innerHTML = priceHtml;
        var cartHtml,
            popHtml,
            ctaHtml,
            saveHtml = '';
        var inputAttr = pdpEcommerceEnabled ? pdpInStock ? '' : 'disabled' : '';
        var btnClass = pdpEcommerceEnabled ? pdpInStock ? '' : 'Button-disabled' : '';
        var addLabel = item.addToCartLabel ? item.addToCartLabel : pdpLabel_addToCart;
        cartHtml = '<a class="EcomProductDetail-skuAddToCart Button Button-primary ' + btnClass + '">' + '<div class="Button-inner">' + '<span>' + addLabel + '</span>' + '</div>' + '</a>';
        var btnClass = pdpEcommerceEnabled ? 'Button-tertiary' : 'Button-primary';
        var arrowHtml = pdpEcommerceEnabled ? '<i class="Button-arrow"></i>' : '';
        var target = 'target="_blank"';
        popHtml = '<a data-model="' + checkUndefined(item.modelNo) + '"' + ' data-country="' + country + '"' + ' data-category="' + checkUndefined(item.category) + '"' + ' data-isexternal="false"' + ' data-site="' + checkUndefined(item.brand) + '"' + ' data-locale="' + locale + '"' + ' data-buynowlabel="' + pdpLabel_buyNow + '"' + ' data-micromodal-trigger="whereToBuy" class="Button ' + btnClass + ' ProductDetail-skuWhere gtm-shop">' + pdpLabel_where + arrowHtml + '</a>';
        ctaHtml = '<a ' + target + 'class="ProductDetail-skuCta Button Button-primary" href="' + checkUndefined(item.where_to_buy_url) + '">' + checkUndefined(item.where_to_buy_label) + arrowHtml + '</a>';
        var saveIconHtml = '<svg class="svg-icon" style="width: 24px;height: 24px;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M893.456828 709.055005"></path>' + '<path d="M491.889987 337.939709"></path>' + '<path d="M568.154951 338.993714"></path>' + '<path d="M527.32401 876.195699c-3.564175 0-7.119141-0.976234-10.256598-2.928702-16.664541-10.379395-408.355455-256.871345-436.366416-500.994342-8.237615-71.78493 15.535835-136.232754 70.656223-191.560874 37.954427-42.778292 91.974761-66.333778 152.175865-66.333778 77.613682 0 158.166299 39.422871 223.789902 108.884896 65.623603-69.462025 146.176221-108.884896 223.780693-108.884896 60.191894 0 114.212228 23.555485 152.157445 66.333778 55.489802 55.698556 79.396281 120.497375 71.045079 192.603623-28.294416 244.245793-420.09073 489.63769-436.754249 499.970012C534.414499 875.228675 530.869766 876.195699 527.32401 876.195699zM303.534108 153.203264c-49.110511 0-92.960205 19.052938-123.463939 53.650921-0.265036 0.302899-0.549515 0.597611-0.833995 0.881067-47.28084 47.28084-66.893526 99.661837-59.954487 160.109558 23.517623 204.964138 346.068853 425.285033 408.061766 465.865263 62.049195-40.456411 384.695592-259.981173 408.393317-464.888006 7.033184-60.750619-12.71151-113.444748-60.352553-161.085792-0.293689-0.284479-0.568958-0.578168-0.833995-0.8913-30.493501-34.588773-74.333986-53.641711-123.44552-53.641711-72.154343 0-148.346653 40.721447-209.021547 111.710244-3.686972 4.313236-9.080819 6.7968-14.759145 6.7968l0 0c-5.678326 0-11.07115-2.483564-14.759145-6.7968C451.889971 193.924711 375.697661 153.203264 303.534108 153.203264z"></path>' + '</svg>' + '<svg class="svg-icon" style="width: 24px; height: 24px;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M512 910.933333 450.133333 854.613333C230.4 655.36 85.333333 523.52 85.333333 362.666667 85.333333 230.826667 188.586667 128 320 128 394.24 128 465.493333 162.56 512 216.746667 558.506667 162.56 629.76 128 704 128 835.413333 128 938.666667 230.826667 938.666667 362.666667 938.666667 523.52 793.6 655.36 573.866667 854.613333L512 910.933333Z"></path>' + '</svg>';
        saveHtml = '<div class="ProductDetail-skuS">' + '<div class="ProductDetail-skuSToggle Button Button-primary">' + saveIconHtml + '<span>' + pdpLabel_addToSavedItems + '</span>' + '</div>' + '</div>';

        if (pdpEcommerceEnabled) {
          if (isAPIOpen) {
            if (!pdpHideCTA) {
              pdpSkuCartHeader.innerHTML = cartHtml;
              pdpSkuAddToCartHeader = pdpHeader.querySelector('.EcomProductDetail-skuAddToCart');

              if (pdpInStock) {
                pdpSkuAddToCartHeader.classList.remove('Button-disabled');
              } else {
                pdpSkuAddToCartHeader.classList.add('Button-disabled');
              }
            } else {
              pdpSkuCartHeader.innerHTML = '';
            }
          } else {
            pdpSkuCartHeader.innerHTML = saveHtml; // check save status
          }
        } else {
          if (item.wheretobuy) {
            if (!pdpHideCTA) {
              pdpSkuCartHeader.innerHTML = popHtml;
            } else {
              pdpSkuCartHeader.innerHTML = '';
            }
          } else {
            if (!pdpHideCTA && checkUndefined(item.where_to_buy_url) && checkUndefined(item.where_to_buy_label)) {
              pdpSkuCartHeader.innerHTML = ctaHtml;
            } else {
              pdpSkuCartHeader.innerHTML = '';
            }
          }
        }

        getElements();
      }
    }

    function buildPDPCarousel(data) {
      //pdpCarousel.setAttribute('data-model', data[0].modelNo);
      pdpCarouselMain = EPD.querySelector('.EcomProductDetail-carousels-mainContainer');
      pdpCarouselThumb = EPD.querySelector('.EcomProductDetail-carousels-thumbContainer');
      buildMainCarousel(data);
      buildThumbCarousel(data); //debugger;

      bindCarousel(); ///Modal();

      setTimeout(function (e) {
        showPlayIcon();
      }, 300);
    }

    function showPlayIcon() {
      playIcons = EPD.querySelectorAll('.play-icon');
      playIcons.forEach(function (icon) {
        icon.style.display = "flex";
      });
    }

    function buildMainCarousel(data) {
      var html = '';

      if (NotUndefined(data)) {
        var item = data;

        if (NotUndefined(item.gallery)) {
          for (var i = 0; i < item.gallery.length; i++) {
            var isVideo = item.gallery[i].isvideo && item.gallery[i].videourl != '';
            var isVideoClass = isVideo ? 'carousels--video' : '';
            var playHtml = isVideo ? '<span class="play-icon"><i></i></span>' : '';
            var videoLabel = isVideo ? '<p>' + videoLabel_cta + '</p>' : '<p></p>';
            var videoUrl = '';
            var videoID = '';
            var vid = '';

            if (isVideo) {
              var videoArray = item.gallery[i].videourl.split('/');

              if (item.gallery[i].videourl.indexOf('vimeo.com') != -1) {
                vid = videoArray[videoArray.length - 1];
                videoID = 'data-video-id="' + vid + '"';
                videoUrl = 'href="https://vimeo.com/' + vid + '"';
              }

              if (item.gallery[i].videourl.indexOf('youtube.com') != -1) {
                vid = videoArray[videoArray.length - 1].replace('watch?v=', '');
                videoID = 'data-video-id="' + vid + '"';
                videoUrl = 'href="https://www.youtube.com/watch?v=' + vid + '"';
              }

              if (item.gallery[i].videourl.indexOf('qq.com') != -1) {
                vid = videoArray[videoArray.length - 1].replace('.html', '');
                videoID = 'data-video-id="' + vid + '"';
                videoUrl = 'href="https://v.qq.com/x/page/' + vid + '.html"';
              }
            }

            var videoTrigger = isVideo ? 'data-micromodal-trigger="ProductDetail-skuVideo-modal-' + vid + '"' : ''; //let videoLabel = isVideo ? '<p>' + videoLabel_cta + '</p>' : '';

            html += '<div class="swiper-slide">' + '<div class="swiper-slide-content">' + '<a class="EcomProductDetail-carousels-main ' + isVideoClass + '" ' + videoTrigger + videoUrl + videoID + '>' + '<img src="' + checkUndefined(item.gallery[i].large) + '">' + //'<span class="product-tag">' + 
            // item.modelNo + 
            //'</span>'+
            videoLabel + playHtml + '</a>' + '</div>' + '</div>';
          }
        }
      }

      pdpCarouselMain.querySelector('.swiper-wrapper').innerHTML = html;
      setCarouselIDs(item);
      preventModalVideoLink();
    }

    function buildThumbCarousel(data) {
      var html = '';

      if (NotUndefined(data)) {
        var item = data;

        if (NotUndefined(item.gallery)) {
          for (var i = 0; i < item.gallery.length; i++) {
            var isVideo = item.gallery[i].isvideo && item.gallery[i].videourl != '';
            var isVideoTClass = isVideo ? 'carousels--video' : '';
            var playTHtml = isVideo ? '<span class="play-icon"><i></i></span>' : '';
            html += '<div class="swiper-slide">' + '<div class="swiper-slide-content">' + '<a class="EcomProductDetail-carousels-thumb ' + isVideoTClass + '">' + '<img src="' + checkUndefined(item.gallery[i].small) + '">' + playTHtml + '</a>' + '</div>' + '</div>';
          }
        }
      }

      var cid = "EcomProductDetail-carousels-swiper-" + item.modelNo;
      pdpCarouselThumb.querySelector('.swiper-wrapper').innerHTML = html;

      if (html == '') {
        pdpCarouselThumbArrows.forEach(function (arrow) {
          arrow.classList.add('hidden');
        });
      } else {
        pdpCarouselThumbArrows.forEach(function (arrow) {
          arrow.classList.remove('hidden');
        });
      }
    }

    function setCarouselIDs(item) {
      var cid = "EcomProductDetail-carousels-swiper-" + item.modelNo;
      pdpCarouselMain.querySelector('.swiper-container').id = cid;
      pdpCarouselThumb.querySelector('.swiper-container').id = cid;
      var rid = "control-right-slider-content-" + item.modelNo;
      var lid = "control-left-slider-content-" + item.modelNo;
      pdpCarousel.querySelector('.EcomProductDetail-carousels-navArrowButton-right').id = rid;
      pdpCarousel.querySelector('.EcomProductDetail-carousels-navArrowButton-left').id = lid;
    }

    function buildPDPContent(data, index) {
      if (NotUndefined(data.skus)) {
        EPD.setAttribute('data-model', data.skus[index].modelNo);
        EPD.setAttribute('data-stock', setStockValue(data.skus[index].stock_status));
        buildSkuDetailHtml(data, index);
        buildSkuFeaturesHtml(data);
        buildSkuAvailabelHtml(data.skus); ///buildSkuWarranty(data.skus[index]);
        ///buildSkuBundle(data.skus[index]);

        buildSkuAccordionHtml(data.skus[index]);
      }
    }

    function buildPDPReviews(data, index) {
      var html = '';

      if (pdpReview && bvLoader) {
        html += '<div id="pdpReviews" class="pdpReviews Container">';
        html += '<h2>' + pdpLabel_ratingsReviews + '</h2>';
        html += '<div data-bv-show="reviews" data-bv-product-id=""></div>';
        html += '</div>';
        var footnotesLen = document.querySelectorAll('.Footnotes').length;
        var footnotes = document.querySelectorAll('.Footnotes')[footnotesLen - 1];

        if (footnotes) {
          footnotes.insertAdjacentHTML('beforebegin', html);
        } else {
          EPD.parentElement.parentElement.insertAdjacentHTML('beforeend', html);
        }
      }
    }

    function buildSkuAvailabelHtml(data) {
      var html = '';
      var checkAttr = checkHashStore() ? 'checked' : '';
      html = '<div class="checkbox-available">' + '<label class="checkbox-label">' + pdpLabel_showStoreProducts + '</label>' + '<div class= "checkbox-box" >' + '<input ' + checkAttr + ' autocomplete="off" id="checkbox-toggle" type="checkbox" class="checkbox-hide" aria-labelledby="checkbox-label">' + '<span for="checkbox-toggle" class="toggle"></sapn>' + '</div>' + '</div>';
      var foundAvailable = data.some(function (sku) {
        return sku.ecommerceEnabled == true;
      });
      var foundUnAvailable = data.some(function (sku) {
        return sku.ecommerceEnabled == false;
      });

      if (foundAvailable && foundUnAvailable && NotUndefined(pdpSkuFeatures) && pdpSkuFeatures.querySelectorAll('.feature').length > 0) {
        pdpSkuAvailable.innerHTML = html;
      }
    }

    function findEcomSku(modelNo, arr) {
      if (NotUndefined(pdpJson.product_models)) {
        var mID = modelNo;
        var returnSku;

        if (Array.isArray(arr)) {
          returnSku = arr.find(function (es) {
            return es.sku == mID || es.modelNo == mID;
          });
        }

        return returnSku;
      }
    }

    function priceFormat(lang, currencyCode, price) {
      var formatter = new Intl.NumberFormat(lang, {
        style: 'currency',
        currency: currencyCode
      });
      var formattedPrice = formatter.format(price);

      if ('fr' == lang && 'CAD' == currencyCode) {
        formattedPrice = formattedPrice.replace('$CA', 'CA$');
      }

      return formattedPrice;
    }

    function buildSkuPriceHtml(item) {
      var priceHtml = '';
      var priceCurrentHtml = '';
      var priceOffHtml = '';
      var sitem = item;

      if (pdpEcommerceEnabled) {
        if (!pdpHideCTA) {
          //var returnItem = findEcomSku(item.modelNo,pdpEcomSkuData);
          //if(returnItem){
          //  sitem = returnItem;
          //}
          if (NotUndefined(sitem.final_price)) {
            priceCurrentHtml = priceFormat(lang, sitem.currencyCode, sitem.final_price);
          }

          priceOffHtml = '<span class="old-price"></span><span class="off-price"></span>';

          if (NotUndefined(sitem.final_price) && NotUndefined(sitem.regular_price) && Number(sitem.final_price) < Number(sitem.regular_price)) {
            priceOffHtml = '<span class="old-price">' + priceFormat(lang, sitem.currencyCode, sitem.regular_price) + '</span>' + '<span class="off-price">' + checkUndefined(sitem.percent_off) + pdpLabel_off + '</span>';
          }

          priceHtml = '<span class="current-price">' + priceCurrentHtml + '</span>' + priceOffHtml;
        } else {
          priceHtml = '';
        }
      } else {
        if (NotUndefined(item.msrp)) {
          if (!pdpHideCTA) {
            //priceCurrentHtml = pdpLabel_currencySymbol + checkUndefined(item.msrp) + '<i>' + pdpLabel_price + '</i>';
            priceCurrentHtml = priceFormat(lang, pdpLabel_currencyCode, sitem.msrp) + '<i>' + pdpLabel_price + '</i>';
            priceHtml = '<span class="current-price">' + priceCurrentHtml + '</span>';
          } else {
            priceHtml = '';
          }
        }
      }

      return priceHtml;
    }

    function buildSkuApiAlertHtml() {
      var html = '';
      var saveItemsHtml = '';
      saveItemsHtml = '<a href="' + wishlistUrl + '">' + pdpLabel_savedItems + '</a>';

      if (pdpEcommerceEnabled && !isAPIOpen) {
        html = '<i></i>' + '<span>' + pdpLabel_ingramDownMessage.replace('[0]', saveItemsHtml) + '</span>';
      }

      pdpSkuAPI.innerHTML = html;
    }

    function isBetweenDates(beginDate, endDate, date) {
      var start = Date.parse(beginDate);
      var end = Date.parse(endDate);
      ;
      var d = Date.parse(date); //console.log('start: ' + start);
      //console.log('end: ' + end);
      //console.log('d: ' + d);

      if (endDate) {
        return d.valueOf() >= start.valueOf() && d.valueOf() <= end.valueOf();
      } else {
        return d.valueOf() >= start.valueOf();
      }
    }

    function checkPromotionDate(item) {
      var isPromoShown = false;
      var promoStartDate = item.promoStartDate ? item.promoStartDate : null;
      var promoEndDate = item.promoEndDate ? item.promoEndDate : null;
      var currentDate = new Date().toISOString(); //console.log('promoStartDate: ' + promoStartDate);
      //console.log('promoEndDate: ' + promoEndDate);
      //console.log('currentDate: ' + currentDate);

      if (promoStartDate) {
        isPromoShown = isBetweenDates(promoStartDate, promoEndDate, currentDate);
      } //console.log('isPromoShown: ' + isPromoShown);


      return isPromoShown;
    }

    function buildSkuPromotionHtml(item) {
      var topPromoHtml = '<div class="ProductDetail-skuPromos">';
      var bottomPromoHtml = '<div class="ProductDetail-skuPromos">';
      var topPromos = [];
      var bottomPromos = [];

      if (item.promotions) {
        topPromos = item.promotions.filter(function (p) {
          return p.displayType == 'top';
        });
        bottomPromos = item.promotions.filter(function (p) {
          return p.displayType == 'bottom';
        });
        topPromos.forEach(function (p) {
          if (!isPublishEnv || isPublishEnv && checkPromotionDate(p)) {
            var promoPos = 'tag--' + p.displayType.toLowerCase();
            var promoColor = 'tag--' + p.color.toLowerCase();
            topPromoHtml += '<div class="ProductDetail-skuPromo ' + promoPos + ' ' + promoColor + '">';
            topPromoHtml += buildImgEditIcon(p);

            if (p.promoTagTitle && p.promoTagTitle != '') {
              topPromoHtml += '<div class="skuPromo-tag">' + p.promoTagTitle + '</div>';
            }

            if (p.description && p.description != '') {
              topPromoHtml += '<div class="skuPromo-des">' + p.description + '</div>';
            }

            topPromoHtml += '</div>';
          }
        });
        bottomPromos.forEach(function (p) {
          if (!isPublishEnv || isPublishEnv && checkPromotionDate(p)) {
            var promoPos = 'tag--' + p.displayType.toLowerCase();
            var promoColor = 'tag--' + p.color.toLowerCase();
            bottomPromoHtml += '<div class="ProductDetail-skuPromo ' + promoPos + ' ' + promoColor + '">';
            bottomPromoHtml += buildImgEditIcon(p);

            if (p.description && p.description != '') {
              bottomPromoHtml += '<div class="skuPromo-des">' + p.description + '</div>';
            }

            bottomPromoHtml += '</div>';
          }
        });
      }

      topPromoHtml += '</div>';
      bottomPromoHtml += '</div>';

      if (pdpSkuPromos) {
        pdpSkuPromos.forEach(function (p) {
          p.remove();
        });
        pdpSkuPromos = pdpMain.querySelectorAll('.ProductDetail-skuPromos');
      }

      pdpSkuPrice.insertAdjacentHTML('beforebegin', topPromoHtml);
      pdpSkuWCSW.insertAdjacentHTML('beforeend', bottomPromoHtml);
    }

    function buildSkuDetailHtml(data, index) {
      var html = '';
      var priceHtml = buildSkuPriceHtml(data.skus[index]);
      var modelHtml = '';
      var modalClass = '';
      var pdpReviewHtml = '';

      if (data.skus[index]['addToCartWarn'] && data.skus[index]['addToCartWarn'] == true) {
        modalClass = 'warn';
      }

      if (!data.skus[index]['hideSkuNumber'] && NotUndefined(data.skus[index].modelNo)) {
        modelHtml = pdpLabel_model + '<span class="value">' + checkUndefined(data.skus[index].modelNo) + '</span>';
      }

      if (pdpReview && bvLoader) {
        pdpReviewHtml = '<div data-bv-show="rating_summary" data-bv-product-id="' + data.skus[index].modelNo + '"></div>';
      }

      updateRatingReviews(data.skus[index].modelNo);
      var stockHtml = '';
      var stockClass = pdpEcommerceEnabled ? pdpInStock ? 'in' : 'out' : '';

      if (pdpEcommerceEnabled && !pdpHideCTA) {
        stockHtml = checkUndefined(data.skus[index].stock_status_label);
      }

      html += '<h1 class="ProductDetail-skuName"> ' + buildImgEditIcon(data.skus[index]) + checkUndefined(data.skus[index].name) + '</h1>' + '<div class="ProductDetail-skuModel ' + modalClass + '">' + modelHtml + '</div>' + pdpReviewHtml + '<div class="layout-forSwitch">' + '<div class="ProductDetail-skuDes copy">' + checkUndefined(data.skus[index].overview) + '</div>' + '<div class="ProductDetail-skuPrice">' + priceHtml + '</div>' + '<div class="ProductDetail-skuStock ' + stockClass + '">' + '<span>' + stockHtml + '</span>' + '</div>' + '</div>';
      pdpSkuInfos.innerHTML = html; ///buildSkuRating(data,index);

      buildSkuApiAlertHtml();
      buildSkuWhere(data, index);
      buildSkuCart(data.skus[index]);
      buildSkuPromotionHtml(data.skus[index]);
    }

    function buildSkuRating(data, index) {
      var html = '';
      var base = 20;
      var starClass = '';

      if (data.skus[index].rating_summary != undefined) {
        var rating = parseInt(data.skus[index].rating_summary); //debugger;

        var count = parseInt(rating / base);
        var has_half = parseInt(rating % base) > 0 && parseInt(rating % base) < 20 ? true : false;

        for (var i = 0; i < 5; i++) {
          if (count > 0) {
            //debugger;
            if (i < count) {
              starClass = "star--full";
            } else {
              if (i == count && has_half && i < 5) {
                starClass = "star--half";
              } else {
                starClass = "";
              }
            }
          }

          html += '<div class="star ' + starClass + '">' + '<svg class="svg-icon icon-star--empty" style="vertical-align: middle;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M785.352203 933.397493c-4.074805 0-8.151657-0.970094-11.833513-3.007497l-261.311471-142.488225L250.942821 930.388972c-8.343015 4.559852-18.527982 3.8814-26.28669-1.599428-7.760754-5.5279-11.640108-14.987343-10.088776-24.347524l47.578622-285.365306L72.563154 429.470355c-6.594185-6.547113-8.971325-16.295128-6.110161-25.122167 2.814092-8.850575 10.379395-15.397688 19.546172-16.949021l285.512662-47.577598 118.529557-236.989529c4.172019-8.391111 12.803607-13.701047 22.165836-13.701047 9.359158 0 17.992793 5.309936 22.163789 13.701047l118.529557 236.989529 285.511639 47.577598c9.217942 1.551332 16.73208 8.051373 19.593244 16.949021 2.813069 8.875135 0.48607 18.575054-6.109138 25.122167L762.264369 619.077737l47.577598 285.365306c1.50119 9.360182-2.37714 18.819624-10.087753 24.347524C795.487028 931.797042 790.394033 933.397493 785.352203 933.397493zM512.206196 734.747153c4.073782 0 8.196683 0.968048 11.880585 3.006474l228.379431 124.545574-41.268916-247.634983c-1.308809-7.90504 1.257643-16.005532 6.932899-21.63167l164.55787-164.555823-250.398934-41.709961c-7.855922-1.308809-14.549368-6.304589-18.140149-13.408381l-101.942787-203.915249-101.991905 203.915249c-3.542686 7.103792-10.234085 12.050454-18.09103 13.408381l-250.40098 41.709961 164.509774 164.555823c5.672186 5.626137 8.244778 13.675464 6.983041 21.63167l-41.273009 247.634983 228.380454-124.545574C504.058632 735.715201 508.132414 734.747153 512.206196 734.747153z"  /></svg>' + '<svg class="svg-icon icon-star--full" style="vertical-align: middle;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M785.352203 933.397493c-4.074805 0-8.151657-0.970094-11.833513-3.007497l-261.311471-142.488225L250.942821 930.388972c-8.343015 4.559852-18.527982 3.8814-26.28669-1.599428-7.760754-5.5279-11.640108-14.987343-10.088776-24.347524l47.578622-285.365306L72.563154 429.470355c-6.594185-6.547113-8.971325-16.295128-6.110161-25.122167 2.814092-8.850575 10.379395-15.397688 19.546172-16.949021l285.512662-47.577598 118.529557-236.989529c4.172019-8.391111 12.803607-13.701047 22.165836-13.701047 9.359158 0 17.992793 5.309936 22.163789 13.701047l118.529557 236.989529 285.511639 47.577598c9.217942 1.551332 16.73208 8.051373 19.593244 16.949021 2.813069 8.875135 0.48607 18.575054-6.109138 25.122167L762.264369 619.077737l47.577598 285.365306c1.50119 9.360182-2.37714 18.819624-10.087753 24.347524C795.487028 931.797042 790.394033 933.397493 785.352203 933.397493z"  /></svg>' + '<svg class="svg-icon icon-star--half" style="vertical-align: middle;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M785.352203 933.397493c-4.074805 0-8.151657-0.970094-11.833513-3.007497l-261.311471-142.488225L250.942821 930.388972c-8.343015 4.559852-18.527982 3.8814-26.28669-1.599428-7.760754-5.5279-11.640108-14.987343-10.088776-24.347524l47.578622-285.365306L72.563154 429.470355c-6.594185-6.547113-8.971325-16.295128-6.110161-25.122167 2.814092-8.850575 10.379395-15.397688 19.546172-16.949021l285.512662-47.577598 118.529557-236.989529c4.172019-8.391111 12.803607-13.701047 22.165836-13.701047 9.359158 0 17.992793 5.309936 22.163789 13.701047l118.529557 236.989529 285.511639 47.577598c9.217942 1.551332 16.73208 8.051373 19.593244 16.949021 2.813069 8.875135 0.48607 18.575054-6.109138 25.122167L762.264369 619.077737l47.577598 285.365306c1.50119 9.360182-2.37714 18.819624-10.087753 24.347524C795.487028 931.797042 790.394033 933.397493 785.352203 933.397493zM512.206196 734.747153c4.073782 0 8.196683 0.968048 11.880585 3.006474l228.379431 124.545574-41.268916-247.634983c-1.308809-7.90504 1.257643-16.005532 6.932899-21.63167l164.55787-164.555823-250.398934-41.709961c-7.855922-1.308809-14.549368-6.304589-18.140149-13.408381l-101.942787-203.915249"  /></svg>' + '</div>';
        }

        pdpSkuRating = pdpMain.querySelector('.ProductDetail-skuRating');
        pdpSkuRating.querySelector('.rating-star').setAttribute('data-value', rating);
        pdpSkuRating.querySelector('.rating-star').innerHTML = html;
        var rating_value = (rating / base).toFixed(1);
        pdpSkuRating.querySelector('.rating-value').innerHTML = rating_value;
        pdpSkuRating.querySelector('.review-count').innerHTML = '(' + data.skus[index].review_count + ')';
      } else {
        pdpSkuRating = pdpMain.querySelector('.ProductDetail-skuRating');
        pdpSkuRating.querySelector('.rating-star').setAttribute('data-value', 0);

        for (var i = 0; i < 5; i++) {
          html += '<div class="star ' + starClass + '">' + '<svg class="svg-icon icon-star--empty" style="vertical-align: middle;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M785.352203 933.397493c-4.074805 0-8.151657-0.970094-11.833513-3.007497l-261.311471-142.488225L250.942821 930.388972c-8.343015 4.559852-18.527982 3.8814-26.28669-1.599428-7.760754-5.5279-11.640108-14.987343-10.088776-24.347524l47.578622-285.365306L72.563154 429.470355c-6.594185-6.547113-8.971325-16.295128-6.110161-25.122167 2.814092-8.850575 10.379395-15.397688 19.546172-16.949021l285.512662-47.577598 118.529557-236.989529c4.172019-8.391111 12.803607-13.701047 22.165836-13.701047 9.359158 0 17.992793 5.309936 22.163789 13.701047l118.529557 236.989529 285.511639 47.577598c9.217942 1.551332 16.73208 8.051373 19.593244 16.949021 2.813069 8.875135 0.48607 18.575054-6.109138 25.122167L762.264369 619.077737l47.577598 285.365306c1.50119 9.360182-2.37714 18.819624-10.087753 24.347524C795.487028 931.797042 790.394033 933.397493 785.352203 933.397493zM512.206196 734.747153c4.073782 0 8.196683 0.968048 11.880585 3.006474l228.379431 124.545574-41.268916-247.634983c-1.308809-7.90504 1.257643-16.005532 6.932899-21.63167l164.55787-164.555823-250.398934-41.709961c-7.855922-1.308809-14.549368-6.304589-18.140149-13.408381l-101.942787-203.915249-101.991905 203.915249c-3.542686 7.103792-10.234085 12.050454-18.09103 13.408381l-250.40098 41.709961 164.509774 164.555823c5.672186 5.626137 8.244778 13.675464 6.983041 21.63167l-41.273009 247.634983 228.380454-124.545574C504.058632 735.715201 508.132414 734.747153 512.206196 734.747153z"  /></svg>' + '<svg class="svg-icon icon-star--full" style="vertical-align: middle;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M785.352203 933.397493c-4.074805 0-8.151657-0.970094-11.833513-3.007497l-261.311471-142.488225L250.942821 930.388972c-8.343015 4.559852-18.527982 3.8814-26.28669-1.599428-7.760754-5.5279-11.640108-14.987343-10.088776-24.347524l47.578622-285.365306L72.563154 429.470355c-6.594185-6.547113-8.971325-16.295128-6.110161-25.122167 2.814092-8.850575 10.379395-15.397688 19.546172-16.949021l285.512662-47.577598 118.529557-236.989529c4.172019-8.391111 12.803607-13.701047 22.165836-13.701047 9.359158 0 17.992793 5.309936 22.163789 13.701047l118.529557 236.989529 285.511639 47.577598c9.217942 1.551332 16.73208 8.051373 19.593244 16.949021 2.813069 8.875135 0.48607 18.575054-6.109138 25.122167L762.264369 619.077737l47.577598 285.365306c1.50119 9.360182-2.37714 18.819624-10.087753 24.347524C795.487028 931.797042 790.394033 933.397493 785.352203 933.397493z"  /></svg>' + '<svg class="svg-icon icon-star--half" style="vertical-align: middle;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M785.352203 933.397493c-4.074805 0-8.151657-0.970094-11.833513-3.007497l-261.311471-142.488225L250.942821 930.388972c-8.343015 4.559852-18.527982 3.8814-26.28669-1.599428-7.760754-5.5279-11.640108-14.987343-10.088776-24.347524l47.578622-285.365306L72.563154 429.470355c-6.594185-6.547113-8.971325-16.295128-6.110161-25.122167 2.814092-8.850575 10.379395-15.397688 19.546172-16.949021l285.512662-47.577598 118.529557-236.989529c4.172019-8.391111 12.803607-13.701047 22.165836-13.701047 9.359158 0 17.992793 5.309936 22.163789 13.701047l118.529557 236.989529 285.511639 47.577598c9.217942 1.551332 16.73208 8.051373 19.593244 16.949021 2.813069 8.875135 0.48607 18.575054-6.109138 25.122167L762.264369 619.077737l47.577598 285.365306c1.50119 9.360182-2.37714 18.819624-10.087753 24.347524C795.487028 931.797042 790.394033 933.397493 785.352203 933.397493zM512.206196 734.747153c4.073782 0 8.196683 0.968048 11.880585 3.006474l228.379431 124.545574-41.268916-247.634983c-1.308809-7.90504 1.257643-16.005532 6.932899-21.63167l164.55787-164.555823-250.398934-41.709961c-7.855922-1.308809-14.549368-6.304589-18.140149-13.408381l-101.942787-203.915249"  /></svg>' + '</div>';
        }

        pdpSkuRating.querySelector('.rating-star').innerHTML = html;
        var rating_value = (rating / base).toFixed(1);
        pdpSkuRating.querySelector('.rating-value').innerHTML = 0;
        pdpSkuRating.querySelector('.review-count').innerHTML = '(' + 0 + ')';
      }
    }

    function buildSkuWarranty(data) {
      var html = '';
      html += '<div class="media EcomProductDetail-media"> ' + '<div class="media-header">' + '<div class="media-eyebrow">' + '<svg width="20" height="27" viewBox="0 0 20 27" fill="none" xmlns="http://www.w3.org/2000/svg">' + '<path d="M19.8157 10.3243C19.8157 4.91193 15.4124 0.508545 9.99991 0.508545C4.58746 0.508545 0.184204 4.91193 0.184204 10.3243C0.184204 13.6434 1.87883 16.7457 4.64184 18.5498V21.6421C4.64184 24.5965 7.0454 27 9.99979 27C12.9542 27 15.3577 24.5965 15.3577 21.6421V19.9053C15.3577 19.9048 15.3577 18.5499 15.3577 18.5499C18.121 16.7458 19.8157 13.6436 19.8157 10.3243ZM13.4656 21.6422C13.4656 23.5532 11.9109 25.1078 9.99991 25.1078C8.08891 25.1078 6.53422 23.5532 6.53422 21.6422V20.8513H13.4656V21.6422ZM13.9404 17.2001C13.6467 17.3689 13.4656 17.6818 13.4656 18.0206V18.9591H10.946V14.0667C12.1745 13.667 13.0652 12.5116 13.0652 11.1514C13.0652 10.6289 12.6416 10.2053 12.1191 10.2053C11.5966 10.2053 11.173 10.6289 11.173 11.1514C11.173 11.7983 10.6467 12.3246 9.99991 12.3246C9.3531 12.3246 8.82678 11.7983 8.82678 11.1514C8.82678 10.6289 8.40316 10.2053 7.88066 10.2053C7.35816 10.2053 6.93453 10.6289 6.93453 11.1514C6.93453 12.5115 7.82522 13.667 9.05378 14.0667V18.9591H6.53434V18.0205C6.53434 17.6818 6.35328 17.3689 6.05953 17.2001C3.60271 15.7887 2.07658 13.1541 2.07658 10.3243C2.07658 5.95531 5.63103 2.4008 10.0001 2.4008C14.3692 2.4008 17.9236 5.95524 17.9236 10.3243C17.9235 13.1541 16.3972 15.7888 13.9404 17.2001Z"></path>' + '</svg>' + '<span>Solution Brief</span>' + '</div>' + '<div class="media-cta">' + '<a href="#" class="Button Button-tertiary--primary">' + '<span>Learn More <i class="Button-arrow"></i></span>' + '</a>' + '</div>' + '</div>' + '<div class="media-left">' + '<img class="media-object" src="https://via.placeholder.com/80x80">' + '</div>' + '<div class="media-body">' + '<p class="media-title">Lorem Ipsum</p>' + '<p class="media-des">Lorem Ipsum has been the industrys standard dummy text ever since the 1500s</p>' + '<div class="check-Warranty">' + '<label class="Form-checkbox" id="Warranty">' + '<input type="checkbox" checked="checked" class="checkbox-custom" name="checkbox-1">' + '<span class="checkbox-text">' + '<span>Extended warranty - 2 years</span>' + '<b>' + pdpLabel_currencySymbol + '9.99</b>' + '</span>' + '<div class="Form-control"></div>' + '</label>' + '</div>' + '</div>  ' + '<div class="check-Warranty cw--mobile">' + '<label class="Form-checkbox" id="Warranty">' + '<input type="checkbox" checked="checked" class="checkbox-custom" name="checkbox-1">' + '<span class="checkbox-text">' + '<span>Extended warranty - 2 years</span>' + '<b>' + pdpLabel_currencySymbol + '9.99</b>' + '</span>' + '<div class="Form-control"></div>' + '</label>' + '</div>' + '</div>';
      pdpSkuWarranty.innerHTML = html;
    }

    function buildSkuSave(data) {
      var html = '';
      var saveClass = '';
      var saveLabel = pdpLabel_save;

      if (!isAPIOpen) {
        saveClass = 'Button Button-primary';
        saveLabel = pdpLabel_addToSavedItems;
      }

      if (pdpEcommerceEnabled) {
        html += '<div class="ProductDetail-skuSToggle ' + saveClass + '">' + '<svg class="svg-icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M893.456828 709.055005"  />' + '<path d="M491.889987 337.939709"  />' + '<path d="M568.154951 338.993714"  />' + '<path d="M527.32401 876.195699c-3.564175 0-7.119141-0.976234-10.256598-2.928702-16.664541-10.379395-408.355455-256.871345-436.366416-500.994342-8.237615-71.78493 15.535835-136.232754 70.656223-191.560874 37.954427-42.778292 91.974761-66.333778 152.175865-66.333778 77.613682 0 158.166299 39.422871 223.789902 108.884896 65.623603-69.462025 146.176221-108.884896 223.780693-108.884896 60.191894 0 114.212228 23.555485 152.157445 66.333778 55.489802 55.698556 79.396281 120.497375 71.045079 192.603623-28.294416 244.245793-420.09073 489.63769-436.754249 499.970012C534.414499 875.228675 530.869766 876.195699 527.32401 876.195699zM303.534108 153.203264c-49.110511 0-92.960205 19.052938-123.463939 53.650921-0.265036 0.302899-0.549515 0.597611-0.833995 0.881067-47.28084 47.28084-66.893526 99.661837-59.954487 160.109558 23.517623 204.964138 346.068853 425.285033 408.061766 465.865263 62.049195-40.456411 384.695592-259.981173 408.393317-464.888006 7.033184-60.750619-12.71151-113.444748-60.352553-161.085792-0.293689-0.284479-0.568958-0.578168-0.833995-0.8913-30.493501-34.588773-74.333986-53.641711-123.44552-53.641711-72.154343 0-148.346653 40.721447-209.021547 111.710244-3.686972 4.313236-9.080819 6.7968-14.759145 6.7968l0 0c-5.678326 0-11.07115-2.483564-14.759145-6.7968C451.889971 193.924711 375.697661 153.203264 303.534108 153.203264z"  />' + '</svg>' + '<svg class="svg-icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">' + '<path d="M512 910.933333 450.133333 854.613333C230.4 655.36 85.333333 523.52 85.333333 362.666667 85.333333 230.826667 188.586667 128 320 128 394.24 128 465.493333 162.56 512 216.746667 558.506667 162.56 629.76 128 704 128 835.413333 128 938.666667 230.826667 938.666667 362.666667 938.666667 523.52 793.6 655.36 573.866667 854.613333L512 910.933333Z"  />' + '</svg>' + '<span>' + saveLabel + '</span>' + '</div>' + '<div class="ProductDetail-skuSTooltip">' + '<span class="tooltip-close"></span>' + '<div class="tooltip-content">' + '<p>' + '<svg class="svg-icon" style="width: 1em;height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M512 85.333333C277.333333 85.333333 85.333333 277.333333 85.333333 512s192 426.666667 426.666667 426.666667 426.666667-192 426.666667-426.666667S746.666667 85.333333 512 85.333333z m230.4 324.266667l-256 256c-12.8 12.8-34.133333 12.8-46.933333 0h4.266666c-4.266667 0-12.8-4.266667-17.066666-8.533333l-140.8-140.8c-12.8-12.8-12.8-34.133333 0-51.2 12.8-12.8 34.133333-12.8 51.2 0l128 128 234.666666-234.666667c12.8-12.8 34.133333-12.8 46.933334 0l4.266666 4.266667c4.266667 12.8 4.266667 34.133333-8.533333 46.933333z"  /></svg>' + '<span>' + pdpLabel_productSave + '</span>' + '</p>' + '<a target="_blank" class="view-save Button Button-tertiary Button-tertiary--primary " href="' + wishlistUrl + '">' + pdpLabel_viewSavedItems + '<i class="Button-arrow"></i></a>' + '</div>' + '</div>';
      }

      pdpMain.querySelector('.ProductDetail-skuS').innerHTML = html;
      getElements();
      pdpSkuS.forEach(function (item) {
        item.classList.remove('opened');
      });
    }

    function buildSkuCart(data) {
      var html = '';
      var inputAttr = pdpEcommerceEnabled ? pdpInStock ? '' : 'disabled' : '';
      var btnClass = pdpEcommerceEnabled ? pdpInStock ? '' : 'Button-disabled' : '';
      var addLabel = data.addToCartLabel ? data.addToCartLabel : pdpLabel_addToCart;

      if (pdpEcommerceEnabled) {
        if (pdpInStock) {
          pdpSkuAddToCart.classList.remove('inactive');
        } else {
          pdpSkuAddToCart.classList.add('inactive');
        }
      } else {
        pdpSkuAddToCart.classList.remove('inactive');
      }

      if (pdpEcommerceEnabled && !pdpHideCTA && isAPIOpen) {
        html += '<div class="EcomProductDetail-control">' + '<div class="control-inner">' + '<div class="control-btn control-minus"></div>' + '<input disabled type="number" class="control-input" value="1" ' + inputAttr + '>' + '<div class="control-btn control-plus"></div>' + '</div>' + '</div>' + '<div class="EcomProductDetail-cart">' + '<a class="EcomProductDetail-skuAddToCart Button Button-primary ' + btnClass + '">' + '<div class="Button-inner">' + '<span>' + addLabel + '</span>' + '</div>' + '</a>' + '</div>';
      }

      pdpSkuAddToCart.innerHTML = html;
      getElements();
      EPD.setAttribute("data-storeCode", data.storeCode);
      EPD.setAttribute("data-id", data.id);

      if (pdpEcommerceEnabled) {
        document.querySelectorAll('.EcomProductDetail-skuAddToCart').forEach(function (button) {
          button.setAttribute("data-model", data.modelNo);
          button.setAttribute("data-storeCode", data.storeCode);
          button.setAttribute("data-quantity", pdpInput.value);
          button.setAttribute("data-currencyCode", data.currencyCode);
          button.setAttribute("data-modelName", data.name);
          button.setAttribute("data-regularPrice", data.regular_price);
          button.setAttribute("data-finalPrice", data.final_price);
          button.setAttribute("data-productId", data.uid);
        });
        bindControlEvent();
        bindCartEvent();
      }
    }

    function buildSkuWhere(data, index) {
      var popHtml = '';
      var ctaHtml = '';
      var i = index;
      var btnClass = pdpEcommerceEnabled ? 'Button-tertiary' : 'Button-primary';
      var arrowHtml = pdpEcommerceEnabled ? '<i class="Button-arrow"></i>' : '';
      var target = 'target="_blank"';
      popHtml += '<a data-model="' + checkUndefined(data.skus[i].modelNo) + '"' + ' data-country="' + country + '"' + ' data-category="' + checkUndefined(data.categoryEn) + '"' + ' data-isexternal="' + data.is_external + '"' + ' data-site="' + checkUndefined(data.skus[i].brand) + '"' + ' data-locale="' + locale + '"' + ' data-buynowlabel="' + pdpLabel_buyNow + '"' + ' data-micromodal-trigger="whereToBuy" class="Button ' + btnClass + ' ProductDetail-skuWhere gtm-shop">' + pdpLabel_where + arrowHtml + '</a>';
      ctaHtml += '<a ' + target + 'class="ProductDetail-skuCta Button Button-primary" href="' + checkUndefined(data.skus[i].where_to_buy_url) + '">' + checkUndefined(data.skus[i].where_to_buy_label) + arrowHtml + '</a>';

      if (pdpEcommerceEnabled) {
        if (!pdpHideCTA) {
          pdpSkuW.innerHTML = popHtml;
        } else {
          pdpSkuW.innerHTML = '';
        }
      } else {
        if (data.skus[i].wheretobuy) {
          if (!pdpHideCTA) {
            pdpSkuW.innerHTML = popHtml;
          } else {
            pdpSkuW.innerHTML = '';
          }
        } else {
          if (!pdpHideCTA && checkUndefined(data.skus[i].where_to_buy_url) && checkUndefined(data.skus[i].where_to_buy_label)) {
            pdpSkuW.innerHTML = ctaHtml;
          } else {
            pdpSkuW.innerHTML = '';
          }
        }
      }

      getElements();
      Modal(); //For WhereToBuy
    }

    function preventModalVideoLink() {
      var videolinks = pdpCarouselMain.querySelectorAll('.carousels--video');
      videolinks.forEach(function (element) {
        element.addEventListener('click', function (event) {
          event.preventDefault();
        });
      });
    }

    function buildSkuBundle(data) {
      if (pdpSkuBundle) {
        var html = '';

        for (var k = 0; k < 4; k++) {
          html += '<div class="swiper-slide">' + '<div class="swiper-slide-content">' + '<div class="EcomProductDetail-bundle">' + buildSkuCard() + '</div>' + '</div>' + '</div>';
        }

        pdpSkuBundle.querySelector('.swiper-wrapper').innerHTML = html;
        bindBundle();
      }
    }

    function buildSkuCard() {
      var html = '';
      html += '<div class="cardProduct">' + '<div class="card-check">' + '<label class="Form-checkbox" id="bundle-card-1">' + '<input type="checkbox" checked="checked" class="checkbox-custom" name="checkbox-1">' + '<span class="checkbox-text">' + '</span>' + '<div class="Form-control"></div>' + '</label>' + '</div>' + '<div class="card-inner">' + '<div class="card-img">' + '<img src="https://placehold.co/192x192.png">' + '<p class="card-tag ">Promotional Tag</p>' + '</div>' + '<p class="card-name">Halo Infinite Special Edition Game Drive for Xbox</p>' + '<p class="card-price">' + '<span class="value">' + pdpLabel_currencySymbol + '149.99</span>' + '</p>' + '<p class="card-discount">' + '<span class="value">' + pdpLabel_currencySymbol + '189.99</span>' + '<span class="percent">20%' + pdpLabel_off + '</span>' + '</p>' + '</div>' + '</div>';
      return html;
    }

    function buildSkuAccordionHtml(data) {
      var condition = NotUndefined(data.key_specs) || NotUndefined(data.productManual) || NotUndefined(data.datasheet) || NotUndefined(data.key_specs_column2) && NotUndefined(data.key_specs_column2.bullets) || NotUndefined(data.key_specs_column3) && NotUndefined(data.key_specs_column3.bullets);
      var html = '';
      html += buildAccordionDetailHtml(data);
      html += buildAccordionKeySpecsHtml(data);
      html += buildAccordionSystemHtml(data);
      html += buildAccordionIncludeHtml(data);
      html += buildAccordionDocumentHtml(data);
      html += buildAccordionSupportHtml(data);
      pdpSkuAccordion.innerHTML = html;
      components_MFCollapse('.EcomProductDetail-accordion');
    }

    function setStockValue(stock) {
      if (NotUndefined(stock)) {
        if (stock.toLowerCase().indexOf('out') != -1) {
          return 'out';
        } else {
          return 'in';
        }
      } else {
        return 'none';
      }
    }

    function generateFeatureTempArray(data, skufeature) {
      var fArray = [];
      var tempArray = [];
      var uniqueArray = skufeature.values.filter(function (item, pos) {
        return skufeature.values.indexOf(item) == pos;
      });

      for (var k = 0; k < uniqueArray.length; k++) {
        for (var j = 0; j < data.skus.length; j++) {
          if (NotUndefined(data.skus[j].configurator_features)) {
            for (var i = 0; i < data.skus[j].configurator_features.length; i++) {
              var feature = data.skus[j].configurator_features[i];

              if (feature.internal_name == skufeature.internal_name && feature.value == skufeature.values[k]) {
                feature.class = 'feature';
                feature.data_stock = setStockValue(data.skus[j].stock_status);
                feature.data_name = data.internal_name;
                feature.data_model = data.skus[j].modelNo;

                if (j == 0) {
                  feature.class += ' active';
                }

                if (fArray.indexOf(feature.value) === -1) {
                  fArray.push(feature.value);
                } else {
                  feature.class += ' hide';
                }

                tempArray.push(feature);
              }
            }
          }
        }
      }
      /*tempArray.sort(function (a, b) {
        if (checkUndefined(a.order)) {
          if (checkUndefined(a.reverse)) {
            return parseFloat(b.order) - parseFloat(a.order);
          } else {
            return parseFloat(a.order) - parseFloat(b.order);
          }
        } else {
          return -1;
        }
      });*/


      return tempArray;
    }

    function buildSkuFeaturesHtml(data) {
      var featuresArry = data.configurator_features_ordered; //['color','capacity','test','format'];

      var html = '';

      if (NotUndefined(featuresArry)) {
        for (var i = 0; i < featuresArry.length; i++) {
          var feature = featuresArry[i];
          html += buildSkuFeatureEachHtml(data, feature);
        }
      }

      pdpSkuFeatures.innerHTML = html;
    }

    function buildSkuFeatureEachHtml(data, skufeature) {
      var html = '';

      if (NotUndefined(skufeature)) {
        if (skufeature.display_type == 'color') {
          html = buildSkuFeatureColorHtml(data, skufeature);
        } else if (skufeature.display_type == 'dropdown') {
          //html = buildSkuFeatureDropHtml(data, skufeature);
          //new dropdown
          html = buildSkuFeatureDrop2Html(data, skufeature);
        } else {
          html = buildSkuFeatureButtonHtml(data, skufeature);
        }
      }

      return html;
    }

    function buildSkuFeatureColorHtml(data, skufeature) {
      var html = '';
      var tempArray = [];
      tempArray = generateFeatureTempArray(data, skufeature);

      if (NotUndefined(tempArray)) {
        html += '<div class="ProductDetail-skuFeature-row">' + '<label class="ProductDetail-skuFeature-label"><span>' + tempArray[0].name + ' - </span>';
        html += '<div class="color-title">';
        tempArray.forEach(function (feature) {
          html += '<span class="' + feature.class + '" data-val= "' + checkUndefined(feature.value) + '">' + checkUndefined(feature.title) + '</span>';
        });
        html += '</div></label>';
        html += '<ul class="ProductDetail-skuFeature ProductDetail-skuFeature-' + checkUndefined(skufeature.display_type) + ' ProductDetail-skuFeature-' + checkUndefined(skufeature.internal_name) + '">';
        tempArray.forEach(function (feature) {
          html += '<li class="' + feature.class + '" data-type="' + checkUndefined(feature.data_name) + '"' + 'data-val= "' + checkUndefined(feature.value) + '"data-model="' + checkUndefined(feature.data_model) + '--' + checkUndefined(feature.data_stock) + '">' + '<span style="background:' + checkUndefined(feature.value) + '">' + '</span>' + '</li>';
        });
        html += '</ul>';
        html += '</div>';
      }

      return html;
    }

    function buildSkuFeatureButtonHtml(data, skufeature) {
      var html = '';
      var tempArray = [];
      tempArray = generateFeatureTempArray(data, skufeature);

      if (NotUndefined(tempArray)) {
        html += '<div class="ProductDetail-skuFeature-row"><label class="ProductDetail-skuFeature-label">' + tempArray[0].name + '</label>' + '<ul class="ProductDetail-skuFeature ProductDetail-skuFeature-' + checkUndefined(skufeature.display_type) + ' ProductDetail-skuFeature-' + checkUndefined(skufeature.internal_name) + '">';
        tempArray.forEach(function (feature) {
          html += '<li class="' + feature.class + '" data-type="' + checkUndefined(feature.data_name) + '"' + 'data-title="' + checkUndefined(feature.title) + '"' + 'data-val= "' + checkUndefined(feature.value) + '"data-model="' + checkUndefined(feature.data_model) + '--' + checkUndefined(feature.data_stock) + '">' + checkUndefined(feature.value) + '</li>';
        });
        html += '</ul></div>';
      }

      return html;
    }

    function buildSkuFeatureDropHtml(data, skufeature) {
      var html = '';
      var tempArray = [];
      var selectStatus = '';
      tempArray = generateFeatureTempArray(data, skufeature);

      if (NotUndefined(tempArray)) {
        if (tempArray.length == 1) {
          selectStatus = 'disabled';
        }

        html += '<div class="ProductDetail-skuFeature-row"><label class="ProductDetail-skuFeature-label">' + tempArray[0].name + '</label>' + '<div class="ProductDetail-skuFeature ProductDetail-skuFeature-' + checkUndefined(skufeature.display_type) + ' ProductDetail-skuFeature-' + checkUndefined(skufeature.internal_name) + '"><select ' + selectStatus + '>';
        tempArray.forEach(function (feature, index) {
          html += '<option class="' + feature.class + '" data-index="' + index + '" data-type="' + checkUndefined(feature.data_name) + '"' + 'data-val= "' + checkUndefined(feature.value) + '"data-model="' + checkUndefined(feature.data_model) + '--' + checkUndefined(feature.data_stock) + '">' + checkUndefined(feature.value) + '</li>';
        });
        html += '</select></div></div>';
      }

      return html;
    }

    function buildSkuFeatureDrop2Html(data, skufeature) {
      var html = '';
      var tempArray = [];
      var selectStatus = '';
      tempArray = generateFeatureTempArray(data, skufeature);

      if (NotUndefined(tempArray)) {
        if (tempArray.length == 1) {
          selectStatus = 'disabled';
        }

        html += '<div class="ProductDetail-skuFeature-row"><label class="ProductDetail-skuFeature-label">' + tempArray[0].name + '</label>' + '<div class="ProductDetail-skuFeature ProductDetail-skuFeature-' + checkUndefined(skufeature.display_type) + ' ProductDetail-skuFeature-' + checkUndefined(skufeature.internal_name) + '"><div class="sDropdown" ' + selectStatus + '>' + '<div class="sDropdown-toggle">' + '<span class="sDropdown-label">' + checkUndefined(tempArray[0].value) + '</span>' + '<span class="sDropdown-icon">' + '</span>' + '</div>' + '<ul class="sDropdown-menu">';
        tempArray.forEach(function (feature, index) {
          html += '<li class="sDropdown-item ' + feature.class + '" data-index="' + index + '" data-type="' + checkUndefined(feature.data_name) + '"' + 'data-val= "' + checkUndefined(feature.value) + '"data-model="' + checkUndefined(feature.data_model) + '--' + checkUndefined(feature.data_stock) + '">' + checkUndefined(feature.value) + '</li>';
        });
        html += '</ul></div></div></div>';
      }

      return html;
    }

    function buildAccordionDetailHtml(data) {
      var html = '';

      if (NotUndefined(data.skuDetail)) {
        html += '<div class="ProductDetail-block ProductDetail-block--detail accordion-item">' + '<h3 class="accordion-header" id="heading_detail">' + '<a class="accordion-button" type="button" data-toggle="mf-collapse" data-target="#collapse_detail" aria-expanded="true" aria-controls="collapse_detail">' + '<span class="accordion-title">' + pdpLabel_detail + '</span>' + '<span class="collapse-trigger"></span>' + '</a>' + '</h3>' + '<div id="collapse_detail" class="accordion-collapse multi-collapse collapse show">' + '<div class="accordion-content">' + '<div class="details">' + checkUndefined(data.skuDetail) + '</div>' + '</div>' + '</div>' + '</div>';
      }

      return html;
    }

    function buildAccordionKeySpecsHtml(data) {
      var html = '';
      var kswidth = '';
      var ksClass = '';
      var kscount = 0;

      if (NotUndefined(data.key_specs)) {
        html += '<div class="ProductDetail-block ProductDetail-block--keySpecs accordion-item">' + '<h3 class="accordion-header" id="heading_keySpecs">' + '<a class="accordion-button" type="button" data-toggle="mf-collapse" data-target="#collapse_keySpecs" aria-expanded="false" aria-controls="collapse_keySpecs">' + '<span class="accordion-title">' + pdpLabel_keySpecs + '</span>' + '<span class="collapse-trigger"></span>' + '</a>' + '</h3>' + '<div id="collapse_keySpecs" class="accordion-collapse multi-collapse collapse" >' + '<div class="accordion-content">' + '<div class="keySpecs">';

        if (Array.isArray(data.key_specs)) {
          for (var i = 0; i < data.key_specs.length; i++) {
            if (NotUndefined(data.key_specs[i].value)) {
              kscount++;
            }
          }

          for (var i = 0; i < data.key_specs.length; i++) {
            if (NotUndefined(data.key_specs[i].value)) {
              if (kscount > 0) {
                if (kscount < 4) {
                  kswidth = Math.floor(100 / kscount) + '%';
                } else {
                  var row = Math.floor(kscount / 3);
                  var left = kscount % 3;

                  if (i < row * 3) {
                    kswidth = Math.floor(100 / 3) + '%';
                  } else {
                    kswidth = Math.floor(100 / left) + '%';
                  }
                }

                if (kscount % 3 == 0) {
                  ksClass = 'last-row';
                } else {
                  ksClass = '';
                }
              }

              html += '<div class="keySpecs-item ' + ksClass + '" style="width:' + kswidth + '">' + '<strong>' + checkUndefined(data.key_specs[i].name) + '</strong>' + '<span>' + checkUndefined(data.key_specs[i].value) + '</span>' + '</div>';
            }
          }
        }

        html += '</div></div></div></div></div>';
      }

      return html;
    }

    function buildAccordionDocumentHtml(data) {
      var html = '';

      if (NotUndefined(data.productManual) && NotUndefined(data.productManual.url) || NotUndefined(data.datasheet) && NotUndefined(data.datasheet.url)) {
        html += '<div class="ProductDetail-block ProductDetail-block--documentation accordion-item">' + '<h3 class="accordion-header" id="heading_documentation">' + '<a class="accordion-button" type="button" data-toggle="mf-collapse" data-target="#collapse_documentation" aria-expanded="false" aria-controls="collapse_documentation">' + '<span class="accordion-title">' + pdpLabel_documentInfo + '</span>' + '<span class="collapse-trigger"></span>' + '</a>' + '</h3>' + '<div id="collapse_documentation" class="accordion-collapse multi-collapse collapse" >' + '<div class="accordion-content">';

        if (NotUndefined(data.datasheet) && NotUndefined(data.datasheet.url)) {
          html += '<p class="link"><a class="gtm-datasheet Button Button-tertiary Button-download" target="_blank" href="' + checkUndefined(data.datasheet.url) + '">' + '<span>' + checkUndefined(data.datasheet.title) + '<i class="Button-arrow"><em></em></i>' + '</span>' + '</a></p>';
        }

        if (NotUndefined(data.productManual) && NotUndefined(data.productManual.url)) {
          html += '<p class="link"><a class="gtm-usermanual Button Button-tertiary Button-download" target="_blank" href="' + checkUndefined(data.productManual.url) + '">' + '<span>' + checkUndefined(data.productManual.title) + '<i class="Button-arrow"><em></em></i>' + '</span>' + '</a></p>';
        }

        html += '<p class="link"><a class="Button Button-tertiary" target="_blank" href="/esg/planet/product-sustainability/#plca"><span>' + pdpLabel_lifeCycleAssessment + '<i class="Button-arrow"><em></em></i></span></a></p>';
        html += '</div></div></div></div>';
      }

      return html;
    }

    function buildAccordionSystemHtml(data) {
      var html = '';

      if (NotUndefined(data.key_specs_column2) && NotUndefined(data.key_specs_column2.bullets)) {
        html += '<div class="ProductDetail-block ProductDetail-block--system accordion-item">' + '<h3 class="accordion-header" id="heading_system">' + '<a class="accordion-button" type="button" data-toggle="mf-collapse" data-target="#collapse_system" aria-expanded="false" aria-controls="collapse_system">' + '<span class="accordion-title">' + checkUndefined(data.key_specs_column2.header) + '</span>' + '<span class="collapse-trigger"></span>' + '</a>' + '</h3> ' + '<div id="collapse_system" class="accordion-collapse multi-collapse collapse" >' + '<div class="accordion-content">';
        html += '<ul>';

        if (Array.isArray(data.key_specs_column2.bullets)) {
          for (var i = 0; i < data.key_specs_column2.bullets.length; i++) {
            html += '<li>' + checkUndefined(data.key_specs_column2.bullets[i]) + '</li>';
          }
        }

        html += '</ul></div></div></div></div>';
      }

      return html;
    }

    function buildAccordionIncludeHtml(data) {
      var html = '';

      if (NotUndefined(data.key_specs_column3) && NotUndefined(data.key_specs_column3.bullets)) {
        html += '<div class="ProductDetail-block ProductDetail-block--include accordion-item">' + '<h3 class="accordion-header" id="heading_include">' + '<a class="accordion-button" type="button" data-toggle="mf-collapse" data-target="#collapse_include" aria-expanded="false" aria-controls="collapse_include">' + '<span class="accordion-title">' + checkUndefined(data.key_specs_column3.header) + '</span>' + '<span class="collapse-trigger"></span>' + '</a>' + '</h3> ' + '<div id="collapse_include" class="accordion-collapse multi-collapse collapse" >' + '<div class="accordion-content">';
        html += '<ul>';

        if (Array.isArray(data.key_specs_column3.bullets)) {
          for (var i = 0; i < data.key_specs_column3.bullets.length; i++) {
            html += '<li>' + checkUndefined(data.key_specs_column3.bullets[i]) + '</li>';
          }
        }

        html += '</ul></div></div></div></div>';
      }

      return html;
    }

    function buildAccordionSupportHtml(data) {
      var html = '';

      if (NotUndefined(data.supportAnchorLabel) && NotUndefined(data.supportAnchorLink) || pdpEcommerceEnabled && (NotUndefined(data.shopHelp) && NotUndefined(data.shopHelpUrl) || NotUndefined(data.shippingFaq) && NotUndefined(data.shippingFaqUrl) || NotUndefined(data.supportChat) && NotUndefined(data.supportChatUrl))) {
        html += '<div class="ProductDetail-block ProductDetail-block--support accordion-item">' + '<h3 class="accordion-header" id="heading_support">' + '<a class="accordion-button" type="button" data-toggle="mf-collapse" data-target="#collapse_support" aria-expanded="false" aria-controls="collapse_support">' + '<span class="accordion-title">' + pdpLabel_support + '</span>' + '<span class="collapse-trigger"></span>' + '</a>' + '</h3>' + '<div id="collapse_support" class="accordion-collapse multi-collapse collapse" >' + '<div class="accordion-content">';

        if (NotUndefined(data.supportAnchorLabel) && NotUndefined(data.supportAnchorLink)) {
          html += '<p class="link">' + '<a href="' + data.supportAnchorLink + '" class="Button Button-tertiary">' + '<span>' + data.supportAnchorLabel + '<i class="Button-arrow"></i></span>' + '</a>' + '</p>';
        }

        if (pdpEcommerceEnabled) {
          if (NotUndefined(data.shopHelp) && NotUndefined(data.shopHelpUrl)) {
            html += '<p class="link">' + '<a href="' + data.shopHelpUrl + '" class="Button Button-tertiary">' + '<span>' + data.shopHelp + '<i class="Button-arrow"></i></span>' + '</a>' + '</p>';
          }

          if (NotUndefined(data.shippingFaq) && NotUndefined(data.shippingFaqUrl)) {
            html += '<p class="link">' + '<a href="' + data.shippingFaqUrl + '" class="Button Button-tertiary">' + '<span>' + data.shippingFaq + '<i class="Button-arrow"></i></span>' + '</a>' + '</p>';
          }

          if (NotUndefined(data.supportChatUrl) && NotUndefined(data.supportChat)) {
            html += '<p class="link">' + '<a href="' + data.supportChatUrl + '" class="Button Button-tertiary">' + '<span>' + data.supportChat + '<i class="Button-arrow"></i></span>' + '</a>' + '</p>';
          }
        }

        html += '</div></div></div></div>';
      }

      return html;
    }

    function updateSkuCarousel(result) {
      //debugger;
      buildPDPCarousel(result);
      Modal();
    }

    function updateRatingReviews(model) {
      if (pdpReview && bvLoader) {
        var ratingReviews = document.querySelector('[data-bv-show="reviews"]');

        if (ratingReviews) {
          ratingReviews.dataset.bvProductId = model;
        }
      }
    }

    function updateRatingSummary(model) {
      if (pdpReview && bvLoader) {
        var ratingSummary = document.querySelector('[data-bv-show="rating_summary"]');

        if (ratingSummary) {
          ratingSummary.dataset.bvProductId = model;
        }
      }
    }

    function updateSkuDetail(result, i) {
      //debugger;
      pdpSkuName.innerHTML = buildImgEditIcon(result.skus[i]) + result.skus[i].name;
      pdpSkuDes.innerHTML = result.skus[i].overview;
      var priceHtml = buildSkuPriceHtml(result.skus[i]);

      if (pdpSkuPrice) {
        pdpSkuPrice.innerHTML = priceHtml;
      }

      pdpSkuDes.innerHTML = result.skus[i].overview;
      buildSkuPromotionHtml(result.skus[i]);
      var modalClass = 'warn';

      if (result.skus[i]['addToCartWarn'] && result.skus[i]['addToCartWarn'] == true) {
        pdpSkuModel.classList.add(modalClass);
      } else {
        if (pdpSkuModel.classList.contains(modalClass)) {
          pdpSkuModel.classList.remove(modalClass);
        }
      }

      if (!result.skus[i]['hideSkuNumber'] && NotUndefined(result.skus[i].modelNo)) {
        pdpSkuModel.innerHTML = pdpLabel_model + '<span class="value">' + result.skus[i].modelNo + '</span>';
      } else {
        pdpSkuModel.innerHTML = '<span class="value"></span>';
      }

      updateRatingSummary(result.skus[i].modelNo);
      updateRatingReviews(result.skus[i].modelNo);
      buildSkuWhere(result, i);

      if (pdpInStock) {
        pdpSkuStock.classList.remove('out');
        pdpSkuStock.classList.add('in');
      } else {
        pdpSkuStock.classList.remove('in');
        pdpSkuStock.classList.add('out');
      }

      if (pdpEcommerceEnabled && !pdpHideCTA) {
        pdpSkuStock.innerHTML = checkUndefined(result.skus[i].stock_status_label);
      } else {
        pdpSkuStock.innerHTML = '';
        pdpSkuStock.classList.remove('in');
        pdpSkuStock.classList.remove('out');
      } ///buildSkuRating(result, i);


      buildSkuApiAlertHtml();
      buildSkuCart(result.skus[i]);
    }

    function bindCarousel() {
      //debugger;
      if (comp != undefined) {
        comp.destroy();
      }

      var el = EPD.querySelector(EcomProductDetail.defaultCarouselSelector); //comp = EcomProductDetail.Carousel({el});

      if (pdpCarouselMain.querySelector('.swiper-slide')) {
        comp = EcomProductDetail.Carousel({
          el: el
        });
      }
    }

    function CalBundle(record) {
      //debugger;
      var bundleSum = pdpSkuBundle.querySelector('.bundle-sum');
      var sum = parseFloat(bundleSum.innerHTML.replace(pdpLabel_currencySymbol, ''));
      var input = record[0].target;
      var card = input.closest('.card-check').parentElement;
      var price = parseFloat(card.querySelector('.card-price .value').innerHTML.replace(pdpLabel_currencySymbol, ''));

      if (input.getAttribute('checked') == 'checked') {
        sum += price;
      } else {
        sum -= price;
      }

      bundleSum.innerHTML = pdpLabel_currencySymbol + sum;
    }

    function bindBundle() {
      //debugger;
      var el = EPD.querySelector(EcomProductDetail.defaultBundleSelector);
      EcomProductDetail.Bundles({
        el: el
      });
      var checkboxes = pdpSkuBundle.querySelectorAll('.Form-checkbox');
      checkboxes.forEach(function (checkbox) {
        var input = checkbox.querySelector('input');
        input.addEventListener('click', function () {
          var checked = input.checked;

          if (checked) {
            input.setAttribute('checked', 'checked');
          } else {
            input.removeAttribute('checked');
          }
        });
      });
    }

    var observerBundles;

    var watchBundles = function watchBundles() {
      observerBundles = new MutationObserver(function (mutationRecords) {
        //console.log(mutationRecords);
        CalBundle(mutationRecords);
      });

      if (pdpSkuBundle) {
        var nodes = pdpSkuBundle.querySelectorAll('.card-check input');
        var config = {
          attributes: true,
          attributeFilter: ['checked']
        };
        nodes.forEach(function (node) {
          observerBundles.observe(node, config);
        });
      }
    };

    watchBundles();
  }

  var checkWarranty = function checkWarranty() {
    if (EPD_warranty) {
      var checkboxes = EPD_warranty.querySelectorAll('.Form-checkbox');
      checkboxes.forEach(function (checkbox) {
        var input = checkbox.querySelector('input');
        input.addEventListener('click', function () {
          //debugger;
          var checked = input.checked;
          var media = input.closest('.media');
          var ws = media.querySelectorAll('.Form-checkbox input');

          if (checked) {
            ws.forEach(function (w) {
              w.checked = true;
              w.setAttribute('checked', 'checked');
            });
          } else {
            ws.forEach(function (w) {
              w.checked = false;
              w.removeAttribute('checked');
            });
          }
        });
      });
    }
  };

  window.addEventListener('resize', function () {
    setTimeout(function () {}, 300);
  });
  window.addEventListener('load', function () {});
  checkWarranty();
};

EcomProductDetail.Carousel = function (_ref) {
  var el = _ref.el;
  var autoplayDelay = 6000;
  var transitionSpeed = 300;
  var EPD = document.querySelector('.EcomProductDetail');

  if (EPD) {
    var EPD_Carousel = EPD.querySelector('.EcomProductDetail-carousels');
    var layoutForCarouselEl = EPD.querySelector('.EcomProductDetail-sidebar .top-bottom');
    var layoutForCarouselMobileEl = EPD.querySelector('.layout-forCarouselMobile');
    var singleSlideClass = 'EcomProductDetail-carousels--singleSlide';
    var bgSwiperEl = el.querySelector('.EcomProductDetail-carousels-mainContainer .swiper-container');
    var contentSwiperEl = el.querySelector('.EcomProductDetail-carousels-thumbContainer .swiper-container');
    var SliderSwiperEl = el.querySelector('.EcomProductDetail-carousels-contentPanel .swiper-wrapper');
    var SliderActiveEl = el.querySelector('.EcomProductDetail-carousels-contentPanel .swiper-slide-active');
    var SliderEl = el.querySelectorAll('.EcomProductDetail-carousels-contentPanel .swiper-slide');
    var leftButtonEl = el.querySelector('.EcomProductDetail-carousels-navArrowButton-left');
    var paginationContainerEl = el.querySelector('.EcomProductDetails-carousel-paginationContainer');
    var rightButtonEl = el.querySelector('.EcomProductDetail-carousels-navArrowButton-right');
    var browserInfo = new (ua_parser_default())().getBrowser();
    var isAutoplayRunning = true;

    var isSingleSlide = function isSingleSlide(swiperEl) {
      if (el.classList.contains(singleSlideClass) || swiperEl && swiperEl.querySelector('.swiper-wrapper').children.length < 2) {
        el.classList.add(singleSlideClass);
        return true;
      }
    };

    var bgSwiper;
    var contentSwiper;
    var contentSwiperMobile;

    var checkSwiper = function checkSwiper() {
      if (bgSwiper != undefined) {
        bgSwiper.destroy();
      }

      if (contentSwiper != undefined) {
        //contentSwiper.detachEvents();
        contentSwiper.destroy();
      }
    };

    var old = 0;

    var setSwiperHeightForIE = function setSwiperHeightForIE(swiperEl, swiper) {
      if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version) && !isSingleSlide(swiperEl)) {
        SliderActiveEl = swiperEl.querySelector('.swiper-slide-active');

        if (SliderActiveEl) {
          SliderActiveEl.style.height = 'auto';
          SliderSwiperEl.style.height = 'auto';

          if (old != swiperEl.realIndex) {
            swiperEl.style.height = SliderActiveEl.clientHeight + 'px';
            old = swiper.realIndex;
          }
        }
      }
    };

    var appendCarousel = function appendCarousel() {
      //debugger;
      if (utilities_CustomUtil.screenIs == 'isMobile') {
        if (!layoutForCarouselMobileEl.querySelector('.EcomProductDetail-carousels')) {
          layoutForCarouselMobileEl.appendChild(EPD_Carousel);
        }
      } else {
        if (!layoutForCarouselEl.querySelector('.EcomProductDetail-carousels')) {
          layoutForCarouselEl.appendChild(EPD_Carousel);
        }
      }
    };

    utilities_CustomUtil.initCheckScreen();
    appendCarousel();

    var initSwiper = function initSwiper() {
      checkSwiper();
      bgSwiper = new core_class(bgSwiperEl, {
        allowTouchMove: !isSingleSlide(bgSwiperEl) && utilities_CustomUtil.screenIs != 'isLaptop',
        //autoplay: isSingleSlide(bgSwiperEl) ? false : { delay: autoplayDelay },
        fadeEffect: {
          crossFade: true
        },
        loop: false,
        speed: transitionSpeed,
        effect: 'fade'
      }); //if (CustomUtil.screenIs != 'isLaptop') {

      contentSwiper = new core_class(contentSwiperEl, {
        // NOTE: Auto height does not work on IE11.
        direction: utilities_CustomUtil.screenIs == 'isLaptop' ? "vertical" : "horizontal",
        //allowTouchMove: CustomUtil.screenIs != 'isLaptop',
        autoHeight: !(browserInfo.name === 'IE' && /^11/.test(browserInfo.version)),
        //autoplay: isSingleSlide(contentSwiperEl) ? false : { delay: autoplayDelay },
        fadeEffect: {
          crossFade: true
        },
        loop: false,
        speed: transitionSpeed,
        effect: 'slide',
        slidesPerView: 'auto',
        watchSlidesProgress: true,
        watchSlidesVisibility: true,
        watchOverflow: true,
        navigation: {
          nextEl: rightButtonEl,
          prevEl: leftButtonEl
        }
      });

      if (!isSingleSlide(bgSwiperEl)) {//updateSwiperHeight();
      }

      contentSwiper.on('slideChange', function () {///bgSwiper.slideTo(contentSwiper.realIndex);
      });
      contentSwiper.on('transitionEnd', function () {//console.log(contentSwiper.realIndex);
        ////updateSwiperHeight();
      });
      contentSwiper.on('autoplayStop', function () {
        return isAutoplayRunning = false;
      });

      if (paginationContainerEl) {
        paginationContainerEl.children.forEach(function (child, i) {
          return child.addEventListener('click', child.handleClick = function () {
            contentSwiper.autoplay.stop();
            contentSwiper.slideToLoop(i);
          });
        });
      } //}


      if (SliderEl) {
        SliderEl[0].classList.add('active--laptop');
      }

      if (!isSingleSlide(bgSwiperEl)) {////updateSwiperHeight();
      }

      SliderEl.forEach(function (el) {
        el.addEventListener('click', function (e) {
          e.preventDefault(); //if (CustomUtil.screenIs != 'isMobile') {

          var index = Array.prototype.slice.call(SliderEl).indexOf(e.currentTarget); //if (index != -1) {
          //  index = index + 1;
          //}

          bgSwiper.slideTo(index);
          bgSwiper.autoplay.stop(); //}
        });
      });
      bgSwiper.on('slideChange', function () {
        updateStoryTabs();
      });
      bgSwiper.on('transitionEnd', function () {//console.log(bgSwiper.realIndex);
        //updateSwiperHeight();
      });
      bgSwiper.on('autoplayStop', function () {
        return isAutoplayRunning = false;
      });
    };

    initSwiper();

    var updateStoryTabs = function updateStoryTabs() {
      SliderEl.forEach(function (tabEl, i) {
        var isActiveIndex = i === bgSwiper.realIndex;
        console.log(bgSwiper.realIndex);

        if (isActiveIndex) {
          tabEl.classList.add('active--laptop');
        } else {
          tabEl.classList.remove('active--laptop');
        } //let barEl = tabEl.querySelector('.FeatureContentLayoutCarousel-paginationButton-progressBar');
        //barEl.style.transition = isActiveIndex && isAutoplayRunning ? 'width ${autoplayDelay + transitionSpeed}ms linear' : 'none';
        //barEl.style.width = isActiveIndex ? '100%' : 0;

      });
    };

    leftButtonEl.addEventListener('click', leftButtonEl.handleClick = function () {
      contentSwiper.autoplay.stop(); //contentSwiper.slidePrev();
    });
    rightButtonEl.addEventListener('click', rightButtonEl.handleClick = function () {
      contentSwiper.autoplay.stop(); //contentSwiper.slideNext();
    });
    window.addEventListener('resize', function (e) {
      setTimeout(function () {
        appendCarousel();

        if (contentSwiper != undefined && contentSwiper.params != undefined) {
          if (utilities_CustomUtil.screenIs != 'isLaptop') {
            contentSwiper.changeDirection('horizontal');
          } else {
            contentSwiper.changeDirection('vertical');
          }
        }
      }, 300);
    });
    return {
      destroy: function destroy() {
        if (bgSwiper != undefined) {
          bgSwiper.destroy();
        }

        if (contentSwiper != undefined) {
          //contentSwiper.detachEvents();
          contentSwiper.destroy();
        }

        if (leftButtonEl) {
          leftButtonEl.classList.remove('swiper-button-lock');
          leftButtonEl.classList.remove('swiper-button-disabled');
          leftButtonEl.removeEventListener('click', leftButtonEl.handleClick);
        }

        if (rightButtonEl) {
          rightButtonEl.classList.remove('swiper-button-lock');
          rightButtonEl.classList.remove('swiper-button-disabled');
          rightButtonEl.removeEventListener('click', rightButtonEl.handleClick);
        }

        if (paginationContainerEl && paginationContainerEl.children) {
          paginationContainerEl.children.forEach(function (child) {
            return child.removeEventListener('click', child.handleClick);
          });
        }
      }
    };
  }
};

EcomProductDetail.defaultCarouselSelector = '.EcomProductDetail-carousels';

EcomProductDetail.initAllCarousel = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? EcomProductDetail.defaultCarouselSelector : _ref2$selector;

  return EcomProductDetail_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    EcomProductDetail.Carousel({
      el: el
    });
  });
};

EcomProductDetail.Bundles = function (_ref3) {
  var el = _ref3.el;
  var autoplayDelay = 6000;
  var transitionSpeed = 300;
  var singleSlideClass = 'EcomProductDetail-bundles--singleSlide';
  var twoSlideClass = 'EcomProductDetail-bundles--twoSlide';
  var threeSlideClass = 'EcomProductDetail-bundles--threeSlide';
  var contentSwiperEl = el.querySelector('.EcomProductDetail-bundles-mainContainer .swiper-container');
  var SliderSwiperEl = el.querySelector('.EcomProductDetail-bundles-contentPanel .swiper-wrapper');
  var SliderActiveEl = el.querySelector('.EcomProductDetail-bundles-contentPanel .swiper-slide-active');
  var SliderEl = el.querySelectorAll('.EcomProductDetail-bundles-contentPanel .swiper-slide');
  var leftButtonEl = el.querySelector('.EcomProductDetail-bundles-navArrowButton-left');
  var paginationContainerEl = el.querySelector('.EcomProductDetails-bundles-paginationContainer');
  var rightButtonEl = el.querySelector('.EcomProductDetail-bundles-navArrowButton-right');
  var browserInfo = new (ua_parser_default())().getBrowser();
  var isAutoplayRunning = true;

  var isSingleSlide = function isSingleSlide(swiperEl) {
    if (el.classList.contains(singleSlideClass) || swiperEl && swiperEl.querySelector('.swiper-wrapper').children.length < 2) {
      el.classList.add(singleSlideClass);
      return true;
    }
  };

  var isTwoSlide = function isTwoSlide(swiperEl) {
    if (el.classList.contains(twoSlideClass) || swiperEl.querySelector('.swiper-wrapper').children.length < 3) {
      el.classList.add(twoSlideClass);
      return true;
    } else {
      el.classList.remove(twoSlideClass);
      return false;
    }
  };

  var contentSwiper;

  var checkSwiper = function checkSwiper() {
    if (contentSwiper != undefined) {
      //contentSwiper.detachEvents();
      contentSwiper.destroy();
    }
  };

  var old = 0;

  var setSwiperHeightForIE = function setSwiperHeightForIE(swiperEl, swiper) {
    if (browserInfo.name === 'IE' && /^11/.test(browserInfo.version) && !isSingleSlide(contentSwiperEl)) {
      SliderActiveEl = swiperEl.querySelector('.swiper-slide-active');

      if (SliderActiveEl) {
        SliderActiveEl.style.height = 'auto';
        SliderSwiperEl.style.height = 'auto';

        if (old != swiperEl.realIndex) {
          swiperEl.style.height = SliderActiveEl.clientHeight + 'px';
          old = swiper.realIndex;
        }
      }
    }
  };

  utilities_CustomUtil.initCheckScreen();

  var initSwiper = function initSwiper() {
    checkSwiper();
    isTwoSlide(contentSwiperEl); //if (CustomUtil.screenIs != 'isLaptop') {

    contentSwiper = new core_class(contentSwiperEl, {
      // NOTE: Auto height does not work on IE11.
      allowTouchMove: !isSingleSlide(contentSwiperEl),
      autoHeight: !(browserInfo.name === 'IE' && /^11/.test(browserInfo.version)),
      //autoplay: isSingleSlide(contentSwiperEl) ? false : { delay: autoplayDelay },
      fadeEffect: {
        crossFade: true
      },
      loop: false,
      speed: transitionSpeed,
      effect: 'slide',
      slidesPerView: 'auto',
      watchSlidesProgress: true,
      watchSlidesVisibility: true,
      watchOverflow: true,
      navigation: {
        nextEl: rightButtonEl,
        prevEl: leftButtonEl
      }
    });
    contentSwiper.on('autoplayStop', function () {
      return isAutoplayRunning = false;
    });

    if (paginationContainerEl) {
      paginationContainerEl.children.forEach(function (child, i) {
        return child.addEventListener('click', child.handleClick = function () {
          contentSwiper.autoplay.stop();
          contentSwiper.slideToLoop(i);
        });
      });
    } //}
    //SliderEl[0].classList.add('active--laptop');

  };

  initSwiper();
  leftButtonEl.addEventListener('click', leftButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slidePrev();
  });
  rightButtonEl.addEventListener('click', rightButtonEl.handleClick = function () {
    contentSwiper.autoplay.stop();
    contentSwiper.slideNext();
  });
  return {
    destroy: function destroy() {
      if (contentSwiper != undefined) {
        contentSwiper.detachEvents();
        contentSwiper.destroy();
      }

      leftButtonEl.removeEventListener('click', leftButtonEl.handleClick);
      rightButtonEl.removeEventListener('click', rightButtonEl.handleClick);
      paginationContainerEl.children.forEach(function (child) {
        return child.removeEventListener('click', child.handleClick);
      });
    }
  };
};

EcomProductDetail.defaultBundleSelector = '.EcomProductDetail-bundles';

EcomProductDetail.initAllBundles = function () {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref4$selector = _ref4.selector,
      selector = _ref4$selector === void 0 ? EcomProductDetail.defaultBundleSelector : _ref4$selector;

  return EcomProductDetail_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    EcomProductDetail.Bundles({
      el: el
    });
  });
};

EcomProductDetail.Sticky = function () {
  //debugger;
  var EPD = document.querySelector('.EcomProductDetail');

  if (EPD) {
    var EPD_Container = document.querySelector('.EcomProductDetail > .Container');
    var EPD_Header = EPD.querySelector('.EcomProductDetail-header');
    var EPD_sidebar = EPD.querySelector('.EcomProductDetail-sidebar');
    var EPD_sidebarToSticky = EPD.querySelector('.EcomProductDetail-sidebar .with-sticky');
    var EPD_main = EPD.querySelector('.EcomProductDetail-main');
    var EPD_cart = EPD_main.querySelector('.EcomProductDetail-cart');
    var pdpSkuCTA = EPD_main.querySelector('.ProductDetail-skuW');
    var pdpSkuAddToCart = EPD_main.querySelector('.EcomProductDetail-addToCart');
    var pdpSkuFeatures = EPD_main.querySelector('.ProductDetail-skuFeatures');
    var EPD_message_absolute = EPD.querySelector('.EcomProductDetailMessage.message-absolute');
    var EPD_message_fixed = EPD.querySelector('.EcomProductDetailMessage.message-fixed');
    var scroTop = window.scrollY || document.documentElement.scrollTop;
    var EPD_Top = EPD.offsetTop;
    var EPD_Cart_Top = EPD.offsetTop + pdpSkuAddToCart.offsetTop; // + 68; //EPD_cart.clientHeight;

    var EPD_Features_Top = EPD.offsetTop + pdpSkuFeatures.offsetTop - utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
    ;
    var EPD_Carousel_Top;
    var EPD_MobileSticky_Top;
    var EPD_Height = EPD.clientHeight;
    var EPD_sidebar_Height = EPD_sidebar ? EPD_sidebar.clientHeight : 0;
    var EPD_containerMargin;
    var isLaptop;
    var isMobile;
    var prevScroTop = 0;
    var stickyEndFlag = null;
    var ticking;
    var toEnd = false; //ScrollDown End sticky to avoid flash

    var toStart = false; //ScrollUp Start  sticky to avoid flash

    var sidebarStickyOptions = {};
    var headerStickyOptions = {};

    var initElements = function initElements() {
      isLaptop = utilities_CustomUtil.screenIs == 'isLaptop';
      isMobile = utilities_CustomUtil.screenIs == 'isMobile';
      EPD_Top = EPD.offsetTop;
      EPD_Features_Top = EPD.offsetTop + pdpSkuFeatures.offsetTop - utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      EPD_Carousel_Top = EPD.offsetTop + EPD.querySelector('.layout-forCarouselMobile').offsetTop - utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      EPD_MobileSticky_Top = EPD.offsetTop + 60 - 2 * utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      EPD_sidebar_Height = EPD_sidebar ? EPD_sidebar.clientHeight : 0;
      EPD_containerMargin = parseFloat(utilities_CustomUtil.getStyle(EPD_Container).marginLeft);
      resetElements();
    };

    var resetElements = function resetElements() {
      isLaptop = utilities_CustomUtil.screenIs == 'isLaptop';
      isMobile = utilities_CustomUtil.screenIs == 'isMobile';
      EPD_Height = EPD.clientHeight;
      EPD_Cart_Top = EPD.offsetTop + pdpSkuAddToCart.offsetTop; // + 68; //EPD_cart.clientHeight;

      EPD_Features_Top = EPD.offsetTop + pdpSkuFeatures.offsetTop - utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      EPD_Carousel_Top = EPD.offsetTop + EPD.querySelector('.layout-forCarouselMobile').offsetTop - utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      EPD_MobileSticky_Top = EPD.offsetTop + 60 - 2 * utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      resetMessageStyle();
      setSidebarStickyOptions();
      setHeaderStickyOptions();
    };

    var addStickyEndFlag = function addStickyEndFlag() {
      if (document.querySelector('.sticky-end-tag') == null) {
        var flag = document.createElement('a');
        flag.className = 'sticky-end-tag with-sticky in-sticky';
        EPD.appendChild(flag);
        stickyEndFlag = document.querySelector('.sticky-end-tag');
      }
    };

    var setSidebarStickyOptions2 = function setSidebarStickyOptions2() {
      stickyEndFlag = document.querySelector('.sticky-end-tag');
      var startTop = EPD_Top;
      var stickyTop = utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      var headerTop = utilities_CustomUtil.settings.headerFixedHeight;
      var endTop = stickyEndFlag.offsetTop - EPD_sidebarToSticky.clientHeight - 2 * utilities_CustomUtil.getInPageNavHeight();
      endTop = EPD_main.clientHeight + headerTop + stickyTop - EPD_sidebarToSticky.clientHeight - 2 * utilities_CustomUtil.getInPageNavHeight();
      endTop = EPD_main.clientHeight + EPD_Top - EPD_sidebarToSticky.clientHeight - 2 * utilities_CustomUtil.getInPageNavHeight();
      EPD_sidebarToSticky.setAttribute("data-stickyEnd", endTop); //debugger;
      //var stickyTop = CustomUtil.getInStickyTop(EPD_sidebarToSticky);
      //var isLong = EPD_sidebarToSticky.clientHeight > (window.innerHeight - startTop) ? true: false;

      var isLong = EPD_sidebarToSticky.clientHeight > window.innerHeight ? true : false;
      var visibleHeight = isLong ? window.innerHeight + stickyTop : EPD_sidebarToSticky.clientHeight + stickyTop;
      sidebarStickyOptions.element = EPD_sidebarToSticky;
      sidebarStickyOptions.overlap = false; //True is make Header overlap the sidebar

      sidebarStickyOptions.startTopDown = startTop - stickyTop;
      sidebarStickyOptions.startTopUp = startTop - stickyTop - utilities_CustomUtil.getInPageNavHeight();
      sidebarStickyOptions.endTopDown = stickyEndFlag.offsetTop - visibleHeight;
      sidebarStickyOptions.endTopUp = stickyEndFlag.offsetTop - utilities_CustomUtil.getInPageNavHeight();
      sidebarStickyOptions.isLong = isLong;
    };

    var setSidebarStickyOptions = function setSidebarStickyOptions() {
      stickyEndFlag = document.querySelector('.sticky-end-tag');
      var startTop = EPD_Top;
      var endTop = stickyEndFlag.offsetTop - EPD_sidebarToSticky.clientHeight - 80;
      EPD_sidebarToSticky.setAttribute("data-stickyEnd", endTop); //debugger;

      var stickyTop = utilities_CustomUtil.getInStickyTop(EPD_sidebarToSticky); //var isLong = EPD_sidebarToSticky.clientHeight > (window.innerHeight - startTop) ? true: false;

      var isLong = EPD_sidebarToSticky.clientHeight > window.innerHeight ? true : false;
      var visibleHeight = isLong ? window.innerHeight + stickyTop : EPD_sidebarToSticky.clientHeight + stickyTop;
      sidebarStickyOptions.element = EPD_sidebarToSticky;
      sidebarStickyOptions.overlap = false; //True is make Header overlap the sidebar

      sidebarStickyOptions.startTopDown = startTop - stickyTop;
      sidebarStickyOptions.startTopUp = startTop - stickyTop - utilities_CustomUtil.getInPageNavHeight();
      sidebarStickyOptions.endTopDown = stickyEndFlag.offsetTop - visibleHeight;
      sidebarStickyOptions.endTopUp = stickyEndFlag.offsetTop - visibleHeight - utilities_CustomUtil.getInPageNavHeight();
      sidebarStickyOptions.isLong = isLong;
    };

    var setHeaderStickyOptions = function setHeaderStickyOptions() {
      var startTop = EPD_Cart_Top; //debugger;

      if (isMobile) {
        startTop = EPD_MobileSticky_Top; //EPD_Carousel_Top; //EPD_Features_Top; 
      }

      headerStickyOptions.element = EPD_Header;
      headerStickyOptions.startTop = startTop + 68; //EPD_cart.clientHeight;
    };

    var initEPDScrollEvent = function initEPDScrollEvent() {
      /*if(!isMobile){
        resetSidebarStyle();
        var scroTop = window.scrollY || document.documentElement.scrollTop;
        var stickyTop = CustomUtil.getInStickyTop(EPD_sidebarToSticky);
        var maxTop = CustomUtil.getStickyMaxTop();
        var sidebarTop;
        if(scroTop > EPD_Top) {
          sidebarTop = stickyTop; 
        }else {
          sidebarTop = CustomUtil.settings.headerFixedHeight + stickyTop; 
        }
        sidebarTop = EPD.offsetTop;
        EPD_sidebarToSticky.style.top = sidebarTop + 'px';
      }*/
      var hasHash = document.location.hash || getSkuFromQuery() != '';

      if (!hasHash) {
        window.scrollTo(0, 0);
        setTimeout(function () {
          window.scrollTo(0, 0);
        }, 100);
      }
    };

    var bindEPDScrollEvent = function bindEPDScrollEvent() {
      utilities_CustomUtil.updateSettings();
      utilities_CustomUtil.initCheckScreen();
      var scroTop = window.scrollY || document.documentElement.scrollTop;
      isLaptop = utilities_CustomUtil.screenIs == 'isLaptop';
      isMobile = utilities_CustomUtil.screenIs == 'isMobile';
      var direction = scroTop > prevScroTop ? 'down' : 'up';
      var scrollGap = scroTop - prevScroTop; //debugger;

      headerStickyOptions.endTop = utilities_CustomUtil.getStickyMaxTop() - 2 * utilities_CustomUtil.getInPageNavHeight();
      headerStickyOptions.isSticky = EPD_Header.classList.contains('.sticky-fixed') ? true : false;
      var isCartEnabled = pdpSkuAddToCart && !pdpSkuAddToCart.classList.contains('inactive') && pdpSkuCTA.querySelector('a') || EPD.classList.contains('api-down') && EPD.classList.contains('ecommerceEnabled'); // pdpSkuAddToCart && pdpSkuAddToCart.querySelector('.EcomProductDetail-cart') && !pdpSkuAddToCart.classList.contains('inactive');

      var headerFixedCondition = scroTop > headerStickyOptions.startTop && scroTop < headerStickyOptions.endTop && isCartEnabled;

      if (direction == 'down') {
        toStart = false;

        if (toEnd) {
          headerFixedCondition = false;
        }
      } else {
        toEnd = false;

        if (toStart) {
          headerFixedCondition = scroTop > headerStickyOptions.startTop && isCartEnabled && true;
        }
      }

      if (scroTop >= headerStickyOptions.endTop) {
        toEnd = true;
      } else {
        toStart = true;
      }

      utilities_CustomUtil.bindStickyEvent(headerFixedCondition, EPD_Header); //debugger;

      if (direction == 'up') {
        sidebarStickyOptions.startTop = sidebarStickyOptions.startTopUp;
        sidebarStickyOptions.endTop = sidebarStickyOptions.endTopUp;
      } else {
        sidebarStickyOptions.startTop = sidebarStickyOptions.startTopDown;
        sidebarStickyOptions.endTop = sidebarStickyOptions.endTopDown;
      }

      var isEnough = EPD_sidebarToSticky.clientHeight < EPD_main.clientHeight;
      var sideBarFixedCondition = scroTop > sidebarStickyOptions.startTop && !isMobile && isEnough && scroTop < sidebarStickyOptions.endTop; //sideBarFixedCondition = scroTop > sidebarStickyOptions.startTop && !isMobile && isEnough; //When end to static.

      sidebarStickyOptions.condition = sideBarFixedCondition;
      sidebarStickyOptions.direction = direction;
      sidebarStickyOptions.scrollGap = scrollGap;
      sidebarStickyOptions.headerCondition = headerStickyOptions;
      utilities_CustomUtil.bindStickySidebarEvent(sidebarStickyOptions);
      var messageFixedCondition = scroTop > EPD.offsetTop && scroTop < headerStickyOptions.endTop;

      if (messageFixedCondition) {
        EPD_message_fixed.querySelector('.EcomProductDetail-message').classList.add('show-message');
        EPD_message_absolute.querySelector('.EcomProductDetail-message').classList.remove('show-message');
      } else {
        EPD_message_fixed.querySelector('.EcomProductDetail-message').classList.remove('show-message');
        EPD_message_absolute.querySelector('.EcomProductDetail-message').classList.add('show-message');
      }

      var EPD_message_inner = EPD_message_fixed.querySelector('.message-inner');
      utilities_CustomUtil.bindStickyEvent(messageFixedCondition, EPD_message_inner);
      resetMessageStyle();
      prevScroTop = scroTop;
    };

    var resetMessageStyle = function resetMessageStyle() {
      var EPD_message = EPD_message_fixed.querySelector('.EcomProductDetail-message');
      var EPD_message_inner = EPD_message.querySelector('.message-inner');

      if (EPD_message_inner.classList.contains('sticky-fixed')) {
        EPD_message_inner.style.right = EPD_containerMargin + 'px';
      } else {
        EPD_message_inner.style.right = '0';
      }
    };

    var resetSidebarStyle = function resetSidebarStyle() {
      utilities_CustomUtil.updateSettings();
      utilities_CustomUtil.initCheckScreen();

      if (EPD_sidebarToSticky) {
        //desktop set same width as relative condition in fixed condition
        if (utilities_CustomUtil.screenIs != 'isMobile') {
          if (EPD_sidebarToSticky.classList.contains('sticky-fixed')) {
            EPD_sidebarToSticky.style.left = EPD_containerMargin + 'px';
          } else {
            EPD_sidebarToSticky.style.left = '0';
          }
        }
      }
    };

    var updateSideBarHeightForLaptop = function updateSideBarHeightForLaptop() {};

    var observerS;

    var watchSidebar = function watchSidebar() {
      observerS = new MutationObserver(function (mutationRecords) {
        //console.log(mutationRecords);
        resetSidebarStyle();
      });
      var node = EPD_sidebarToSticky;
      var config = {
        attributes: true,
        attributeFilter: ['class']
      };

      if (node) {
        observerS.observe(node, config);
      }
    };

    var observerD;

    var watchDoc = function watchDoc() {
      observerD = new MutationObserver(function (mutationRecords) {
        //console.log(mutationRecords);
        resetElements();
      });
      var node = EPD;
      var config = {
        childList: true,
        characterData: true,
        subtree: true
      };

      if (node) {
        observerD.observe(node, config);
      }
    };

    var observerC;

    var watchCollapse = function watchCollapse() {
      observerC = new MutationObserver(function (mutationRecords) {
        //debugger;
        //console.log(mutationRecords);
        resetElements();

        if (!isMobile) {
          window.scrollBy(0, 1);
        }
      });
      var nodes = EPD.querySelectorAll('.accordion-collapse');
      var config = {
        attributes: true,
        attributeFilter: ['class']
      };
      nodes.forEach(function (node) {
        observerC.observe(node, config);
      });
    };

    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          bindEPDScrollEvent();
          ticking = false;
        });
        ticking = true;
      }
    });
    window.addEventListener('resize', function (e) {
      setTimeout(function () {
        isLaptop = utilities_CustomUtil.screenIs == 'isLaptop';
        EPD_containerMargin = parseFloat(utilities_CustomUtil.getStyle(EPD_Container).marginLeft);
        resetElements();
        resetSidebarStyle();
        console.log("isLaptop:" + isLaptop);
      }, 300);
    });
    window.addEventListener('load', function (e) {
      initEPDScrollEvent();
    });
    addStickyEndFlag();
    initElements();
    updateSideBarHeightForLaptop();
    watchSidebar();
    watchCollapse();
    watchDoc();
  }
};

EcomProductDetail.bindEvent1 = function () {
  //EcomProductDetail.Init();
  components_MFCollapse('.EcomProductDetail-accordion');
  utilities_CustomUtil.revealStickyElements();
  EcomProductDetail.Sticky();
};

EcomProductDetail.bindEvent = function () {
  EcomProductDetail.Init();
  utilities_CustomUtil.revealStickyElements(); //EcomProductDetail.Sticky();
};

/* harmony default export */ var modules_EcomProductDetail = (EcomProductDetail);
;// CONCATENATED MODULE: ./stories/js/modules/PrimaryNavEComm/index.js




function PrimaryNavEComm() {
  console.log('PrimaryNavEComm');
  var container = document.querySelector('.PrimaryNavEComm');

  if (container) {
    var shyNav = document.querySelector('[data-shy-nav]');
    var shyPlaceholder = document.querySelector('.ShyNav-shim');
    var navLinks = document.querySelectorAll('[data-navigationmenu-section]');
    var submenus = document.querySelectorAll('[data-navigationmenu]');
    var search = document.querySelector('[data-search]');
    var searchTriggers = document.querySelectorAll('[data-search-trigger]');
    var primaryNav = document.querySelector('.PrimaryNav');
    var secondaryNav = document.querySelector('.SecondaryNav');
    var activeMenu = document.querySelector('.NavigationMenu.is-active');
    var mobildRow = document.querySelector('.PrimaryNav >.Container--row');
    var alertBanner = document.querySelector('.AlertBar');
    var alertHeight = 0;
    var shyPlaceholderHeight = shyPlaceholder ? shyPlaceholder.clientHeight : 0;
    var dropdowns = primaryNav ? primaryNav.querySelectorAll('.dropdown') : [];
    var dropdownToggles = primaryNav ? primaryNav.querySelectorAll('.toggle-mobile') : [];
    var dropdownMenus = primaryNav ? primaryNav.querySelectorAll('.dropdown-menu') : [];
    var miniCartDropdownMenu = document.querySelector('.dropdown-menu[data-navigationmenu="miniCart"]');
    var uaResult = new (ua_parser_default())().getResult();
    var browserInfo = new (ua_parser_default())().getBrowser();
    var customUtil = utilities_CustomUtil.initSettings();
    customUtil.initCheckScreen();
    updateElementsWithAlert();
    toggleDropdown();
    components_MFCollapse('.PrimaryNavEComm .MobileMenu-account');

    function toggleDropdown() {
      dropdownToggles.forEach(function (toggle) {
        toggle.addEventListener('click', function (event) {
          event.preventDefault();
          var parentDropdown = this.closest('.dropdown');
          parentDropdown.classList.toggle('is-active');
          search.classList.remove('is-active');
          var isOpen = Array.from(dropdowns).some(function (dropdown) {
            return dropdown.classList.contains('is-active');
          });
          document.body.classList.toggle('PrimaryNavEComm-dropdown-opened', isOpen);
          dropdownMenus.forEach(function (menu) {
            if (menu !== parentDropdown.querySelector('.dropdown-menu')) {
              menu.closest('.dropdown').classList.remove('is-active');
            }
          });
        });
      });
      dropdownMenus.forEach(function (menu) {
        menu.addEventListener('click', function (event) {
          event.stopPropagation();
        });
      });
      searchTriggers.forEach(function (trigger) {
        trigger.addEventListener('click', function () {
          dropdowns.forEach(function (dropdown) {
            dropdown.classList.remove('is-active');
          });
          document.body.classList.remove('PrimaryNavEComm-dropdown-opened');
        });
      });
    }

    function updateElementsWithAlert() {
      shyPlaceholderHeight = customUtil.screenIs == 'isMobile' || customUtil.screenIs == 'isTablet' ? 68 : 120;

      if (alertBanner) {
        shyNav.insertBefore(alertBanner, secondaryNav);

        if (customUtil.screenIs == 'isMobile') {
          miniCartDropdownMenu.style.top = -alertBanner.clientHeight + 'px';
        } else {
          miniCartDropdownMenu.style.top = '';
        }

        if (customUtil.screenIs == 'isMobile' || customUtil.screenIs == 'isTablet') {
          search.style.top = mobildRow.clientHeight + alertBanner.clientHeight + 'px';
        } else {
          search.style.top = secondaryNav.clientHeight + alertBanner.clientHeight + 'px';
        }

        shyPlaceholder.style.height = shyPlaceholderHeight + alertBanner.clientHeight + 'px';
        shyNav.style.height = shyPlaceholder.clientHeight + 'px';
      }
    }

    var timeoutMouseenter = {};
    var timeoutMouseleave = {};
    var delay = 250;
    navLinks.forEach(function (link) {
      var linkSubmenu = document.querySelector("[data-navigationmenu=\"".concat(link.dataset.navigationmenuSection, "\"]"));

      if (linkSubmenu) {
        var id = link.getAttribute('data-navigationmenu-section');
        link.addEventListener('mouseenter', function () {
          if (typeof timeoutMouseleave[id] != 'undefined') {
            clearTimeout(timeoutMouseleave[id]);
          }

          timeoutMouseenter[id] = setTimeout(function () {
            linkSubmenu.classList.add('is-active'); //reset submenu top

            link.classList.add('is-active'); //reset submenu top

            var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));
          }, delay);
        });
        link.addEventListener('mouseleave', function () {
          if (typeof timeoutMouseenter[id] != 'undefined') {
            clearTimeout(timeoutMouseenter[id]);
          }

          timeoutMouseleave[id] = setTimeout(function () {
            linkSubmenu.classList.remove('is-active');
            link.classList.remove('is-active');
          }, delay);
        });
        linkSubmenu.addEventListener('mouseleave', function () {
          if (typeof timeoutMouseenter[id] != 'undefined') {
            clearTimeout(timeoutMouseenter[id]);
          }

          timeoutMouseleave[id] = setTimeout(function () {
            linkSubmenu.classList.remove('is-active');
            link.classList.remove('is-active');
          }, delay);
        });
      }
    });
    submenus.forEach(function (submenu) {
      var id = submenu.getAttribute('data-navigationmenu');
      submenu.addEventListener('mouseenter', function (e) {
        if (typeof timeoutMouseleave[id] != 'undefined') {
          clearTimeout(timeoutMouseleave[id]);
        } //submenu.classList.add('is-active');

      });
      submenu.addEventListener('mouseleave', function () {
        timeoutMouseleave[id] = setTimeout(function () {
          submenu.classList.remove('is-active');
          var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

          if (0 - shytop > shyNav.clientHeight) {
            shyNav.style.top = -parseInt(shyNav.clientHeight) + 'px';
            customUtil.settings.headerStatus = 0;
            customUtil.updateStickyElements();
          }
        }, delay);
      });
    });

    if (shyNav) {
      var scrollPosition = 0;
      var scrollUpPosition = 0;
      var scrollDownPosition = 0;
      var currentlyScrollingDown = false;
      var ticking = false;
      var isStuck = false;
      var longScroll = false;
      var navHeight = parseInt(shyNav.clientHeight);
      var prevScroTop = 0;
      var directionSwitch = false;
      var activeMenuHeight = 0;

      function updateHeaderPositionWhenScroll() {
        var scroTop = window.scrollY || document.documentElement.scrollTop;
        navHeight = shyNav.clientHeight;

        if (alertBanner) {
          alertHeight = alertBanner.clientHeight;
        }

        if (shyNav.clientHeight == 0) {
          // navHeight = customUtil.screenIs == 'isMobile' ? 68 + alertHeight : 120 + alertHeight;
          if (customUtil.screenIs == 'isMobile' || customUtil.screenIs == 'isTablet') {
            navHeight = 68 + alertHeight;
          } else {
            navHeight = 120 + alertHeight;
          }
        }

        activeMenu = document.querySelector('.NavigationMenu.is-active');

        if (search && search.classList.contains('is-touched')) {
          //Condition when searchbox opened.
          navHeight = shyNav.clientHeight + search.clientHeight;
        }

        if (activeMenu) {
          //Condition when submenu opened.
          navHeight = shyNav.clientHeight + activeMenu.clientHeight;
          activeMenuHeight = activeMenu.clientHeight;
        } else {
          if (search && !search.classList.contains('is-touched')) {
            if (scroTop <= prevScroTop) {
              //Condition when submenu opened and scroll outside, then scrollup, firstly reset primarynav top.
              if (!directionSwitch) {
                var shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));

                if (0 - parseInt(shytop) > parseInt(shyNav.clientHeight)) {
                  shyNav.style.top = -parseInt(shyNav.clientHeight) + 'px';
                  directionSwitch = true;
                }
              }
            }
          }
        }

        var navTopPX = shyNav.style.top;
        var navTop = parseInt(navTopPX.slice(0, navTopPX.length - 2));
        var setTop = 0;

        if (scroTop > prevScroTop) {
          // Scroll Down
          document.querySelector('body').setAttribute('data-direction', 'down');
          var topValue = navTop > -navHeight ? parseInt(navTop - (scroTop - prevScroTop)) : -navHeight;

          if (-topValue > navHeight) {
            //long scroll as anchor
            setTop = -navHeight;
          } else {
            setTop = scroTop > navHeight ? topValue : -(0 - scroTop) < shyPlaceholder.clientHeight ? 0 - scroTop : topValue;
          }

          shyNav.style.top = setTop + 'px';

          if (search) {
            if (customUtil.screenIs == 'isMobile' || customUtil.screenIs == 'isTablet') {
              search.style.top = setTop + secondaryNav.clientHeight + mobildRow.clientHeight + alertHeight + 'px';
            } else {
              search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
            }
          }

          directionSwitch = false;
        } else {
          // Scroll Up
          document.querySelector('body').setAttribute('data-direction', 'up');

          if (customUtil.checkNavigationSection() && customUtil.checkInPageNav()) {
            if (scroTop > navHeight) {
              //When not fetch the shynav position, hide shynav
              setTop = 0;
            } else {
              //When fetch the shynav position, show shynav as before
              var _topValue = parseInt(navTop - (scroTop - prevScroTop)) > 0 ? 0 : parseInt(navTop - (scroTop - prevScroTop));

              setTop = navTop >= 0 ? 0 : _topValue;
              shyNav.style.top = setTop + 'px';

              if (search) {
                if (customUtil.screenIs == 'isMobile' || customUtil.screenIs == 'isTablet') {
                  search.style.top = setTop + secondaryNav.clientHeight + mobildRow.clientHeight + alertHeight + 'px';
                } else {
                  search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
                }
              }
            }
          } else {
            var _topValue2 = parseInt(navTop - (scroTop - prevScroTop)) > 0 ? 0 : parseInt(navTop - (scroTop - prevScroTop));

            setTop = navTop >= 0 ? 0 : _topValue2;
            shyNav.style.top = setTop + 'px';

            if (search) {
              // search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
              if (customUtil.screenIs == 'isMobile' || customUtil.screenIs == 'isTablet') {
                search.style.top = setTop + secondaryNav.clientHeight + mobildRow.clientHeight + alertHeight + 'px';
              } else {
                search.style.top = setTop + secondaryNav.clientHeight + alertHeight + 'px';
              }
            }
          }
        } // 0 = hide, 1 = show part, 2 = show all


        if (setTop == 0) {
          customUtil.settings.headerStatus = 2;
        } else if (setTop == -navHeight) {
          customUtil.settings.headerStatus = 0;
        } else {
          customUtil.settings.headerStatus = 1;
        } //console.log('headerStatus:' + customUtil.settings.headerStatus);


        var bodyDirection = document.body.getAttribute('data-direction');

        if (customUtil.settings.headerStatus === 0 && bodyDirection === 'down') {
          document.body.classList.add('headerStatus--hidden');
        } else if ((customUtil.settings.headerStatus === 1 || customUtil.settings.headerStatus === 2) && bodyDirection === 'up') {
          document.body.classList.remove('headerStatus--hidden');
        }

        prevScroTop = scroTop;
      }

      function updateHeaderPosition(scrollPos) {
        var navPosition = shyNav.getBoundingClientRect().top;
        longScroll = Math.abs(scrollDownPosition - scrollUpPosition) > navHeight;
        if (scrollPos < 0) shyNav.style.top = 0;

        if (scrollPos > scrollPosition) {
          // SCROLLING DOWN
          scrollDownPosition = currentlyScrollingDown ? scrollPos : scrollDownPosition;

          if (!currentlyScrollingDown && isStuck) {
            shyNav.style.position = 'absolute';
            shyNav.style.top = "".concat(scrollUpPosition, "px");
          }

          currentlyScrollingDown = true;
          isStuck = false;
        } else {
          // SCROLLING UP
          currentlyScrollingDown = false;
          scrollUpPosition = currentlyScrollingDown ? scrollUpPosition : scrollPos;

          if (navPosition >= 0) {
            // STUCK HEADER
            shyNav.style.position = 'fixed';
            shyNav.style.top = 0;
            isStuck = true;
            scrollPosition = scrollPos;
            return;
          } else {
            isStuck = false;
          } // EDGE CASE - Header


          if (navPosition >= scrollPos) {
            // shyNav.style.position = 'fixed';
            shyNav.style.top = 0;
          } else {
            if (shyNav.style.position == 'fixed') return;
            shyNav.style.position = 'absolute';

            if (longScroll) {
              shyNav.style.top = "".concat(scrollDownPosition - navHeight, "px");
            }
          }
        }

        scrollPosition = scrollPos;
      }

      window.addEventListener('scroll', function (e) {
        var newScrollPosition = window.scrollY || document.documentElement.scrollTop;

        if (!ticking) {
          window.requestAnimationFrame(function () {
            updateHeaderPositionWhenScroll(); //updateHeaderPosition(newScrollPosition);

            ticking = false;
          });
          ticking = true;
        }
      });
      window.addEventListener('resize', function () {
        /*let shytop = parseInt(shyNav.style.top.slice(0, shyNav.style.top.length - 2));
        if (customUtil.screenIs == 'isMobile') {
          search.style.top = shytop + mobildRow.clientHeight + 'px';
        } else {
          search.style.top = shytop + secondaryNav.clientHeight + 'px';
        }*/
        customUtil.initCheckScreen();
        updateElementsWithAlert();
        customUtil.updateStickyElements();
      }, false);
      window.addEventListener('hashchange', function () {
        scrollDownPosition = window.scrollY || document.documentElement.scrollTop;
      }, false);

      if (document.location.hash != undefined && document.location.hash != '') {
        scrollDownPosition = window.scrollY || document.documentElement.scrollTop;
        currentlyScrollingDown = true;
      }
    }
  }
}

function PrimaryNavEComm_SMobileMenu() {
  var body = document.body;
  var mobileMenu = document.querySelector('[data-mobilemenu]');
  var mobileMenuTriggers = document.querySelectorAll('[data-mobilemenu-trigger]');
  var mobileSubmenus = document.querySelectorAll('[data-submenu]');
  var submenuTriggers = document.querySelectorAll('[data-submenu-trigger]');
  mobileMenuTriggers.forEach(function (trigger) {
    trigger.addEventListener('click', function () {
      mobileMenuTriggers.forEach(function () {
        return trigger.classList.toggle('is-active');
      });
      document.body.classList.toggle('is-mobileMenuOpen');
      mobileMenu.classList.toggle('is-open');
      mobileMenu.querySelector('.MobileMenu-subMenus-menu').classList.remove('is-open');
      body.classList.remove('is-submenuOpen');
      body.classList.remove('is-submenuChildOpen');
    });
  });
  submenuTriggers.forEach(function (trigger) {
    var submenuName = trigger.dataset.submenuTrigger;
    trigger.addEventListener('click', function () {
      mobileSubmenus.forEach(function (submenu) {
        submenu.classList.remove('is-open');
      });

      if (submenuName) {
        var submenu = document.querySelector("[data-submenu=\"".concat(submenuName, "\"]"));
        submenu.classList.add('is-open');
        body.classList.add('is-submenuOpen');

        if (submenu.dataset.submenuChild) {
          body.classList.add('is-submenuChildOpen');
        } else {
          body.classList.remove('is-submenuChildOpen');
        }
      } else {
        var openSubmenu = document.querySelector('[data-submenu].is-open');

        if (openSubmenu) {
          openSubmenu.classList.remove('is-open');
        }

        body.classList.remove('is-submenuOpen');
        body.classList.remove('is-submenuChildOpen');
      }
    });
  });
}

function PrimaryNavEComm_SNavigationMenu() {
  console.log('NavigationMenu');
  var timeoutMouseenter = {};
  var delay = 250;
  var navMenus = document.querySelectorAll('[data-navigationmenu]');
  navMenus.forEach(function (navMenu) {
    var wideCallout = navMenu.querySelector('.NavigationMenu-wideCallout');
    var navMenuTabs = navMenu.querySelectorAll('[data-navigationmenu-tab]');
    var navMenuContents = navMenu.querySelectorAll('[data-navigationmenu-content]');
    var navMenuCallouts = navMenu.querySelectorAll('[data-navigationmenu-callout]');
    navMenuTabs.forEach(function (tab) {
      var connectedContent = navMenu.querySelector("[data-navigationmenu-content=\"".concat(tab.dataset.navigationmenuTab, "\"]"));
      var connectedCallout = navMenu.querySelector("[data-navigationmenu-callout=\"".concat(tab.dataset.navigationmenuTab, "\"]"));
      var id = tab.getAttribute("data-navigationmenu-tab");
      tab.addEventListener('mouseenter', function () {
        timeoutMouseenter[id] = setTimeout(function () {
          navMenuTabs.forEach(function (otherTab) {
            return otherTab.classList.remove('is-active');
          });
          tab.classList.add('is-active');
          navMenuContents.forEach(function (content) {
            content.classList.remove('is-active');
            connectedContent.classList.add('is-active');
          });
          navMenuCallouts.forEach(function (callout) {
            callout.classList.remove('is-active');

            if (connectedCallout != undefined) {
              connectedCallout.classList.add('is-active');
              wideCallout.removeAttribute("style");
            } else {
              wideCallout.style.display = "none";
            }
          });
        }, delay);
      });
      tab.addEventListener('mouseleave', function () {
        if (typeof timeoutMouseenter[id] != "undefined") {
          clearTimeout(timeoutMouseenter[id]);
        }
      });
    });
  });
}

/* harmony default export */ var modules_PrimaryNavEComm = (PrimaryNavEComm);
;// CONCATENATED MODULE: ./stories/js/modules/ProductCategory/index.js




function ProductCategory() {
  var container = document.querySelector('.ProductCategory');

  if (container) {
    var filters = container.querySelector('.ProductCategory-filters');
    var filterOpenBtns = container.querySelectorAll('.filters-open-button');
    var filterCloseBtn = container.querySelector('.filters-close');
    var filterShowBtn = container.querySelector("a.btn-show");
    var filterAccordion = container.querySelector('.accordion-filters');
    var filterAccordionBtns = container.querySelectorAll('.accordion-button');
    var sortAccordion = container.querySelector('.accordion--sort');
    var fAccordionBtns = filterAccordion.querySelectorAll('.accordion-button');
    var sAccordionBtn = sortAccordion.querySelector('.accordion-button'); // var mobileCollapse = false;
    //debugger;

    var showAccordion = function showAccordion(btn) {
      if (btn) {
        var target = btn.getAttribute('data-target');
        btn.classList.remove('collapsed');
        btn.setAttribute('aria-expanded', 'true');
        container.querySelector(target).classList.add('show');
      }
    };

    var hideAccordion = function hideAccordion(btn) {
      if (btn) {
        var target = btn.getAttribute('data-target');
        btn.classList.add('collapsed');
        btn.setAttribute("aria-expanded", "false");
        container.querySelector(target).classList.remove('show');
      }
    };

    var showAllAccordions = function showAllAccordions() {
      filterAccordionBtns.forEach(function (btn) {
        showAccordion(btn);
      });
    };

    var hideAllAccordions = function hideAllAccordions() {
      filterAccordionBtns.forEach(function (btn) {
        hideAccordion(btn);
      });
    };

    var bindSort = function bindSort() {
      if (sAccordionBtn) {
        sAccordionBtn.addEventListener('click', function (e) {
          e.preventDefault();

          if (sAccordionBtn.getAttribute('aria-expanded') == 'false') {
            showAccordion(sAccordionBtn);
          } else {
            hideAccordion(sAccordionBtn);
          }
        });
      }
    };

    var bindEvents = function bindEvents() {
      fAccordionBtns.forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.preventDefault();

          if (btn.getAttribute('aria-expanded') == 'false') {
            showAccordion(btn);
          } else {
            hideAccordion(btn);
          }
        });
      });
      filterOpenBtns.forEach(function (btn) {
        btn.addEventListener('click', function (e) {
          e.preventDefault();
          filters.classList.add('opened');
          document.body.classList.add('no-scroll');
          updateMobileStatus(btn.getAttribute('data-accordion-open')); //MFCollapse('.ProductCategory-accordion');
        });
      });
      filterShowBtn.addEventListener("click", function (event) {
        filterCloseBtn.click();
      });

      if (filterCloseBtn) {
        filterCloseBtn.addEventListener('click', function (e) {
          e.preventDefault();
          filters.classList.remove('opened');
          document.body.classList.remove('no-scroll');
          var view = document.body.getAttribute('data-viewport');

          if (view != 'isLaptop') {
            resetMobileStatus();
          } // mobileCollapse = false; 

        });
      }

      if (filterAccordion) {
        var checkboxes = filterAccordion.querySelectorAll('.Form-checkbox');
        checkboxes.forEach(function (checkbox) {
          var input = checkbox.querySelector('input');
          input.addEventListener('click', function () {
            var checked = input.checked;

            if (checked) {
              input.setAttribute('checked', 'checked');
            } else {
              input.removeAttribute('checked');
            }
          });
        });
      }
    };

    var resetElements = function resetElements() {
      filterOpenBtns = container.querySelectorAll('.filters-open-button');
      filterCloseBtn = container.querySelector('.filters-close');
      filterShowBtn = container.querySelector("a.btn-show");
      filterAccordion = container.querySelector('.accordion-filters');
      filterAccordionBtns = container.querySelectorAll('.accordion-button');
      sortAccordion = container.querySelector('.accordion--sort');
      fAccordionBtns = filterAccordion.querySelectorAll('.accordion-button');
      sAccordionBtn = sortAccordion.querySelector('.accordion-button');
    };

    var updateMobileStatus = function updateMobileStatus(target) {
      var btn = filters.querySelector('[data-target="#' + target + '"]');

      if (btn && btn.getAttribute('aria-expanded') == 'false') {
        showAccordion(btn);
      } else {
        if (target == 'none') {
          hideAllAccordions();
        }
      }
    };

    var resetMobileStatus = function resetMobileStatus() {
      hideAllAccordions();
    };

    var resetFilterStatus = function resetFilterStatus() {
      var body = document.querySelector('body');
      var view = body.getAttribute('data-viewport');

      if (view == 'isLaptop') {
        showAllAccordions();
      } else {
        if (!filters.classList.contains('opened')) {
          hideAllAccordions();
        }
      }
    };

    var observer_sfilter; //watch filters

    var watchSelectedFilter = function watchSelectedFilter() {
      observer_sfilter = new MutationObserver(function (mutationRecords) {
        //console.log(mutationRecords);
        resetElements(); //MFCollapse('.ProductCategory-accordion');

        bindEvents();
        resetFilterStatus();
      });
      var node = filters;
      var config = {
        childList: true,
        characterData: true,
        subtree: true
      };

      if (node) {
        observer_sfilter.observe(node, config);
      }
    };

    var observerFilter;

    var watchFilter = function watchFilter() {
      observerFilter = new MutationObserver(function (mutationRecords) {
        //console.log(mutationRecords);
        resetFilterStatus(mutationRecords);
      });
      var node = document.querySelector('body');
      var config = {
        attributes: true,
        attributeFilter: ['data-viewport']
      };

      if (node) {
        observerFilter.observe(node, config);
      }
    };

    bindSort();
    watchFilter();
    watchSelectedFilter();

    if (utilities_CustomUtil.isLocalhost()) {
      resetElements(); //MFCollapse('.ProductCategory-accordion');

      bindEvents();
      resetFilterStatus();
    }
  }
}

/* harmony default export */ var modules_ProductCategory = (ProductCategory);
;// CONCATENATED MODULE: ./stories/js/modules/ProductCategoryCarousel/index.js
function ProductCategoryCarousel_toConsumableArray(arr) { return ProductCategoryCarousel_arrayWithoutHoles(arr) || ProductCategoryCarousel_iterableToArray(arr) || ProductCategoryCarousel_unsupportedIterableToArray(arr) || ProductCategoryCarousel_nonIterableSpread(); }

function ProductCategoryCarousel_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function ProductCategoryCarousel_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ProductCategoryCarousel_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ProductCategoryCarousel_arrayLikeToArray(o, minLen); }

function ProductCategoryCarousel_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function ProductCategoryCarousel_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return ProductCategoryCarousel_arrayLikeToArray(arr); }

function ProductCategoryCarousel_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




core_class.use([navigation]);

function ProductCategoryCarousel() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      el = _ref.el;

  var container = document.getElementById('ProductCategoryCarousel');
  var transitionSpeed = 300;
  var swiperTarget = el.getAttribute('id');
  var leftButtonEl = document.getElementById('control-left-' + swiperTarget);
  var rightButtonEl = document.getElementById('control-right-' + swiperTarget);
  var cardsSwiper = new core_class(el, {
    effect: 'slide',
    speed: transitionSpeed,
    slidesPerView: 'auto',
    watchSlidesProgress: true,
    watchSlidesVisibility: true,
    watchOverflow: true,
    loop: false,
    navigation: {
      nextEl: rightButtonEl,
      prevEl: leftButtonEl
    }
  });
  revealElements();
  rightButtonEl.addEventListener('click', function (e) {
    // var container = e.currentTarget.parentElement.parentElement;
    if (e.currentTarget.classList.contains('swiper-button-disabled')) {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.add('last-visible');
      });
    } else {
      container.querySelectorAll('.swiper-slide-visible').forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }
  });
  leftButtonEl.addEventListener('click', function (e) {
    // var container = e.currentTarget.parentElement.parentElement;
    var lastVisibles = container.querySelectorAll('.last-visible');

    if (lastVisibles) {
      lastVisibles.forEach(function (element) {
        element.classList.remove('last-visible');
      });
    }
  });
  return {
    destroy: function destroy() {
      cardsSwiper.detachEvents();
      cardsSwiper.destroy();
    }
  };
}

ProductCategoryCarousel.defaultSelector = '.ProductCategoryCarousel .swiper-container';

ProductCategoryCarousel.initAll = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$selector = _ref2.selector,
      selector = _ref2$selector === void 0 ? ProductCategoryCarousel.defaultSelector : _ref2$selector;

  return ProductCategoryCarousel_toConsumableArray(document.querySelectorAll(selector)).map(function (el) {
    return ProductCategoryCarousel({
      el: el
    });
  });
};

/* harmony default export */ var modules_ProductCategoryCarousel = (ProductCategoryCarousel);
;// CONCATENATED MODULE: ./stories/js/modules/NavigationSidebarAccordion/index.js



function NavigationSidebarAccordion() {
  console.log('NavigationSidebarAccordion');
  var body = document.body;
  var NSA = document.querySelector('.NavigationSidebarAccordion');
  var ticking = false;
  var prevScroTop = 0;

  if (NSA) {
    var NSATrigger = NSA.querySelector('[data-NavigationSidebarAccordion-trigger]');
    var NSAMenu = NSA.querySelector('.NavigationSidebarAccordion-menu-container');
    var NSAMenuAccordions = NSA.querySelectorAll('.accordion-item');
    var NSA_top = NSA.offsetTop;
    var NSA_height = NSA.clientHeight;
    var viewPort = body.getAttribute('data-viewport');
    var isLaptop = viewPort == 'isLaptop' ? true : false;
    var viewPortOld = viewPort;
    var toEnd = false; //ScrollDown End sticky to avoid flash

    var toStart = false; //ScrollUp Start  sticky to avoid flash

    if (document.domain == 'localhost' && document.location.pathname == '/iframe.html') {//isLaptop = true;
    }

    components_MFCollapse('.NavigationSidebarAccordion');

    if (!isLaptop) {
      if (!NSAMenu.classList.contains('is-open')) {
        NSAMenuAccordions.forEach(function (accordion) {
          if (!accordion.classList.contains('current')) {
            if (accordion.querySelector('.accordion-button')) {
              accordion.querySelector('.accordion-button').click();
            }
          }
        });
      }
    }

    function bindNSAFixedEvent() {
      var top = NSA_top;
      var customUtil = utilities_CustomUtil.initSettings();
      var scroTop = window.scrollY || document.documentElement.scrollTop;
      var condition = scroTop > top;
      var ele = NSA;
      var maxTop = customUtil.getStickyMaxTop();

      if (scroTop < prevScroTop) {//scroll up
        //maxTop = maxTop - customUtil.settings.headerFixedHeight;
      }

      if (scroTop > prevScroTop) {
        //down
        if (top < 0) {
          top = 0;
        }

        condition = scroTop > top && scroTop < maxTop;
        toStart = false;

        if (toEnd) {
          condition = false;
        }
      } else {
        //up 
        var minTop = top - NSA_height - customUtil.settings.headerFixedHeight;

        if (minTop < 0) {
          minTop = 0;
        }

        condition = scroTop > minTop && scroTop < maxTop;
        toEnd = false;

        if (toStart) {
          condition = scroTop > minTop && true;
        }
      }

      if (scroTop >= maxTop) {
        toEnd = true;
      } else {
        toStart = true;
      }

      condition = condition && !isLaptop;
      utilities_CustomUtil.bindStickyEvent(condition, ele);
      prevScroTop = scroTop;
    }

    NSATrigger.addEventListener('click', function () {
      NSATrigger.parentNode.classList.toggle('is-active');
      NSAMenu.classList.toggle('is-open');
      NSA_height = NSA.clientHeight;
    });
    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          bindNSAFixedEvent();
          ticking = false;
        });
        ticking = true;
      }
    });
    window.addEventListener('resize', function (e) {
      viewPort = body.getAttribute('data-viewport');
      isLaptop = viewPort == 'isLaptop' ? true : false;

      if (isLaptop && viewPortOld != 'isLaptop') {
        NSAMenuAccordions.forEach(function (accordion) {
          var co = accordion.querySelector('.accordion-collapse');

          if (co && !co.classList.contains('show')) {
            if (accordion.querySelector('.accordion-button')) {
              accordion.querySelector('.accordion-button').click();
            }
          }
        });
      } else if (!isLaptop && viewPortOld == 'isLaptop') {
        NSAMenuAccordions.forEach(function (accordion) {
          var co = accordion.querySelector('.accordion-collapse');
          var notCurrent = co && !co.closest('.accordion-item').classList.contains('current');

          if (notCurrent && co.classList.contains('show')) {
            if (accordion.querySelector('.accordion-button')) {
              accordion.querySelector('.accordion-button').click();
            }
          }
        });
      }

      viewPortOld = viewPort;
    });
  }
}

/* harmony default export */ var modules_NavigationSidebarAccordion = (NavigationSidebarAccordion);
;// CONCATENATED MODULE: ./stories/js/modules/AemTranslationModal/index.js
function AemTranslationModal() {
  console.log('AemTranslationModal');
  var translationModal = document.querySelector('.AemTranslationModal');

  if (translationModal) {
    // toggle dropdowns
    var dropdownTriggers = translationModal.querySelectorAll(".tm-dropdown-trigger");
    var allDropdowns = translationModal.querySelectorAll('.tm-dropdown');
    var allDropdownItems = translationModal.querySelectorAll('.tm-dropdown-item');
    allDropdownItems.forEach(function (item) {
      item.addEventListener('click', function (event) {
        event.stopPropagation();
      });
    });

    function closeOtherDropdowns(currentDropdown) {
      allDropdowns.forEach(function (dropdown) {
        if (dropdown !== currentDropdown && !dropdown.contains(currentDropdown)) {
          dropdown.classList.remove('is-open');
          var dropdownMenu = dropdown.querySelector('.tm-dropdown-menu');

          if (dropdownMenu) {
            dropdownMenu.classList.remove('is-open');
          }
        }
      });
    }

    function closeAllDropdowns() {
      allDropdowns.forEach(function (item) {
        item.classList.remove('is-open');
        var dropdown = item.querySelector('.tm-dropdown-menu');

        if (dropdown) {
          dropdown.classList.remove('is-open');
        }
      });
    }

    dropdownTriggers.forEach(function (trigger) {
      trigger.addEventListener("click", function (event) {
        var parentDropdown = this.closest(".tm-dropdown");
        var siblingDropdownMenu = parentDropdown.querySelector('.tm-dropdown-menu');
        event.stopPropagation();
        parentDropdown.classList.toggle('is-open');
        siblingDropdownMenu.classList.toggle('is-open');
        closeOtherDropdowns(parentDropdown);
      });
    });
    document.addEventListener("click", function (event) {
      var openDropdowns = translationModal.querySelectorAll(".tm-dropdown.is-open");
      openDropdowns.forEach(function (dropdown) {
        if (!dropdown.contains(event.target)) {
          dropdown.classList.remove("is-open");
          var dropdownMenu = dropdown.querySelector(".tm-dropdown-menu");

          if (dropdownMenu) {
            dropdownMenu.classList.remove("is-open");
          }
        }
      });
    });
    document.addEventListener("click", function (event) {
      if (!event.target.closest('.tm-dropdown')) {
        closeAllDropdowns();
      }
    }); // Expand collapse the hidden live copy section

    var tmTrElements = translationModal.querySelectorAll('.tm-tr');
    tmTrElements.forEach(function (tmTrElement) {
      tmTrElement.addEventListener('click', function () {
        var nextElement = tmTrElement.nextElementSibling;

        if (nextElement && nextElement.classList.contains('tm-sub')) {
          nextElement.classList.toggle('hidden');
          tmTrElement.classList.toggle('sub-opened');
        }
      });
    }); // Toggle Sync Page Properties Table

    var lmTable = translationModal.querySelector('.tm-table--lm');
    var ppTable = translationModal.querySelector('.tm-table--pp');
    var tableWrapper = translationModal.querySelector('.tm-table-wrapper');
    var ppToggleButton = translationModal.querySelector('.btn--show-pp-table');

    if (ppToggleButton) {
      ppToggleButton.addEventListener('click', function () {
        lmTable.classList.toggle('hidden');
        ppTable.classList.toggle('hidden');
        tableWrapper.classList.toggle('table-lm-opened');
        tableWrapper.classList.toggle('table-pp-opened');

        if (ppTable.classList.contains('hidden')) {
          ppToggleButton.classList.remove('is-selected');
        } else {
          ppToggleButton.classList.add('is-selected');
        }
      });
    }
  }
}

/* harmony default export */ var modules_AemTranslationModal = (AemTranslationModal);
;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/bind.js


function bind_bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/utils.js




// utils is a library of generic helper functions non-specific to axios

const {toString: utils_toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = utils_toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray: utils_isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function utils_isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const lib_utils_isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => lib_utils_isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (utils_isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (utils_isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const lib_utils_extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind_bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (utils_isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const utils_toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  utils_isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const utils_noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
}

const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0]
  }

  return str;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (lib_utils_isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = utils_isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (lib_utils_isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

/* harmony default export */ var utils = ({
  isArray: utils_isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView: utils_isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: lib_utils_isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend: lib_utils_extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: utils_hasOwnProperty,
  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase: utils_toCamelCase,
  noop: utils_noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosError.js




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const AxiosError_prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(AxiosError_prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ var core_AxiosError = (AxiosError);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/null.js
// eslint-disable-next-line strict
/* harmony default export */ var helpers_null = (null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toFormData.js




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (helpers_null || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ var helpers_toFormData = (toFormData);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && helpers_toFormData(params, this, options);
}

const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

AxiosURLSearchParams_prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

AxiosURLSearchParams_prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ var helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/buildURL.js





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function buildURL_encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || buildURL_encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new helpers_AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/InterceptorManager.js




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ var core_InterceptorManager = (InterceptorManager);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/transitional.js


/* harmony default export */ var defaults_transitional = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js



/* harmony default export */ var classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/FormData.js


/* harmony default export */ var classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/classes/Blob.js


/* harmony default export */ var classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/browser/index.js




/* harmony default export */ var platform_browser = ({
  isBrowser: true,
  classes: {
    URLSearchParams: classes_URLSearchParams,
    FormData: classes_FormData,
    Blob: classes_Blob
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/common/utils.js
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = (
  (product) => {
    return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0
  })(typeof navigator !== 'undefined' && navigator.product);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();



;// CONCATENATED MODULE: ./node_modules/axios/lib/platform/index.js



/* harmony default export */ var platform = ({
  ...common_utils_namespaceObject,
  ...platform_browser
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/toURLEncodedForm.js






function toURLEncodedForm(data, options) {
  return helpers_toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/formDataToJSON.js




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ var helpers_formDataToJSON = (formDataToJSON);

;// CONCATENATED MODULE: ./node_modules/axios/lib/defaults/index.js










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults_defaults = {

  transitional: defaults_transitional,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return helpers_toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults_defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults_defaults.headers[method] = {};
});

/* harmony default export */ var lib_defaults = (defaults_defaults);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseHeaders.js




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ var helpers_parseHeaders = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/AxiosHeaders.js





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function AxiosHeaders_normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(AxiosHeaders_normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = AxiosHeaders_normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(helpers_parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = AxiosHeaders_normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = AxiosHeaders_normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils.freezeMethods(AxiosHeaders);

/* harmony default export */ var core_AxiosHeaders = (AxiosHeaders);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/transformData.js






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || lib_defaults;
  const context = response || config;
  const headers = core_AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/isCancel.js


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CanceledError.js





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, core_AxiosError, {
  __CANCEL__: true
});

/* harmony default export */ var cancel_CanceledError = (CanceledError);

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/settle.js




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new core_AxiosError(
      'Request failed with status code ' + response.status,
      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/cookies.js



/* harmony default export */ var cookies = (platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils.isString(path) && cookie.push('path=' + path);

      utils.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });


;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAbsoluteURL.js


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/combineURLs.js


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/buildFullPath.js





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isURLSameOrigin.js





/* harmony default export */ var isURLSameOrigin = (platform.hasStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })());

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/parseProtocol.js


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/speedometer.js


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ var helpers_speedometer = (speedometer);

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/xhr.js
















function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = helpers_speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ var xhr = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();
    let {responseType, withXSRFToken} = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    let contentType;

    if (utils.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false); // Let the browser set it
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        // fix semicolon duplication issue for ReactNative FormData implementation
        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
      }
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = core_AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || defaults_transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new core_AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if(platform.hasStandardBrowserEnv) {
      withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));

      if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {
        // Add xsrf header
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/adapters/adapters.js





const knownAdapters = {
  http: helpers_null,
  xhr: xhr
}

utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;

/* harmony default export */ var adapters = ({
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new core_AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new core_AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/dispatchRequest.js









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new cancel_CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = core_AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = core_AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/mergeConfig.js





const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/env/data.js
const VERSION = "1.6.7";
;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/validator.js





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new core_AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        core_AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ var validator = ({
  assertOptions,
  validators
});

;// CONCATENATED MODULE: ./node_modules/axios/lib/core/Axios.js











const Axios_validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new core_InterceptorManager(),
      response: new core_InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;

        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';

        if (!err.stack) {
          err.stack = stack;
          // match without the 2 top stack lines
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
          err.stack += '\n' + stack
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: Axios_validators.function,
          serialize: Axios_validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ var core_Axios = (Axios);

;// CONCATENATED MODULE: ./node_modules/axios/lib/cancel/CancelToken.js




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new cancel_CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ var cancel_CancelToken = (CancelToken);

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/spread.js


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/isAxiosError.js




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

;// CONCATENATED MODULE: ./node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ var helpers_HttpStatusCode = (HttpStatusCode);

;// CONCATENATED MODULE: ./node_modules/axios/lib/axios.js




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new core_Axios(defaultConfig);
  const instance = bind_bind(core_Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(lib_defaults);

// Expose Axios class to allow class inheritance
axios.Axios = core_Axios;

// Expose Cancel & CancelToken
axios.CanceledError = cancel_CanceledError;
axios.CancelToken = cancel_CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = helpers_toFormData;

// Expose AxiosError class
axios.AxiosError = core_AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = core_AxiosHeaders;

axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = helpers_HttpStatusCode;

axios.default = axios;

// this module should only have a default export
/* harmony default export */ var lib_axios = (axios);

// EXTERNAL MODULE: ./node_modules/qs/lib/index.js
var qs_lib = __webpack_require__(129);
var qs_lib_default = /*#__PURE__*/__webpack_require__.n(qs_lib);
;// CONCATENATED MODULE: ./stories/js/modules/SearchNew/localLabels.js
var localLabels = {
  "shop": "SHOP",
  "seagate_direct_home": "Seagate Direct Home",
  "spp_home": "SPP Home",
  "standart_model": "Standard Model",
  "select_options": "Mix and match options...",
  "customize": "Customize",
  "model_numbers": "Model Numbers",
  "select_drive": "Select Drive",
  "model_number": "Model Number",
  "serial_number": "Serial Number",
  "do_you_own_this": "Do you own this?",
  "your_product": "Your Product",
  "get_personalized_support_experience": "Get a Personalized Support Experience",
  "get_support_now": "Get Support Now",
  "add_to_shortlist": "Add to Shortlist",
  "buy_from_seagate_online": "Buy from Seagate Online",
  "qty": "Qty",
  "comparison_shop": "Comparison Shop",
  "find_a_distributor": "Find a Distributor",
  "find_a_store_nearby": "Find a store nearby",
  "find": "Find",
  "add_to_cart": "Add to Cart",
  "back_order": "Back Order",
  "pre_order": "Pre Order",
  "not_available": "Sorry! Currently, there are no price and purchase options available for this product.",
  "dr_in_stock": "In Stock",
  "dr_out_of_stock": "Out of stock",
  "dr_back_order": "Back-Order",
  "dr_pre_order": "Pre-Order",
  "back_order_desc": "Available for Back Order",
  "pre_order_desc": "Available for Pre Order",
  "configure_and_buy": "Configure &amp; Buy",
  "none": "None",
  "color": "Color",
  "on_sale": "On Sale",
  "price": "Price",
  "suggested_price": "Suggested Price",
  "compare_prices": "Compare Prices",
  "unitedStates": "United States",
  "china": "China",
  "partner_offerings": "Partner Offerings",
  "buy": "Buy",
  "buy_now": "BUY NOW",
  "not_selected": "Model Not Selected",
  "select_value": "Please select a value for each option above.",
  "wait_message": "Gathering price and purchase options.",
  "more_resellers": "More Resellers",
  "japan": "Japan",
  "republicofKorea": "Republic of Korea",
  "taiwan": "Taiwan",
  "germany": "Germany",
  "spain": "Spain",
  "france": "France",
  "italy": "Italy",
  "russia": "Russia",
  "poland": "Poland",
  "turkey": "Turkey",
  "Portugal": "Portugal",
  "find_a_store_url": "http://wheretobuy.seagate.com/",
  "select_model": "Select your model",
  "model_not_selected": "Model not selected",
  "select_option_value": "Please select a value for each configuration option.",
  "not_available_resellers": "We're adding more resellers all the time, try another model or check back soon.",
  "not_available_seagate": "Sorry, the model you selected is currently unavailable for purchase on Seagate.com.",
  "show_more_resellers": "Show more Resellers",
  "buy_from_reseller": "Buy from a Reseller",
  "buy_from_seagate": "Buy from Seagate",
  "available": "Available",
  "unavailable": "Unavailable",
  "selected": "Selected",
  "preorder": "Pre order",
  "instock": "In stock",
  "outofstock": "Out of stock",
  "backorder": "Backorder",
  "get_alert": "Get In-Stock Alert",
  "notavailable": "Not available",
  "sale": "SALE",
  "consumer_identity_url": "https://myportal.seagate.com/consumer-identity",
  "consumer_util_url": "https://myportal.seagate.com/consumer-identity/common/consumerUtil.jsp",
  "my_profile_url_non_consumer": "https://partnerreg.seagate.com/partnerprofile/myaccount.jsp",
  "my_dashboard_url_sd": "https://seagate.my.site.com/seagatedirect/s/",
  "my_profile_url_sd": "https://seagate.my.site.com/seagatedirect/s/myprofile",
  "my_dashboard_url_emp": "https://www.seagate.com/",
  "my_profile_url_emp": "https://www.seagate.com/",
  "my_dashboard_url_supplier": "https://supplier.seagate.com/portal/site/supplier",
  "my_profile_url_supplier": "https://supplier.seagate.com/portal/site/supplier/myprofile",
  "my_dashboard_url_spp": "https://www.seagate.com/partners/my-spp-dashboard/",
  "my_profile_url_spp": "https://seagate.my.salesforce.com/apex/SPP_CompanyProfile_VF",
  "my_dashboard_url_t2": "https://program.seagate.com/s",
  "my_profile_url_t2": "https://program.seagate.com/s/editprofile",
  "my_dashboard_url_ci": "https://myportal.seagate.com/consumer-identity/home.jsp",
  "my_profile_url_ci": "https://myportal.seagate.com/consumer-identity/profile/",
  "t2_locales": "",
  "sessionCookieName": "OAM_GITO",
  "login_url": "https://ssologin.seagate.com/oam/server/authentication",
  "logout_url": "https://ssologin.seagate.com/oam/server/logout?end_url=",
  "logout_url_ci": "https://myportal.seagate.com/consumer-identity/logout",
  "partnersLoggedInUserMsg": "<strong>You are signed in as {0} ({1}).</strong>",
  "partnersInternalSeagateUserMsg": "To sign in to the Portal you must first logout of the my.seagate account by clicking the Logout button below.",
  "get_support_now_url": "http://support2.seagate.com/CSO_Customer_GetSupport",
  "resellers_only": "Available at our Resellers only",
  "original": "Orig.",
  "including_taxes": "including taxes",
  "notify_me": "Get in-stock alert",
  "lacie_consumer_domain": "https://myportal.lacie.com",
  "consumer_webroot": "consumer-identity",
  "consumer_dashboard": "home.jsp",
  "consumer_profile": "profile",
  "consumer_logout": "logout",
  "consumer_util": "common/consumerUtil.jsp",
  "starting_at": "Starting at",
  "learnMore": "Learn more",
  "hideKBTab": "false",
  "tpsccError": "No results found.",
  "tpsccDownloadDataSheet": "Download Data Sheet",
  "knowledge_base_ck": "knowledge_base",
  "currency": "$ ",
  "searchpageLoadingMessage": "The page is in the process of loading",
  "searchpageError": "Search is currently not available, please try again later.",
  "searchpageResultsReturned": "Results Returned for",
  "searchpageSearchedFor": "Searched for",
  "searchpageCorrectedSearch": "Showing Results for",
  "searchpageOriginalSearch": "Search for",
  "searchpageSelectFilters": "Select Filters +",
  "searchpageClearAllFilters": "Clear All",
  "searchpageSupportLink": "Support",
  "searchpageProductInformation": "Product Information",
  "searchpageLoadMore": "Load More Results",
  "searchpageFilters": "Filters",
  "searchpageApply": "Apply",
  "searchpageClear": "Clear",
  "searchpageAllResults": "All Results",
  "searchpageProducts": "Products",
  "searchpageSoftwareDownloads": "Software Downloads",
  "searchpageKnowledgeBase": "Knowledge Base",
  "searchpageDocuments": "Documents",
  "searchpageArticles": "Articles",
  "typeaheadDocumentationHeading": "Documentation",
  "typeaheadPopularSearchesHeading": "Popular Searches",
  "typeaheadKnowledgeBaseHeading": "Knowledge Base",
  "typeaheadMoreIn": "More",
  "typeaheadSupportDownloadsHeading": "Support Downloads",
  "typeaheadProductInformation": "Product Information",
  "typeaheadSupportLink": "Support",
  "typeaheadSearch": "Search",
  "typeaheadPlaceholder": "Search Seagate.com",
  "CAPACITY_0_300": "300GB and under",
  "CAPACITY_301_499": "301-499GB",
  "CAPACITY_500_999": "500-999GB",
  "CAPACITY_1000_2999": "1-2.9TB",
  "CAPACITY_3000_9999999": "3TB and over",
  "CAPACITY_1000_1999": "1-1.9TB",
  "CAPACITY_2000_2999": "2-2.9TB",
  "CAPACITY_3000_3999": "3-3.9TB",
  "CAPACITY_4000_4999": "4-4.9TB",
  "CAPACITY_5000_5999": "5-5.9TB",
  "CAPACITY_6000_6999": "6-6.9TB",
  "CAPACITY_7000_7999": "7-7.9TB",
  "CAPACITY_8000_8999": "8-8.9TB",
  "CAPACITY_9000_9999": "9-9.9TB",
  "CAPACITY_10000_10999": "10-10.9TB",
  "CAPACITY_11000_11999": "11-11.9TB",
  "CAPACITY_12000_9999999": "12TB and over",
  "CAPACITY_0_500": "500 GB and under",
  "CAPACITY_501_1999": "501-1999 GB",
  "CAPACITY_2000_4999": "2-4.9 TB",
  "CAPACITY_5000_9999": "5-9.9 TB",
  "CAPACITY_10000_9999999": "10 TB and over",
  "CATEGORY_KEY": "Category",
  "SUBCATEGORY_KEY": "Product Sub-Category",
  "CAPACITY_KEY": "Capacity",
  "INTERFACETECH_KEY": "Interface",
  "SPIN_KEY": "Spin Speed",
  "FORMFACTOR_KEY": "Form Factor",
  "CACHESIZE_KEY": "Cache Size",
  "RESET_FILTER": "RESET FILTERS",
  "search.Products": "Products",
  "search.Documents": "Documents",
  "search.Articles": "Articles",
  "search.NoResults": "There were no results for this search criteria. Enter different criteria.",
  "search.SomeSuggestions": "Some Suggestions:",
  "search.MakeSure": "Make sure all words are spelled correctly.",
  "search.TryDifferent": "Try different keywords.",
  "search.TryMore": "Try more general keywords.",
  "search.results.view.search.instead": "Search instead for",
  "wtb_selectcountry": "Country/Region",
  "wtb_allproducts": "All Products",
  "wtb_externaldrives": "External Drives",
  "wtb_internaldrives": "Internal Drives",
  "wtb_desktop": "Desktop",
  "wtb_portable": "Portable",
  "wtb_gaming": "Gaming",
  "wtb_desktopharddrive": "Desktop Hard Drive",
  "wtb_laptopharddrive": "Laptop Hard Drive",
  "wtb_networkattachedstoragenasharddrive": "Network Attached Storage (NAS) Hard Drive",
  "wtb_surveillanceharddrive": "Surveillance Hard Drive",
  "wtb_enterpriseharddrive": "Enterprise Hard Drive",
  "wtb_enterprisesolidstatedrivessd": "Enterprise Solid State Drive (SSD)",
  "wtb_solidstatedrivessd": "Solid State Drive (SSD)",
  "wtb_gamingstorage": "Gaming Storage",
  "wtb_porsche": "Porsche",
  "wtb_rugged": "Rugged",
  "wtb_d2": "d2",
  "wtb_big": "big",
  "wtb_mobiledrive": "Mobile Drive",
  "wtb_copilot": "Copilot",
  "wtb_mobilessd": "Mobile SSD",
  "wtb_portablessd": "Portable SSD",
  "wtb_mobiledrivemoonsilver": "Mobile Drive - Moon Silver",
  "wtb_mobiledrivespacegray": "Mobile Drive - Space Gray",
  "wtb_ruggedbossssd": "Rugged BOSS SSD",
  "countryCodes": "AF|AX|AL|DZ|AS|AD|AO|AI|AQ|AG|AR|AM|AW|AU|AT|AZ|BS|BH|BD|BB|BY|BE|BZ|BJ|BM|BT|BO|BQ|BA|BW|BV|BR|IO|BN|BG|BF|BI|KH|CM|CA|CV|KY|CF|TD|CL|CN|CX|CC|CO|KM|CG|CD|CK|CR|CI|HR|CW|CY|CZ|DK|DJ|DM|DO|EC|EG|SV|GQ|ER|EE|ET|FK|FO|FJ|FI|FR|GF|PF|TF|GA|GM|GE|DE|GH|GI|GR|GL|GD|GP|GU|GT|GG|GN|GW|GY|HT|HM|VA|HN|HK|HU|IS|IN|ID|IQ|IE|IM|IL|IT|JM|JP|JE|JO|KZ|KE|KI|KR|XK|KW|KG|LA|LV|LB|LS|LR|LY|LI|LT|LU|MO|MG|MW|MY|MV|ML|MT|MH|MQ|MR|MU|YT|MX|FM|MD|MC|MN|ME|MS|MA|MZ|MM|NA|NR|NP|NL|AN|NC|NZ|NI|NE|NG|NU|NF|MP|NO|OM|PK|PW|PS|PA|PG|PY|PE|PH|PN|PL|PT|PR|QA|MK|RE|RO|RU|RW|SH|KN|LC|MF|PM|VC|WS|SM|ST|SA|SN|RS|SC|SL|SG|SK|SI|SB|SO|ZA|GS|ES|LK|SR|SJ|SZ|SE|CH|TW|TJ|TZ|TH|TL|TG|TK|TO|TT|TN|TR|TM|TC|TV|UG|UA|AE|GB|US|UM|UY|UZ|VU|VE|VN|VG|VI|WF|EH|YE|ZM|ZW",
  "countryNames": "AFGHANISTAN|ALAND ISLANDS|ALBANIA|ALGERIA|AMERICAN SAMOA|ANDORRA|ANGOLA|ANGUILLA|ANTARCTICA|ANTIGUA AND BARBUDA|ARGENTINA|ARMENIA|ARUBA|AUSTRALIA|AUSTRIA|AZERBAIJAN|BAHAMAS|BAHRAIN|BANGLADESH|BARBADOS|BELARUS|BELGIUM|BELIZE|BENIN|BERMUDA|BHUTAN|BOLIVIA|BONAIRE, SAINT EUSTATIUS AND SABA|BOSNIA AND HERZEGOVINA|BOTSWANA|BOUVET ISLAND|BRAZIL|BRITISH INDIAN OCEAN TERRITORY|BRUNEI DARUSSALAM|BULGARIA|BURKINA FASO|BURUNDI|CAMBODIA|CAMEROON|CANADA|CAPE VERDE|CAYMAN ISLANDS|CENTRAL AFRICAN REPUBLIC|CHAD|CHILE|CHINA|CHRISTMAS ISLAND|COCOS (KEELING) ISLANDS|COLOMBIA|COMOROS|CONGO|CONGO, THE DEMOCRATIC REPUBLIC OF THE|COOK ISLANDS|COSTA RICA|COTE D'IVOIRE|CROATIA|CURACAO|CYPRUS|CZECH REPUBLIC|DENMARK|DJIBOUTI|DOMINICA|DOMINICAN REPUBLIC|ECUADOR|EGYPT|EL SALVADOR|EQUATORIAL GUINEA|ERITREA|ESTONIA|ETHIOPIA|FALKLAND ISLANDS (MALVINAS)|FAROE ISLANDS|FIJI|FINLAND|FRANCE|FRENCH GUIANA|FRENCH POLYNESIA|FRENCH SOUTHERN TERRITORIES|GABON|GAMBIA|GEORGIA|GERMANY|GHANA|GIBRALTAR|GREECE|GREENLAND|GRENADA|GUADELOUPE|GUAM|GUATEMALA|GUERNSEY|GUINEA|GUINEA-BISSAU|GUYANA|HAITI|HEARD ISLAND AND MCDONALD ISLANDS|HOLY SEE (VATICAN CITY STATE)|HONDURAS|HONG KONG|HUNGARY|ICELAND|INDIA|INDONESIA|IRAQ|IRELAND|ISLE OF MAN|ISRAEL|ITALY|JAMAICA|JAPAN|JERSEY|JORDAN|KAZAKHSTAN|KENYA|KIRIBATI|KOREA, REPUBLIC OF|KOSOVO|KUWAIT|KYRGYZSTAN|LAO PEOPLE'S DEMOCRATIC REPUBLIC|LATVIA|LEBANON|LESOTHO|LIBERIA|LIBYAN ARAB JAMAHIRIYA|LIECHTENSTEIN|LITHUANIA|LUXEMBOURG|MACAO|MADAGASCAR|MALAWI|MALAYSIA|MALDIVES|MALI|MALTA|MARSHALL ISLANDS|MARTINIQUE|MAURITANIA|MAURITIUS|MAYOTTE|MEXICO|MICRONESIA, FEDERATED STATES OF|MOLDOVA, REPUBLIC OF|MONACO|MONGOLIA|MONTENEGRO|MONTSERRAT|MOROCCO|MOZAMBIQUE|MYANMAR|NAMIBIA|NAURU|NEPAL|NETHERLANDS|NETHERLANDS ANTILLES|NEW CALEDONIA|NEW ZEALAND|NICARAGUA|NIGER|NIGERIA|NIUE|NORFOLK ISLAND|NORTHERN MARIANA ISLANDS|NORWAY|OMAN|PAKISTAN|PALAU|PALESTINIAN TERRITORY, OCCUPIED|PANAMA|PAPUA NEW GUINEA|PARAGUAY|PERU|PHILIPPINES|PITCAIRN|POLAND|PORTUGAL|PUERTO RICO|QATAR|REPUBLIC OF NORTH MACEDONIA|REUNION|ROMANIA|RUSSIAN FEDERATION|RWANDA|SAINT HELENA|SAINT KITTS AND NEVIS|SAINT LUCIA|SAINT MARTIN|SAINT PIERRE AND MIQUELON|SAINT VINCENT AND THE GRENADINES|SAMOA|SAN MARINO|SAO TOME AND PRINCIPE|SAUDI ARABIA|SENEGAL|SERBIA|SEYCHELLES|SIERRA LEONE|SINGAPORE|SLOVAKIA|SLOVENIA|SOLOMON ISLANDS|SOMALIA|SOUTH AFRICA|SOUTH GEORGIA AND THE SOUTH SANDWICH ISLANDS|SPAIN|SRI LANKA|SURINAME|SVALBARD AND JAN MAYEN|SWAZILAND|SWEDEN|SWITZERLAND|TAIWAN|TAJIKISTAN|TANZANIA, UNITED REPUBLIC OF|THAILAND|TIMOR-LESTE|TOGO|TOKELAU|TONGA|TRINIDAD AND TOBAGO|TUNISIA|TURKEY|TURKMENISTAN|TURKS AND CAICOS ISLANDS|TUVALU|UGANDA|UKRAINE|UNITED ARAB EMIRATES|UNITED KINGDOM|UNITED STATES|UNITED STATES MINOR OUTLYING ISLANDS|URUGUAY|UZBEKISTAN|VANUATU|VENEZUELA|VIET NAM|VIRGIN ISLANDS, BRITISH|VIRGIN ISLANDS, U.S.|WALLIS AND FUTUNA|WESTERN SAHARA|YEMEN|ZAMBIA|ZIMBABWE",
  "countryDefault": "US",
  "wtb_findaretailer": "Find a Retailer",
  "is_blueboard_locale": "en-us,en-ca,fr-ca",
  "is_blueboard_emea_country": "AT,RO,DE,DZ,BH,CY,EG,IQ,JO,KW,LB,MA,OM,PS,QA,SA,AE,YE,LI,CH,GH,GR,IR,IL,KE,NG,SD,SY,AF,AX,AO,BQ,BA,BW,BV,IO,BG,HR,CW,CZ,DK,em,ER,EE,ET,FO,FK,FI,GM,GE,GI,GB,GL,GD,GG,HU,IS,IE,IM,JE,LV,LS,LR,LT,MK,MW,MT,YT,MD,ME,MS,MZ,NA,NL,AN,NO,PT,RS,SL,SK,SI,SO,ZA,GS,SS,SR,SJ,SZ,SE,TZ,TM,UG,UA,GB,UZ,VG,WF,EH,ZM,ZW,GQ,ES,AL,AD,BE,BJ,BF,BI,CM,CF,TD,KM,CG,CD,CI,DJ,FR,GF,PF,TF,GA,GP,GN,LU,MG,ML,MR,MU,MC,NC,NE,RE,RW,BL,MF,ST,SN,SC,TG,TN,IT,LY,SM,VA,PL,AM,AZ,BY,KZ,KG,RU,TJ,TR",
  "wtb_noresellerlist": "Reseller List not Available",
  "selectYourCountryRegion": "Select Your Country/Region",
  "wtb_storage_device": "Storage Device",
  "wtb_enterprise_data_storage_systems": "Enterprise Data Storage Systems",
  "prevLabel": "Prev",
  "nextLabel": "Next",
  "no_firmware_updates_currently_available_for_serial_number": "No firmware updates currently available for serial number",
  "minute_read": "{0} minute read",
  "off": "off"
};
/* harmony default export */ var SearchNew_localLabels = (localLabels);
;// CONCATENATED MODULE: ./stories/js/modules/SearchNew/index.js




function SearchNew() {
  console.log('SearchNew');
  window.rcLocaleJS = document.documentElement.lang;
  var searchPage = document.getElementById('SearchPage');
  var labels = window.labels ? window.labels : SearchNew_localLabels;
  var rcLocaleJS = window.rcLocaleJS ? window.rcLocaleJS : 'en-us';
  var searchQuery = window.location.search;
  var searchURL = window.location.href;
  var brand = window.brand ? window.brand : 'seagate';
  var api = '/ww/solrUnifiedSearch'; // api = '/ww/solrUnifiedSearch?locale=en_us&term=backup&brand=seagate',

  var facetFields = null;
  var facetPageType = null;
  var keyMatches = [];
  var searchTerm = null;
  var spellcheck = null;
  var spellcheckQ = null;
  var searchResults = [];
  var matchResults = null;
  var allResults = null;
  var pageTargets = {
    articles: 'articles',
    documents: 'documents',
    knowledgeBase: 'knowledgebase',
    support: 'support',
    product: 'pdp'
  };
  var pageType = 'false';
  var allPageTypes = [];
  var loading = true;
  var errored = false;
  var selectedFacets = [];
  var start = 20;
  var featuredProducts = [];
  var featuredProductLimit = 2;
  var featuredProductRelevanceFloor = .0;
  var mobileRefinementsVisible = false;
  var initStatus = true;
  var activePageType = false;
  var displayedFacetGroups = []; // Page Type filter group should only be displayed at top

  var refinementMenuStatus = false;
  var isOpen = false;
  var isloadMore = false;
  var search_Content;
  var search_Error;
  var search_Loading;
  var search_noResults;
  var search_Header;
  var search_Category;
  var search_Categories;
  var search_KeyMatches;
  var search_Filters;
  var search_Filter;
  var search_refinementFooter;
  var searched_Filters;
  var searched_Filter;
  var search_List;

  var allPageResultsTotal = function allPageResultsTotal() {
    var total = 0;

    for (var quantity in facetPageType) {
      total = total += parseInt(facetPageType[quantity]);
    }

    return total;
  };

  var isAllPageWithoutResults = function isAllPageWithoutResults() {
    return pageType == 'false' && allResults === null;
  };

  var leftColumnHasFilters = function leftColumnHasFilters() {
    return facetFields && pageType === pageTargets.product;
  };

  var leftColumnHasContent = function leftColumnHasContent() {
    return leftColumnHasFilters() || keyMatches.length > 0;
  };

  var getLabel = function getLabel(key) {
    return labels[key] ? labels[key] : '';
  };

  var buildSearchPage = function buildSearchPage() {
    var html = '';

    if (errored) {
      html += searchError();
    } else {
      if (!loading) {
        html += searchHeading();
      }

      if (!loading) {
        html += contentCategory();
      }

      if (!loading) {
        html += searchContent();
      }

      if (loading) {
        searchPage.classList.add('loading');
        html += loadingSearch();
      } else {
        searchPage.classList.remove('loading');
      }
    }

    searchPage.innerHTML = html;
    encodeHTMLAttribute();
  };

  function encodeHTMLAttribute() {
    if (searchPage) {
      var headingLabel = searchPage.querySelector('.search-info > a');

      if (headingLabel) {
        headingLabel.setAttribute('href', '/search/?keyword=' + searchTerm);
        headingLabel.textContent = searchTerm;
      }

      var headingInput = searchPage.querySelector('#body-searchbar');

      if (headingInput) {
        headingInput.setAttribute('value', searchTerm);
      }
    }
  }

  var searchContent = function searchContent() {
    var html = '';
    html += '<div class="search-content">';
    html += '<div class="container">';
    html += '<div class="row-fluid">';
    html += leftColumn();
    html += rightColumn();
    return html;
  };

  var leftColumn = function leftColumn() {
    var html = '';

    if (leftColumnHasContent()) {
      html += '<div class="span3">';
      html += resultKeymatch();

      if (leftColumnHasFilters()) {
        html += refinementNavigation();
      }

      html += '</div>';
    }

    return html;
  };

  var rightColumn = function rightColumn() {
    var html = '';
    var spanClass = leftColumnHasContent() ? 'span9' : 'span12';
    html += '<div class="' + spanClass + '">';
    html += searchedFilters();
    html += resultsListing();
    html += '</div>';
    return html;
  };

  var searchError = function searchError() {
    var html = '';
    html += '<div id="search-error" class="search-error">';
    html += '<div class="container">';
    html += '<div class="search-list">';

    if (labels) {
      html += '<h5> ' + getLabel('searchpageError') + '</h5>';
    }

    html += '</div>';
    html += '</div>';
    html += '</div>';
    return html;
  };

  var loadingSearch = function loadingSearch() {
    var html = '';
    html += "<div class=\"loading-box\">\n\t\t<div class=\"overlay\"></div>\n\t\t<div class=\"placeholder\">\n\t\t\t<div class=\"search-header\">\n\t\t\t\t<div class=\"container\">\n\t\t\t\t\t<p class=\"search-info\"></p>\n\t\t\t\t\t<div class=\"search-header-box\">\t\t\t\t\t\t\t\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"search-nav\">\n\t\t\t\t<div class=\"container sdropdown\">\n\t\t\t\t\t<div class=\"dropdown-toggle search-nav-toggle hidden-desktop\">\n\t\t\t\t\t\t<p></p>\t\t\t\t\t\t\t\n\t\t\t\t\t</div>\n\t\t\t\t\t<ul class=\"dropdown-menu\">\n\t\t\t\t\t\t<li></li>\n\t\t\t\t\t\t<li></li>\n\t\t\t\t\t\t<li></li>\n\t\t\t\t\t\t<li></li>\n\t\t\t\t\t\t<li></li>\n\t\t\t\t\t\t<li></li>\n\t\t\t\t\t</ul>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"search-content\">\n\t\t\t\t<div class=\"container\">\n\t\t\t\t\t<div class=\"row-fluid\">\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t<div class=\"span12\">\n\t\t\t\t\t\t\t<div class=\"search-list\">\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t<div class=\"search-items\">\n\t\t\t\t\t\t\t\t\t<div class=\"search-item\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"item-body\">\n\t\t\t\t\t\t\t\t\t\t\t<h6><a href=\"\"></a></h6>\n\t\t\t\t\t\t\t\t\t\t\t<p></p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"search-item\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"item-body\">\n\t\t\t\t\t\t\t\t\t\t\t<h6><a href=\"\"></a></h6>\n\t\t\t\t\t\t\t\t\t\t\t<p></p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"search-item\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"item-body\">\n\t\t\t\t\t\t\t\t\t\t\t<h6><a href=\"\"></a></h6>\n\t\t\t\t\t\t\t\t\t\t\t<p></p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"search-item\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"item-body\">\n\t\t\t\t\t\t\t\t\t\t\t<h6><a href=\"\"></a></h6>\n\t\t\t\t\t\t\t\t\t\t\t<p></p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"search-item\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"item-body\">\n\t\t\t\t\t\t\t\t\t\t\t<h6><a href=\"\"></a></h6>\n\t\t\t\t\t\t\t\t\t\t\t<p></p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"search-item\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"item-body\">\n\t\t\t\t\t\t\t\t\t\t\t<h6><a href=\"\"></a></h6>\n\t\t\t\t\t\t\t\t\t\t\t<p></p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"search-item\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"item-body\">\n\t\t\t\t\t\t\t\t\t\t\t<h6><a href=\"\"></a></h6>\n\t\t\t\t\t\t\t\t\t\t\t<p></p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<button class=\"load-more-button\"></button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n \t</div> ";
    return html;
  };

  var noResults = function noResults() {
    var html = '';

    if (labels) {
      html += '<div id="no-results" class="no-results" style="min-height: calc(100vh - 593px)">';
      html += '<h4>' + getLabel('search.NoResults') + '</h4>';
      html += '<h5>' + getLabel('search.SomeSuggestions') + '</h5>';
      html += '<ul>';
      html += '	<li>' + getLabel('search.MakeSure') + '</li>';
      html += '	<li>' + getLabel('search.TryDifferent') + '</li>';
      html += '	<li>' + getLabel('search.TryMore') + '</li>';
      html += '</ul>';
      html += '</div>';
    }

    return html;
  };

  function escape(s) {
    return ('' + s
    /* Forces the conversion to string. */
    ).replace('&', '&amp;')
    /* These 5 replacements protect from HTML/XML. */
    .replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;').replace("'", '&#x27;');
  }

  var searchHeading = function searchHeading() {
    var html = '';
    html += '<div class="search-header">';
    html += '<div class="container">';

    if (labels) {
      html += '<p class="search-info" id="results-returned">';
      html += allResults || 0;
      html += ' ' + getLabel('searchpageResultsReturned'); //html += ' <a href="/search/?keyword='+ escape(searchTerm) + '">' + escape(searchTerm) +'</a>. ';

      html += ' <a></a>. ';

      if (spellcheck == 'false') {
        html += '<span>' + getLabel('search.results.view.search.instead') + ' <a href="/search/?keyword=' + spellcheckQ + '&ignoreSpellCheck=true">' + spellcheckQ + '</a>.</span>';
      }

      html += '</p>';
    }

    html += '<div class="search-header-box">';
    html += '<form id="body-searchbar-container" action="/search/" method="post">';
    html += '<span class="search-glass"></span>';
    html += '<input id="body-searchbar"';
    html += 'type="text"';
    html += 'value=""'; //html += 'value="' + escape(searchTerm) + '"';

    html += 'autocomplete="off"';
    html += 'class="search-input" />';
    html += '<input type="submit" id="search-input-submit" class="search-submit hidden" />';

    if (searchTerm && searchTerm.length > 1) {
      html += '<span class="search-clear"></span>';
    }

    html += '  </form>';
    html += '</div>';
    html += '</div>';
    html += '</div>';
    return html;
  };

  var contentCategory = function contentCategory() {
    var html = '';
    var navclass = isAllPageWithoutResults() ? 'disabled' : '';

    if (facetPageType && labels) {
      html += '<div class="search-nav ' + navclass + '" id="content-categories">';
      html += '<div class="container sdropdown">';
      html += '<div class="dropdown-toggle search-nav-toggle hidden-desktop" data-toggle="sdropdown">';
      html += '<p>';
      html += '<span>' + getLabel('searchpageAllResults') + '</span>';

      if (!isAllPageWithoutResults()) {
        if (allResults != null) {
          html += '<em>( ' + allResults + ')</em>';
        }
      }

      html += '</p>';
      html += '<i></i>';
      html += '</div>';
      html += '<ul class="dropdown-menu">';
      var categoryclass = pageType == 'false' && !isAllPageWithoutResults() ? 'active' : '';
      html += '<li class="content-category ' + categoryclass + '" data-type="all" data-category="false">';
      html += '<p>';
      html += '<span>' + getLabel('searchpageAllResults') + '</span>';

      if (!isAllPageWithoutResults()) {
        if (allResults != null) {
          html += '<em>( ' + allResults + ' )</em>';
        }
      }

      html += '</p>';
      html += '</li>';
      html += '<!-- v-if="facetPageType[pageTargets.product]" -->';
      var productclass = pageType == pageTargets.product ? 'active' : '';
      html += '<li data-type="product" class="content-category ' + productclass + '" data-category="' + pageTargets.product + '">';
      html += '<i></i>';
      html += '<p>';
      html += '<span>' + getLabel('searchpageProducts') + '</span> ';

      if (allPageTypes[pageTargets.product]) {
        html += '<em>(' + allPageTypes[pageTargets.product] + ')</em>';
      }

      html += '</p>';
      html += '</li>';
      html += '<!-- v-if="facetPageType[pageTargets.support]" -->';
      var supportclass = pageType == pageTargets.support ? 'active' : '';
      html += '<li data-type="software-download" class="content-category ' + supportclass + '" data-category="' + pageTargets.support + '">';
      html += '<i></i>';
      html += '<p>';
      html += '<span>' + getLabel('searchpageSoftwareDownloads') + '</span> ';

      if (allPageTypes[pageTargets.support]) {
        html += '<em>(' + allPageTypes[pageTargets.support] + ')</em>';
      }

      html += '</p>';
      html += '</li>';
      html += '<!-- v-if="facetPageType[pageTargets.knowledgeBase]" -->';
      var knowledgeclass = pageType == pageTargets.knowledgeBase ? 'active' : '';
      html += '<li data-type="knowledge-base" class="content-category ' + knowledgeclass + '" data-category="' + pageTargets.knowledgeBase + '">';
      html += '<i></i>';
      html += '<p>';
      html += '<span>' + getLabel('searchpageKnowledgeBase') + '</span> ';

      if (allPageTypes[pageTargets.knowledgeBase]) {
        html += '<em>(' + allPageTypes[pageTargets.knowledgeBase] + ')</em>';
      }

      html += '</p>';
      html += '</li>';
      html += '<!-- v-if="facetPageType[pageTargets.documents]" -->';
      var docclass = pageType == pageTargets.documents ? 'active' : '';
      html += '<li data-type="document" class="content-category ' + docclass + '" data-category="' + pageTargets.documents + '">';
      html += '<i></i>';
      html += '<p>';
      html += '<span>' + getLabel('searchpageDocuments') + '</span> ';

      if (allPageTypes[pageTargets.documents]) {
        html += '<em>(' + allPageTypes[pageTargets.documents] + ')</em>';
      }

      html += '</p>';
      html += '</li>';
      html += '<!-- v-if="facetPageType[pageTargets.articles]" -->';
      var articleclass = pageType == pageTargets.articles ? 'active' : '';
      html += '<li data-type="article" class="content-category ' + articleclass + '" data-category="' + pageTargets.articles + '">';
      html += '<i></i>';
      html += '<p>';
      html += '<span>' + getLabel('searchpageArticles') + '</span> ';

      if (allPageTypes[pageTargets.articles]) {
        html += '<em>(' + allPageTypes[pageTargets.articles] + ')</em>';
      }

      html += '</p>';
      html += '</li>';
      html += '</ul>';
      html += '</div>';
      html += '</div>';
    }

    return html;
  };

  var resultKeymatch = function resultKeymatch() {
    var html = '';

    if (keyMatches && keyMatches.length > 0) {
      html += '<div class="search-keymatchs" id="search-keymatchs">';
      keyMatches.forEach(function (doc, index) {
        if (index == 0) {
          html += '<div class="search-keymatch">';

          if (imageCheck(doc)) {
            html += '<div class="image">';
            html += '<a href="' + doc.url + '"><img src="' + getAbsoluteImagePath(doc.image) + '" alt="' + doc['title_' + doc.lang] + '"></a>';
            html += '</div>';
          }

          html += '<div class="text">';
          html += '<h6 class="search-keymatch-title"><a href="' + doc.url + '">' + doc['title_' + doc.lang] + '</a></h6>';

          if (doc['description_' + doc.lang]) {
            html += '<p class="search-keymatch-desc">' + doc['description_' + doc.lang] + '</p>';
          }

          html += '<p><a href="' + doc.url + '">' + getLabel('typeaheadMoreIn') + '<i class="ss-icon">&#x25BB;</i></a></p>';
          html += '</div>';
          html += '</div>';
        }
      });
      html += '</div>';
    }

    return html;
  };

  var refinementNavigation = function refinementNavigation() {
    var html = '';
    var cclass = isOpen ? 'filter-visible' : '';
    html += '<div id="refinements" class="search-filters clearfix" class="' + cclass + '">';
    html += '<h4>';
    html += '<span class="search-filter-toggle">' + getLabel('searchpageFilters') + '</span>';
    html += '<span class="search-filter-close"></span>';
    html += '</h4>';
    html += '<div class="search-filter-list">';
    Object.keys(facetFields).forEach(function (facetFieldKey) {
      var facetField = facetFields[facetFieldKey];

      if (facetFieldKey != 'pageType' && Object.keys(facetFields[facetFieldKey]).length !== 0) {
        html += '<div class="search-filter refinement-group">';
        html += '<p>';
        html += getLabel(facetFieldKey.toUpperCase() + '_KEY') || facetFieldKey;
        html += '</p>';
        html += '<div class="control-group">';
        html += '<div class="controls">';
        Object.keys(facetField).forEach(function (facetKey) {
          var facetValue = facetField[facetKey];
          var keyClass = inactiveFacetCheck(facetValue) === true ? 'inactive-filter' : '';
          var disabled = inactiveFacetCheck(facetValue) === true ? 'disabled' : '';
          html += '<div class="checkbox" data-key="' + facetKey + '" data-field ="' + facetFieldKey + '">';
          html += '<input type="checkbox" class="facet checkbox-custom" id="refinement' + facetKey + facetFieldKey + '" ref="refinement' + facetKey + facetFieldKey + '" value="' + facetKey + facetFieldKey + '" ' + disabled + '">';
          var label = getLabel(facetKey) != '' ? getLabel(facetKey) : facetKey;
          html += '<label for="' + facetKey + facetFieldKey + '"><span><i class="ss-icon">&#x2713;</i></span>' + label + ' (' + facetValue + ')' + '</label>';
          html += ' </div>';
        });
        html += '</div>';
        html += '</div>';
        html += '</div>';
      }
    });
    html += '</div>';

    if (labels) {
      html += '<div id="refinement-footer" class="hidden-desktop search-btns">'; //html += '<!--<button class="btn btn-default" onclick="' + clearActiveFacets() +'">'+getLabel('searchpageClear') +'</button>';
      //html += '<button class="btn btn-primary" onclick="' +closeFilter() +'">'+getLabel('searchpageApply') +'</button>-->';

      html += '</div>';
    }

    html += '</div>';
    return html;
  };

  var searchedFilters = function searchedFilters() {
    var html = '';

    if (selectedFacets && selectedFacets.length > 0) {
      html += '<div id="searchHeadingFilterList" class="searched-filters">';
      html += '<ul>';
      selectedFacets.forEach(function (activeFacet) {
        html += '<li data-key="' + activeFacet.uniqueId + '" class="active-filter" value="' + activeFacet.uniqueId + '">';
        html += '<i class="ss-icon">&#x2421;</i>';

        if (activeFacet.facetField == 'capacity') {
          html += '<span>' + getLabel(activeFacet.facet) + '</span>';
        } else {
          html += '<span>' + activeFacet.facet + '</span>';
        }

        html += '</li>';
      });
      html += '</ul>';

      if (selectedFacets.length > 1 && labels) {
        html += '<span class="active-filter filter-clear">';
        html += getLabel('searchpageClearAllFilters');
        html += '</span>';
      }

      html += '</div>';
    }

    return html;
  };

  var resultsListing = function resultsListing() {
    var html = '';
    html += '<div class="search-list" id="search-body">';
    html += '<!-- if high match product -->';

    if (featuredProducts && featuredProducts.length > 0) {
      html += '<div class="search-products">';
      html += '  <h4>' + getLabel('searchpageProducts') + '</h4>';
      html += '  <div class="row-fluid" id="rollup-products">';
      featuredProducts.forEach(function (doc) {
        var key = doc.id;
        html += '<div class="span4">';
        html += '<div class="search-product search-item rollup-product">';

        if (doc.imagePath) {
          html += '<div class="product-image">';
          html += '<a href="' + doc.url + '"><img src="' + getAbsoluteImagePath(doc.imagePath) + '" alt="' + doc['title_' + doc.lang] + '"></a>';
          html += '</div>';
        }

        html += '<div class="product-content product-text-box">';
        html += '<h6 class="search-result-title"><a href="' + doc.url + '">' + doc['title_' + doc.lang] + '</a></h6>';

        if (doc['description_' + doc.lang]) {
          html += '<p class="search-result-desc">' + doc['description_' + doc.lang] + '</p>';
        }

        if (doc.supportURL) {
          html += '<p><a class="search-results-link" href="' + getAbsoluteSubcategoryLinkPath(doc.supportURL, doc.url) + '" alt=""> ' + getLabel('searchpageSupportLink') + ' <i class="ss-icon">&#x25BB;</i></a></p>';
        }

        if (doc.featuresURL) {
          html += '<p><a class="search-results-link" href="' + getAbsoluteSubcategoryLinkPath(doc.featuresURL, doc.url) + '" alt=""> ' + getLabel('searchpageProductInformation') + ' <i class="ss-icon">&#x25BB;</i></a></p>';
        }

        html += '</div>';
        html += '</div>';
        html += '</div>';
      });
      html += '</div>';
      html += '</div>';
    }

    if (searchResults) {
      html += '<div id="results" class="search-items">';
      html += updateSearchResult();
      html += '</div>';
    }

    html += updateLoadMore();

    if (!errored && !loading && !searchResults.length && !keyMatches.length) {
      html += noResults();
    }

    html += '</div>';
    return html;
  };

  function updateSearchResult() {
    var html = '';
    searchResults.forEach(function (result, index) {
      var key = index;

      if (index < start) {
        html += '<div>';
        result.doclist.forEach(function (doc) {
          html += '<div>';
          var key = doc.id;

          if (doc.pageType != 'pdp' && doc.pageType != 'support' && doc.pageType != 'support_eol') {
            html += '<div class="search-item result" data-type="' + selectType(doc) + '">';
            html += '<div class="item-body">';
            html += '<h6 class="search-result-title">';

            if (doc['title_' + doc.lang]) {
              html += '<a href="' + doc.url + '">' + doc['title_' + doc.lang] + '</a>';
            } else {
              html += '<a href="' + doc.url + '">' + doc.url + ' </a>';
            }

            html += '</h6>';

            if (doc['description_' + doc.lang]) {
              html += '<p class="search-result-desc">' + doc['description_' + doc.lang] + '</p>';
            }

            html += '</div>';
            html += '</div>';
          }

          if (featuredProducts ? productCheck(doc) : doc.pageType === 'pdp' || doc.pageType === 'support' || doc.pageType === 'support_eol') {
            html += '<div class="search-item" data-type="' + selectType(doc) + '">';
            html += '<div class="item-body">';
            html += '<h6 class="search-result-title"><a href="' + doc.url + '">' + doc['title_' + doc.lang] + '</a></h6>';

            if (doc['description_' + doc.lang]) {
              html += '<p class="search-result-desc">' + doc['description_' + doc.lang] + '</p>';
            }

            if (doc.supportURL) {
              html += '<p><a class="search-results-link" href="' + getAbsoluteSubcategoryLinkPath(doc.supportURL, doc.url) + '" alt=""> ' + getLabel('searchpageSupportLink') + '<i class="ss-icon">&#x25BB;</i></a></p>';
            }

            if (doc.featuresURL) {
              html += '<p><a class="search-results-link" href="' + getAbsoluteSubcategoryLinkPath(doc.featuresURL, doc.url) + '" alt=""> ' + getLabel('searchpageProductInformation') + '<i class="ss-icon">&#x25BB;</i></a></p>';
            }

            html += '</div>';

            if (doc.imagePath) {
              html += '<div class="item-image">';
              html += '<a href="' + doc.url + '"><img src="' + getAbsoluteImagePath(doc.imagePath) + '" alt="' + doc['title_' + doc.lang] + '"></a>';
              html += '</div>';
            }

            html += '</div>';
          }

          html += '</div>';
        });
        html += '</div>';
      }
    });
    return html;
  }

  function updateLoadMore() {
    var html = '';

    if (start < matchResults) {
      html += '<button class="load-more-button" id="load-more"> ' + getLabel('searchpageLoadMore') + '</button>';
    }

    return html;
  }

  function getElements() {
    search_Content = searchPage.querySelector('.search-content');
    search_Error = searchPage.querySelector('.search-error');
    search_Loading = searchPage.querySelector('.loading-box');
    search_noResults = searchPage.querySelector('.no-results');
    search_Header = searchPage.querySelector('.search-header');
    search_Category = searchPage.querySelector('.search-nav');
    search_Categories = search_Category ? search_Category.querySelectorAll('.content-category') : null;
    search_KeyMatches = searchPage.querySelector('.search-keymatchs');
    search_Filters = searchPage.querySelector('.search-filters');
    search_Filter = search_Filters ? search_Filters.querySelectorAll('.search-filter') : null;
    search_refinementFooter = document.getElementById('refinement-footer');
    searched_Filters = searchPage.querySelector('.searched-filters');
    searched_Filter = searched_Filters ? searched_Filters.querySelectorAll('.active-filter') : null;
    search_List = searchPage.querySelector('.search-list');
  }

  function updateOtherElementsClass(ele, cla) {
    var array_categories = Array.from(ele);
    var other_categories = array_categories.filter(function (c) {
      return array_categories.indexOf(c) != index;
    });
    other_categories.map(function (mc) {
      mc.classList.remove(cla);
    });
  }

  function bindSearchPageEvents() {
    if (search_Category) {
      search_Categories.forEach(function (cc, index) {
        cc.addEventListener('click', function (e) {
          e.preventDefault();
          var category = cc.dataset.category;
          selectCategories(category);
        });
      });
      var search_Category_dropdown = search_Category.querySelector('.sdropdown');
      var search_Category_dropdown_toggle = search_Category_dropdown.querySelector('.dropdown-toggle');
      search_Category_dropdown_toggle.addEventListener('click', function (e) {
        e.preventDefault();
        search_Category_dropdown.classList.toggle('open');
      });
      document.addEventListener("click", function (event) {
        if (!event.target.closest('.sdropdown')) {
          search_Category_dropdown.classList.remove('open');
        }
      });
    }

    if (search_List) {
      var load_more = search_List.querySelector('.load-more-button');

      if (load_more) {
        load_more.addEventListener('click', function () {
          isloadMore = true;
          loadMoreResults();
        });
      }
    }

    if (search_Filters) {
      var toggle_filter = search_Filters.querySelector('.search-filter-toggle');
      var toggle_close = search_Filters.querySelector('.search-filter-close');

      if (toggle_filter) {
        toggle_filter.addEventListener('click', function () {
          openFilter();
        });
      }

      if (toggle_close) {
        toggle_close.addEventListener('click', function () {
          closeFilter();
        });
      }

      var checkboxes = search_Filters.querySelectorAll('.checkbox');
      checkboxes.forEach(function (box) {
        box.addEventListener('click', function (e) {
          var key = box.dataset.key;
          var field = box.dataset.field;
          toggleFacet(key, field);
        });
      });
    }

    if (searched_Filters) {
      var filter_clear = searched_Filters.querySelector('.filter-clear');

      if (filter_clear) {
        filter_clear.addEventListener('click', function () {
          clearFacets();
        });
      }

      var active_filters = searched_Filters.querySelectorAll('.active-filter');
      active_filters.forEach(function (filter) {
        filter.addEventListener('click', function (e) {
          //if(e.target.localName == 'i') {
          var activeFacetUniqueId = filter.dataset.key;
          removeFacet(activeFacetUniqueId); //}
        });
      });
    }

    if (search_Header) {
      var search_clear = search_Header.querySelector('.search-clear');
      var search_input = search_Header.querySelector('.search-input');
      var search_submit = search_Header.querySelector('.search-input-submit');
      var search_form = search_Header.querySelector('form');

      if (search_clear) {
        search_clear.addEventListener('click', function (e) {
          searchTerm = '';

          if (search_input) {
            search_input.value = searchTerm;
          }

          search_clear.classList.add('hidden');
        });
      }

      if (search_form) {
        search_form.addEventListener('keypress', function (e) {
          if (e.keyCode === 13) {
            if (search_input && search_input.value.length > 1 && search_input.value.trim() != '') {
              searchTerm = e.target.value;
            }

            e.preventDefault();
            handleSubmit();
          }
        });
      }

      if (search_input) {
        search_input.addEventListener('keyup', function (e) {
          if (e.target.value.length > 1) {
            search_clear.classList.remove('hidden');
          } else {
            search_clear.classList.add('hidden');
          }
        });
      }
    }
  }

  function getValueFromQuery(key) {
    var params = new URLSearchParams(document.location.search);
    var hashMode = '';

    if (params.has(key) && params.get(key) != '') {
      hashMode = params.get(key);
    } else {
      hashMode = null;
    }

    return hashMode;
  }

  function setSearchType() {
    var type = getValueFromQuery('pagetype') ? getValueFromQuery('pagetype') : 'false';
    searchPage.setAttribute('data-pageType', type); //pageType = type;
  }

  function initSearch() {
    if (searchURL.indexOf('/search/') != -1 || searchURL.indexOf('/search.html?wcmmode=disabled') != -1) {
      setSearchType();
      initSearchResults();
    } //LocalTest


    if (checkLocalhost()) {
      setSearchType();
      setProp('keyword', 'nas');
      searchQuery = window.location.search;
      searchURL = window.location.href;
      getSearchResults({});
    }
  }

  function initSearchResults() {
    var params = {
      brand: brand,
      locale: getLocale(),
      term: getProp('keyword') != undefined ? getProp('keyword') : null,
      ignoreSpellCheck: getProp('ignoreSpellCheck') != undefined ? getProp('ignoreSpellCheck') : 'false'
    };
    getSearchResults(params);
  }

  function getLocale() {
    var locale = rcLocaleJS;

    if (locale.indexOf("-") != -1) {
      var reformatLocale = locale.replace("-", "_");
      return reformatLocale;
    } else {
      return locale;
    }
  }

  function getProp(target) {
    var query = searchQuery.substring(1);
    var vars = query.split("&");

    for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split("=");

      if (pair[0] == target) {
        return decodeURIComponent(pair[1]);
      }
    } //return new URL(searchURL).searchParams.get(target)

  }

  function setProp(target, value) {
    var old;
    var newurl;

    if (getProp(target) != undefined) {
      old = getProp(target);

      if (value == 'false') {
        newurl = searchURL.replace('&' + target + '=' + old, '');
      } else {
        newurl = searchURL.replace('=' + old, '=' + value);
      }
    } else {
      if (value != 'false') {
        newurl = searchURL + '&' + target + '=' + value;
      } else {
        newurl = searchURL;
      }
    }

    window.history.replaceState({
      path: newurl
    }, '', newurl); //return new URL(searchURL).searchParams.get(target)
  }

  function checkLocalhost() {
    if (document.domain == 'localhost' && document.location.pathname == '/iframe.html') {
      return true;
    } else {
      return false;
    }
  }

  function checkJsonApi(flag) {
    //var jsonApi = '/assets/json/general-search-v2.json';
    if (checkLocalhost()) {
      switch (pageType) {
        case 'pdp':
          if (flag) {
            api = '/assets/json/search-pdp-20.json';
          } else {
            api = '/assets/json/search-pdp.json';
          }

          break;

        case 'support':
          api = '/assets/json/search-support.json';
          break;

        case 'knowledgebase':
          api = '/assets/json/search-knowledge.json';
          break;

        case 'documents':
          api = '/assets/json/search-doc.json';
          break;

        case 'articles':
          api = '/assets/json/search-article.json';
          break;

        default:
          api = '/assets/json/search-all.json';
          break;
      }
    }
  }

  function getSearchResults(params) {
    //when all, !params['fq_pagetype']==true
    //loading = true
    checkJsonApi(false);
    lib_axios.get(api, {
      params: params,
      paramsSerializer: function paramsSerializer(params) {
        return qs_lib_default().stringify(params, {
          arrayFormat: 'repeat'
        });
      }
    }).then(function (response) {
      return searchTerm = response.data.responseHeader != undefined ? response.data.responseHeader.params.q || params['term'] : params['term'], spellcheck = response.data.responseHeader != undefined ? response.data.responseHeader.params.spellcheck : null, spellcheckQ = response.data.responseHeader != undefined ? response.data.responseHeader.params['spellcheck.q'] : null, facetFields = response.data.facet_field != undefined ? response.data.facet_field || null : null, facetPageType = response.data.facet_field != undefined ? response.data.facet_field.pageType || null : null, matchResults = response.data.grouped != undefined ? response.data.grouped.pdhInternalNamesGroup.matches || null : null, searchResults = response.data.grouped != undefined ? response.data.grouped.pdhInternalNamesGroup.groups || [] : [], featuredProducts = response.data.grouped != undefined ? featuredProductsCheck(response.data.grouped.pdhInternalNamesGroup.groups) || [] : [], keyMatches = response.data.keyMatches != undefined ? response.data.keyMatches.docs || [] : [];
    }).catch(function (error) {
      console.log(error);
      errored = true;
    }).finally(function () {
      if (initStatus) {
        loading = true;
      } else {
        loading = false;
      }

      if (pageType == 'false') {
        allResults = matchResults;
        allPageTypes = facetPageType;
      }

      if (initStatus && getProp('pagetype') != undefined) {
        pageType = getProp('pagetype');
        dupGetSearchResultsForParams(params);
        initStatus = false;
      } else {
        loading = false;
      }

      buildSearchPage();
      getElements();
      updateFacet();
      bindSearchPageEvents();
    });
  }

  function dupGetSearchResultsForParams(params) {
    if (pageType != 'false') {
      params['fq_pagetype'] = pageType;
    }

    getSearchResults(params);
  } // Because top match products are not returned as unique object they must be filtered out:
  // If statements execute left to right, current format may not be best computational order but given the speed of virtual DOM rendering this should not be noticable to the user.
  // featuredProductCounter <= featureProductLimit: Has the featured product limit already been reached?
  // doc.pageType === pageTargets.product && property: Is result actually a product?
  // doc.score > featureProductRelevanceFloor: Prevents elaborate display of low match products when few results


  function featuredProductsCheck(searchResults) {
    var target = pageTargets.product;
    var relevanceFloor = featuredProductRelevanceFloor;
    var productLimit = featuredProductLimit;
    var products = [];
    var productCounter = 0; // Counter is related to default value of start because start is modified the value is set here.

    var counterLimit = searchResults.length < 20 ? searchResults.length - 1 : 19;

    for (var counter = 0; counter < counterLimit; counter++) {
      if (searchResults[counter].doclist) {
        searchResults[counter].doclist.forEach(function (doc) {
          if (productCounter < productLimit && doc.pageType === target && doc.score > relevanceFloor) {
            // If max products allowed break early
            productCounter += 1;
            products.push(doc);
          }
        });
      } // If max products is not acheived early


      if (products.length == productLimit) {
        return products;
      }
    }
  }

  function loadMoreResults() {
    var params = {
      brand: brand,
      locale: getLocale(),
      start: start,
      term: getProp('keyword'),
      ignoreSpellCheck: getProp('ignoreSpellCheck') != undefined ? getProp('ignoreSpellCheck') : 'false',
      fq_pagetype: pageType != 'false' ? pageType : undefined
    };

    if (selectedFacets.length > 0) {
      params = buildRefinedParams(params);
    }

    checkJsonApi(true);
    lib_axios.get(api, {
      params: params,
      paramsSerializer: function paramsSerializer(params) {
        return qs_lib_default().stringify(params, {
          arrayFormat: 'repeat'
        });
      }
    }).then(function (response) {
      var moreResults = response.data.grouped.pdhInternalNamesGroup.groups;

      for (var key in moreResults) {
        searchResults.push(moreResults[key]);
      }
    }).catch(function (error) {
      console.log(error);
      errored = true;
    }).finally(function () {
      start += 20;
      loading = false;
      loadMoreSearchList();
      isloadMore = false;
    });
  }

  function loadMoreSearchList() {
    var searchHtml = updateSearchResult();
    var moreHtml = updateLoadMore();

    if (search_List) {
      search_List.querySelector('.search-items').innerHTML = searchHtml; //search_List.insertAdjacentHTML('afterend', moreHtml);

      if (start > matchResults) {
        search_List.querySelector('.load-more-button').remove();
      }
    }

    getElements();
  }

  function refineSearchResults() {
    // resets start on facet select
    start = 20;
    var params = {
      brand: brand,
      locale: getLocale(),
      term: getProp('keyword'),
      ignoreSpellCheck: getProp('ignoreSpellCheck') != undefined ? getProp('ignoreSpellCheck') : 'false'
    };
    setProp('pagetype', pageType);

    if (pageType != 'false') {
      params['fq_pagetype'] = pageType;
    }

    if (selectedFacets.length > 0) {
      params = buildRefinedParams(params);
    }

    getSearchResults(params);
  }

  function buildRefinedParams(initialParams) {
    var refinedParams = initialParams;
    selectedFacets.forEach(function (facet) {
      var exportString = 'fq_' + facet.facetField.toLowerCase();
      var exportValue = facet.facet; //alert(initialParams[exportString]);

      if (initialParams[exportString]) {
        initialParams[exportString].push(exportValue); //alert("pushValue:"+ initialParams[exportString]);
      } else {
        initialParams[exportString] = [];
        initialParams[exportString].push(exportValue);
      } //initialParams[exportString] = facet.facet;

    });
    return refinedParams;
  }

  function clearFacets() {
    // Empties selected facets array
    selectedFacets.splice(0, selectedFacets.length);
    refineSearchResults();
  }

  function removeFacet(activeFacetUniqueId) {
    //document.getElementById['mobile-refinement' + activeFacetUniqueId][0].checked = false
    if (document.getElementById(['refinement' + activeFacetUniqueId][0])) {
      document.getElementById(['refinement' + activeFacetUniqueId][0]).checked = false;
    }

    selectedFacets.splice(selectedFacets.findIndex(function (facet) {
      return facet.uniqueId === activeFacetUniqueId;
    }), 1);
    refineSearchResults();
  }

  function clearSearchResults() {
    facetFields = null;
    facetPageType = null;
    keyMatches = [];
    searchTerm = null;
    spellcheck = null;
    spellcheckQ = null;
    searchResults = [];
    matchResults = null;
    allResults = null;
  }

  function selectCategories(pType) {
    if (!isAllPageWithoutResults()) {
      pageType = pType;
      activePageType = pType;
      searchPage.setAttribute('data-pageType', activePageType);
      clearFacets();
      console.log(activePageType);
    }
  }

  function getAbsoluteImagePath(imagePath) {
    //if (typeof(imagePath) != "undefined") {
    //  const path = "https://www.seagate.com"; 
    //let index = imagePath.indexOf('/www-content/');
    //if(index == 0){
    //  return (path + imagePath);
    //} else if (imagePath.indexOf('http') == 0) {
    //    return imagePath;
    //}
    return imagePath; //}
  }

  function imageCheck(doc) {
    return typeof doc.image != 'undefined';
  }

  function openFilter() {
    isOpen = true;
  }

  function closeFilter() {
    isOpen = false;
  }

  function hideMobile() {
    mobileRefinementsVisible = !mobileRefinementsVisible;
  }

  function facetGroupIsExpanded(key) {
    return displayedFacetGroups.indexOf(key) !== -1;
  }

  function toggleFacetGroups(key) {
    if (facetGroupIsExpanded(key)) {
      displayedFacetGroups.splice(displayedFacetGroups.indexOf(key), 1);
    } else {
      displayedFacetGroups.push(key);
    }
  }

  function inactiveFacetCheck(facetValue) {
    return facetValue === 0;
  }

  function toggleFacet(facetKey, facetField) {
    // Because the html is screen width responsive and both menus exist at all times this code updates the checkbox element for the filter in both menus at the same time. This is redundant, because it is repeating the user's command for the navigation the user is currently interacting with. While this doesn't affect performance this section can be DRYed up.
    var targetFacet = facetKey + facetField;
    var activeFacet = {
      facet: facetKey,
      facetField: facetField,
      uniqueId: targetFacet
    }; // Checkboxes interacting with checkboxes in other menu

    if (selectedFacets.filter(function (facet) {
      return facet.uniqueId === activeFacet.uniqueId;
    }).length === 0) {
      //document.getElementById['mobile-refinement' + targetFacet][0].checked = true
      if (document.getElementById(['refinement' + targetFacet][0])) {
        document.getElementById(['refinement' + targetFacet][0]).checked = true;
      }
    } else {
      // console.log(document.getElementById['mobile-refinement' + targetFilter])
      //document.getElementById['mobile-refinement' + targetFacet][0].checked = false
      if (document.getElementById(['refinement' + targetFacet][0])) {
        document.getElementById(['refinement' + targetFacet][0]).checked = false;
      }
    } // Display / remove filter in heading


    refinementSelectedInNavigation(activeFacet);
  }

  function refinementSelectedInNavigation(activeFacet) {
    if (selectedFacets.filter(function (facet) {
      return facet.uniqueId === activeFacet.uniqueId;
    }).length === 0) {
      // missing - adds it
      selectedFacets.push(activeFacet);
    } else {
      selectedFacets.splice(selectedFacets.findIndex(function (facet) {
        return facet.uniqueId === activeFacet.uniqueId;
      }), 1);
    }

    refineSearchResults();
  }

  function activeFacetsClearedMobile() {
    clearActiveFacets();
  }

  function clearActiveFacets() {
    var allFacets = document.getElementsByClassName('facet');

    for (var i = 0; i < allFacets.length; i++) {
      allFacets[i].checked = false;
    }
  }

  function activeFacetRemovedMobile(activeFacetUniqueId) {
    removeFacet(activeFacetUniqueId);
  }

  function updateFacet() {
    for (var i = 0; i < selectedFacets.length; i++) {
      var targetFacet = selectedFacets[i].uniqueId;

      if (document.getElementById(['refinement' + targetFacet][0])) {
        document.getElementById(['refinement' + targetFacet][0]).checked = true;
      }
    }
  }

  function getAbsoluteSubcategoryLinkPath(relativePath, parentURL) {
    var parser = document.createElement('a');
    parser.href = parentURL;
    return parser.protocol + "//" + parser.hostname + relativePath;
  }

  function selectType(doc) {
    var type = "";
    if (doc.pageType == "pdp") type = "product";else if (doc.pageType == "support" || doc.pageType == "support_eol") {
      if (doc.url.indexOf("/support/downloads/") != -1 || doc.url.indexOf("/support/software/") != -1) {
        type = "software-download";
      } else {
        type = "product";
      }
    } else if (doc.pageType == "knowledgebase") type = "knowledge-base";else if (doc.pageType == "product") type = "document";else if (doc.pageType == "press" || doc.pageType == "article") type = "article";else {
      if (doc.url.indexOf("/support/downloads/") != -1) {
        type = "software-download";
      } else {
        type = "general";
      }
    }
    return type;
  }

  function getIcon(pageType) {
    // Identifies icon filtering through object pageTargets
    var pageIcon = Object.keys(pageTargets).filter(function (pageTarget) {
      return pageTargets[pageTarget] === pageType;
    })[0];
    return pageIcon + 'Icon';
  }

  function imageCheck(doc) {
    return typeof doc.image != 'undefined';
  }

  function productCheck(doc) {
    return featuredProducts.filter(function (result) {
      return result.id === doc.id;
    }).length === 0 && (doc.pageType === 'pdp' || doc.pageType === 'support' || doc.pageType === 'support_eol');
  }

  function handleSubmit() {
    if (checkLocalhost()) {
      window.location.href = '/iframe.html?id=searchnew--default&keyword=nas&pagetype=support';
    } else {
      window.location.href = '/search/?keyword=' + encodeURIComponent(searchTerm);
    }
  }

  initSearch();
}

/* harmony default export */ var modules_SearchNew = (SearchNew);
;// CONCATENATED MODULE: ./stories/js/modules/WhereToBuy/index.js
//import CustomUtil from '../../utilities/CustomUtil';
function WhereToBuy() {
  console.log('WhereToBuy');
  var wtb = document.querySelector('.page--whereToBuy');

  if (wtb) {
    var tabs = wtb.querySelector('.wtb-tab-tabs');
    var tabsTriggers = wtb.querySelectorAll('.wtb-tab-trigger');
    /*let filters = wtb.querySelectorAll('.Form-group');
    let countrySelect = wtb.querySelector('.country-select');
    let isMobile = getComputedStyle(document.querySelector('.visible--mobile')).display == 'none' ? false : true;
    let text = wtb.querySelector('[for="country-options"]').innerHTML;
    if (!isMobile) {
      if (countrySelect.querySelector('option[value="' + text + '"]')) {
        countrySelect.selectedIndex = 0;
      }
    } else {
      if (!countrySelect.querySelector('option[value="' + text + '"]')) {
        let option = document.createElement('option');
        option.text = text;
        option.value = text;
        countrySelect.appendChild(option);
      }
      countrySelect.value = text;
    }*/

    tabsTriggers.forEach(function (trigger, index) {
      trigger.addEventListener('click', function (e) {
        //var trigger = e.currentTarget;
        if (trigger.dataset.rel == "lacie") {
          tabs.classList.add('slide');
        } else {
          tabs.classList.remove('slide');
        }

        removeElseClass(tabsTriggers, index, 'active');
        trigger.classList.add("active");
      });
    });
    window.addEventListener('load', function (e) {//CustomUtil.setSameBoxElementHeight('.page--whereToBuy', '.wtb-results-card');
    });
    window.addEventListener('resize', function (e) {//CustomUtil.setSameBoxElementHeight('.page--whereToBuy', '.wtb-results-card');
    });

    var removeElseClass = function removeElseClass(ele, index, cla) {
      var array_eles = Array.from(ele);
      var other_eles = array_eles.filter(function (el) {
        return array_eles.indexOf(el) != index;
      });
      other_eles.map(function (ee) {
        ee.classList.remove(cla);
      });
    };
    /*let bindFilters = () => {
      filters.forEach((filter, i) => {
        filter.querySelector('.Form-label').addEventListener('click', (e) => {
          isMobile = getComputedStyle(document.querySelector('.visible--mobile')).display == 'none' ? false : true;
          if (isMobile) {
            if (!filter.classList.contains('open')) {
              filters.forEach((f, i) => {
                f.classList.remove('open');
              });
              filter.classList.add('open');
            } else {
              filter.classList.remove('open');
            }
          }
        });
      });
    };*/
    //bindFilters();

  }
}

/* harmony default export */ var modules_WhereToBuy = (WhereToBuy);
;// CONCATENATED MODULE: ./stories/assets/json/price.json
var price_namespaceObject = JSON.parse('{"p":{"rx":[{"brand":"seagate","prodchildname_en":"Boba Fett Drive","ecomm_enabled":false,"modelNumber":"STKL2000406","skuName_en":"Boba Fett Special Edition FireCuda External Hard Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/boba-fett/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/boba-fett/?sku=STKL2000406","drProductID":""},{"brand":"seagate","prodchildname_en":"firecuda-520-ssd-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"ZP1000GM30012","skuName_en":"FireCuda 520 SSD Cyberpunk 2077 Limited Edition 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/?sku=ZP1000GM30012","drProductID":""},{"brand":"seagate","prodchildname_en":"FireCuda 520 Cyberpunk 2077 Limited Edition","ecomm_enabled":false,"modelNumber":"ZP1000GM30013000","skuName_en":"FireCuda 520 SSD Cyberpunk 2077 Limited Edition 2TB - AniDemo","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/?sku=ZP1000GM30013000","drProductID":""},{"brand":"seagate","prodchildname_en":"FireCuda 520 Cyberpunk 2077 Limited Edition","ecomm_enabled":false,"modelNumber":"ZP1000GM30014000","skuName_en":"FireCuda 520 SSD Cyberpunk 2077 Limited Edition 3TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/?sku=ZP1000GM30014000","drProductID":""},{"brand":"seagate","prodchildname_en":"FireCuda HDD","ecomm_enabled":false,"modelNumber":"ST8000DX001","skuName_en":"FireCuda HDD 8TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-hdd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-hdd/?sku=ST8000DX001","drProductID":""},{"brand":"seagate","prodchildname_en":"Game Drive HDD for PS4","ecomm_enabled":false,"modelNumber":"STGD4000400","skuName_en":"Game Drive for PS4 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/playstation-gaming/game-drive-ps4/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/playstation-gaming/game-drive-ps4/?sku=STGD4000400","drProductID":""},{"brand":"seagate","prodchildname_en":"Exos AP 2U12 ","ecomm_enabled":false,"modelNumber":"exos-ap-2u12-storage-server","skuName_en":"Exos AP 2U12 Storage Server","pdpURL":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-2u12/","id":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-2u12/?sku=exos-ap-2u12-storage-server","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST1000DM010","skuName_en":"BarraCuda 3.5\\" Hard Drive 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST1000DM010","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST2000DM008","skuName_en":"BarraCuda 3.5\\" Hard Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST2000DM008","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST8000DM004","skuName_en":"BarraCuda 3.5\\" Hard Drive 8TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST8000DM004","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST2000DM007","skuName_en":"BarraCuda Hard Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST2000DM007","drProductID":""},{"brand":"seagate","prodchildname_en":"Ultra Touch HDD","ecomm_enabled":true,"modelNumber":"STMA5000400","skuName_en":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA5000400","drProductID":"","ecomm_regular_price":250,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":250},{"brand":"seagate","prodchildname_en":"Han Solo Drive","ecomm_enabled":true,"modelNumber":"STKL2000413","skuName_en":"Han Solo<sup>&trade;</sup> Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/han-solo/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/han-solo/?sku=STKL2000413","drProductID":"","ecomm_regular_price":0.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":0.99},{"brand":"seagate","prodchildname_en":"Darth Vader Drive","ecomm_enabled":true,"modelNumber":"STKL2000411","skuName_en":"Darth Vader<sup>&trade;</sup> Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/darth-vader/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/darth-vader/?sku=STKL2000411","drProductID":"","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_en":"Lyve Mobile Mount","ecomm_enabled":false,"modelNumber":"3EYAP1-RA2 STKU400","skuName_en":"Lyve Mobile Mount","pdpURL":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/","id":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/?sku=3EYAP1-RA2 STKU400","drProductID":""},{"brand":"seagate","prodchildname_en":"Lyve Mobile Mount","ecomm_enabled":false,"modelNumber":"3EYAP1-RA1 STKU400","skuName_en":"Lyve Mobile Mount","pdpURL":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/","id":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/?sku=3EYAP1-RA1 STKU400","drProductID":""},{"brand":"seagate","prodchildname_en":"storage-expansion-for-xbox-series-x-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"STJR1000400","skuName_en":"Seagate Storage Expansion Card for Xbox Series X|S 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/?sku=STJR1000400","drProductID":""},{"brand":"seagate","prodchildname_en":"storage-expansion-for-xbox-series-x-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"STJR2000400","skuName_en":"Seagate Storage Expansion Card for Xbox Series X|S 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/?sku=STJR2000400","drProductID":""},{"brand":"seagate","prodchildname_en":"FireCuda 520N SSD","ecomm_enabled":false,"modelNumber":"ZP1024GV3A002","skuName_en":"FireCuda 520N 1024GB ","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/?sku=ZP1024GV3A002","drProductID":"JL1900"},{"brand":"lacie","prodchildname_en":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS20000800","skuName_en":"1big Dock HDD 20TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS20000800","drProductID":""},{"brand":"lacie","prodchildname_en":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS24000800","skuName_en":"1big Dock HDD 24TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS24000800","drProductID":""},{"brand":"seagate","prodchildname_en":"Okoye Special Edition FireCuda External Hard Drive","ecomm_enabled":false,"modelNumber":"STLX2000403","skuName_en":"Okoye Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/okoye/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/okoye/?sku=STLX2000403","drProductID":""},{"brand":"seagate","prodchildname_en":"King of Wakanda Hard Drive","ecomm_enabled":false,"modelNumber":"STLX2000400","skuName_en":"King of Wakanda Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/king-of-wakanda/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/king-of-wakanda/?sku=STLX2000400","drProductID":""},{"brand":"seagate","prodchildname_en":"Black Panther Drive","ecomm_enabled":false,"modelNumber":"STLX2000401","skuName_en":"Black Panther Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/black-panther/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/black-panther/?sku=STLX2000401","drProductID":""},{"brand":"seagate","prodchildname_en":"firecuda-520-ssd-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"ZP1000GM30002","skuName_en":"FireCuda 520 SSD 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/?sku=ZP1000GM30002","drProductID":""},{"brand":"seagate","prodchildname_en":"firecuda-520-ssd-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"ZP2000GM30002","skuName_en":"FireCuda 520 SSD 500GB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/?sku=ZP2000GM30002","drProductID":""},{"brand":"seagate","prodchildname_en":"firecuda-520-ssd-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"ZP500GM30002","skuName_en":"FireCuda 520 SSD 500GB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/?sku=ZP500GM30002","drProductID":""},{"brand":"seagate","prodchildname_en":"FireCuda 520 Cyberpunk 2077 Limited Edition","ecomm_enabled":false,"modelNumber":"ZP1000GM30012","skuName_en":"FireCuda 520 SSD Cyberpunk 2077 Limited Edition 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/?sku=ZP1000GM30012","drProductID":""},{"brand":"seagate","prodchildname_en":"FireCuda HDD","ecomm_enabled":false,"modelNumber":"ST4000DX005","skuName_en":"FireCuda HDD 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-hdd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-hdd/?sku=ST4000DX005","drProductID":""},{"brand":"seagate","prodchildname_en":"Exos AP 5U84","ecomm_enabled":false,"modelNumber":"exos-ap-5u84-sku-master","skuName_en":"Exos AP 5U84","pdpURL":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-5u84/","id":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-5u84/?sku=exos-ap-5u84-sku-master","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST2000DM005","skuName_en":"BarraCuda 3.5\\" Hard Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST2000DM005","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST3000DM007","skuName_en":"BarraCuda 3.5\\" Hard Drive 3TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST3000DM007","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST4000DM004","skuName_en":"BarraCuda 3.5\\" Hard Drive 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST4000DM004","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST500DM009","skuName_en":"BarraCuda 3.5\\" Hard Drive 500GB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST500DM009","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST6000DM003","skuName_en":"BarraCuda 3.5\\" Hard Drive 6TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST6000DM003","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST1000DM004","skuName_en":"Desktop SATA HDD SED 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST1000DM004","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST4000LM024","skuName_en":"BarraCuda 2.5\\" Hard Drive 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST4000LM024","drProductID":""},{"brand":"seagate","prodchildname_en":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST5000LM000","skuName_en":"BarraCuda 2.5\\" Hard Drive 5TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST5000LM000","drProductID":""},{"brand":"seagate","prodchildname_en":"Ultra Touch HDD","ecomm_enabled":false,"modelNumber":"STHH1000400","skuName_en":"Ultra Touch HDD 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STHH1000400","drProductID":""},{"brand":"seagate","prodchildname_en":"Ultra Touch HDD","ecomm_enabled":true,"modelNumber":"STMA2000400","skuName_en":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA2000400","drProductID":"","ecomm_regular_price":149.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":149.99},{"brand":"seagate","prodchildname_en":"Ultra Touch HDD","ecomm_enabled":false,"modelNumber":"STMA4000400","skuName_en":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA4000400","drProductID":""},{"brand":"seagate","prodchildname_en":"Ultra Touch HDD","ecomm_enabled":false,"modelNumber":"STMA6000400","skuName_en":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA6000400","drProductID":""},{"brand":"seagate","prodchildname_en":"lyve-mobile-rackmount-receiver-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"lyve-mobile-rackmount-receiver-content-layout-product-detail-master-sku","skuName_en":"Lyve Mobile Rackmount Receiver","pdpURL":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-rackmount-receiver/","id":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-rackmount-receiver/?sku=lyve-mobile-rackmount-receiver-content-layout-product-detail-master-sku","drProductID":""},{"brand":"seagate","prodchildname_en":"storage-expansion-for-xbox-series-x-content-layout-product-detail-master-prod","ecomm_enabled":true,"modelNumber":"STJR512400","skuName_en":"Seagate Storage Expansion Card for Xbox Series X|S 512GB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/?sku=STJR512400","drProductID":"","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"OUT_OF_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_en":"FireCuda 520N SSD","ecomm_enabled":false,"modelNumber":"ZP2048GV3A002","skuName_en":"FireCuda 520N 2048GB ","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/?sku=ZP2048GV3A002","drProductID":"JL1854"},{"brand":"seagate","prodchildname_en":"Photo Drive","ecomm_enabled":false,"modelNumber":"STJS2000401","skuName_en":"Photo Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/?sku=STJS2000401","drProductID":"HSTEST12356"},{"brand":"seagate","prodchildname_en":"Photo Drive","ecomm_enabled":false,"modelNumber":"STJS2000402_Ani","skuName_en":"Photo Drive 5TB","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/?sku=STJS2000402_Ani","drProductID":""},{"brand":"lacie","prodchildname_en":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS10000800","skuName_en":"1big Dock HDD 10TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS10000800","drProductID":""},{"brand":"lacie","prodchildname_en":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS16000800","skuName_en":"1big Dock HDD 16TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS16000800","drProductID":""},{"brand":"lacie","prodchildname_en":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS18000800","skuName_en":"1big Dock HDD 18TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS18000800","drProductID":""},{"brand":"lacie","prodchildname_en":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS4000800","skuName_en":"1big Dock HDD 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS4000800","drProductID":""},{"brand":"lacie","prodchildname_en":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS8000800","skuName_en":"1big Dock HDD 8TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS8000800","drProductID":""}]}}');
;// CONCATENATED MODULE: ./stories/assets/json/price2.json
var price2_namespaceObject = JSON.parse('{"p":{"rx":[{"brand":"seagate","prodchildname_fr":"Exos AP 2U12 ","ecomm_enabled":false,"modelNumber":"exos-ap-2u12-storage-server","skuName_fr":"Exos AP 2U12 Storage Server","pdpURL":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-2u12/","id":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-2u12/?sku=exos-ap-2u12-storage-server"},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":true,"modelNumber":"ST1000DM010","skuName_fr":"BarraCuda 3.5\\" Hard Drive 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST1000DM010","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":true,"modelNumber":"ST8000DM004","skuName_fr":"BarraCuda 3.5\\" Hard Drive 8TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST8000DM004","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST2000DM007","skuName_fr":"BarraCuda Hard Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST2000DM007"},{"brand":"seagate","prodchildname_fr":"Ultra Touch HDD","ecomm_enabled":true,"modelNumber":"STMA5000400","skuName_fr":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA5000400","ecomm_regular_price":250,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":250},{"brand":"seagate","prodchildname_fr":"Han Solo Drive","ecomm_enabled":true,"modelNumber":"STKL2000413","skuName_fr":"Han Solo<sup>&trade;</sup> Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/han-solo/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/han-solo/?sku=STKL2000413","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"Darth Vader Drive","ecomm_enabled":true,"modelNumber":"STKL2000411","skuName_fr":"Darth Vader<sup>&trade;</sup> Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/darth-vader/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/darth-vader/?sku=STKL2000411","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"Lyve Mobile Mount","ecomm_enabled":false,"modelNumber":"3EYAP1-RA2 STKU400","skuName_fr":"Lyve Mobile Mount","pdpURL":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/","id":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/?sku=3EYAP1-RA2 STKU400"},{"brand":"seagate","prodchildname_fr":"Lyve Mobile Mount","ecomm_enabled":false,"modelNumber":"3EYAP1-RA1 STKU400","skuName_fr":"Lyve Mobile Mount","pdpURL":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/","id":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-mount/?sku=3EYAP1-RA1 STKU400"},{"brand":"seagate","prodchildname_fr":"storage-expansion-for-xbox-series-x-content-layout-product-detail-master-prod","ecomm_enabled":true,"modelNumber":"STJR1000400","skuName_fr":"Seagate Storage Expansion Card for Xbox Series X|S 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/?sku=STJR1000400","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"storage-expansion-for-xbox-series-x-content-layout-product-detail-master-prod","ecomm_enabled":true,"modelNumber":"STJR2000400","skuName_fr":"Seagate Storage Expansion Card for Xbox Series X|S 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/?sku=STJR2000400","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"FireCuda 520N SSD","ecomm_enabled":false,"modelNumber":"ZP1024GV3A002","skuName_fr":"FireCuda 520N 1024GB ","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/?sku=ZP1024GV3A002"},{"brand":"lacie","prodchildname_fr":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS20000800","skuName_fr":"1big Dock HDD 20TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS20000800"},{"brand":"lacie","prodchildname_fr":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS24000800","skuName_fr":"1big Dock HDD 24TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS24000800"},{"brand":"seagate","prodchildname_fr":"Okoye Special Edition FireCuda External Hard Drive","ecomm_enabled":false,"modelNumber":"STLX2000403","skuName_fr":"Okoye Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/okoye/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/okoye/?sku=STLX2000403"},{"brand":"seagate","prodchildname_fr":"King of Wakanda Hard Drive","ecomm_enabled":false,"modelNumber":"STLX2000400","skuName_fr":"King of Wakanda Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/king-of-wakanda/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/king-of-wakanda/?sku=STLX2000400"},{"brand":"seagate","prodchildname_fr":"Black Panther Drive","ecomm_enabled":false,"modelNumber":"STLX2000401","skuName_fr":"Black Panther Special Edition FireCuda External Hard Drive","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/black-panther/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/special-editions/black-panther/?sku=STLX2000401"},{"brand":"seagate","prodchildname_fr":"firecuda-520-ssd-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"ZP1000GM30002","skuName_fr":"FireCuda 520 SSD 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/?sku=ZP1000GM30002"},{"brand":"seagate","prodchildname_fr":"firecuda-520-ssd-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"ZP2000GM30002","skuName_fr":"FireCuda 520 SSD 500GB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/?sku=ZP2000GM30002"},{"brand":"seagate","prodchildname_fr":"firecuda-520-ssd-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"ZP500GM30002","skuName_fr":"FireCuda 520 SSD 500GB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-ssd/?sku=ZP500GM30002"},{"brand":"seagate","prodchildname_fr":"FireCuda 520 Cyberpunk 2077 Limited Edition","ecomm_enabled":true,"modelNumber":"ZP1000GM30012","skuName_fr":"FireCuda 520 SSD Cyberpunk 2077 Limited Edition 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520-cyberpunk-2077-ssd/?sku=ZP1000GM30012","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"FireCuda HDD","ecomm_enabled":true,"modelNumber":"ST4000DX005","skuName_fr":"FireCuda HDD 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-hdd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-hdd/?sku=ST4000DX005","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"Exos AP 5U84","ecomm_enabled":false,"modelNumber":"exos-ap-5u84-sku-master","skuName_fr":"Exos AP 5U84","pdpURL":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-5u84/","id":"https://wwwdevaem.seagate.com/products/storage/data-storage-systems/application-platforms/exos-ap-5u84/?sku=exos-ap-5u84-sku-master"},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":true,"modelNumber":"ST2000DM005","skuName_fr":"BarraCuda 3.5\\" Hard Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST2000DM005","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":true,"modelNumber":"ST3000DM007","skuName_fr":"BarraCuda 3.5\\" Hard Drive 3TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST3000DM007","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":true,"modelNumber":"ST4000DM004","skuName_fr":"BarraCuda 3.5\\" Hard Drive 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST4000DM004","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":true,"modelNumber":"ST500DM009","skuName_fr":"BarraCuda 3.5\\" Hard Drive 500GB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST500DM009","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":true,"modelNumber":"ST6000DM003","skuName_fr":"BarraCuda 3.5\\" Hard Drive 6TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST6000DM003","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST1000DM004","skuName_fr":"Desktop SATA HDD SED 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST1000DM004"},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST4000LM024","skuName_fr":"BarraCuda 2.5\\" Hard Drive 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST4000LM024"},{"brand":"seagate","prodchildname_fr":"BarraCuda 3.5","ecomm_enabled":false,"modelNumber":"ST5000LM000","skuName_fr":"BarraCuda 2.5\\" Hard Drive 5TB","pdpURL":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/","id":"https://wwwdevaem.seagate.com/products/hard-drives/barracuda-hard-drives/?sku=ST5000LM000"},{"brand":"seagate","prodchildname_fr":"Ultra Touch HDD","ecomm_enabled":true,"modelNumber":"STHH1000400","skuName_fr":"Ultra Touch HDD 1TB","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STHH1000400","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"Ultra Touch HDD","ecomm_enabled":true,"modelNumber":"STMA2000400","skuName_fr":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA2000400","ecomm_regular_price":149.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":149.99},{"brand":"seagate","prodchildname_fr":"Ultra Touch HDD","ecomm_enabled":true,"modelNumber":"STMA4000400","skuName_fr":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA4000400","ecomm_regular_price":149.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":149.99},{"brand":"seagate","prodchildname_fr":"Ultra Touch HDD","ecomm_enabled":true,"modelNumber":"STMA6000400","skuName_fr":"Ultra Touch HDD","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/ultra-touch-external-drives/?sku=STMA6000400","ecomm_regular_price":1299.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"IN_STOCK","ecomm_final_price":1299.99},{"brand":"seagate","prodchildname_fr":"lyve-mobile-rackmount-receiver-content-layout-product-detail-master-prod","ecomm_enabled":false,"modelNumber":"lyve-mobile-rackmount-receiver-content-layout-product-detail-master-sku","skuName_fr":"Lyve Mobile Rackmount Receiver","pdpURL":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-rackmount-receiver/","id":"https://wwwdevaem.seagate.com/products/data-transport/lyve-mobile-rackmount-receiver/?sku=lyve-mobile-rackmount-receiver-content-layout-product-detail-master-sku"},{"brand":"seagate","prodchildname_fr":"storage-expansion-for-xbox-series-x-content-layout-product-detail-master-prod","ecomm_enabled":true,"modelNumber":"STJR512400","skuName_fr":"Seagate Storage Expansion Card for Xbox Series X|S 512GB","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/xbox-gaming/storage-expansion-for-xbox-series-x/?sku=STJR512400","ecomm_regular_price":109.99,"ecomm_currency":"$","ecomm_currency_code":"USD","ecomm_stock_status":"OUT_OF_STOCK","ecomm_final_price":109.99},{"brand":"seagate","prodchildname_fr":"FireCuda 520N SSD","ecomm_enabled":false,"modelNumber":"ZP2048GV3A002","skuName_fr":"FireCuda 520N 2048GB ","pdpURL":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/","id":"https://wwwdevaem.seagate.com/products/gaming-drives/pc-gaming/firecuda-520n-ssd/?sku=ZP2048GV3A002"},{"brand":"seagate","prodchildname_fr":"Photo Drive","ecomm_enabled":false,"modelNumber":"STJS2000401","skuName_fr":"Photo Drive 2TB","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/?sku=STJS2000401"},{"brand":"seagate","prodchildname_fr":"Photo Drive","ecomm_enabled":false,"modelNumber":"STJS2000402_Ani","skuName_fr":"Photo Drive 5TB","pdpURL":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/","id":"https://wwwdevaem.seagate.com/products/external-hard-drives/photo-drive/?sku=STJS2000402_Ani"},{"brand":"lacie","prodchildname_fr":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS10000800","skuName_fr":"1big Dock HDD 10TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS10000800"},{"brand":"lacie","prodchildname_fr":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS16000800","skuName_fr":"1big Dock HDD 16TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS16000800"},{"brand":"lacie","prodchildname_fr":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS18000800","skuName_fr":"1big Dock HDD 18TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS18000800"},{"brand":"lacie","prodchildname_fr":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS4000800","skuName_fr":"1big Dock HDD 4TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS4000800"},{"brand":"lacie","prodchildname_fr":"LaCie 1big Dock","ecomm_enabled":false,"modelNumber":"STHS8000800","skuName_fr":"1big Dock HDD 8TB","pdpURL":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/","id":"https://wwwdevaem.seagate.com/products/creative-pro/lacie-1big-dock/?sku=STHS8000800"}]}}');
;// CONCATENATED MODULE: ./stories/js/modules/AemPricingUpdate/index.js
function AemPricingUpdate_toConsumableArray(arr) { return AemPricingUpdate_arrayWithoutHoles(arr) || AemPricingUpdate_iterableToArray(arr) || AemPricingUpdate_unsupportedIterableToArray(arr) || AemPricingUpdate_nonIterableSpread(); }

function AemPricingUpdate_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function AemPricingUpdate_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AemPricingUpdate_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AemPricingUpdate_arrayLikeToArray(o, minLen); }

function AemPricingUpdate_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function AemPricingUpdate_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AemPricingUpdate_arrayLikeToArray(arr); }

function AemPricingUpdate_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




function AemPricingUpdate() {
  var pricingUpdate = document.querySelector('.AemPricingUpdate');
  var locale;
  var loc;
  var seaLocale;
  var storeCode;
  var priceData;
  var finalPriceArray = [];
  var isUpdated = false;
  var updatedSkus = [];
  if (!pricingUpdate) return;

  if (typeof eCommerceConfig != "undefined") {
    locale = eCommerceConfig.pageLocale.replace('_', '-');
  } else {
    locale = 'en-us';
  }

  var puHeader = pricingUpdate.querySelector('.pu-header');
  var puView = pricingUpdate.querySelector('.pu-columnview');
  var puLocaleSelector = pricingUpdate.querySelector('.pu-hu-locale-selector');
  var puAlertError = pricingUpdate.querySelector('.pu-alert.alert-error');
  var puAlertSuccess = pricingUpdate.querySelector('.pu-alert.alert-success');
  var productColumn = pricingUpdate.querySelector('[data-pu-column-type="product"]');
  var skuColumn = pricingUpdate.querySelector('[data-pu-column-type="sku"]');
  if (!productColumn || !skuColumn) return;
  var productTable = productColumn.querySelector('table');
  var skuTables = skuColumn.querySelectorAll('table');
  if (!productTable || skuTables.length === 0) return;
  var puSearch = pricingUpdate.querySelector('.pu-header-search');
  var puSearchInput = puSearch.querySelector('.search-input-keyword');
  var puSearchList = puSearch.querySelector('.search-list');
  var isLocalhost = document.domain == 'localhost' && document.location.pathname == '/iframe.html';

  var updateLocale = function updateLocale(locale) {
    loc = locale.split('-')[0];
    seaLocale = locale.replace('-', '_');
    storeCode = locale == 'en-us' ? locale.split('-')[1] : locale.split('-')[1] + '_' + locale.split('-')[0];
  };

  var getData = function getData(locale) {
    updateLocale(locale);

    if (isLocalhost) {
      if (locale != 'en-us') {
        priceData = price2_namespaceObject.p.rx;
      } else {
        priceData = price_namespaceObject.p.rx;
      }

      initPriceData();
    } else {
      puView.classList.add('loading');
      callData();
    }
  };

  var callData = function callData() {
    var url = '/ww/solrQueryResponseRetrieval';
    var formGetData = new FormData();
    formGetData.append("collection", 'product');
    formGetData.append("omitHeader", 'true');
    formGetData.append("indent", 'true');
    formGetData.append("q", '*');
    formGetData.append("fq", 'seaLocale:' + seaLocale);
    formGetData.append("fq", 'brand:(seagate OR lacie)');
    formGetData.append("fq", 'showOnProductFinder:true');
    formGetData.append("rows", '10000');
    var flString = 'brand,prodchildname_' + loc + ',skuName_' + loc + ',id,modelNumber,pdpURL,ecomm_enabled,ecomm_regular_price,ecomm_currency,ecomm_currency_code,ecomm_stock_status,ecomm_final_price,drProductID';
    formGetData.append("f1", flString);
    fetch(url, {
      method: "POST",
      body: formGetData
    }).then(function (response) {
      //console.log(response);
      return response.json();
    }).then(function (data) {
      //console.log(data);
      puView.classList.remove('loading');
      priceData = data.response.docs;
      initPriceData();

      if (isUpdated) {//showUpdatedPriceTable();
      }
    }).catch(function (error) {
      console.log(error);
    });
  };

  var initPriceData = function initPriceData() {
    var prodResult = [];
    priceData.map(function (x) {
      return x['prodchildname_' + loc];
    }).filter(function (value) {
      var isDuplicate = prodResult.includes(value);

      if (!isDuplicate) {
        prodResult.push(value);
        return true;
      }

      return false;
    }); //console.log(prodResult);

    prodResult.forEach(function (p) {
      var v = {};
      v['prodchildname_' + loc] = p;
      v['skus'] = [];
      finalPriceArray.push(v);
    });
    finalPriceArray.forEach(function (r, index) {
      priceData.filter(function (value) {
        if (value['prodchildname_' + loc] == r['prodchildname_' + loc]) {
          r.skus.push(value);
        }
      });

      if (r.skus) {
        r['pdpURL'] = r.skus[0].pdpURL;
        var paths = r.skus[0].pdpURL.split("/");
        r['prodKey'] = paths.pop() || paths.pop();
      }
    });
    updateProdTableContent(); //console.log(finalPriceArray);
  };

  var updateProdCheckbox = function updateProdCheckbox(prodCheckbox, tag) {
    var skusCheckbox = skuColumn.querySelectorAll('tbody .checkbox-input');
    var prodRow = prodCheckbox.closest('tr');
    var skuTable = skuColumn.querySelector('.table-header-fixed');
    var prod = prodRow.dataset.puProductKey;

    if (!prod) {
      prod = skuTable.dataset.puProductParent;
      prodRow = productColumn.querySelector('[data-pu-product-key="' + prod + '"]');
    }

    var prodsCheckbox = AemPricingUpdate_toConsumableArray(productColumn.querySelectorAll('tr[data-pu-product-key]'));

    if (tag != 0 && tag != 1) {
      prodsCheckbox.filter(function (c) {
        return c.dataset.puProductKey != prod;
      }).map(function (s) {
        var checkbox = s.querySelector('.pu-checkbox-input');
        checkbox.checked = false;
      });
    }

    if (tag == 0) {
      prodCheckbox.checked = false;
    }

    if (prodCheckbox.checked) {
      skusCheckbox.forEach(function (c) {
        c.closest('tr').classList.remove('hide');

        if (!c.checked) {
          c.checked = true;
          c.closest('tr').setAttribute('data-state', 'checked');
        }
      });
    } else {
      skusCheckbox.forEach(function (c) {
        c.closest('tr').classList.remove('hide');

        if (c.checked) {
          c.checked = false;
          c.closest('tr').setAttribute('data-state', 'unchecked');
        }
      });
    }

    var skusState = checkStats();

    if (tag == 1) {
      skusState = 'unchecked';
    }

    updateProdState(prodRow, skuTable, skusState);
  };

  var updatePrice = function updatePrice(ele) {
    var updateSkus = [];

    if (ele.closest('tr[data-pu-product-key]')) {
      //when update product
      var checkedPro = ele.closest('tr[data-pu-product-key]');
      var checkedProKey = checkedPro.dataset.puProductKey;
      updateSkus = priceData.filter(function (cb) {
        return cb.pdpURL.indexOf(checkedProKey) != -1;
      });
    } else if (ele.closest('tr[data-id]')) {
      //when update sku
      var checkedSku = ele.closest('tr[data-id]');
      var checkedSkuKey = checkedSku.dataset.id;
      updateSkus = priceData.filter(function (cb) {
        return cb.modelNumber === checkedSkuKey;
      });
    } else {
      //when update button
      var skusCheckbox = AemPricingUpdate_toConsumableArray(skuColumn.querySelectorAll('tbody .checkbox-input'));

      var checkedSkus = skusCheckbox.filter(function (cb) {
        return cb.checked;
      }).map(function (x) {
        return x.closest('tr[data-id]').dataset.id;
      });
      checkedSkus.forEach(function (c) {
        priceData.forEach(function (p) {
          if (p.modelNumber === c) {
            updateSkus.push(p);
          }
        });
      });
    } //console.log('checkedSkus:' + updateSkus);


    updatedSkus = updateSkus;
    postDataToUpdate(updateSkus);
  };

  var postDataToUpdate = function postDataToUpdate(updateSkus) {
    var url = '/ww/pricing-update-tool';
    var formPostData = new FormData();
    var sku = '';
    var id = '';
    var pdpurl = '';
    updateSkus.forEach(function (s, index) {
      if (updateSkus.length == 1) {
        sku = s.modelNumber;
        id = s.id;
        pdpurl = s.pdpURL;
      } else {
        if (index != updateSkus.length - 1) {
          sku += s.modelNumber + '^';
          id += s.id + '^';
          pdpurl += s.pdpURL + '^';
        } else {
          sku += s.modelNumber;
          id += s.id;
          pdpurl += s.pdpURL;
        }
      }
    });
    formPostData.append("action", 'update');
    formPostData.append("sku", sku);
    formPostData.append("id", id);
    formPostData.append("pdpurl", pdpurl);
    formPostData.append("locale", seaLocale);
    formPostData.append("storeCode", storeCode);
    fetch(url, {
      method: "POST",
      body: formPostData
    }).then(function (response) {
      //console.log(response);
      return response.json();
    }).then(function (data) {
      //console.log(data);
      isUpdated = true;
      puAlertSuccess.style.display = 'flex';
      setTimeout(function () {
        puAlertSuccess.style.display = 'none';
        clearTable();
        getData(locale);
      }, 500); //location.reload();
    }).catch(function (error) {
      isUpdated = false;
      puAlertError.style.display = 'flex';
      console.log(error);
    });
  };

  var showUpdatedPriceTable = function showUpdatedPriceTable() {
    var paths = updatedSkus[0].pdpURL.split("/");
    var productKey = paths.pop() || paths.pop();
    var productRow = productColumn.querySelector('tr[data-pu-product-key="' + productKey + '"');
    productRow.click();
  };

  var checkStats = function checkStats() {
    var skusCheckbox = AemPricingUpdate_toConsumableArray(skuColumn.querySelectorAll('tbody .checkbox-input'));

    var skusState = skusCheckbox.every(function (cb) {
      return cb.checked;
    }) ? 'checked' : skusCheckbox.some(function (cb) {
      return cb.checked;
    }) ? 'indeterminate' : 'unchecked';
    var skusSelected = skusCheckbox.filter(function (cb) {
      return cb.checked;
    }).length;

    if (skusState !== 'unchecked') {
      puHeader.classList.remove('is-locale');
      puHeader.classList.add('is-update');
      puHeader.querySelector('.pu-update-count > i').innerHTML = skusSelected;
    } else {
      puHeader.classList.remove('is-update');
    }

    return skusState;
  };

  var clearStates = function clearStates(prodcheckbox, tag) {
    if (prodcheckbox) {
      updateProdCheckbox(prodcheckbox, tag);
    }
  };

  var updateProCheckboxState = function updateProCheckboxState() {
    var skusState = checkStats();
    var skuTable = skuColumn.querySelector('.table-header-fixed');
    var prod = skuTable.getAttribute('data-pu-product-parent');
    var prodRow = productColumn.querySelector('[data-pu-product-key="' + prod + '"]');
    updateProdState(prodRow, skuTable, skusState);
  };

  var updateProdState = function updateProdState(prodRow, skuTable, state) {
    if (prodRow && skuTable) {
      var proCheckbox = prodRow.querySelector('.pu-checkbox-input');
      var skuCheckbox = skuTable.querySelector('.pu-checkbox-input');

      if (state == 'unchecked') {
        proCheckbox.checked = false;
        skuCheckbox.checked = false;
      } else {
        proCheckbox.checked = true;
        skuCheckbox.checked = true;
      }

      prodRow.setAttribute('data-state', state);
      skuTable.setAttribute('data-state', state);
      prodRow.querySelector('.pu-checkbox').setAttribute('checked', state);
      skuTable.querySelector('.pu-checkbox').setAttribute('checked', state);
    }
  };

  var updateSkuCheckbox = function updateSkuCheckbox(checkbox) {
    var checked = checkbox.checked;

    if (checked) {
      checkbox.closest('tr').setAttribute('data-state', 'checked');
    } else {
      checkbox.closest('tr').setAttribute('data-state', 'unchecked');
    }

    updateProCheckboxState();
  };

  var updateCheckboxByType = function updateCheckboxByType(type) {
    var skus = AemPricingUpdate_toConsumableArray(skuColumn.querySelectorAll('tbody tr'));

    if (type != '') {
      var activeskus = skuColumn.querySelectorAll('tbody [data-pu-sku-type="' + type + '"]');
      activeskus.forEach(function (sku) {
        var checkbox = sku.querySelector('.checkbox-input');
        checkbox.checked = true;
        checkbox.closest('tr').setAttribute('data-state', 'checked');
        checkbox.closest('tr').classList.remove('hide');
      });
      skus.filter(function (c) {
        return c.dataset.puSkuType != type;
      }).map(function (s) {
        var checkbox = s.querySelector('.checkbox-input');
        checkbox.checked = false;
        checkbox.closest('tr').setAttribute('data-state', 'unchecked');
        checkbox.closest('tr').classList.add('hide');
      });
    } else {
      skus.map(function (s) {
        var checkbox = s.querySelector('.checkbox-input');
        checkbox.checked = true;
        checkbox.closest('tr').setAttribute('data-state', 'checked');
        checkbox.closest('tr').classList.remove('hide');
      });
    }

    updateProCheckboxState();
  };

  var updateTableFixedHeader = function updateTableFixedHeader() {
    var tables = pricingUpdate.querySelectorAll('table');
    var tableHeaderFixed = skuColumn.querySelector('.table-header-fixed');
    var tableHeaderStatic = skuColumn.querySelector('.table-sku:not(.table-header-fixed)');
    var tableHeaderFixedTDs = tableHeaderFixed.querySelectorAll('td');
    var tableHeaderStaticTDs = tableHeaderStatic.querySelectorAll('thead td');
    var tableStaticTRs = tableHeaderStatic.querySelectorAll('tr');
    tableHeaderStatic.style.width = '100%';
    tableHeaderStaticTDs.forEach(function (td) {
      //td.style.height = 'auto';
      td.style.width = 'auto';
    });
    var tableHeaderHeight = tableHeaderStatic.querySelector('thead') ? tableHeaderStatic.querySelector('thead').clientHeight : 48;
    tableHeaderStatic.style.marginTop = -tableHeaderHeight + 'px';
    tableHeaderStatic.closest('.sku-table-container').style.height = 'calc(100% - ' + tableHeaderHeight + 'px)';
    var tableHeaderStaticWidth = tableHeaderStatic.clientWidth + 'px';
    tableHeaderStatic.style.width = tableHeaderStaticWidth;
    tableHeaderFixed.style.width = tableHeaderStaticWidth;
    tableStaticTRs.forEach(function (tr, ind) {
      var td = tr.querySelectorAll('td');
      td.forEach(function (td, index) {
        var tdWidth = td.clientWidth + 'px';
        td.style.width = tdWidth;

        if (ind == 0) {
          tableHeaderFixedTDs[index].style.width = tdWidth;
        }
      });
    });
  };

  var checkUndefined = function checkUndefined(e) {
    if (e == null || e == undefined || e == '') {
      return '';
    } else {
      return e;
    }
  };

  var buildTableRow = function buildTableRow(item) {
    var html = '';
    var type = item.ecomm_enabled ? 'ecom' : 'non-ecom';
    var typeLabel = item.ecomm_enabled ? 'ecom' : '';
    html += '<tr data-pu-sku-type="' + type + '" data-id="' + item.modelNumber + '">';
    html += '      <td>';
    html += '        <div class="sku-checkbox">';
    html += '          <input type="checkbox" class="checkbox-input" id="' + item.modelNumber + '">';
    html += '          <span class="checkbox-span"><i></i></span>';
    html += '          <label class="checkbox-label" for="' + item.modelNumber + '"></label>';
    html += '        </div>';
    html += '      </td>';
    html += '      <td>';
    html += '      <div class="col-item">';
    html += '      <div class="sku-info">';
    html += '      <p class="sku-id">' + item.modelNumber + '</p>';
    html += '      <p class="sku-url" title="' + item.id + '">' + item.id + '</p>';
    html += '      </div>';
    html += '      <div class="sku-type"><span>' + typeLabel + '</span></div>';
    html += '      <div class="pu-update-price"><span></span>';
    html += '      </div>';
    html += '      </div>';
    html += '      </td>';
    html += '      <td>' + checkUndefined(item.drProductID) + '</td>';
    html += '      <td>' + checkUndefined(item.ecomm_stock_status) + '</td>';
    html += '      <td>' + checkUndefined(item.ecomm_currency) + '</td>';
    html += '      <td>' + checkUndefined(item.ecomm_regular_price) + '</td>';
    html += '      <td>' + checkUndefined(item.ecomm_final_price) + '</td>';
    html += '    </tr>';
    return html;
  };

  var updateSkuTableHeader = function updateSkuTableHeader(key) {
    var html = '';
    html += '<thead>';
    html += '  <tr>';
    html += '    <td>';
    html += '    <div>';
    html += '      <div class="pu-checkbox">';
    html += '        <input type="checkbox" class="pu-checkbox-input checkbox-input" id="puCheckboxID--sku-all">';
    html += '        <span class="checkbox-span"><i></i></span>';
    html += '        <label class="checkbox-label" for="puCheckboxID--sku-all"></label>';
    html += '      </div>';
    html += '      <div class="pu-custom-selection">';
    html += '        <div class="pu-cs-trigger"></div>';
    html += '        <div class="pu-cs-list">';
    html += '          <div data-pu-select-sku-type="ecom">Select only eCommerce SKUs</div>';
    html += '          <div data-pu-select-sku-type="non-ecom">Select only non-eCommerce SKUs</div>';
    html += '          <div data-pu-select-sku-type="">Select all SKUs</div>';
    html += '        </div>';
    html += '      </div>';
    html += '      </div>';
    html += '    </td>';
    html += '    <td>SKU &amp; SKU URL</td>';
    html += '    <td>Distributer Product Number</td>';
    html += '    <td>Stock Status</td>';
    html += '    <td>Currency</td>';
    html += '     <td>Regular Price</td>';
    html += '    <td>Final Price</td>';
    html += '  </tr>';
    html += '</thead>';
    return html;
  };

  var updateSkuTableContent = function updateSkuTableContent(key) {
    var priceTable = skuColumn.querySelector('.table-sku:not(.table-header-fixed)');
    priceTable.innerHTML = '';
    var html = '';
    html += updateSkuTableHeader(key);
    html += '<tbody>';
    finalPriceArray.forEach(function (item) {
      if (item.prodKey == key) {
        if (item.skus) {
          item.skus.forEach(function (iitem) {
            html += buildTableRow(iitem);
          });
        }
      }
    });
    html += '</tbody>';
    priceTable.innerHTML = html;
    priceTable.dataset.puProductParent = key;
  };

  var updateProdTableContent = function updateProdTableContent() {
    var ProdTable = productColumn.querySelector('table tbody');
    ProdTable.innerHTML = '';
    var html = '';
    finalPriceArray.forEach(function (item) {
      var count = item.skus ? item.skus.filter(function (s) {
        return s.ecomm_enabled == true;
      }).length : '';
      if (count == 0) count = '';
      var name = item['prodchildname_' + loc];
      html += '<tr data-pu-product-key="' + item.prodKey + '">';
      html += '<td>';
      html += '<div class="pu-checkbox">';
      html += '<input type="checkbox" class="pu-checkbox-input checkbox-input" id="' + item.prodKey + '">';
      html += '<span class="checkbox-span"><i></i></span>';
      html += '<label class="checkbox-label" for="' + item.prodKey + '"></label>';
      html += '</div>';
      html += '</td>';
      html += '<td>';
      html += '<div class="col-item">';
      html += '<div class="product-info">';
      html += '<p class="product-id" title="' + name + '">' + name + '</p>';
      html += '<p class="product-url" title="' + item.pdpURL + '">' + item.pdpURL + '</p>';
      html += '</div>';
      html += '<div class="product-count">';
      html += '<span>' + count + '</span>';
      html += '</div>';
      html += '<div class="pu-update-price"><span></span></div>';
      html += '</div>';
      html += '</td>';
      html += '</tr>';
    });
    ProdTable.innerHTML = html;
  };

  var focusProductRow = function focusProductRow(productRow) {
    var productRows = AemPricingUpdate_toConsumableArray(productColumn.querySelectorAll('tr[data-pu-product-key]'));

    var productKey = productRow.dataset.puProductKey;
    productRow.classList.remove('unfocus');
    productRow.classList.add('focus');
    productRows.filter(function (c) {
      return c.dataset.puProductKey != productKey;
    }).map(function (s) {
      s.classList.remove('focus');
      s.classList.remove('unfocus');
    });
  };

  var focusSkuRow = function focusSkuRow(skuRow) {
    var skuRows = AemPricingUpdate_toConsumableArray(skuColumn.querySelectorAll('tbody tr'));

    if (!skuRow) {
      skuRows.each(function (s) {
        s.classList.remove('focus');
        s.classList.remove('unfocus');
      });
    } else {
      var skuID = skuRow.dataset.id;
      skuRow.classList.remove('unfocus');
      skuRow.classList.add('focus');
      skuRows.filter(function (c) {
        return c.dataset.id != skuID;
      }).map(function (s) {
        s.classList.remove('focus');
        s.classList.remove('unfocus');
      });
    }
  };

  var getCheckedProductRow = function getCheckedProductRow() {
    var prodRow = productColumn.querySelector('[data-state="checked"]') || productColumn.querySelector('[data-state="indeterminate"]');

    if (prodRow) {
      var prodcheckbox = prodRow.querySelector('.pu-checkbox-input');
      return prodcheckbox;
    } else {
      return null;
    }
  };

  var bindEvents = function bindEvents() {
    pricingUpdate.addEventListener('click', function (e) {
      e.stopPropagation();
      var target = e.target;
      var skuTable = skuColumn.querySelector('.table-header-fixed');
      var productKey = skuTable.dataset.puProductParent;
      var isClickProRow = e.target.closest('tr[data-pu-product-key]');
      var isClickSkuRow = e.target.closest('tr[data-id]');
      var activeProRow = productColumn.querySelector('tr[data-pu-product-key="' + productKey + '"]');
      var activeSkuRow = skuColumn.querySelector('tr.focus');

      if (isClickProRow) {
        if (isClickProRow != activeProRow) {
          clearStates(getCheckedProductRow(), 1);
          var ProRow = e.target.closest('tr[data-pu-product-key]');
          var productKey = ProRow.dataset.puProductKey;
          skuTable.dataset.puProductParent = productKey;
          updateSkuTableContent(productKey);
          puHeader.classList.remove('is-update');
        }

        focusProductRow(isClickProRow);
      } else {
        if (activeProRow) {
          activeProRow.classList.remove('focus');
          activeProRow.classList.add('unfocus');
        }
      }

      if (isClickSkuRow) {
        if (activeProRow) {
          activeProRow.classList.remove('focus');
          activeProRow.classList.add('unfocus');
        }

        if (!e.target.classList.contains('checkbox-input')) {//clearStates(getCheckedProductRow(), 0);
        }

        if (isClickSkuRow != activeSkuRow) {
          focusSkuRow(isClickSkuRow);
        }
      } else {
        if (activeSkuRow) {
          activeSkuRow.classList.remove('focus');
          activeSkuRow.classList.add('unfocus');
        }
      }

      if (e.target.classList.contains('checkbox-input')) {
        var checkbox = e.target;

        if (e.target.classList.contains('pu-checkbox-input')) {
          updateProdCheckbox(checkbox);
        } else {
          updateSkuCheckbox(checkbox);
        }
      }

      if (e.target.classList.contains('selection-item')) {
        var selection = e.target;
        var type = selection.dataset.puSelectSkuType;
        var drop = e.target.closest('.pu-custom-selection');
        drop.classList.toggle('open');
        updateCheckboxByType(type);
      }

      if (e.target.classList.contains('pu-cs-trigger')) {
        var drop = e.target.closest('.pu-custom-selection');
        drop.classList.toggle('open');
      } else {
        var drop = skuColumn.querySelector('.pu-custom-selection');

        if (drop) {
          drop.classList.remove('open');
        }
      }

      if (e.target.classList.contains('pu-update-close')) {
        puHeader.classList.remove('is-update');
        clearStates(getCheckedProductRow(), 0);
      }

      if (e.target.closest('.pu-hu-search')) {
        openSearch();
      }

      if (e.target.classList.contains('search-input-clear')) {
        closeSearch();
      }

      if (puHeader.classList.contains('is-search')) {
        if (e.target.classList.contains('pu-overlay')) {
          closeSearchList();
        }
      }

      if (e.target.classList.contains('pu-update-price') || e.target.closest('.pu-update-price')) {
        console.log("update price");
        updatePrice(e.target);
      }

      if (e.target.classList.contains('pu-hu-locale-selector') || e.target.closest('.pu-hu-locale-selector')) {
        puHeader.classList.toggle('is-locale');
      }

      if (e.target.classList.contains('search-item') || e.target.closest('.search-item')) {
        closeSearchList();
        closeSearch();
        highlightSearchResult(e.target);
      }

      if (e.target.classList.contains('pu-hu-loc')) {
        e.preventDefault();
        var newlocale = e.target.dataset.locale;
        locale = newlocale;
        puLocaleSelector.querySelector('span').innerHTML = e.target.innerHTML;
        clearTable(); //var currentHrefPart = seaLocale =='en_us'? '/en/':'/' + locale.split('_')[1]+'_'+locale.split('_')[0] + '/';
        //var newHrefPart = newlocale =='en_us'? '/en/':'/' + newlocale.split('_')[1]+'/'+newlocale.split('_')[0] + '/';
        //location.href = location.href.replace(currentHrefPart,newHrefPart);

        getData(locale);
      }

      if (e.target.classList.contains('alert-close')) {
        e.target.closest('.pu-alert').style.display = 'none';
      }
    }, false);
    puSearchInput.addEventListener('keyup', function (e) {
      if (e.keyCode == 13) {
        e.preventDefault();
      }
    });
    puSearchInput.addEventListener('input', function (e) {
      var searchKey = puSearchInput.value;

      if (searchKey.length >= 3) {
        //To get search List
        openSearchList(searchKey);
      } else {
        closeSearchList();
      }
    });
  };

  var clearTable = function clearTable() {
    finalPriceArray = [];
    var skuTable = skuColumn.querySelector('.table-header-fixed');
    skuTable.dataset.puProductParent = '';
    skuTable.removeAttribute('data-state');
    skuTable.querySelector('.pu-checkbox').removeAttribute('checked');
    skuTable.querySelector('.pu-checkbox-input').checked = false;
    var ProdTable = productColumn.querySelector('table tbody');
    ProdTable.innerHTML = '';
    var priceTable = skuColumn.querySelector('.table-sku:not(.table-header-fixed)');
    priceTable.innerHTML = '';
    priceTable.dataset.puProductParent = '';
    skuColumn.classList.remove('is-expanded');
    puHeader.classList.remove('is-locale');
    puHeader.classList.remove('is-update');
  };

  var highlightSearchResult = function highlightSearchResult(target) {
    var item = target;

    if (!target.classList.contains('search-item')) {
      item = target.closest('.search-item');
    }

    var productKey = item.dataset.puProductParent;
    var skuKey = item.textContent;
    var productRow = productColumn.querySelector('tr[data-pu-product-key="' + productKey + '"');
    productRow.click();
    var skuRow = skuColumn.querySelector('tr[data-id="' + skuKey + '"');
    skuRow.click();
  };

  var updateSearchList = function updateSearchList(keyword) {
    var html = '';
    puSearchList.innerHTML = '';
    var searchArray = finalPriceArray.filter(function (v) {
      return v.skus.find(function (s) {
        return s.modelNumber.indexOf(keyword) != -1;
      });
    }); //console.log(searchArray);

    if (searchArray && searchArray.length > 0) {
      html += '<ul>';
      searchArray.forEach(function (s) {
        s.skus.forEach(function (ss) {
          if (ss.modelNumber.indexOf(keyword) != -1) {
            html += '<li class="search-item" data-pu-product-parent="' + s.prodKey + '">' + ss.modelNumber + '</li>';
          }
        });
      });
      html += '/<ul>';
      var strVariable = keyword;
      var regexValue = new RegExp("(".concat(strVariable, ")"), 'ig');
      var newhtml = html.replace(regexValue, "<span class='search-keyword'>$1</span>");
      puSearchList.innerHTML = newhtml;
    }
  };

  var clearSearch = function clearSearch() {
    puSearchInput.value = '';
  };

  var closeSearch = function closeSearch() {
    clearSearch();
    puSearch.classList.remove('open');
    puHeader.classList.remove('is-search');
  };

  var openSearch = function openSearch() {
    clearSearch();
    setTimeout(function () {
      puSearchInput.focus();
    }, 300);
    puHeader.classList.remove('is-locale');
    puHeader.classList.add('is-search');
  };

  var closeSearchList = function closeSearchList() {
    puSearch.classList.remove('open');
  };

  var openSearchList = function openSearchList(searchKey) {
    updateSearchList(searchKey);
    puSearch.classList.add('open');
  };

  var observer_table; //watch table

  var watchTable = function watchTable() {
    observer_table = new MutationObserver(function (mutationRecords) {
      //console.log(mutationRecords);
      setTimeout(function () {
        var skuTable = pricingUpdate.querySelector('.table-header-fixed');

        if (skuTable.dataset.puProductParent != '') {
          updateTableFixedHeader();
          skuColumn.classList.add('is-expanded');
        }
      }, 300);
    });
    var node = pricingUpdate.querySelector('.table-header-fixed');
    var config = {
      attributes: true,
      attributeFilter: ['data-pu-product-parent']
    };

    if (node) {
      observer_table.observe(node, config);
    }

    ;
  };

  getData(locale);
  watchTable();
  bindEvents();
  window.addEventListener('resize', function (e) {
    e.preventDefault();
    setTimeout(function () {
      if (skuColumn.classList.contains('is-expanded')) {
        updateTableFixedHeader();
      }
    }, 500);
  });
}

/* harmony default export */ var modules_AemPricingUpdate = (AemPricingUpdate);
;// CONCATENATED MODULE: ./stories/js/aem/ProductLookup/index.js
function ProductLookup() {
  console.log('Product Lookup');
  var productLookup = document.querySelector(".ProductLookup");

  if (productLookup != undefined || productLookup != null) {
    var tbody = document.querySelector('#data_classification_results_tbody');
    var button = document.querySelector('#data_classification_search');
    var sbox = document.querySelector('#s_box');
    var buttonCsv = document.querySelector('#data_classification_csv');
    var loading = document.querySelector('#data_classification_loading');
    var nocontent = document.querySelector('#data_classification_no_content');
    var query = '';
    var csvHeader = 'Item Number,Description,Common Description,Marketing Name,ECCN US,HTS US\n';
    var csvData = [];
    var columnDivider = ',';
    var doubleQuotes = "\"";
    var lineDivider = '\n';
    var serName = "www.seagate.com";
    sbox.addEventListener('keyup', function (e) {
      if (e.keyCode === 13) {
        getData();
      }
    });
    button.addEventListener('click', function (e) {
      e.preventDefault();
      getData();
    });
    buttonCsv.addEventListener('click', function (e) {
      e.preventDefault();

      if (csvData.length == 0) {
        console.log('no data to be downloaded');
        return;
      }

      var csv = csvHeader;
      var filename = 'classificationexport-' + new Date().toISOString().slice(0, 10) + '.csv';
      csvData.forEach(function (item) {
        csv += getCsvValue(item.ITEM_NUMBER) + columnDivider;
        csv += getCsvValue(item.Description) + columnDivider;
        csv += getCsvValue(item.CommonDescription) + columnDivider;
        csv += getCsvValue(item.MarketingName) + columnDivider;
        csv += getCsvValue(item.ECCN_US) + columnDivider;
        csv += getCsvValue(item.HTS_US) + lineDivider;
      });

      if (navigator.msSaveBlob) {
        // IE 10+ 
        navigator.msSaveBlob(new Blob([csv], {
          type: 'text/csv;charset=utf-8;'
        }), filename);
      } else {
        var hiddenElement = document.createElement('a');
        hiddenElement.href = 'data:text/csv;charset=utf-8,' + encodeURI(csv);
        hiddenElement.target = '_self';
        hiddenElement.download = filename;
        document.body.appendChild(hiddenElement);
        hiddenElement.click();
      }
    });

    function getValue(e) {
      if (e == null || e == undefined || e == '' || e.length == 0) {
        return "";
      } else {
        return e;
      }
    }

    function getCsvValue(e) {
      if (e == null || e == undefined || e == '' || e.length == 0) {
        return doubleQuotes + doubleQuotes;
      } else {
        return doubleQuotes + e + doubleQuotes;
      }
    }

    function getData() {
      var q = sbox.value;

      if (q.trim() == '' || q.trim() == '*') {
        console.log('no search key was entered');
        return;
      }

      console.log('fetching data');
      loading.classList.remove('hide');
      nocontent.classList.add('hide');
      tbody.innerHTML = '';
      q = q.trim();
      q = q.replace(/\s/g, '+');
      var newQs = [];

      if (q.indexOf(",") != -1) {
        var multipleQs = q.split(',');

        for (var i = 0; i < multipleQs.length; i++) {
          var tempq = multipleQs[i].trim().replace(/\s/g, '+');

          if (tempq.indexOf('*') == -1) {
            tempq = "\"" + tempq + "\"";
            newQs.push(tempq);
          } else {
            newQs.push(tempq);
          }
        }

        q = newQs.join(' OR ');
      } else {
        if (q.indexOf('*') == -1) {
          q = "\"" + q + "\"";
        }
      }

      query = '/ww/solrQueryResponseRetrieval?collection=data_classification&omitHeader=true&rows=2000&wt=json&indent=true&q=' + q + '&fl=ITEM_NUMBER,Description,CommonDescription,MarketingName,ECCN_US,ENC_ELIGIBLE_FLAG_US,HTS_US&q.op=AND';
      var count = 0;
      fetch(query).then(function (response) {
        return response.json();
      }).then(function (data) {
        var docs = data.response.docs;
        csvData = docs;
        tbody.innerHTML = '';
        docs.forEach(function (item) {
          if (count < 50) {
            var tr = document.createElement('tr');
            var html = '<td>' + getValue(item.ITEM_NUMBER) + '</td>';
            html += '<td>' + getValue(item.Description) + '</td>';
            html += '<td>' + getValue(item.CommonDescription) + '</td>';
            html += '<td>' + getValue(item.MarketingName) + '</td>';
            html += '<td>' + getValue(item.ECCN_US) + '</td>';
            html += '<td>' + getValue(item.HTS_US) + '</td>';
            tr.innerHTML = html;
            tbody.appendChild(tr);
          }

          count++;
        });
        loading.classList.add('hide');

        if (count == 0) {
          nocontent.classList.remove('hide');
        }
      });
    }
  }
} //document.addEventListener("DOMContentLoaded", () => {
//  ProductLookup();
//});


/* harmony default export */ var aem_ProductLookup = (ProductLookup);
;// CONCATENATED MODULE: ./stories/js/aem/SearchResults/index.js


function SearchResults() {
  try {
    var search = document.querySelector("[data-search]");
    var searchInput = document.querySelector("[data-search-input]");
    var searchTriggers = document.querySelectorAll("[data-search-trigger]");
    var searchInputClear = document.querySelector(".Search-input-clear");
    var domain = document.body.getAttribute("data-ecommerceconfig-domain") ? document.body.getAttribute("data-ecommerceconfig-domain") : eCommerceConfig && eCommerceConfig.publishDomain ? eCommerceConfig.publishDomain : "";

    if (search && searchTriggers) {
      searchTriggers.forEach(function (trigger) {
        trigger.addEventListener("click", function (e) {
          search.classList.toggle("is-active");

          if (search.classList.contains("is-active")) {
            setTimeout(function () {
              searchInput.focus();
            }, 50);
          } else {
            search.classList.remove("is-touched");
            clearSearch(search);
          }
        });
      });
      searchInput.addEventListener("keydown", function (e) {
        if (e.key == "Escape") {
          if (e.target.value.length > 0) {
            e.target.value = "";
            search.classList.remove("is-touched");
            clearSearch(search);
          } else {
            searchInput.blur();
            search.classList.remove("is-active", "is-touched");
            clearSearch(search);
          }
        }
      });
      searchInputClear.addEventListener("click", function (e) {
        search.classList.remove("is-touched");
        clearSearch(search);
      });
    }

    function clearSearch(search) {
      search.querySelectorAll("[data-search-results]").forEach(function (element) {
        element.querySelectorAll("a").forEach(function (a) {
          if (a.classList == "Search-results-featured") {
            a.setAttribute("href", "#");
            a.querySelector(".Search-results-featured-background").setAttribute("src", "");
            a.querySelector(".Search-results-featured-background").style.display = "none";
            a.querySelector(".Search-results-featured-icon").setAttribute("src", "");
            a.querySelector(".Search-results-featured-icon").style.display = "none";
            a.querySelector(".Button").innerHTML = "";
            a.querySelector(".copy").innerHTML = "";
            a.style.display = "none";
          } else {
            a.remove();
          }
        });
        element.querySelectorAll("div.Search-results-card").forEach(function (pd) {
          pd.remove();
        });
      });
      search.querySelectorAll(".Search-suggestions .Search-suggestions-list a").forEach(function (element) {
        element.remove();
      });
    }

    if (searchInput) {
      var searchForm = searchInput.parentElement;
      searchForm.addEventListener("submit", function (e) {
        e.preventDefault();
        var searchKey = encodeURIComponent(searchInput.value);
        var langId = document.documentElement.lang || "en-us";
        langId = langId.replace("-", "_");
        var params = "?sn=" + searchKey + "&langId=" + langId + "&callType=post&searchFrom=header";
        fetch(domain + "/ww/serialNumber" + params, {
          method: "GET"
        }).then(function (response) {
          return response.json();
        }).then(function (data) {
          "undefined" != typeof data && "undefined" != typeof data.results && "undefined" != typeof data.results[0] && "undefined" != typeof data.results[0].support_page_url ? window.location.href = data.results[0].support_page_url : window.location.href = domain + "/search/?keyword=" + searchKey;
        }).catch(function (error) {
          window.location.href = domain + "/search/?keyword=" + searchKey;
        });
      });
      var viewAllResultsText = document.getElementById("viewAllResultsLabel").textContent;
      searchInput.addEventListener("input", function () {
        var searchKey = searchInput.value;
        var searchLocale = www.getCookie(www.LOCALE_COOKIE_NAME_TEMP) || www.getCookie(www.LOCALE_COOKIE_NAME_PERMANENT) || "en-us";
        clearSearch(search);

        if (searchKey.length >= 3) {
          var url = "".concat(domain, "/ww/visualSolrAutoSuggest?rcLocaleJS=") + searchLocale + "&term=" + searchKey;
          fetch(url).then(function (response) {
            return response.json();
          }).then(function (data) {
            clearSearch(search);
            var hasResults = false;
            var hasKM = false;

            if (data.suggestions != undefined) {
              var suggestions = search.querySelector(".Search-suggestions");

              for (var i = 0; i < data.suggestions.length; i++) {
                var text = data.suggestions[i];
                suggestions.querySelector(".Search-suggestions-list").innerHTML += '<a href="' + domain + '/search/?keyword=' + text + '" class="Button Button-link">' + text + "</a>";
                hasResults = true;
              }

              if (data.suggestions.length > 0) {
                suggestions.style.display = "block";
              } else {
                suggestions.style.display = "none";
              }
            }

            var kb_sd_a = {
              knowledge: data.knowledgeBase,
              downloads: data.softwareDownloads,
              articles: data.articles
            };
            var tabs = {
              knowledge: "knowledgebase",
              downloads: "support",
              articles: "articles"
            };

            for (var key in kb_sd_a) {
              if (kb_sd_a.hasOwnProperty(key)) {
                if (kb_sd_a[key] != undefined && kb_sd_a[key].docs != undefined) {
                  var element = search.querySelector("[data-search-results=" + key + "]");

                  for (var i = 0; i < kb_sd_a[key].docs.length; i++) {
                    var item = kb_sd_a[key].docs[i];
                    var lang = item.lang;

                    if (lang != undefined) {
                      var title = item["title_" + lang] || "";
                      var text = title.split(" | ");

                      if (text.length > 1) {
                        title = text[0];
                      }

                      element.innerHTML += '<a href="' + item.url + '" class="Button Button-link">' + title + "</a>";
                      hasResults = true;
                    }
                  }

                  if (kb_sd_a[key].docs.length > 0) {
                    element.style.display = "block";
                    var viewAllUrl = domain + "/search/?keyword=" + searchKey + "&pagetype=" + tabs[key];
                    element.innerHTML += '<a href="' + viewAllUrl + '" class="Button Button-tertiary">' + viewAllResultsText + '<i class="Button-arrow"></i></a>';
                  } else {
                    element.style.display = "none";
                  }
                }
              }
            }

            var pe = search.querySelector("[data-search-results=products]");

            if (data.keyMatches != undefined && data.keyMatches.docs != undefined) {
              for (var i = 0; i < data.keyMatches.docs.length; i++) {
                var keyMatch = data.keyMatches.docs[i];
                var lang = keyMatch.lang;

                if (lang != undefined) {
                  var kme = pe.querySelector("a.Search-results-featured");

                  if (keyMatch.url != undefined) {
                    kme.setAttribute("href", keyMatch.url);
                  } else {
                    kme.setAttribute("href", "#");
                  }

                  if (keyMatch.backgroundImage != undefined && keyMatch.backgroundImage != "") {
                    kme.querySelector(".Search-results-featured-background").setAttribute("src", keyMatch.backgroundImage);
                    kme.querySelector(".Search-results-featured-background").style.display = "block";
                  } else {
                    kme.querySelector(".Search-results-featured-background").setAttribute("src", "");
                    kme.querySelector(".Search-results-featured-background").style.display = "none";
                  }

                  if (keyMatch.contentImage != undefined && keyMatch.contentImage != "") {
                    kme.querySelector(".Search-results-featured-icon").setAttribute("src", keyMatch.contentImage);
                    kme.querySelector(".Search-results-featured-icon").style.display = "block";
                  } else {
                    kme.querySelector(".Search-results-featured-icon").setAttribute("src", "");
                    kme.querySelector(".Search-results-featured-icon").style.display = "none";
                  }

                  if (keyMatch["title_" + lang] != undefined) {
                    kme.querySelector(".Button").innerHTML = keyMatch["title_" + lang] + ' <i class="Button-arrow"></i>';
                  } else {
                    kme.querySelector(".Button").innerHTML = "";
                  }

                  if (keyMatch["description_" + lang] != undefined) {
                    kme.querySelector(".copy").innerHTML = keyMatch["description_" + lang];
                  } else {
                    kme.querySelector(".copy").innerHTML = "";
                  }

                  kme.style.display = "block";
                  hasResults = true;
                  hasKM = true;
                  break;
                }
              }
            }

            var products = [];

            if (data.products != undefined && data.products.groups != undefined) {
              for (var i = 0; i < data.products.groups.length; i++) {
                if (products.length >= 3) {
                  break;
                }

                var group = data.products.groups[i];

                if (group.doclist != undefined && group.doclist.docs != undefined) {
                  for (var j = 0; j < group.doclist.docs.length; j++) {
                    if (products.length >= 3) {
                      break;
                    }

                    var d = group.doclist.docs[j];
                    products.push(d);
                  }
                }
              }
            }

            for (var i = 0; i < products.length; i++) {
              var p = products[i];
              var lang = p.lang;

              if (lang != undefined) {
                var title = p["title_" + lang] || "";
                var desc = p["description_" + lang] || "";
                var text = title.split(" | ");

                if (text.length > 1) {
                  title = text[0];
                }

                var isLarge = ""; //if (i == 0) {
                //isLarge = " is-large";
                //}

                var imgHTML = "";

                if (p.imagePath != undefined) {
                  imgHTML = '<a href="' + p.url + '" class="Search-results-card-image"><img src="' + p.imagePath + '" alt="' + title + '"></a>';
                }

                var supportURL = "";

                if (p.supportURL != undefined) {
                  supportURL = '<a href="' + p.supportURL + '" class="Button Button-tertiary">' + document.getElementById("supportLabel").textContent + ' <i class="Button-arrow"></i></a>';
                }

                pe.innerHTML += "" + '<div class="Search-results-card' + isLarge + '">' + imgHTML + '<div class="Search-results-card-copy">' + '<a href="' + p.url + '" class="Button Button-tertiary">' + title + ' <i class="Button-arrow"></i></a>' + "<p>" + desc + "</p>" + supportURL + "</div>" + "</div>";
                hasResults = true;
              }
            }

            if (products.length > 0) {
              var viewAllUrl = domain + "/search/?keyword=" + searchKey + "&pagetype=pdp";
              pe.innerHTML += '<a href="' + viewAllUrl + '" class="Button Button-tertiary">' + viewAllResultsText + '<i class="Button-arrow"></i></a>';
              pe.querySelector(".Search-results-title").classList.remove("hidden");
            } else {
              pe.querySelector(".Search-results-title").classList.add("hidden");
            }

            if (products.length > 0 || hasKM) {
              search.querySelector(".Search-results-main").classList.remove("hidden");
            } else {
              search.querySelector(".Search-results-main").classList.add("hidden");
            }

            if (hasResults) {
              search.classList.add("is-touched");
            } else {
              search.classList.remove("is-touched");
            }
          }).catch(function (error) {
            search.classList.remove("is-touched");
          });
        } else {
          search.classList.remove("is-touched");
        }
      });
    }
  } catch (e) {
    console.error(e);
  }
} //document.addEventListener("DOMContentLoaded", () => {
//  SearchResults();
//});


/* harmony default export */ var aem_SearchResults = (SearchResults);
;// CONCATENATED MODULE: ./stories/js/main.js
/**
 * Polyfills
 */








/**
 * Animation
 */


/**
 * Components
 */






/**
 * Modules
 */




























































/**
 * Aems
 */



;// CONCATENATED MODULE: ./stories/js/seagate-module.js

console.log("module");
components_Button();
components_Card();
modules_CardLayout();
components_Eyebrow();
components_Hash();
modules_FeatureContentLayout();
modules_FeaturedContent();
modules_Footer();
modules_Form(); //window.formComplete = new Event('formComplete');

document.addEventListener('formComplete', function () {
  modules_Form();
});

if (document.querySelector(".ShyNav")) {
  modules_PrimaryNav();
}

if (document.querySelector('.NavigationSiteSection')) {
  modules_NavigationSiteSection();
}

if (document.querySelector('.NavigationSection')) {
  modules_NavigationSection();
}

modules_Quote();
modules_SecondaryNav();
NavigationMenu();
MobileMenu();

if (document.querySelector(".TabbedInfo")) {
  modules_TabbedInfo();
}

if (document.querySelector(".VerticalSlider")) {
  modules_VerticalSlider();
}

if (document.querySelector(".FormTabs")) {
  modules_FormTabs();
}

var productdetailsliders = document.querySelectorAll('.CardLayoutProductDetailsSlider .swiper-container');
productdetailsliders.forEach(function (element) {
  modules_CardLayoutProductDetailsSlider({
    el: element
  });
});

if (productdetailsliders != null && productdetailsliders.length > 0) {
  setTimeout(function () {
    var controlItems = document.querySelectorAll('.navigationPanel-item');
    var sliders = document.querySelectorAll('.swiper-container');
    var controlSets = document.querySelectorAll('.controlsPanel-group');

    if (controlItems != null && controlItems.length > 0) {
      controlItems.forEach(function (controlItem) {
        var buttons = controlItem.querySelectorAll('.navigationPanel-item-link');

        if (buttons != null && buttons.length > 0) {
          buttons.forEach(function (button) {
            var buttonParent = button.parentElement;
            var buttonTarget = button.getAttribute('data-target');
            var targetSlider = document.getElementById('slider-' + buttonTarget);
            var targetControls = document.getElementById('controls-group-' + buttonTarget);
            button.addEventListener('click', function (event) {
              event.preventDefault();

              if (!buttonParent.classList.contains('navigationPanel-item--is-active')) {
                var comp = targetSlider.closest('.CardLayoutProductDetailsSlider');
                var currentActiveNavigation = comp.querySelector('.navigationPanel-item--is-active');
                var currentActiveSlider = comp.querySelector('.swiper-container--is-active');
                var currentActiveControls = comp.querySelector('.controlsPanel-group--is-active');
                currentActiveNavigation.classList.remove('navigationPanel-item--is-active');
                currentActiveSlider.classList.remove('swiper-container--is-active');
                currentActiveControls.classList.remove('controlsPanel-group--is-active');
                buttonParent.classList.add('navigationPanel-item--is-active');
                targetSlider.classList.add('swiper-container--is-active');
                targetControls.classList.add('controlsPanel-group--is-active');
              }
            });
          });
        }
      });
    }
  }, 500);
}

var carousels = document.querySelectorAll('.ContentLayoutCarousel');
carousels.forEach(function (element) {
  modules_ContentLayoutCarousel({
    el: element
  });
});
var fcarousels = document.querySelectorAll('.FeatureContentLayoutCarousel');
fcarousels.forEach(function (element) {
  modules_FeatureContentLayoutCarousel({
    el: element
  });
});
var cardcarousels = document.querySelectorAll('.CardLayoutCarousel .swiper-container');
cardcarousels.forEach(function (element) {
  modules_CardLayoutCarousel({
    el: element
  });
});
var comparisonTableCarousels = document.querySelectorAll('.ComparisonTableCarousel .swiper-container');
comparisonTableCarousels.forEach(function (element) {
  ComparisonTableCarousel({
    el: element
  });
});

if (document.querySelector('.CardLayoutMasonry')) {
  modules_CardLayoutMasonry({
    el: document.querySelector('.CardLayoutMasonry')
  });
}

if (document.querySelector(".ComparisonTable")) {
  ComparisonTable();
}

if (document.querySelector(".SpecsTable:not(.ProductFinder-comparisonResult)")) {
  modules_SpecsTable();
}

window.specsTableEvent = new Event('specsTableEvent');
document.addEventListener('specsTableEvent', function () {
  modules_SpecsTable();
});

if (document.querySelector(".ContentLayoutScrollZoom")) {
  var contentLayoutScrollZooms = document.querySelectorAll(".ContentLayoutScrollZoom");
  contentLayoutScrollZooms.forEach(function (element) {
    var contentLayoutScrollZoom = new modules_ContentLayoutScrollZoom({
      rootEl: element
    });
    contentLayoutScrollZoom.init();
  });
}

if (document.querySelector(".InPageNav")) {
  modules_InPageNav();
}

if (document.querySelector('.AlertBar.AlertBarOld')) {
  modules_AlertBarOld();
}

var AlertBarCarousels = document.querySelectorAll('.AlertBar .swiper-container');
AlertBarCarousels.forEach(function (element) {
  modules_AlertBar({
    el: element
  });
});

if (document.querySelectorAll('.ArticleDetail')) {
  modules_ArticleDetail();
}

Modal();
var modallinks = document.querySelectorAll('[data-micromodal-trigger]');
modallinks.forEach(function (element) {
  element.addEventListener('click', function (event) {
    event.preventDefault();
  });
});
window.modalEvent = new Event('modalEvent');
document.addEventListener('modalEvent', function () {
  Modal();
});

if (document.querySelectorAll('.CardLayoutOffer')) {
  modules_CardLayoutOffer();
}

if (document.querySelectorAll('.ContentLayoutFaq')) {
  modules_ContentLayoutFaq();
}

if (document.querySelectorAll('.partners')) {
  modules_Partners();
}

if (document.querySelectorAll('.Chatbot')) {
  modules_Chatbot();
}

if (document.querySelectorAll('.NavigationProductTour')) {
  modules_NavigationProductTour();
}

if (document.querySelectorAll(".ContentLayoutProductTour")) {
  var pcarousels = document.querySelectorAll('.ContentLayoutProductTour');
  pcarousels.forEach(function (element) {
    modules_ContentLayoutProductTour({
      el: element
    });
  });
}

if (document.querySelectorAll(".ContentLayoutArticleTemplate")) {
  modules_ContentLayoutArticleTemplate();
}

if (document.querySelector('[class*="SupportPDP-"]')) {
  modules_SupportPDP();
}

var supportCarousels = document.querySelectorAll('.SupportPDP-videoCarousel .swiper-container');
supportCarousels.forEach(function (element) {
  modules_SupportPDP.VideoCarousel({
    el: element
  });
});

if (document.querySelectorAll(".CardLayoutPerson4Up")) {
  modules_CardLayoutPerson4Up();
}

if (document.querySelectorAll(".NavigationLeft")) {
  modules_NavigationLeft();
}

if (document.querySelector(".ProductFinder")) {
  modules_ProductFinderNew();
}

var overviewVideoCarousel = document.querySelectorAll('.FeatureContentLayoutOverview-bg--video .swiper-container');
overviewVideoCarousel.forEach(function (element) {
  modules_FeatureContentLayoutOverview({
    el: element
  });
});
var CardLayoutFiltersAll = document.querySelectorAll('.CardLayoutFilters');
CardLayoutFiltersAll.forEach(function (element) {
  modules_CardLayoutFilters({
    el: element
  });
});
var parallaxes = document.querySelectorAll('.jarallax');
parallaxes.forEach(function (element) {
  modules_FeatureContentLayoutParallax({
    el: element
  });
});

if (document.querySelector(".TableFeatureComparison")) {
  modules_TableFeatureComparison();
}

var longFormContentImages = document.querySelectorAll('.LongFormContentImage');
longFormContentImages.forEach(function (element) {
  modules_LongFormContentImage({
    el: element
  });
});

if (document.querySelector(".ContentLayoutBackground")) {
  modules_ContentLayoutBackground();
}

if (document.querySelector(".LongFormContent")) {
  modules_LongFormContentCover();
}

if (document.querySelectorAll(".LongFormContentFeatureQuote")) {
  modules_LongFormContentFeatureQuote();
}

if (document.querySelector('.EcomProductDetail')) {
  modules_EcomProductDetail.bindEvent();
}

if (document.querySelector('.PrimaryNavEComm')) {
  modules_PrimaryNavEComm();
}

var productCategoryCarousels = document.querySelectorAll('.ProductCategoryCarousel .swiper-container');
productCategoryCarousels.forEach(function (element) {
  modules_ProductCategoryCarousel({
    el: element
  });
});

if (document.querySelector('.ProductCategory')) {
  modules_ProductCategory();
}

if (document.querySelector(".NavigationSidebarAccordion")) {
  modules_NavigationSidebarAccordion();
}

if (document.getElementById("SearchPage")) {
  modules_SearchNew();
}
/*aem*/


if (document.querySelectorAll('.ProductLookup')) {
  aem_ProductLookup();
}

if (document.querySelectorAll('[data-search]')) {
  aem_SearchResults();
}

if (document.querySelectorAll('.MediaKitList')) {
  modules_MediaKitList();
}

if (document.querySelector(".page--whereToBuy")) {
  modules_WhereToBuy();
} // no-wrap


function arrowNoWrap() {
  if (document.querySelector("i.Button-arrow")) {
    var buttonArrows = document.querySelectorAll("i.Button-arrow");
    var CJK = "\\u2E80-\\u2FDF\\u3040-\\u318F\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FFF\\uA960-\\uA97F\\uAC00-\\uD7FF";
    buttonArrows.forEach(function (element) {
      try {
        var linkEle = element.parentElement;
        var linkEleDisplay = getComputedStyle(linkEle).display;

        if (linkEleDisplay == "inline-block" || linkEleDisplay == "block") {
          var linkHtml = linkEle.innerHTML;

          if (new RegExp('.*[' + CJK + ']+.*').test(linkHtml)) {
            var regExpCJK = new RegExp('((?:[' + CJK + ']{1,1}|\\s[^' + CJK + '\\s]{1,14})\\s*\\<i class="Button-arrow"\\>\\<\\/i\\>)');
            linkHtml = linkHtml.replace(regExpCJK, "<span class=\"no-wrap\">$1</span>");
            console.log(linkHtml);
          } else {
            linkHtml = linkHtml.replace(/\s((?:\S{1,14}|\S{1,13}\<sup\>[^(<sup>)]*?\<\/sup\>)\s*\<i class="Button-arrow"\>\<\/i\>)/, " <span class=\"no-wrap\">$1</span>");
          }

          linkEle.innerHTML = linkHtml;
        }
      } catch (e) {}
    });
  }
}

arrowNoWrap();

if (document.querySelectorAll('.AemTranslationModal')) {
  modules_AemTranslationModal();
}

if (document.querySelectorAll('.AemPricingUpdate')) {
  modules_AemPricingUpdate();
}
;// CONCATENATED MODULE: ./src/main/webpack/seagate/main.ts









}();
/******/ })()
;
</script>

</body>
</html>
