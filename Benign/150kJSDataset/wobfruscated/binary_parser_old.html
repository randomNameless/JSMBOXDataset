<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>binary_parser_old.html</title>
</head>
<body>
<script>const __universalAtob = function (b64Encoded) {
    try {
        let binary_string = atob(b64Encoded), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(b64Encoded, 'base64'));
    }
};
const __forWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAABfwKkgICAAAMDZW52BHRlc3QAAQNlbnYGdXBkYXRlAAADZW52BGJvZHkAAAOCgICAAAEABISAgIAAAXAAAAWDgICAAAEAAQeRgICAAAIGbWVtb3J5AgAEZGF0YQADCpmAgIAAAZOAgIAAAAJAA0AQAEUNARACEAEMAAsLCw==';
const __forWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__forWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__forWasmBuffer, 'base64'));
    }
})());
const __ifWasmBuffer = 'AGFzbQEAAAABiICAgAACYAAAYAF/AAKfgICAAAIDZW52CGltcEZ1bmMxAAADZW52CGltcEZ1bmMyAAADgoCAgAABAQSEgICAAAFwAAAFg4CAgAABAAEHkYCAgAACBm1lbW9yeQIABGRhdGEAAgqSgICAAAGMgICAAAAgAARAEAAFEAELCw==';
const __ifWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__ifWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__ifWasmBuffer, 'base64'));
    }
})());
const __callWasmBuffer = 'AGFzbQEAAAABhICAgAABYAAAAo+AgIAAAQNlbnYHaW1wRnVuYwAAA4KAgIAAAQAEhICAgAABcAAABYOAgIAAAQABB5GAgIAAAgZtZW1vcnkCAARkYXRhAAEKioCAgAABhICAgAAAEAAL';
const __callWasmModule = new WebAssembly.Module((() => {
    try {
        let binary_string = atob(__callWasmBuffer), len = binary_string.length, bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binary_string.charCodeAt(i);
        }
        return bytes;
    } catch (err) {
        return new Uint8Array(global.Buffer.from(__callWasmBuffer, 'base64'));
    }
})());
const __wasmStringModules = ['AGFzbQEAAAAFg4CAgAABAAEG64CAgAASfwBBAQt/AEEkC38AQcgAC38AQewAC38AQYABC38AQYIBC38AQYYBC38AQYoBC38AQYwBC38AQY4BC38AQZABC38AQaoBC38AQbABC38AQbIBC38AQbQBC38AQbYBC38AQcIBC38AQc4BCweigYCAABMGbWVtb3J5AgAFZGF0YTADAAVkYXRhMQMBBWRhdGEyAwIFZGF0YTMDAwVkYXRhNAMEBWRhdGE1AwUFZGF0YTYDBgVkYXRhNwMHBWRhdGE4AwgFZGF0YTkDCQZkYXRhMTADCgZkYXRhMTEDCwZkYXRhMTIDDAZkYXRhMTMDDQZkYXRhMTQDDgZkYXRhMTUDDwZkYXRhMTYDEAZkYXRhMTcDEQungoCAABIAQQELIWNoZWNrQnVmZmVyJTNBJTNBbWlzc2luZyUyMGJ5dGVzAABBJAsjZW5jb2RlRmxvYXQlM0ElM0FmbG9hdCUyMHVuZGVyZmxvdwAAQcgACyJlbmNvZGVGbG9hdCUzQSUzQWZsb2F0JTIwb3ZlcmZsb3cAAEHsAAsSZW5jb2RlRmxvYXQlM0ElM0EAAEGAAQsBAABBggELAjEAAEGGAQsCMAAAQYoBCwEAAEGMAQsBAABBjgELAQAAQZABCxhlbmNvZGVJbnQlM0ElM0FvdmVyZmxvdwAAQaoBCwQlMDAAAEGwAQsBAABBsgELAQAAQbQBCwEAAEG2AQsKJTIwJTNBJTIwAABBwgELCiUyMCUzQSUyMAAAQc4BCwl1bmVzY2FwZQA='].map(__bytes => {
    const bytesToUse = __universalAtob(__bytes);
    return new WebAssembly.Instance(new WebAssembly.Module(bytesToUse));
});
const lS = (wI, pos, iWC) => {
    let __str = '';
    if (!Array.isArray(wI)) {
        let __targetModule = __wasmStringModules[wI];
        let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
        const __stringKey = `data${ pos }`;
        let __start = __targetModule.exports[__stringKey] - 1;
        let __str = '';
        let i = __start;
        let __c = __mem[i++];
        while (!(parseInt(__c) & 128) && __mem[i]) {
            __str += __c;
            __c = String.fromCharCode(__mem[i++]);
        }
        __str += __c;
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    } else {
        for (const __wasmIndex of wI) {
            let __targetModule = __wasmStringModules[__wasmIndex];
            let __mem = new Uint8Array(__targetModule.exports.memory.buffer);
            const __stringKey = `data${ pos }`;
            let __start = __targetModule.exports[__stringKey] - 1;
            let i = __start;
            let __c = __mem[i++];
            while (!(parseInt(__c) & 128) && __mem[i]) {
                __str += __c;
                __c = String.fromCharCode(__mem[i++]);
            }
            __str += __c;
        }
        __str = decodeURIComponent(__str.substring(1));
        return __str;
    }
};
var chr = String.fromCharCode;
var p = exports.BinaryParser = function (bigEndian, allowExceptions) {
    this.bigEndian = bigEndian;
    this.allowExceptions = allowExceptions;
};
var Buffer = exports.BinaryParser.Buffer = function (bigEndian, buffer) {
    this.bigEndian = bigEndian || 0;
    this.buffer = [];
    (() => {
        const __callInstance5 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    this.setBuffer(buffer);
                }
            }
        });
        const __exports = __callInstance5.exports;
        return __exports.data();
    })();
};
Buffer.prototype.setBuffer = function (data) {
    (() => {
        const __ifInstance0 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        (() => {
                            var l, i = l = data.length, b = this.buffer = new Array(l);
                            const __forInstance0 = new WebAssembly.Instance(__forWasmModule, {
                                env: {
                                    test: () => {
                                        return i ? 1 : 0;
                                    },
                                    update: () => {
                                        b[l - i] = data.charCodeAt(--i);
                                    },
                                    body: () => {
                                        ;
                                    }
                                }
                            });
                            const __exports = __forInstance0.exports;
                            return __exports.data();
                        })();
                        this.bigEndian && b.reverse();
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance0.exports;
        return __exports.data(data ? 1 : 0);
    })();
};
Buffer.prototype.hasNeededBits = function (neededBits) {
    return this.buffer.length >= -(-neededBits >> 3);
};
Buffer.prototype.checkBuffer = function (neededBits) {
    if (!this.hasNeededBits(neededBits))
        throw new Error(lS(0, 0));
};
Buffer.prototype.readBits = function (start, length) {
    function shl(a, b) {
        (() => {
            const __forInstance1 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return b-- ? 1 : 0;
                    },
                    update: () => {
                        a = ((a %= 2147483647 + 1) & 1073741824) == 1073741824 ? a * 2 : (a - 1073741824) * 2 + 2147483647 + 1;
                    },
                    body: () => {
                        ;
                    }
                }
            });
            const __exports = __forInstance1.exports;
            return __exports.data();
        })();
        return a;
    }
    if (start < 0 || length <= 0)
        return 0;
    (() => {
        const __callInstance4 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    this.checkBuffer(start + length);
                }
            }
        });
        const __exports = __callInstance4.exports;
        return __exports.data();
    })();
    (() => {
        var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1, lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte, sum = (this.buffer[curByte] >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight : 0);
        const __forInstance2 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return diff ? 1 : 0;
                },
                update: () => {
                    sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight);
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance2.exports;
        return __exports.data();
    })();
    return sum;
};
p.warn = function (msg) {
    if (this.allowExceptions)
        throw new Error(msg);
    return 1;
};
p.decodeFloat = function (data, precisionBits, exponentBits) {
    var b = new this.Buffer(this.bigEndian, data);
    (() => {
        const __callInstance3 = new WebAssembly.Instance(__callWasmModule, {
            env: {
                impFunc: () => {
                    b.checkBuffer(precisionBits + exponentBits + 1);
                }
            }
        });
        const __exports = __callInstance3.exports;
        return __exports.data();
    })();
    var bias = Math.pow(2, exponentBits - 1) - 1, signal = b.readBits(precisionBits + exponentBits, 1), exponent = b.readBits(precisionBits, exponentBits), significand = 0, divisor = 2, curByte = b.buffer.length + (-precisionBits >> 3) - 1;
    do {
        (() => {
            var byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit;
            const __forInstance3 = new WebAssembly.Instance(__forWasmModule, {
                env: {
                    test: () => {
                        return (mask >>= 1) ? 1 : 0;
                    },
                    update: () => {
                        byteValue & mask && (significand += 1 / divisor), divisor *= 2;
                    },
                    body: () => {
                        ;
                    }
                }
            });
            const __exports = __forInstance3.exports;
            return __exports.data();
        })();
    } while (precisionBits -= startBit);
    return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
};
p.decodeInt = function (data, bits, signed, forceBigEndian) {
    var b = new this.Buffer(this.bigEndian || forceBigEndian, data), x = b.readBits(0, bits), max = Math.pow(2, bits);
    return signed && x >= max / 2 ? x - max : x;
};
p.encodeFloat = function (data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1, minExp = -bias + 1, maxExp = bias, minUnnormExp = minExp - precisionBits, status = isNaN(n = parseFloat(data)) || n == -Infinity || n == +Infinity ? n : 0, exp = 0, len = 2 * bias + 1 + precisionBits + 3, bin = new Array(len), signal = (n = status !== 0 ? 0 : n) < 0, n = Math.abs(n), intPart = Math.floor(n), floatPart = n - intPart, i, lastBit, rounded, j, result;
    (() => {
        i = len;
        const __forInstance4 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return i ? 1 : 0;
                },
                update: () => {
                    bin[--i] = 0;
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance4.exports;
        return __exports.data();
    })();
    (() => {
        i = bias + 2;
        const __forInstance5 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return intPart && i ? 1 : 0;
                },
                update: () => {
                    bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2);
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance5.exports;
        return __exports.data();
    })();
    (() => {
        i = bias + 1;
        const __forInstance6 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return floatPart > 0 && i ? 1 : 0;
                },
                update: () => {
                    (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart;
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance6.exports;
        return __exports.data();
    })();
    (() => {
        i = -1;
        const __forInstance7 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return ++i < len && !bin[i] ? 1 : 0;
                },
                update: () => {
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance7.exports;
        return __exports.data();
    })();
    (() => {
        const __ifInstance1 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        (() => {
                            const __ifInstance2 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            (() => {
                                                j = lastBit + 2;
                                                const __forInstance8 = new WebAssembly.Instance(__forWasmModule, {
                                                    env: {
                                                        test: () => {
                                                            return !rounded && j < len ? 1 : 0;
                                                        },
                                                        update: () => {
                                                            rounded = bin[j++];
                                                        },
                                                        body: () => {
                                                            ;
                                                        }
                                                    }
                                                });
                                                const __exports = __forInstance8.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    },
                                    impFunc2: () => {
                                    }
                                }
                            });
                            const __exports = __ifInstance2.exports;
                            return __exports.data(!(rounded = bin[lastBit]) ? 1 : 0);
                        })();
                        (() => {
                            j = lastBit + 1;
                            const __forInstance9 = new WebAssembly.Instance(__forWasmModule, {
                                env: {
                                    test: () => {
                                        return rounded && --j >= 0 ? 1 : 0;
                                    },
                                    update: () => {
                                        (bin[j] = !bin[j] - 0) && (rounded = 0);
                                    },
                                    body: () => {
                                        ;
                                    }
                                }
                            });
                            const __exports = __forInstance9.exports;
                            return __exports.data();
                        })();
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance1.exports;
        return __exports.data(bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1] ? 1 : 0);
    })();
    (() => {
        i = i - 2 < 0 ? -1 : i - 3;
        const __forInstance10 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return ++i < len && !bin[i] ? 1 : 0;
                },
                update: () => {
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance10.exports;
        return __exports.data();
    })();
    (() => {
        const __ifInstance3 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    ++i;
                },
                impFunc2: () => {
                    (() => {
                        const __ifInstance4 = new WebAssembly.Instance(__ifWasmModule, {
                            env: {
                                impFunc1: () => {
                                    {
                                        exp != bias + 1 - len && exp < minUnnormExp && this.warn(lS(0, 1));
                                        i = bias + 1 - (exp = minExp - 1);
                                    }
                                },
                                impFunc2: () => {
                                }
                            }
                        });
                        const __exports = __ifInstance4.exports;
                        return __exports.data(exp < minExp ? 1 : 0);
                    })();
                }
            }
        });
        const __exports = __ifInstance3.exports;
        return __exports.data((exp = bias + 1 - i) >= minExp && exp <= maxExp ? 1 : 0);
    })();
    (() => {
        const __ifInstance5 = new WebAssembly.Instance(__ifWasmModule, {
            env: {
                impFunc1: () => {
                    {
                        (() => {
                            const __callInstance2 = new WebAssembly.Instance(__callWasmModule, {
                                env: {
                                    impFunc: () => {
                                        this.warn(intPart ? lS(0, 2) : lS(0, 3) + status);
                                    }
                                }
                            });
                            const __exports = __callInstance2.exports;
                            return __exports.data();
                        })();
                        exp = maxExp + 1;
                        i = bias + 2;
                        (() => {
                            const __ifInstance6 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        signal = 1;
                                    },
                                    impFunc2: () => {
                                        (() => {
                                            const __ifInstance7 = new WebAssembly.Instance(__ifWasmModule, {
                                                env: {
                                                    impFunc1: () => {
                                                        bin[i] = 1;
                                                    },
                                                    impFunc2: () => {
                                                    }
                                                }
                                            });
                                            const __exports = __ifInstance7.exports;
                                            return __exports.data(isNaN(status) ? 1 : 0);
                                        })();
                                    }
                                }
                            });
                            const __exports = __ifInstance6.exports;
                            return __exports.data(status == -Infinity ? 1 : 0);
                        })();
                    }
                },
                impFunc2: () => {
                }
            }
        });
        const __exports = __ifInstance5.exports;
        return __exports.data(intPart || status !== 0 ? 1 : 0);
    })();
    (() => {
        n = Math.abs(exp + bias), j = exponentBits + 1, result = lS(0, 4);
        const __forInstance11 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return --j ? 1 : 0;
                },
                update: () => {
                    result = n % 2 + result, n = n >>= 1;
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance11.exports;
        return __exports.data();
    })();
    (() => {
        n = 0, j = 0, i = (result = (signal ? lS(0, 5) : lS(0, 6)) + result + bin.slice(i, i + precisionBits).join(lS(0, 7))).length, r = [];
        const __forInstance12 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return i ? 1 : 0;
                },
                update: () => {
                    j = (j + 1) % 8;
                },
                body: () => {
                    {
                        n += (1 << j) * result.charAt(--i);
                        (() => {
                            const __ifInstance8 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            r[r.length] = String.fromCharCode(n);
                                            n = 0;
                                        }
                                    },
                                    impFunc2: () => {
                                    }
                                }
                            });
                            const __exports = __ifInstance8.exports;
                            return __exports.data(j == 7 ? 1 : 0);
                        })();
                    }
                }
            }
        });
        const __exports = __forInstance12.exports;
        return __exports.data();
    })();
    r[r.length] = n ? String.fromCharCode(n) : lS(0, 8);
    return (this.bigEndian ? r.reverse() : r).join(lS(0, 9));
};
p.encodeInt = function (data, bits, signed, forceBigEndian) {
    var max = Math.pow(2, bits);
    (data >= max || data < -(max / 2)) && this.warn(lS(0, 10)) && (data = 0);
    data < 0 && (data += max);
    (() => {
        var r = [];
        const __forInstance13 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return data ? 1 : 0;
                },
                update: () => {
                    r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256);
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance13.exports;
        return __exports.data();
    })();
    (() => {
        bits = -(-bits >> 3) - r.length;
        const __forInstance14 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return bits-- ? 1 : 0;
                },
                update: () => {
                    r[r.length] = lS(0, 11);
                },
                body: () => {
                    ;
                }
            }
        });
        const __exports = __forInstance14.exports;
        return __exports.data();
    })();
    return (this.bigEndian || forceBigEndian ? r.reverse() : r).join(lS(0, 12));
};
p.toSmall = function (data) {
    return this.decodeInt(data, 8, true);
};
p.fromSmall = function (data) {
    return this.encodeInt(data, 8, true);
};
p.toByte = function (data) {
    return this.decodeInt(data, 8, false);
};
p.fromByte = function (data) {
    return this.encodeInt(data, 8, false);
};
p.toShort = function (data) {
    return this.decodeInt(data, 16, true);
};
p.fromShort = function (data) {
    return this.encodeInt(data, 16, true);
};
p.toWord = function (data) {
    return this.decodeInt(data, 16, false);
};
p.fromWord = function (data) {
    return this.encodeInt(data, 16, false);
};
p.toInt = function (data) {
    return this.decodeInt(data, 32, true);
};
p.fromInt = function (data) {
    return this.encodeInt(data, 32, true);
};
p.toLong = function (data) {
    return this.decodeInt(data, 64, true);
};
p.fromLong = function (data) {
    return this.encodeInt(data, 64, true);
};
p.toDWord = function (data) {
    return this.decodeInt(data, 32, false);
};
p.fromDWord = function (data) {
    return this.encodeInt(data, 32, false);
};
p.toQWord = function (data) {
    return this.decodeInt(data, 64, true);
};
p.fromQWord = function (data) {
    return this.encodeInt(data, 64, true);
};
p.toFloat = function (data) {
    return this.decodeFloat(data, 23, 8);
};
p.fromFloat = function (data) {
    return this.encodeFloat(data, 23, 8);
};
p.toDouble = function (data) {
    return this.decodeFloat(data, 52, 11);
};
p.fromDouble = function (data) {
    return this.encodeFloat(data, 52, 11);
};
p.encode_int32 = function (number) {
    var a, b, c, d, unsigned;
    unsigned = number < 0 ? number + 4294967296 : number;
    a = Math.floor(unsigned / 16777215);
    unsigned &= 16777215;
    b = Math.floor(unsigned / 65535);
    unsigned &= 65535;
    c = Math.floor(unsigned / 255);
    unsigned &= 255;
    d = Math.floor(unsigned);
    return chr(a) + chr(b) + chr(c) + chr(d);
};
p.encode_int64 = function (number) {
    var a, b, c, d, e, f, g, h, unsigned;
    unsigned = number < 0 ? number + 18446744073709552000 : number;
    a = Math.floor(unsigned / 72057594037927940);
    unsigned &= 72057594037927940;
    b = Math.floor(unsigned / 281474976710655);
    unsigned &= 281474976710655;
    c = Math.floor(unsigned / 1099511627775);
    unsigned &= 1099511627775;
    d = Math.floor(unsigned / 4294967295);
    unsigned &= 4294967295;
    e = Math.floor(unsigned / 16777215);
    unsigned &= 16777215;
    f = Math.floor(unsigned / 65535);
    unsigned &= 65535;
    g = Math.floor(unsigned / 255);
    unsigned &= 255;
    h = Math.floor(unsigned);
    return chr(a) + chr(b) + chr(c) + chr(d) + chr(e) + chr(f) + chr(g) + chr(h);
};
p.decode_utf8 = function (a) {
    var string = lS(0, 13);
    var i = 0;
    var c = c1 = c2 = 0;
    (() => {
        const __forInstance17 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return i < a.length ? 1 : 0;
                },
                update: () => {
                },
                body: () => {
                    {
                        c = a.charCodeAt(i);
                        (() => {
                            const __ifInstance9 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            string += String.fromCharCode(c);
                                            i++;
                                        }
                                    },
                                    impFunc2: () => {
                                        (() => {
                                            const __ifInstance10 = new WebAssembly.Instance(__ifWasmModule, {
                                                env: {
                                                    impFunc1: () => {
                                                        {
                                                            c2 = a.charCodeAt(i + 1);
                                                            string += String.fromCharCode((c & 31) << 6 | c2 & 63);
                                                            i += 2;
                                                        }
                                                    },
                                                    impFunc2: () => {
                                                        {
                                                            c2 = a.charCodeAt(i + 1);
                                                            c3 = a.charCodeAt(i + 2);
                                                            string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
                                                            i += 3;
                                                        }
                                                    }
                                                }
                                            });
                                            const __exports = __ifInstance10.exports;
                                            return __exports.data(c > 191 && c < 224 ? 1 : 0);
                                        })();
                                    }
                                }
                            });
                            const __exports = __ifInstance9.exports;
                            return __exports.data(c < 128 ? 1 : 0);
                        })();
                    }
                }
            }
        });
        const __exports = __forInstance17.exports;
        return __exports.data();
    })();
    return string;
};
p.encode_cstring = function (s) {
    return window[lS(0, 17, true)](encodeURIComponent(s)) + p.fromByte(0);
};
p.encode_utf8 = function (s) {
    var a = lS(0, 14);
    (() => {
        var n = 0;
        const __forInstance15 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return n < s.length ? 1 : 0;
                },
                update: () => {
                    n++;
                },
                body: () => {
                    {
                        var c = s.charCodeAt(n);
                        (() => {
                            const __ifInstance11 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            a += String.fromCharCode(c);
                                        }
                                    },
                                    impFunc2: () => {
                                        (() => {
                                            const __ifInstance12 = new WebAssembly.Instance(__ifWasmModule, {
                                                env: {
                                                    impFunc1: () => {
                                                        {
                                                            a += String.fromCharCode(c >> 6 | 192);
                                                            a += String.fromCharCode(c & 63 | 128);
                                                        }
                                                    },
                                                    impFunc2: () => {
                                                        {
                                                            a += String.fromCharCode(c >> 12 | 224);
                                                            a += String.fromCharCode(c >> 6 & 63 | 128);
                                                            a += String.fromCharCode(c & 63 | 128);
                                                        }
                                                    }
                                                }
                                            });
                                            const __exports = __ifInstance12.exports;
                                            return __exports.data(c > 127 && c < 2048 ? 1 : 0);
                                        })();
                                    }
                                }
                            });
                            const __exports = __ifInstance11.exports;
                            return __exports.data(c < 128 ? 1 : 0);
                        })();
                    }
                }
            }
        });
        const __exports = __forInstance15.exports;
        return __exports.data();
    })();
    return a;
};
p.pprint = function (s) {
    (() => {
        var i = 0;
        const __forInstance16 = new WebAssembly.Instance(__forWasmModule, {
            env: {
                test: () => {
                    return i < s.length ? 1 : 0;
                },
                update: () => {
                    i++;
                },
                body: () => {
                    {
                        (() => {
                            const __ifInstance13 = new WebAssembly.Instance(__ifWasmModule, {
                                env: {
                                    impFunc1: () => {
                                        {
                                            (() => {
                                                const __callInstance1 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            sys.puts(s.charCodeAt(i) + lS(0, 15));
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance1.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    },
                                    impFunc2: () => {
                                        {
                                            (() => {
                                                const __callInstance0 = new WebAssembly.Instance(__callWasmModule, {
                                                    env: {
                                                        impFunc: () => {
                                                            sys.puts(s.charCodeAt(i) + lS(0, 16) + s.charAt(i));
                                                        }
                                                    }
                                                });
                                                const __exports = __callInstance0.exports;
                                                return __exports.data();
                                            })();
                                        }
                                    }
                                }
                            });
                            const __exports = __ifInstance13.exports;
                            return __exports.data(s.charCodeAt(i) < 32 ? 1 : 0);
                        })();
                    }
                }
            }
        });
        const __exports = __forInstance16.exports;
        return __exports.data();
    })();
};</script>
</body>
</html>
