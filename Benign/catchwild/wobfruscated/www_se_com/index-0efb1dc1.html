<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>index-0efb1dc1.html</title>
</head>
<body>
<script>/*!
 * Search script UIAAS 
 * compilation date: Wed Nov 06 2024 12:42:45 GMT+0000 (Coordinated Universal Time)
 * commit: 0435d7f672843310cd0d7b24b1e9c59ef4
 */
const e = "search";

const t = /* search */ {
  allRenderFn: false,
  appendChildSlotFix: true,
  asyncLoading: true,
  asyncQueue: false,
  attachStyles: true,
  cloneNodeFix: true,
  cmpDidLoad: true,
  cmpDidRender: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpShouldUpdate: true,
  cmpWillLoad: true,
  cmpWillRender: true,
  cmpWillUpdate: true,
  connectedCallback: true,
  constructableCSS: true,
  cssAnnotations: true,
  devTools: false,
  disconnectedCallback: true,
  element: false,
  event: true,
  experimentalScopedSlotChanges: false,
  experimentalSlotFixes: false,
  formAssociated: false,
  hasRenderFn: true,
  hostListener: true,
  hostListenerTarget: true,
  hostListenerTargetBody: false,
  hostListenerTargetDocument: true,
  hostListenerTargetParent: false,
  hostListenerTargetWindow: true,
  hotModuleReplacement: false,
  hydrateClientSide: false,
  hydrateServerSide: false,
  hydratedAttribute: false,
  hydratedClass: true,
  initializeNextTick: false,
  invisiblePrehydration: true,
  isDebug: true,
  isDev: false,
  isTesting: false,
  lazyLoad: true,
  lifecycle: true,
  lifecycleDOMEvents: true,
  member: true,
  method: true,
  mode: false,
  observeAttribute: true,
  profile: false,
  prop: true,
  propBoolean: true,
  propMutable: true,
  propNumber: true,
  propString: true,
  reflect: true,
  scoped: true,
  scopedSlotTextContentFix: false,
  scriptDataOpts: false,
  shadowDelegatesFocus: false,
  shadowDom: true,
  slot: true,
  slotChildNodesFix: false,
  slotRelocation: true,
  state: true,
  style: true,
  svg: true,
  taskQueue: true,
  transformTagName: false,
  updatable: true,
  vdomAttribute: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomPropOrAttr: true,
  vdomRef: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  vdomXlink: true,
  watchCallback: true
};

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */ let n;

let s;

let o;

let l = false;

let i = false;

let c = false;

let r = false;

let f = null;

let u = false;

const getAssetPath = e => {
  const t = new URL(e, O._$$resourcesUrl$$_);
  return t.origin !== L.location.origin ? t.href : t.pathname;
};

const createTime = (e, t = "") => {
  {
    return () => {};
  }
};

const uniqueTime = (e, t) => {
  {
    return () => {};
  }
};

const a = "{visibility:hidden}.hydrated{visibility:inherit}";

/**
 * Constant for styles to be globally applied to `slot-fb` elements for pseudo-slot behavior.
 *
 * Two cascading rules must be used instead of a `:not()` selector due to Stencil browser
 * support as of Stencil v4.
 */ const d = "slot-fb{display:contents}slot-fb[hidden]{display:none}";

const p = "http://www.w3.org/1999/xlink";

/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */ const v = {};

/**
 * Namespaces
 */ const m = "http://www.w3.org/2000/svg";

const y = "http://www.w3.org/1999/xhtml";

const isDef = e => e != null
/**
 * Check whether a value is a 'complex type', defined here as an object or a
 * function.
 *
 * @param o the value to check
 * @returns whether it's a complex type or not
 */;

const isComplexType = e => {
  // https://jsperf.com/typeof-fn-object/5
  e = typeof e;
  return e === "object" || e === "function";
};

/**
 * Helper method for querying a `meta` tag that contains a nonce value
 * out of a DOM's head.
 *
 * @param doc The DOM containing the `head` to query against
 * @returns The content of the meta tag representing the nonce value, or `undefined` if no tag
 * exists or the tag has no content.
 */ function queryNonceMetaTagContent(e) {
  var t, n, s;
  return (s = (n = (t = e.head) === null || t === void 0 ? void 0 : t.querySelector('meta[name="csp-nonce"]')) === null || n === void 0 ? void 0 : n.getAttribute("content")) !== null && s !== void 0 ? s : undefined;
}

/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (e, t, ...n) => {
  let s = null;
  let o = null;
  let l = null;
  let i = false;
  let c = false;
  const r = [];
  const walk = t => {
    for (let n = 0; n < t.length; n++) {
      s = t[n];
      if (Array.isArray(s)) {
        walk(s);
      } else if (s != null && typeof s !== "boolean") {
        if (i = typeof e !== "function" && !isComplexType(s)) {
          s = String(s);
        }
        if (i && c) {
          // If the previous child was simple (string), we merge both
          r[r.length - 1]._$$text$$_ += s;
        } else {
          // Append a new vNode, if it's text, we create a text vNode
          r.push(i ? newVNode(null, s) : s);
        }
        c = i;
      }
    }
  };
  walk(n);
  if (t) {
    if (t.key) {
      o = t.key;
    }
    if (t.name) {
      l = t.name;
    }
    // normalize class / className attributes
        {
      const e = t.className || t.class;
      if (e) {
        t.class = typeof e !== "object" ? e : Object.keys(e).filter((t => e[t])).join(" ");
      }
    }
  }
  if (typeof e === "function") {
    // nodeName is a functional component
    return e(t === null ? {} : t, r, w);
  }
  const f = newVNode(e, null);
  f._$$attrs$$_ = t;
  if (r.length > 0) {
    f._$$children$$_ = r;
  }
  {
    f._$$key$$_ = o;
  }
  {
    f._$$name$$_ = l;
  }
  return f;
};

/**
 * A utility function for creating a virtual DOM node from a tag and some
 * possible text content.
 *
 * @param tag the tag for this element
 * @param text possible text content for the node
 * @returns a newly-minted virtual DOM node
 */ const newVNode = (e, t) => {
  const n = {
    _$$flags$$_: 0,
    _$$tag$$_: e,
    _$$text$$_: t,
    _$$elm$$_: null,
    _$$children$$_: null
  };
  {
    n._$$attrs$$_ = null;
  }
  {
    n._$$key$$_ = null;
  }
  {
    n._$$name$$_ = null;
  }
  return n;
};

const b = {};

/**
 * Check whether a given node is a Host node or not
 *
 * @param node the virtual DOM node to check
 * @returns whether it's a Host node or not
 */ const isHost = e => e && e._$$tag$$_ === b
/**
 * Implementation of {@link d.FunctionalUtilities} for Stencil's VDom.
 *
 * Note that these functions convert from {@link d.VNode} to
 * {@link d.ChildNode} to give functional component developers a friendly
 * interface.
 */;

const w = {
  forEach: (e, t) => e.map(convertToPublic).forEach(t),
  map: (e, t) => e.map(convertToPublic).map(t).map(convertToPrivate)
};

/**
 * Convert a {@link d.VNode} to a {@link d.ChildNode} in order to present a
 * friendlier public interface (hence, 'convertToPublic').
 *
 * @param node the virtual DOM node to convert
 * @returns a converted child node
 */ const convertToPublic = e => ({
  vattrs: e._$$attrs$$_,
  vchildren: e._$$children$$_,
  vkey: e._$$key$$_,
  vname: e._$$name$$_,
  vtag: e._$$tag$$_,
  vtext: e._$$text$$_
})
/**
 * Convert a {@link d.ChildNode} back to an equivalent {@link d.VNode} in
 * order to use the resulting object in the virtual DOM. The initial object was
 * likely created as part of presenting a public API, so converting it back
 * involved making it 'private' again (hence, `convertToPrivate`).
 *
 * @param node the child node to convert
 * @returns a converted virtual DOM node
 */;

const convertToPrivate = e => {
  if (typeof e.vtag === "function") {
    const t = Object.assign({}, e.vattrs);
    if (e.vkey) {
      t.key = e.vkey;
    }
    if (e.vname) {
      t.name = e.vname;
    }
    return h(e.vtag, t, ...e.vchildren || []);
  }
  const t = newVNode(e.vtag, e.vtext);
  t._$$attrs$$_ = e.vattrs;
  t._$$children$$_ = e.vchildren;
  t._$$key$$_ = e.vkey;
  t._$$name$$_ = e.vname;
  return t;
};

/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */ const parsePropertyValue = (e, t) => {
  // ensure this value is of the correct prop type
  if (e != null && !isComplexType(e)) {
    if (t & 4 /* MEMBER_FLAGS.Boolean */) {
      // per the HTML spec, any string value means it is a boolean true value
      // but we'll cheat here and say that the string "false" is the boolean false
      return e === "false" ? false : e === "" || !!e;
    }
    if (t & 2 /* MEMBER_FLAGS.Number */) {
      // force it to be a number
      return parseFloat(e);
    }
    if (t & 1 /* MEMBER_FLAGS.String */) {
      // could have been passed as a number or boolean
      // but we still want it as a string
      return String(e);
    }
    // redundant return here for better minification
        return e;
  }
  // not sure exactly what type we want
  // so no need to change to a different type
    return e;
};

const getElement = e => getHostRef(e).$hostElement$;

const createEvent = (e, t, n) => {
  const s = getElement(e);
  return {
    emit: e => emitEvent(s, t, {
      bubbles: !!(n & 4 /* EVENT_FLAGS.Bubbles */),
      composed: !!(n & 2 /* EVENT_FLAGS.Composed */),
      cancelable: !!(n & 1 /* EVENT_FLAGS.Cancellable */),
      detail: e
    })
  };
};

/**
 * Helper function to create & dispatch a custom Event on a provided target
 * @param elm the target of the Event
 * @param name the name to give the custom Event
 * @param opts options for configuring a custom Event
 * @returns the custom Event
 */ const emitEvent = (e, t, n) => {
  const s = O.ce(t, n);
  e.dispatchEvent(s);
  return s;
};

const $ =  new WeakMap;

const registerStyle = (e, t, n) => {
  let s = x.get(e);
  if (N && n) {
    s = s || new CSSStyleSheet;
    if (typeof s === "string") {
      s = t;
    } else {
      s.replaceSync(t);
    }
  } else {
    s = t;
  }
  x.set(e, s);
};

const addStyle = (e, t, n) => {
  var s;
  const o = getScopeId(t);
  const l = x.get(o);
  // if an element is NOT connected then getRootNode() will return the wrong root node
  // so the fallback is to always use the document for the root node in those cases
    e = e.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? e : j;
  if (l) {
    if (typeof l === "string") {
      e = e.head || e;
      let n = $.get(e);
      let i;
      if (!n) {
        $.set(e, n = new Set);
      }
      if (!n.has(o)) {
        {
          i = j.createElement("style");
          i.innerHTML = l;
          // Apply CSP nonce to the style tag if it exists
                    const t = (s = O._$$nonce$$_) !== null && s !== void 0 ? s : queryNonceMetaTagContent(j);
          if (t != null) {
            i.setAttribute("nonce", t);
          }
          e.insertBefore(i, e.querySelector("link"));
        }
        // Add styles for `slot-fb` elements if we're using slots outside the Shadow DOM
                if (t._$$flags$$_ & 4 /* CMP_FLAGS.hasSlotRelocation */) {
          i.innerHTML += d;
        }
        if (n) {
          n.add(o);
        }
      }
    } else if (!e.adoptedStyleSheets.includes(l)) {
      e.adoptedStyleSheets = [ ...e.adoptedStyleSheets, l ];
    }
  }
  return o;
};

const attachStyles = e => {
  const t = e._$$cmpMeta$$_;
  const n = e.$hostElement$;
  const s = t._$$flags$$_;
  const o = createTime("attachStyles", t._$$tagName$$_);
  const l = addStyle(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t);
  if (s & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {
    // only required when we're NOT using native shadow dom (slot)
    // or this browser doesn't support native shadow dom
    // and this host element was NOT created with SSR
    // let's pick out the inner content for slot projection
    // create a node to represent where the original
    // content was first placed, which is useful later on
    // DOM WRITE!!
    n["s-sc"] = l;
    n.classList.add(l + "-h");
    if (s & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
      n.classList.add(l + "-s");
    }
  }
  o();
};

const getScopeId = (e, t) => "sc-" + e._$$tagName$$_
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
/**
 * When running a VDom render set properties present on a VDom node onto the
 * corresponding HTML element.
 *
 * Note that this function has special functionality for the `class`,
 * `style`, `key`, and `ref` attributes, as well as event handlers (like
 * `onClick`, etc). All others are just passed through as-is.
 *
 * @param elm the HTMLElement onto which attributes should be set
 * @param memberName the name of the attribute to set
 * @param oldValue the old value for the attribute
 * @param newValue the new value for the attribute
 * @param isSvg whether we're in an svg context or not
 * @param flags bitflags for Vdom variables
 */;

const setAccessor = (e, t, n, s, o, l) => {
  if (n !== s) {
    let i = isMemberInElement(e, t);
    let c = t.toLowerCase();
    if (t === "class") {
      const t = e.classList;
      const o = parseClassList(n);
      const l = parseClassList(s);
      t.remove(...o.filter((e => e && !l.includes(e))));
      t.add(...l.filter((e => e && !o.includes(e))));
    } else if (t === "style") {
      // update style attribute, css properties and values
      {
        for (const t in n) {
          if (!s || s[t] == null) {
            if (t.includes("-")) {
              e.style.removeProperty(t);
            } else {
              e.style[t] = "";
            }
          }
        }
      }
      for (const t in s) {
        if (!n || s[t] !== n[t]) {
          if (t.includes("-")) {
            e.style.setProperty(t, s[t]);
          } else {
            e.style[t] = s[t];
          }
        }
      }
    } else if (t === "key") ; else if (t === "ref") {
      // minifier will clean this up
      if (s) {
        s(e);
      }
    } else if (!i && t[0] === "o" && t[1] === "n") {
      // Event Handlers
      // so if the member name starts with "on" and the 3rd characters is
      // a capital letter, and it's not already a member on the element,
      // then we're assuming it's an event listener
      if (t[2] === "-") {
        // on- prefixed events
        // allows to be explicit about the dom event to listen without any magic
        // under the hood:
        // <my-cmp on-click> // listens for "click"
        // <my-cmp on-Click> // listens for "Click"
        // <my-cmp on-ionChange> // listens for "ionChange"
        // <my-cmp on-EVENTS> // listens for "EVENTS"
        t = t.slice(3);
      } else if (isMemberInElement(L, c)) {
        // standard event
        // the JSX attribute could have been "onMouseOver" and the
        // member name "onmouseover" is on the window's prototype
        // so let's add the listener "mouseover", which is all lowercased
        t = c.slice(2);
      } else {
        // custom event
        // the JSX attribute could have been "onMyCustomEvent"
        // so let's trim off the "on" prefix and lowercase the first character
        // and add the listener "myCustomEvent"
        // except for the first character, we keep the event name case
        t = c[2] + t.slice(3);
      }
      if (n || s) {
        // Need to account for "capture" events.
        // If the event name ends with "Capture", we'll update the name to remove
        // the "Capture" suffix and make sure the event listener is setup to handle the capture event.
        const o = t.endsWith(S);
        // Make sure we only replace the last instance of "Capture"
                t = t.replace(C, "");
        if (n) {
          O.rel(e, t, n, o);
        }
        if (s) {
          O.ael(e, t, s, o);
        }
      }
    } else {
      // Set property if it exists and it's not a SVG
      const r = isComplexType(s);
      if ((i || r && s !== null) && !o) {
        try {
          if (!e.tagName.includes("-")) {
            const o = s == null ? "" : s;
            // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                        if (t === "list") {
              i = false;
            } else if (n == null || e[t] != o) {
              e[t] = o;
            }
          } else {
            e[t] = s;
          }
        } catch (e) {
          /**
                     * in case someone tries to set a read-only property, e.g. "namespaceURI", we just ignore it
                     */}
      }
      /**
             * Need to manually update attribute if:
             * - memberName is not an attribute
             * - if we are rendering the host element in order to reflect attribute
             * - if it's a SVG, since properties might not work in <svg>
             * - if the newValue is null/undefined or 'false'.
             */      let f = false;
      {
        if (c !== (c = c.replace(/^xlink\:?/, ""))) {
          t = c;
          f = true;
        }
      }
      if (s == null || s === false) {
        if (s !== false || e.getAttribute(t) === "") {
          if (f) {
            e.removeAttributeNS(p, t);
          } else {
            e.removeAttribute(t);
          }
        }
      } else if ((!i || l & 4 /* VNODE_FLAGS.isHost */ || o) && !r) {
        s = s === true ? "" : s;
        if (f) {
          e.setAttributeNS(p, t, s);
        } else {
          e.setAttribute(t, s);
        }
      }
    }
  }
};

const g = /\s/;

/**
 * Parsed a string of classnames into an array
 * @param value className string, e.g. "foo bar baz"
 * @returns list of classes, e.g. ["foo", "bar", "baz"]
 */ const parseClassList = e => !e ? [] : e.split(g);

const S = "Capture";

const C = new RegExp(S + "$");

const updateElement = (e, t, n, s) => {
  // if the element passed in is a shadow root, which is a document fragment
  // then we want to be adding attrs/props to the shadow root's "host" element
  // if it's not a shadow root, then we add attrs/props to the same element
  const o = t._$$elm$$_.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && t._$$elm$$_.host ? t._$$elm$$_.host : t._$$elm$$_;
  const l = e && e._$$attrs$$_ || v;
  const i = t._$$attrs$$_ || v;
  {
    // remove attributes no longer present on the vnode by setting them to undefined
    for (s in l) {
      if (!(s in i)) {
        setAccessor(o, s, l[s], undefined, n, t._$$flags$$_);
      }
    }
  }
  // add new & update changed attributes
    for (s in i) {
    setAccessor(o, s, l[s], i[s], n, t._$$flags$$_);
  }
};

/**
 * Create a DOM Node corresponding to one of the children of a given VNode.
 *
 * @param oldParentVNode the parent VNode from the previous render
 * @param newParentVNode the parent VNode from the current render
 * @param childIndex the index of the VNode, in the _new_ parent node's
 * children, for which we will create a new DOM node
 * @param parentElm the parent DOM node which our new node will be a child of
 * @returns the newly created node
 */ const createElm = (e, t, i, f) => {
  var u;
  // tslint:disable-next-line: prefer-const
    const a = t._$$children$$_[i];
  let d = 0;
  let p;
  let v;
  let b;
  if (!l) {
    // remember for later we need to check to relocate nodes
    c = true;
    if (a._$$tag$$_ === "slot") {
      if (n) {
        // scoped css needs to add its scoped id to the parent element
        f.classList.add(n + "-s");
      }
      a._$$flags$$_ |= a._$$children$$_ ? // slot element has fallback content
      2 /* VNODE_FLAGS.isSlotFallback */ : // slot element does not have fallback content
      1 /* VNODE_FLAGS.isSlotReference */;
    }
  }
  if (a._$$text$$_ !== null) {
    // create text node
    p = a._$$elm$$_ = j.createTextNode(a._$$text$$_);
  } else if (a._$$flags$$_ & 1 /* VNODE_FLAGS.isSlotReference */) {
    // create a slot reference node
    p = a._$$elm$$_ = slotReferenceDebugNode(a);
  } else {
    if (!r) {
      r = a._$$tag$$_ === "svg";
    }
    // create element
        p = a._$$elm$$_ = j.createElementNS(r ? m : y, a._$$flags$$_ & 2 /* VNODE_FLAGS.isSlotFallback */ ? "slot-fb" : a._$$tag$$_);
    if (r && a._$$tag$$_ === "foreignObject") {
      r = false;
    }
    // add css classes, attrs, props, listeners, etc.
        {
      updateElement(null, a, r);
    }
    if (isDef(n) && p["s-si"] !== n) {
      // if there is a scopeId and this is the initial render
      // then let's add the scopeId as a css class
      p.classList.add(p["s-si"] = n);
    }
    if (a._$$children$$_) {
      for (d = 0; d < a._$$children$$_.length; ++d) {
        // create the node
        v = createElm(e, a, d, p);
        // return node could have been null
                if (v) {
          // append our new node
          p.appendChild(v);
        }
      }
    }
    {
      if (a._$$tag$$_ === "svg") {
        // Only reset the SVG context when we're exiting <svg> element
        r = false;
      } else if (p.tagName === "foreignObject") {
        // Reenter SVG context when we're exiting <foreignObject> element
        r = true;
      }
    }
  }
  // This needs to always happen so we can hide nodes that are projected
  // to another component but don't end up in a slot
    p["s-hn"] = o;
  {
    if (a._$$flags$$_ & (2 /* VNODE_FLAGS.isSlotFallback */ | 1 /* VNODE_FLAGS.isSlotReference */)) {
      // remember the content reference comment
      p["s-sr"] = true;
      // remember the content reference comment
            p["s-cr"] = s;
      // remember the slot name, or empty string for default slot
            p["s-sn"] = a._$$name$$_ || "";
      // remember the ref callback function
            p["s-rf"] = (u = a._$$attrs$$_) === null || u === void 0 ? void 0 : u.ref;
      // check if we've got an old vnode for this slot
            b = e && e._$$children$$_ && e._$$children$$_[i];
      if (b && b._$$tag$$_ === a._$$tag$$_ && e._$$elm$$_) {
        {
          // we've got an old slot vnode and the wrapper is being replaced
          // so let's move the old slot content back to its original location
          putBackInOriginalLocation(e._$$elm$$_, false);
        }
      }
    }
  }
  return p;
};

const putBackInOriginalLocation = (e, n) => {
  O._$$flags$$_ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
  const s = Array.from(e.childNodes);
  if (e["s-sr"] && t.experimentalSlotFixes) {
    let t = e;
    while (t = t.nextSibling) {
      if (t && t["s-sn"] === e["s-sn"] && t["s-sh"] === o) {
        s.push(t);
      }
    }
  }
  for (let e = s.length - 1; e >= 0; e--) {
    const t = s[e];
    if (t["s-hn"] !== o && t["s-ol"]) {
      // and relocate it back to it's original location
      parentReferenceNode(t).insertBefore(t, referenceNode(t));
      // remove the old original location comment entirely
      // later on the patch function will know what to do
      // and move this to the correct spot if need be
            t["s-ol"].remove();
      t["s-ol"] = undefined;
      // Reset so we can correctly move the node around again.
            t["s-sh"] = undefined;
      c = true;
    }
    if (n) {
      putBackInOriginalLocation(t, n);
    }
  }
  O._$$flags$$_ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
};

/**
 * Create DOM nodes corresponding to a list of {@link d.Vnode} objects and
 * add them to the DOM in the appropriate place.
 *
 * @param parentElm the DOM node which should be used as a parent for the new
 * DOM nodes
 * @param before a child of the `parentElm` which the new children should be
 * inserted before (optional)
 * @param parentVNode the parent virtual DOM node
 * @param vnodes the new child virtual DOM nodes to produce DOM nodes for
 * @param startIdx the index in the child virtual DOM nodes at which to start
 * creating DOM nodes (inclusive)
 * @param endIdx the index in the child virtual DOM nodes at which to stop
 * creating DOM nodes (inclusive)
 */ const addVnodes = (e, t, n, s, l, i) => {
  let c = e["s-cr"] && e["s-cr"].parentNode || e;
  let r;
  if (c.shadowRoot && c.tagName === o) {
    c = c.shadowRoot;
  }
  for (;l <= i; ++l) {
    if (s[l]) {
      r = createElm(null, n, l, e);
      if (r) {
        s[l]._$$elm$$_ = r;
        c.insertBefore(r, referenceNode(t));
      }
    }
  }
};

/**
 * Remove the DOM elements corresponding to a list of {@link d.VNode} objects.
 * This can be used to, for instance, clean up after a list of children which
 * should no longer be shown.
 *
 * This function also handles some of Stencil's slot relocation logic.
 *
 * @param vnodes a list of virtual DOM nodes to remove
 * @param startIdx the index at which to start removing nodes (inclusive)
 * @param endIdx the index at which to stop removing nodes (inclusive)
 */ const removeVnodes = (e, t, n) => {
  for (let s = t; s <= n; ++s) {
    const t = e[s];
    if (t) {
      const e = t._$$elm$$_;
      nullifyVNodeRefs(t);
      if (e) {
        {
          // we're removing this element
          // so it's possible we need to show slot fallback content now
          i = true;
          if (e["s-ol"]) {
            // remove the original location comment
            e["s-ol"].remove();
          } else {
            // it's possible that child nodes of the node
            // that's being removed are slot nodes
            putBackInOriginalLocation(e, true);
          }
        }
        // remove the vnode's element from the dom
                e.remove();
      }
    }
  }
};

/**
 * Reconcile the children of a new VNode with the children of an old VNode by
 * traversing the two collections of children, identifying nodes that are
 * conserved or changed, calling out to `patch` to make any necessary
 * updates to the DOM, and rearranging DOM nodes as needed.
 *
 * The algorithm for reconciling children works by analyzing two 'windows' onto
 * the two arrays of children (`oldCh` and `newCh`). We keep track of the
 * 'windows' by storing start and end indices and references to the
 * corresponding array entries. Initially the two 'windows' are basically equal
 * to the entire array, but we progressively narrow the windows until there are
 * no children left to update by doing the following:
 *
 * 1. Skip any `null` entries at the beginning or end of the two arrays, so
 *    that if we have an initial array like the following we'll end up dealing
 *    only with a window bounded by the highlighted elements:
 *
 *    [null, null, VNode1 , ... , VNode2, null, null]
 *                 ^^^^^^         ^^^^^^
 *
 * 2. Check to see if the elements at the head and tail positions are equal
 *    across the windows. This will basically detect elements which haven't
 *    been added, removed, or changed position, i.e. if you had the following
 *    VNode elements (represented as HTML):
 *
 *    oldVNode: `<div><p><span>HEY</span></p></div>`
 *    newVNode: `<div><p><span>THERE</span></p></div>`
 *
 *    Then when comparing the children of the `<div>` tag we check the equality
 *    of the VNodes corresponding to the `<p>` tags and, since they are the
 *    same tag in the same position, we'd be able to avoid completely
 *    re-rendering the subtree under them with a new DOM element and would just
 *    call out to `patch` to handle reconciling their children and so on.
 *
 * 3. Check, for both windows, to see if the element at the beginning of the
 *    window corresponds to the element at the end of the other window. This is
 *    a heuristic which will let us identify _some_ situations in which
 *    elements have changed position, for instance it _should_ detect that the
 *    children nodes themselves have not changed but merely moved in the
 *    following example:
 *
 *    oldVNode: `<div><element-one /><element-two /></div>`
 *    newVNode: `<div><element-two /><element-one /></div>`
 *
 *    If we find cases like this then we also need to move the concrete DOM
 *    elements corresponding to the moved children to write the re-order to the
 *    DOM.
 *
 * 4. Finally, if VNodes have the `key` attribute set on them we check for any
 *    nodes in the old children which have the same key as the first element in
 *    our window on the new children. If we find such a node we handle calling
 *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
 *    what we find.
 *
 * Finally, once we've narrowed our 'windows' to the point that either of them
 * collapse (i.e. they have length 0) we then handle any remaining VNode
 * insertion or deletion that needs to happen to get a DOM state that correctly
 * reflects the new child VNodes. If, for instance, after our window on the old
 * children has collapsed we still have more nodes on the new children that
 * we haven't dealt with yet then we need to add them, or if the new children
 * collapse but we still have unhandled _old_ children then we need to make
 * sure the corresponding DOM nodes are removed.
 *
 * @param parentElm the node into which the parent VNode is rendered
 * @param oldCh the old children of the parent node
 * @param newVNode the new VNode which will replace the parent
 * @param newCh the new children of the parent node
 * @param isInitialRender whether or not this is the first render of the vdom
 */ const updateChildren = (e, t, n, s, o = false) => {
  let l = 0;
  let i = 0;
  let c = 0;
  let r = 0;
  let f = t.length - 1;
  let u = t[0];
  let a = t[f];
  let d = s.length - 1;
  let p = s[0];
  let v = s[d];
  let m;
  let y;
  while (l <= f && i <= d) {
    if (u == null) {
      // VNode might have been moved left
      u = t[++l];
    } else if (a == null) {
      a = t[--f];
    } else if (p == null) {
      p = s[++i];
    } else if (v == null) {
      v = s[--d];
    } else if (isSameVnode(u, p, o)) {
      // if the start nodes are the same then we should patch the new VNode
      // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
      // indices to reflect that. We don't need to move any DOM Nodes around
      // since things are matched up in order.
      patch(u, p, o);
      u = t[++l];
      p = s[++i];
    } else if (isSameVnode(a, v, o)) {
      // likewise, if the end nodes are the same we patch new onto old and
      // decrement our end indices, and also likewise in this case we don't
      // need to move any DOM Nodes.
      patch(a, v, o);
      a = t[--f];
      v = s[--d];
    } else if (isSameVnode(u, v, o)) {
      // case: "Vnode moved right"
      // We've found that the last node in our window on the new children is
      // the same VNode as the _first_ node in our window on the old children
      // we're dealing with now. Visually, this is the layout of these two
      // nodes:
      // newCh: [..., newStartVnode , ... , newEndVnode , ...]
      //                                    ^^^^^^^^^^^
      // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
      //              ^^^^^^^^^^^^^
      // In this situation we need to patch `newEndVnode` onto `oldStartVnode`
      // and move the DOM element for `oldStartVnode`.
      if (u._$$tag$$_ === "slot" || v._$$tag$$_ === "slot") {
        putBackInOriginalLocation(u._$$elm$$_.parentNode, false);
      }
      patch(u, v, o);
      // We need to move the element for `oldStartVnode` into a position which
      // will be appropriate for `newEndVnode`. For this we can use
      // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
      // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
      // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
      
      // <old-start-node />
      // <some-intervening-node />
      // <old-end-node />
      // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
      // <next-sibling />
      
      // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
      // the node for `oldStartVnode` at the end of the children of
      // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
      // aren't any siblings, and passing `null` to `Node.insertBefore` will
      // append it to the children of the parent element.
            e.insertBefore(u._$$elm$$_, a._$$elm$$_.nextSibling);
      u = t[++l];
      v = s[--d];
    } else if (isSameVnode(a, p, o)) {
      // case: "Vnode moved left"
      // We've found that the first node in our window on the new children is
      // the same VNode as the _last_ node in our window on the old children.
      // Visually, this is the layout of these two nodes:
      // newCh: [..., newStartVnode , ... , newEndVnode , ...]
      //              ^^^^^^^^^^^^^
      // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
      //                                    ^^^^^^^^^^^
      // In this situation we need to patch `newStartVnode` onto `oldEndVnode`
      // (which will handle updating any changed attributes, reconciling their
      // children etc) but we also need to move the DOM node to which
      // `oldEndVnode` corresponds.
      if (u._$$tag$$_ === "slot" || v._$$tag$$_ === "slot") {
        putBackInOriginalLocation(a._$$elm$$_.parentNode, false);
      }
      patch(a, p, o);
      // We've already checked above if `oldStartVnode` and `newStartVnode` are
      // the same node, so since we're here we know that they are not. Thus we
      // can move the element for `oldEndVnode` _before_ the element for
      // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
      // future.
            e.insertBefore(a._$$elm$$_, u._$$elm$$_);
      a = t[--f];
      p = s[++i];
    } else {
      // Here we do some checks to match up old and new nodes based on the
      // `$key$` attribute, which is set by putting a `key="my-key"` attribute
      // in the JSX for a DOM element in the implementation of a Stencil
      // component.
      // First we check to see if there are any nodes in the array of old
      // children which have the same key as the first node in the new
      // children.
      c = -1;
      {
        for (r = l; r <= f; ++r) {
          if (t[r] && t[r]._$$key$$_ !== null && t[r]._$$key$$_ === p._$$key$$_) {
            c = r;
            break;
          }
        }
      }
      if (c >= 0) {
        // We found a node in the old children which matches up with the first
        // node in the new children! So let's deal with that
        y = t[c];
        if (y._$$tag$$_ !== p._$$tag$$_) {
          // the tag doesn't match so we'll need a new DOM element
          m = createElm(t && t[i], n, c, e);
        } else {
          patch(y, p, o);
          // invalidate the matching old node so that we won't try to update it
          // again later on
                    t[c] = undefined;
          m = y._$$elm$$_;
        }
        p = s[++i];
      } else {
        // We either didn't find an element in the old children that matches
        // the key of the first new child OR the build is not using `key`
        // attributes at all. In either case we need to create a new element
        // for the new node.
        m = createElm(t && t[i], n, i, e);
        p = s[++i];
      }
      if (m) {
        // if we created a new node then handle inserting it to the DOM
        {
          parentReferenceNode(u._$$elm$$_).insertBefore(m, referenceNode(u._$$elm$$_));
        }
      }
    }
  }
  if (l > f) {
    // we have some more new nodes to add which don't match up with old nodes
    addVnodes(e, s[d + 1] == null ? null : s[d + 1]._$$elm$$_, n, s, i, d);
  } else if (i > d) {
    // there are nodes in the `oldCh` array which no longer correspond to nodes
    // in the new array, so lets remove them (which entails cleaning up the
    // relevant DOM nodes)
    removeVnodes(t, l, f);
  }
};

/**
 * Compare two VNodes to determine if they are the same
 *
 * **NB**: This function is an equality _heuristic_ based on the available
 * information set on the two VNodes and can be misleading under certain
 * circumstances. In particular, if the two nodes do not have `key` attrs
 * (available under `$key$` on VNodes) then the function falls back on merely
 * checking that they have the same tag.
 *
 * So, in other words, if `key` attrs are not set on VNodes which may be
 * changing order within a `children` array or something along those lines then
 * we could obtain a false negative and then have to do needless re-rendering
 * (i.e. we'd say two VNodes aren't equal when in fact they should be).
 *
 * @param leftVNode the first VNode to check
 * @param rightVNode the second VNode to check
 * @param isInitialRender whether or not this is the first render of the vdom
 * @returns whether they're equal or not
 */ const isSameVnode = (e, t, n = false) => {
  // compare if two vnode to see if they're "technically" the same
  // need to have the same element tag, and same key to be the same
  if (e._$$tag$$_ === t._$$tag$$_) {
    if (e._$$tag$$_ === "slot") {
      return e._$$name$$_ === t._$$name$$_;
    }
    // this will be set if JSX tags in the build have `key` attrs set on them
    // we only want to check this if we're not on the first render since on
    // first render `leftVNode.$key$` will always be `null`, so we can be led
    // astray and, for instance, accidentally delete a DOM node that we want to
    // keep around.
        if (!n) {
      return e._$$key$$_ === t._$$key$$_;
    }
    return true;
  }
  return false;
};

const referenceNode = e => e && e["s-ol"] || e;

const parentReferenceNode = e => (e["s-ol"] ? e["s-ol"] : e).parentNode
/**
 * Handle reconciling an outdated VNode with a new one which corresponds to
 * it. This function handles flushing updates to the DOM and reconciling the
 * children of the two nodes (if any).
 *
 * @param oldVNode an old VNode whose DOM element and children we want to update
 * @param newVNode a new VNode representing an updated version of the old one
 * @param isInitialRender whether or not this is the first render of the vdom
 */;

const patch = (e, t, n = false) => {
  const s = t._$$elm$$_ = e._$$elm$$_;
  const o = e._$$children$$_;
  const i = t._$$children$$_;
  const c = t._$$tag$$_;
  const f = t._$$text$$_;
  let u;
  if (f === null) {
    {
      // test if we're rendering an svg element, or still rendering nodes inside of one
      // only add this to the when the compiler sees we're using an svg somewhere
      r = c === "svg" ? true : c === "foreignObject" ? false : r;
    }
    {
      if (c === "slot" && !l) ; else {
        // either this is the first render of an element OR it's an update
        // AND we already know it's possible it could have changed
        // this updates the element's css classes, attrs, props, listeners, etc.
        updateElement(e, t, r);
      }
    }
    if (o !== null && i !== null) {
      // looks like there's child vnodes for both the old and new vnodes
      // so we need to call `updateChildren` to reconcile them
      updateChildren(s, o, t, i, n);
    } else if (i !== null) {
      // no old child vnodes, but there are new child vnodes to add
      if (e._$$text$$_ !== null) {
        // the old vnode was text, so be sure to clear it out
        s.textContent = "";
      }
      // add the new vnode children
            addVnodes(s, null, t, i, 0, i.length - 1);
    } else if (o !== null) {
      // no new child vnodes, but there are old child vnodes to remove
      removeVnodes(o, 0, o.length - 1);
    }
    if (r && c === "svg") {
      r = false;
    }
  } else if (u = s["s-cr"]) {
    // this element has slotted content
    u.parentNode.textContent = f;
  } else if (e._$$text$$_ !== f) {
    // update the text content for the text only vnode
    // and also only if the text is different than before
    s.data = f;
  }
};

/**
 * Adjust the `.hidden` property as-needed on any nodes in a DOM subtree which
 * are slot fallbacks nodes.
 *
 * A slot fallback node should be visible by default. Then, it should be
 * conditionally hidden if:
 *
 * - it has a sibling with a `slot` property set to its slot name or if
 * - it is a default fallback slot node, in which case we hide if it has any
 *   content
 *
 * @param elm the element of interest
 */ const updateFallbackSlotVisibility = e => {
  const t = e.childNodes;
  for (const e of t) {
    if (e.nodeType === 1 /* NODE_TYPE.ElementNode */) {
      if (e["s-sr"]) {
        // this is a slot fallback node
        // get the slot name for this slot reference node
        const n = e["s-sn"];
        // by default always show a fallback slot node
        // then hide it if there are other slots in the light dom
                e.hidden = false;
        // we need to check all of its sibling nodes in order to see if
        // `childNode` should be hidden
                for (const s of t) {
          // Don't check the node against itself
          if (s !== e) {
            if (s["s-hn"] !== e["s-hn"] || n !== "") {
              // this sibling node is from a different component OR is a named
              // fallback slot node
              if (s.nodeType === 1 /* NODE_TYPE.ElementNode */ && (n === s.getAttribute("slot") || n === s["s-sn"])) {
                e.hidden = true;
                break;
              }
            } else {
              // this is a default fallback slot node
              // any element or text node (with content)
              // should hide the default fallback slot node
              if (s.nodeType === 1 /* NODE_TYPE.ElementNode */ || s.nodeType === 3 /* NODE_TYPE.TextNode */ && s.textContent.trim() !== "") {
                e.hidden = true;
                break;
              }
            }
          }
        }
      }
      // keep drilling down
            updateFallbackSlotVisibility(e);
    }
  }
};

/**
 * Component-global information about nodes which are either currently being
 * relocated or will be shortly.
 */ const k = [];

/**
 * Mark the contents of a slot for relocation via adding references to them to
 * the {@link relocateNodes} data structure. The actual work of relocating them
 * will then be handled in {@link renderVdom}.
 *
 * @param elm a render node whose child nodes need to be relocated
 */ const markSlotContentForRelocation = e => {
  // tslint:disable-next-line: prefer-const
  let n;
  let s;
  let o;
  for (const l of e.childNodes) {
    // we need to find child nodes which are slot references so we can then try
    // to match them up with nodes that need to be relocated
    if (l["s-sr"] && (n = l["s-cr"]) && n.parentNode) {
      // first get the content reference comment node ('s-cr'), then we get
      // its parent, which is where all the host content is now
      s = n.parentNode.childNodes;
      const e = l["s-sn"];
      // iterate through all the nodes under the location where the host was
      // originally rendered
            for (o = s.length - 1; o >= 0; o--) {
        n = s[o];
        // check that the node is not a content reference node or a node
        // reference and then check that the host name does not match that of
        // childNode.
        // In addition, check that the slot either has not already been relocated, or
        // that its current location's host is not childNode's host. This is essentially
        // a check so that we don't try to relocate (and then hide) a node that is already
        // where it should be.
                if (!n["s-cn"] && !n["s-nr"] && n["s-hn"] !== l["s-hn"] && !t.experimentalSlotFixes) {
          // if `node` is located in the slot that `childNode` refers to (via the
          // `'s-sn'` property) then we need to relocate it from it's current spot
          // (under the host element parent) to the right slot location
          if (isNodeLocatedInSlot(n, e)) {
            // it's possible we've already decided to relocate this node
            let t = k.find((e => e._$$nodeToRelocate$$_ === n));
            // made some changes to slots
            // let's make sure we also double check
            // fallbacks are correctly hidden or shown
                        i = true;
            // ensure that the slot-name attr is correct
                        n["s-sn"] = n["s-sn"] || e;
            if (t) {
              t._$$nodeToRelocate$$_["s-sh"] = l["s-hn"];
              // we marked this node for relocation previously but didn't find
              // out the slot reference node to which it needs to be relocated
              // so write it down now!
                            t._$$slotRefNode$$_ = l;
            } else {
              n["s-sh"] = l["s-hn"];
              // add to our list of nodes to relocate
                            k.push({
                _$$slotRefNode$$_: l,
                _$$nodeToRelocate$$_: n
              });
            }
            if (n["s-sr"]) {
              k.map((e => {
                if (isNodeLocatedInSlot(e._$$nodeToRelocate$$_, n["s-sn"])) {
                  t = k.find((e => e._$$nodeToRelocate$$_ === n));
                  if (t && !e._$$slotRefNode$$_) {
                    e._$$slotRefNode$$_ = t._$$slotRefNode$$_;
                  }
                }
              }));
            }
          } else if (!k.some((e => e._$$nodeToRelocate$$_ === n))) {
            // the node is not found within the slot (`childNode`) that we're
            // currently looking at, so we stick it into `relocateNodes` to
            // handle later. If we never find a home for this element then
            // we'll need to hide it
            k.push({
              _$$nodeToRelocate$$_: n
            });
          }
        }
      }
    }
    // if we're dealing with any type of element (capable of itself being a
    // slot reference or containing one) then we recur
        if (l.nodeType === 1 /* NODE_TYPE.ElementNode */) {
      markSlotContentForRelocation(l);
    }
  }
};

/**
 * Check whether a node is located in a given named slot.
 *
 * @param nodeToRelocate the node of interest
 * @param slotName the slot name to check
 * @returns whether the node is located in the slot or not
 */ const isNodeLocatedInSlot = (e, t) => {
  if (e.nodeType === 1 /* NODE_TYPE.ElementNode */) {
    if (e.getAttribute("slot") === null && t === "") {
      // if the node doesn't have a slot attribute, and the slot we're checking
      // is not a named slot, then we assume the node should be within the slot
      return true;
    }
    if (e.getAttribute("slot") === t) {
      return true;
    }
    return false;
  }
  if (e["s-sn"] === t) {
    return true;
  }
  return t === "";
};

/**
 * 'Nullify' any VDom `ref` callbacks on a VDom node or its children by calling
 * them with `null`. This signals that the DOM element corresponding to the VDom
 * node has been removed from the DOM.
 *
 * @param vNode a virtual DOM node
 */ const nullifyVNodeRefs = e => {
  {
    e._$$attrs$$_ && e._$$attrs$$_.ref && e._$$attrs$$_.ref(null);
    e._$$children$$_ && e._$$children$$_.map(nullifyVNodeRefs);
  }
};

/**
 * The main entry point for Stencil's virtual DOM-based rendering engine
 *
 * Given a {@link d.HostRef} container and some virtual DOM nodes, this
 * function will handle creating a virtual DOM tree with a single root, patching
 * the current virtual DOM tree onto an old one (if any), dealing with slot
 * relocation, and reflecting attributes.
 *
 * @param hostRef data needed to root and render the virtual DOM tree, such as
 * the DOM node into which it should be rendered.
 * @param renderFnResults the virtual DOM nodes to be rendered
 * @param isInitialLoad whether or not this is the first call after page load
 */ const renderVdom = (e, t, r = false) => {
  var f, u, a, d;
  const p = e.$hostElement$;
  const v = e._$$cmpMeta$$_;
  const m = e._$$vnode$$_ || newVNode(null, null);
  // if `renderFnResults` is a Host node then we can use it directly. If not,
  // we need to call `h` again to wrap the children of our component in a
  // 'dummy' Host node (well, an empty vnode) since `renderVdom` assumes
  // implicitly that the top-level vdom node is 1) an only child and 2)
  // contains attrs that need to be set on the host element.
    const y = isHost(t) ? t : h(null, null, t);
  o = p.tagName;
  if (v._$$attrsToReflect$$_) {
    y._$$attrs$$_ = y._$$attrs$$_ || {};
    v._$$attrsToReflect$$_.map((([e, t]) => y._$$attrs$$_[t] = p[e]));
  }
  // On the first render and *only* on the first render we want to check for
  // any attributes set on the host element which are also set on the vdom
  // node. If we find them, we override the value on the VDom node attrs with
  // the value from the host element, which allows developers building apps
  // with Stencil components to override e.g. the `role` attribute on a
  // component even if it's already set on the `Host`.
    if (r && y._$$attrs$$_) {
    for (const e of Object.keys(y._$$attrs$$_)) {
      // We have a special implementation in `setAccessor` for `style` and
      // `class` which reconciles values coming from the VDom with values
      // already present on the DOM element, so we don't want to override those
      // attributes on the VDom tree with values from the host element if they
      // are present.
      // Likewise, `ref` and `key` are special internal values for the Stencil
      // runtime and we don't want to override those either.
      if (p.hasAttribute(e) && ![ "key", "ref", "style", "class" ].includes(e)) {
        y._$$attrs$$_[e] = p[e];
      }
    }
  }
  y._$$tag$$_ = null;
  y._$$flags$$_ |= 4 /* VNODE_FLAGS.isHost */;
  e._$$vnode$$_ = y;
  y._$$elm$$_ = m._$$elm$$_ = p.shadowRoot || p;
  {
    n = p["s-sc"];
  }
  l = (v._$$flags$$_ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;
  {
    s = p["s-cr"];
    // always reset
        i = false;
  }
  // synchronous patch
    patch(m, y, r);
  {
    // while we're moving nodes around existing nodes, temporarily disable
    // the disconnectCallback from working
    O._$$flags$$_ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
    if (c) {
      markSlotContentForRelocation(y._$$elm$$_);
      for (const e of k) {
        const t = e._$$nodeToRelocate$$_;
        if (!t["s-ol"]) {
          // add a reference node marking this node's original location
          // keep a reference to this node for later lookups
          const e = originalLocationDebugNode(t);
          e["s-nr"] = t;
          t.parentNode.insertBefore(t["s-ol"] = e, t);
        }
      }
      for (const e of k) {
        const t = e._$$nodeToRelocate$$_;
        const n = e._$$slotRefNode$$_;
        if (n) {
          const e = n.parentNode;
          // When determining where to insert content, the most simple case would be
          // to relocate the node immediately following the slot reference node. We do this
          // by getting a reference to the node immediately following the slot reference node
          // since we will use `insertBefore` to manipulate the DOM.
          
          // If there is no node immediately following the slot reference node, then we will just
          // end up appending the node as the last child of the parent.
                    let s = n.nextSibling;
          // If the node we're currently planning on inserting the new node before is an element,
          // we need to do some additional checks to make sure we're inserting the node in the correct order.
          // The use case here would be that we have multiple nodes being relocated to the same slot. So, we want
          // to make sure they get inserted into their new home in the same order they were declared in their original location.
          
          // TODO(STENCIL-914): Remove `experimentalSlotFixes` check
                    {
            let n = (f = t["s-ol"]) === null || f === void 0 ? void 0 : f.previousSibling;
            while (n) {
              let o = (u = n["s-nr"]) !== null && u !== void 0 ? u : null;
              if (o && o["s-sn"] === t["s-sn"] && e === o.parentNode) {
                o = o.nextSibling;
                if (!o || !o["s-nr"]) {
                  s = o;
                  break;
                }
              }
              n = n.previousSibling;
            }
          }
          if (!s && e !== t.parentNode || t.nextSibling !== s) {
            // we've checked that it's worth while to relocate
            // since that the node to relocate
            // has a different next sibling or parent relocated
            if (t !== s) {
              if (!t["s-hn"] && t["s-ol"]) {
                // probably a component in the index.html that doesn't have its hostname set
                t["s-hn"] = t["s-ol"].parentNode.nodeName;
              }
              // Add it back to the dom but in its new home
              // If we get to this point and `insertBeforeNode` is `null`, that means
              // we're just going to append the node as the last child of the parent. Passing
              // `null` as the second arg here will trigger that behavior.
                            e.insertBefore(t, s);
              // Reset the `hidden` value back to what it was defined as originally
              // This solves a problem where a `slot` is dynamically rendered and `hidden` may have
              // been set on content originally, but now it has a slot to go to so it should have
              // the value it was defined as having in the DOM, not what we overrode it to.
                            if (t.nodeType === 1 /* NODE_TYPE.ElementNode */) {
                t.hidden = (a = t["s-ih"]) !== null && a !== void 0 ? a : false;
              }
            }
          }
          t && typeof n["s-rf"] === "function" && n["s-rf"](t);
        } else {
          // this node doesn't have a slot home to go to, so let's hide it
          if (t.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            // Store the initial value of `hidden` so we can reset it later when
            // moving nodes around.
            if (r) {
              t["s-ih"] = (d = t.hidden) !== null && d !== void 0 ? d : false;
            }
            t.hidden = true;
          }
        }
      }
    }
    if (i) {
      updateFallbackSlotVisibility(y._$$elm$$_);
    }
    // done moving nodes around
    // allow the disconnect callback to work again
        O._$$flags$$_ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
    // always reset
        k.length = 0;
  }
  // Clear the content ref so we don't create a memory leak
    s = undefined;
};

// slot comment debug nodes only created with the `--debug` flag
// otherwise these nodes are text nodes w/out content
const slotReferenceDebugNode = e => j.createComment(`<slot${e._$$name$$_ ? ' name="' + e._$$name$$_ + '"' : ""}> (host=${o.toLowerCase()})`);

const originalLocationDebugNode = e => j.createComment(`org-location for ` + (e.localName ? `<${e.localName}> (host=${e["s-hn"]})` : `[${e.textContent}]`));

const attachToAncestor = (e, t) => {
  if (t && !e._$$onRenderResolve$$_ && t["s-p"]) {
    t["s-p"].push(new Promise((t => e._$$onRenderResolve$$_ = t)));
  }
};

const scheduleUpdate = (e, t) => {
  {
    e._$$flags$$_ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
  }
  if (e._$$flags$$_ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
    e._$$flags$$_ |= 512 /* HOST_FLAGS.needsRerender */;
    return;
  }
  attachToAncestor(e, e._$$ancestorComponent$$_);
  // there is no ancestor component or the ancestor component
  // has already fired off its lifecycle update then
  // fire off the initial update
    const dispatch = () => dispatchHooks(e, t);
  return A(dispatch);
};

/**
 * Dispatch initial-render and update lifecycle hooks, enqueuing calls to
 * component lifecycle methods like `componentWillLoad` as well as
 * {@link updateComponent}, which will kick off the virtual DOM re-render.
 *
 * @param hostRef a reference to a host DOM node
 * @param isInitialLoad whether we're on the initial load or not
 * @returns an empty Promise which is used to enqueue a series of operations for
 * the component
 */ const dispatchHooks = (e, t) => {
  const n = e.$hostElement$;
  const s = createTime("scheduleUpdate", e._$$cmpMeta$$_._$$tagName$$_);
  const o = e._$$lazyInstance$$_;
  // We're going to use this variable together with `enqueue` to implement a
  // little promise-based queue. We start out with it `undefined`. When we add
  // the first function to the queue we'll set this variable to be that
  // function's return value. When we attempt to add subsequent values to the
  // queue we'll check that value and, if it was a `Promise`, we'll then chain
  // the new function off of that `Promise` using `.then()`. This will give our
  // queue two nice properties:
  
  // 1. If all functions added to the queue are synchronous they'll be called
  //    synchronously right away.
  // 2. If all functions added to the queue are asynchronous they'll all be
  //    called in order after `dispatchHooks` exits.
    let l;
  if (t) {
    {
      e._$$flags$$_ |= 256 /* HOST_FLAGS.isListenReady */;
      if (e._$$queuedListeners$$_) {
        e._$$queuedListeners$$_.map((([e, t]) => safeCall(o, e, t)));
        e._$$queuedListeners$$_ = undefined;
      }
    }
    emitLifecycleEvent(n, "componentWillLoad");
    {
      // If `componentWillLoad` returns a `Promise` then we want to wait on
      // whatever's going on in that `Promise` before we launch into
      // rendering the component, doing other lifecycle stuff, etc. So
      // in that case we assign the returned promise to the variable we
      // declared above to hold a possible 'queueing' Promise
      l = safeCall(o, "componentWillLoad");
    }
  } else {
    emitLifecycleEvent(n, "componentWillUpdate");
    {
      // Like `componentWillLoad` above, we allow Stencil component
      // authors to return a `Promise` from this lifecycle callback, and
      // we specify that our runtime will wait for that `Promise` to
      // resolve before the component re-renders. So if the method
      // returns a `Promise` we need to keep it around!
      l = safeCall(o, "componentWillUpdate");
    }
  }
  emitLifecycleEvent(n, "componentWillRender");
  {
    l = enqueue(l, (() => safeCall(o, "componentWillRender")));
  }
  s();
  return enqueue(l, (() => updateComponent(e, o, t)));
};

/**
 * This function uses a Promise to implement a simple first-in, first-out queue
 * of functions to be called.
 *
 * The queue is ordered on the basis of the first argument. If it's
 * `undefined`, then nothing is on the queue yet, so the provided function can
 * be called synchronously (although note that this function may return a
 * `Promise`). The idea is that then the return value of that enqueueing
 * operation is kept around, so that if it was a `Promise` then subsequent
 * functions can be enqueued by calling this function again with that `Promise`
 * as the first argument.
 *
 * @param maybePromise either a `Promise` which should resolve before the next function is called or an 'empty' sentinel
 * @param fn a function to enqueue
 * @returns either a `Promise` or the return value of the provided function
 */ const enqueue = (e, t) => isPromisey(e) ? e.then(t) : t()
/**
 * Check that a value is a `Promise`. To check, we first see if the value is an
 * instance of the `Promise` global. In a few circumstances, in particular if
 * the global has been overwritten, this is could be misleading, so we also do
 * a little 'duck typing' check to see if the `.then` property of the value is
 * defined and a function.
 *
 * @param maybePromise it might be a promise!
 * @returns whether it is or not
 */;

const isPromisey = e => e instanceof Promise || e && e.then && typeof e.then === "function"
/**
 * Update a component given reference to its host elements and so on.
 *
 * @param hostRef an object containing references to the element's host node,
 * VDom nodes, and other metadata
 * @param instance a reference to the underlying host element where it will be
 * rendered
 * @param isInitialLoad whether or not this function is being called as part of
 * the first render cycle
 */;

const updateComponent = async (e, t, n) => {
  var s;
  const o = e.$hostElement$;
  const l = createTime("update", e._$$cmpMeta$$_._$$tagName$$_);
  const i = o["s-rc"];
  if (n) {
    // DOM WRITE!
    attachStyles(e);
  }
  const c = createTime("render", e._$$cmpMeta$$_._$$tagName$$_);
  {
    callRender(e, t, o, n);
  }
  if (i) {
    // ok, so turns out there are some child host elements
    // waiting on this parent element to load
    // let's fire off all update callbacks waiting
    i.map((e => e()));
    o["s-rc"] = undefined;
  }
  c();
  l();
  {
    const t = (s = o["s-p"]) !== null && s !== void 0 ? s : [];
    const postUpdate = () => postUpdateComponent(e);
    if (t.length === 0) {
      postUpdate();
    } else {
      Promise.all(t).then(postUpdate);
      e._$$flags$$_ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
      t.length = 0;
    }
  }
};

/**
 * Handle making the call to the VDom renderer with the proper context given
 * various build variables
 *
 * @param hostRef an object containing references to the element's host node,
 * VDom nodes, and other metadata
 * @param instance a reference to the underlying host element where it will be
 * rendered
 * @param elm the Host element for the component
 * @param isInitialLoad whether or not this function is being called as part of
 * @returns an empty promise
 */ const callRender = (e, t, n, s) => {
  try {
    f = t;
    /**
         * minification optimization: `allRenderFn` is `true` if all components have a `render`
         * method, so we can call the method immediately. If not, check before calling it.
         */    t = t.render && t.render();
    {
      e._$$flags$$_ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
    }
    {
      e._$$flags$$_ |= 2 /* HOST_FLAGS.hasRendered */;
    }
    {
      {
        // looks like we've got child nodes to render into this host element
        // or we need to update the css class/attrs on the host element
        // DOM WRITE!
        {
          renderVdom(e, t, s);
        }
      }
    }
  } catch (t) {
    consoleError(t, e.$hostElement$);
  }
  f = null;
  return null;
};

const getRenderingRef = () => f;

const postUpdateComponent = e => {
  const t = e._$$cmpMeta$$_._$$tagName$$_;
  const n = e.$hostElement$;
  const s = createTime("postUpdate", t);
  const o = e._$$lazyInstance$$_;
  const l = e._$$ancestorComponent$$_;
  {
    safeCall(o, "componentDidRender");
  }
  emitLifecycleEvent(n, "componentDidRender");
  if (!(e._$$flags$$_ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
    e._$$flags$$_ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
    {
      // DOM WRITE!
      addHydratedFlag(n);
    }
    {
      safeCall(o, "componentDidLoad");
    }
    emitLifecycleEvent(n, "componentDidLoad");
    s();
    {
      e._$$onReadyResolve$$_(n);
      if (!l) {
        appDidLoad();
      }
    }
  } else {
    {
      safeCall(o, "componentDidUpdate");
    }
    emitLifecycleEvent(n, "componentDidUpdate");
    s();
  }
  {
    e._$$onInstanceResolve$$_(n);
  }
  // load events fire from bottom to top
  // the deepest elements load first then bubbles up
    {
    if (e._$$onRenderResolve$$_) {
      e._$$onRenderResolve$$_();
      e._$$onRenderResolve$$_ = undefined;
    }
    if (e._$$flags$$_ & 512 /* HOST_FLAGS.needsRerender */) {
      nextTick((() => scheduleUpdate(e, false)));
    }
    e._$$flags$$_ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);
  }
  // ( _)
  // ( _)>-
  // (_)
};

const forceUpdate = e => {
  {
    const t = getHostRef(e);
    const n = t.$hostElement$.isConnected;
    if (n && (t._$$flags$$_ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
      scheduleUpdate(t, false);
    }
    // Returns "true" when the forced update was successfully scheduled
        return n;
  }
};

const appDidLoad = t => {
  // on appload
  // we have finish the first big initial render
  {
    addHydratedFlag(j.documentElement);
  }
  nextTick((() => emitEvent(L, "appload", {
    detail: {
      namespace: e
    }
  })));
};

/**
 * Allows to safely call a method, e.g. `componentDidLoad`, on an instance,
 * e.g. custom element node. If a build figures out that e.g. no component
 * has a `componentDidLoad` method, the instance method gets removed from the
 * output bundle and this function returns `undefined`.
 * @param instance any object that may or may not contain methods
 * @param method method name
 * @param arg single arbitrary argument
 * @returns result of method call if it exists, otherwise `undefined`
 */ const safeCall = (e, t, n) => {
  if (e && e[t]) {
    try {
      return e[t](n);
    } catch (e) {
      consoleError(e);
    }
  }
  return undefined;
};

/**
 * For debugging purposes as `BUILD.lifecycleDOMEvents` is `false` by default and will
 * get removed by the compiler. Used for timing events to see how long they take.
 * @param elm the target of the Event
 * @param lifecycleName name of the event
 */ const emitLifecycleEvent = (t, n) => {
  {
    emitEvent(t, "stencil_" + n, {
      bubbles: true,
      composed: true,
      detail: {
        namespace: e
      }
    });
  }
};

const addHydratedFlag = e => e.classList.add("hydrated");

const getValue = (e, t) => getHostRef(e)._$$instanceValues$$_.get(t);

const setValue = (e, t, n, s) => {
  // check our new property value against our internal value
  const o = getHostRef(e);
  const l = o.$hostElement$;
  const i = o._$$instanceValues$$_.get(t);
  const c = o._$$flags$$_;
  const r = o._$$lazyInstance$$_;
  n = parsePropertyValue(n, s._$$members$$_[t][0]);
  // explicitly check for NaN on both sides, as `NaN === NaN` is always false
    const f = Number.isNaN(i) && Number.isNaN(n);
  const u = n !== i && !f;
  if ((!(c & 8 /* HOST_FLAGS.isConstructingInstance */) || i === undefined) && u) {
    // gadzooks! the property's value has changed!!
    // set our new value!
    o._$$instanceValues$$_.set(t, n);
    if (r) {
      // get an array of method names of watch functions to call
      if (s._$$watchers$$_ && c & 128 /* HOST_FLAGS.isWatchReady */) {
        const e = s._$$watchers$$_[t];
        if (e) {
          // this instance is watching for when this property changed
          e.map((e => {
            try {
              // fire off each of the watch methods that are watching this property
              r[e](n, i, t);
            } catch (e) {
              consoleError(e, l);
            }
          }));
        }
      }
      if ((c & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
        if (r.componentShouldUpdate) {
          if (r.componentShouldUpdate(n, i, t) === false) {
            return;
          }
        }
        // looks like this value actually changed, so we've got work to do!
        // but only if we've already rendered, otherwise just chill out
        // queue that we need to do an update, but don't worry about queuing
        // up millions cuz this function ensures it only runs once
                scheduleUpdate(o, false);
      }
    }
  }
};

/**
 * Attach a series of runtime constructs to a compiled Stencil component
 * constructor, including getters and setters for the `@Prop` and `@State`
 * decorators, callbacks for when attributes change, and so on.
 *
 * @param Cstr the constructor for a component that we need to process
 * @param cmpMeta metadata collected previously about the component
 * @param flags a number used to store a series of bit flags
 * @returns a reference to the same constructor passed in (but now mutated)
 */ const proxyComponent = (e, t, n) => {
  var s;
  const o = e.prototype;
  if (t._$$members$$_) {
    if (e.watchers) {
      t._$$watchers$$_ = e.watchers;
    }
    // It's better to have a const than two Object.entries()
        const l = Object.entries(t._$$members$$_);
    l.map((([e, [s]]) => {
      if (s & 31 /* MEMBER_FLAGS.Prop */ || n & 2 /* PROXY_FLAGS.proxyState */ && s & 32 /* MEMBER_FLAGS.State */) {
        // proxyComponent - prop
        Object.defineProperty(o, e, {
          get() {
            // proxyComponent, get value
            return getValue(this, e);
          },
          set(n) {
            // proxyComponent, set value
            setValue(this, e, n, t);
          },
          configurable: true,
          enumerable: true
        });
      } else if (n & 1 /* PROXY_FLAGS.isElementConstructor */ && s & 64 /* MEMBER_FLAGS.Method */) {
        // proxyComponent - method
        Object.defineProperty(o, e, {
          value(...t) {
            var n;
            const s = getHostRef(this);
            return (n = s === null || s === void 0 ? void 0 : s._$$onInstancePromise$$_) === null || n === void 0 ? void 0 : n.then((() => {
              var n;
              return (n = s._$$lazyInstance$$_) === null || n === void 0 ? void 0 : n[e](...t);
            }));
          }
        });
      }
    }));
    if (n & 1 /* PROXY_FLAGS.isElementConstructor */) {
      const n = new Map;
      o.attributeChangedCallback = function(e, s, l) {
        O.jmp((() => {
          var i;
          const c = n.get(e);
          //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
          //  in the case where an attribute was set inline.
          //  ```html
          //    <my-component some-attribute="some-value"></my-component>
          //  ```
          
          //  There is an edge case where a developer sets the attribute inline on a custom element and then
          //  programmatically changes it before it has been upgraded as shown below:
          
          //  ```html
          //    <!-- this component has _not_ been upgraded yet -->
          //    <my-component id="test" some-attribute="some-value"></my-component>
          //    <script>
          //      // grab non-upgraded component
          //      el = document.querySelector("#test");
          //      el.someAttribute = "another-value";
          //      // upgrade component
          //      customElements.define('my-component', MyComponent);
          //    <\/script>
          //  ```
          //  In this case if we do not un-shadow here and use the value of the shadowing property, attributeChangedCallback
          //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
          //  to the value that was set inline i.e. "some-value" from above example. When
          //  the connectedCallback attempts to un-shadow it will use "some-value" as the initial value rather than "another-value"
          
          //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/un-shadowed
          //  by connectedCallback as this attributeChangedCallback will not fire.
          
          //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
          
          //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
          //  properties here given that this goes against best practices outlined here
          //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
                    if (this.hasOwnProperty(c)) {
            l = this[c];
            delete this[c];
          } else if (o.hasOwnProperty(c) && typeof this[c] === "number" && this[c] == l) {
            // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
            // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
            // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
            return;
          } else if (c == null) {
            // At this point we should know this is not a "member", so we can treat it like watching an attribute
            // on a vanilla web component
            const n = getHostRef(this);
            const o = n === null || n === void 0 ? void 0 : n._$$flags$$_;
            // We only want to trigger the callback(s) if:
            // 1. The instance is ready
            // 2. The watchers are ready
            // 3. The value has changed
                        if (o && !(o & 8 /* HOST_FLAGS.isConstructingInstance */) && o & 128 /* HOST_FLAGS.isWatchReady */ && l !== s) {
              const o = n._$$lazyInstance$$_;
              const c = (i = t._$$watchers$$_) === null || i === void 0 ? void 0 : i[e];
              c === null || c === void 0 ? void 0 : c.forEach((t => {
                if (o[t] != null) {
                  o[t].call(o, l, s, e);
                }
              }));
            }
            return;
          }
          this[c] = l === null && typeof this[c] === "boolean" ? false : l;
        }));
      };
      // Create an array of attributes to observe
      // This list in comprised of all strings used within a `@Watch()` decorator
      // on a component as well as any Stencil-specific "members" (`@Prop()`s and `@State()`s).
      // As such, there is no way to guarantee type-safety here that a user hasn't entered
      // an invalid attribute.
            e.observedAttributes = Array.from(new Set([ ...Object.keys((s = t._$$watchers$$_) !== null && s !== void 0 ? s : {}), ...l.filter((([e, t]) => t[0] & 15 /* MEMBER_FLAGS.HasAttribute */)).map((([e, s]) => {
        var o;
        const l = s[1] || e;
        n.set(l, e);
        if (s[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {
          (o = t._$$attrsToReflect$$_) === null || o === void 0 ? void 0 : o.push([ e, l ]);
        }
        return l;
      })) ]));
    }
  }
  return e;
};

/**
 * Initialize a Stencil component given a reference to its host element, its
 * runtime bookkeeping data structure, runtime metadata about the component,
 * and (optionally) an HMR version ID.
 *
 * @param elm a host element
 * @param hostRef the element's runtime bookkeeping object
 * @param cmpMeta runtime metadata for the Stencil component
 * @param hmrVersionId an (optional) HMR version ID
 */ const initializeComponent = async (e, t, n, s) => {
  let o;
  // initializeComponent
    if ((t._$$flags$$_ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
    // Let the runtime know that the component has been initialized
    t._$$flags$$_ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
    const s = n._$$lazyBundleId$$_;
    if (s) {
      // lazy loaded components
      // request the component's implementation to be
      // wired up with the host element
      o = loadModule(n);
      if (o.then) {
        // Await creates a micro-task avoid if possible
        const e = uniqueTime();
        o = await o;
        e();
      }
      if (!o) {
        throw new Error(`Constructor for "${n._$$tagName$$_}#${t._$$modeName$$_}" was not found`);
      }
      if (!o.isProxied) {
        // we've never proxied this Constructor before
        // let's add the getters/setters to its prototype before
        // the first time we create an instance of the implementation
        {
          n._$$watchers$$_ = o.watchers;
        }
        proxyComponent(o, n, 2 /* PROXY_FLAGS.proxyState */);
        o.isProxied = true;
      }
      const e = createTime("createInstance", n._$$tagName$$_);
      // ok, time to construct the instance
      // but let's keep track of when we start and stop
      // so that the getters/setters don't incorrectly step on data
            {
        t._$$flags$$_ |= 8 /* HOST_FLAGS.isConstructingInstance */;
      }
      // construct the lazy-loaded component implementation
      // passing the hostRef is very important during
      // construction in order to directly wire together the
      // host element and the lazy-loaded instance
            try {
        new o(t);
      } catch (e) {
        consoleError(e);
      }
      {
        t._$$flags$$_ &= ~8 /* HOST_FLAGS.isConstructingInstance */;
      }
      {
        t._$$flags$$_ |= 128 /* HOST_FLAGS.isWatchReady */;
      }
      e();
      fireConnectedCallback(t._$$lazyInstance$$_);
    } else {
      // sync constructor component
      o = e.constructor;
      // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,
      // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_
      // Stencil has completed instantiating the component.
            customElements.whenDefined(n._$$tagName$$_).then((() => t._$$flags$$_ |= 128 /* HOST_FLAGS.isWatchReady */));
    }
    if (o.style) {
      // this component has styles but we haven't registered them yet
      let e = o.style;
      const t = getScopeId(n);
      if (!x.has(t)) {
        const s = createTime("registerStyles", n._$$tagName$$_);
        registerStyle(t, e, !!(n._$$flags$$_ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
        s();
      }
    }
  }
  // we've successfully created a lazy instance
    const l = t._$$ancestorComponent$$_;
  const schedule = () => scheduleUpdate(t, true);
  if (l && l["s-rc"]) {
    // this is the initial load and this component it has an ancestor component
    // but the ancestor component has NOT fired its will update lifecycle yet
    // so let's just cool our jets and wait for the ancestor to continue first
    // this will get fired off when the ancestor component
    // finally gets around to rendering its lazy self
    // fire off the initial update
    l["s-rc"].push(schedule);
  } else {
    schedule();
  }
};

const fireConnectedCallback = e => {
  {
    safeCall(e, "connectedCallback");
  }
};

const connectedCallback = e => {
  if ((O._$$flags$$_ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
    const t = getHostRef(e);
    const n = t._$$cmpMeta$$_;
    const s = createTime("connectedCallback", n._$$tagName$$_);
    if (!(t._$$flags$$_ & 1 /* HOST_FLAGS.hasConnected */)) {
      // first time this component has connected
      t._$$flags$$_ |= 1 /* HOST_FLAGS.hasConnected */;
      {
        // initUpdate
        // if the slot polyfill is required we'll need to put some nodes
        // in here to act as original content anchors as we move nodes around
        // host element has been connected to the DOM
        if (// TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
        n._$$flags$$_ & (4 /* CMP_FLAGS.hasSlotRelocation */ | 8 /* CMP_FLAGS.needsShadowDomShim */)) {
          setContentReference(e);
        }
      }
      {
        // find the first ancestor component (if there is one) and register
        // this component as one of the actively loading child components for its ancestor
        let n = e;
        while (n = n.parentNode || n.host) {
          // climb up the ancestors looking for the first
          // component that hasn't finished its lifecycle update yet
          if (n["s-p"]) {
            // we found this components first ancestor component
            // keep a reference to this component's ancestor component
            attachToAncestor(t, t._$$ancestorComponent$$_ = n);
            break;
          }
        }
      }
      // Lazy properties
      // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
            if (n._$$members$$_) {
        Object.entries(n._$$members$$_).map((([t, [n]]) => {
          if (n & 31 /* MEMBER_FLAGS.Prop */ && e.hasOwnProperty(t)) {
            const n = e[t];
            delete e[t];
            e[t] = n;
          }
        }));
      }
      {
        initializeComponent(e, t, n);
      }
    } else {
      // not the first time this has connected
      // reattach any event listeners to the host
      // since they would have been removed when disconnected
      addHostEventListeners(e, t, n._$$listeners$$_);
      // fire off connectedCallback() on component instance
            if (t === null || t === void 0 ? void 0 : t._$$lazyInstance$$_) {
        fireConnectedCallback(t._$$lazyInstance$$_);
      } else if (t === null || t === void 0 ? void 0 : t._$$onReadyPromise$$_) {
        t._$$onReadyPromise$$_.then((() => fireConnectedCallback(t._$$lazyInstance$$_)));
      }
    }
    s();
  }
};

const setContentReference = e => {
  // only required when we're NOT using native shadow dom (slot)
  // or this browser doesn't support native shadow dom
  // and this host element was NOT created with SSR
  // let's pick out the inner content for slot projection
  // create a node to represent where the original
  // content was first placed, which is useful later on
  const t = e["s-cr"] = j.createComment(`content-ref (host=${e.localName})`);
  t["s-cn"] = true;
  e.insertBefore(t, e.firstChild);
};

const disconnectInstance = e => {
  {
    safeCall(e, "disconnectedCallback");
  }
};

const disconnectedCallback = async e => {
  if ((O._$$flags$$_ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
    const t = getHostRef(e);
    {
      if (t._$$rmListeners$$_) {
        t._$$rmListeners$$_.map((e => e()));
        t._$$rmListeners$$_ = undefined;
      }
    }
    if (t === null || t === void 0 ? void 0 : t._$$lazyInstance$$_) {
      disconnectInstance(t._$$lazyInstance$$_);
    } else if (t === null || t === void 0 ? void 0 : t._$$onReadyPromise$$_) {
      t._$$onReadyPromise$$_.then((() => disconnectInstance(t._$$lazyInstance$$_)));
    }
  }
};

const patchCloneNode = e => {
  const t = e.cloneNode;
  e.cloneNode = function(e) {
    const n = this;
    const s = n.shadowRoot && M;
    const o = t.call(n, s ? e : false);
    if (!s && e) {
      let e = 0;
      let t, s;
      const l = [ "s-id", "s-cr", "s-lr", "s-rc", "s-sc", "s-p", "s-cn", "s-sr", "s-sn", "s-hn", "s-ol", "s-nr", "s-si", "s-rf" ];
      for (;e < n.childNodes.length; e++) {
        t = n.childNodes[e]["s-nr"];
        s = l.every((t => !n.childNodes[e][t]));
        if (t) {
          if (o.__appendChild) {
            o.__appendChild(t.cloneNode(true));
          } else {
            o.appendChild(t.cloneNode(true));
          }
        }
        if (s) {
          o.appendChild(n.childNodes[e].cloneNode(true));
        }
      }
    }
    return o;
  };
};

/**
 * Patches the `appendChild` method on a `scoped` Stencil component.
 * The patch will attempt to find a slot with the same name as the node being appended
 * and insert it into the slot reference if found. Otherwise, it falls-back to the original
 * `appendChild` method.
 *
 * @param HostElementPrototype The Stencil component to be patched
 */ const patchSlotAppendChild = e => {
  e.__appendChild = e.appendChild;
  e.appendChild = function(e) {
    const t = e["s-sn"] = getSlotName(e);
    const n = getHostSlotNode(this.childNodes, t);
    if (n) {
      const s = getHostSlotChildNodes(n, t);
      const o = s[s.length - 1];
      const l = o.parentNode.insertBefore(e, o.nextSibling);
      // Check if there is fallback content that should be hidden
            updateFallbackSlotVisibility(this);
      return l;
    }
    return this.__appendChild(e);
  };
};

const getSlotName = e => e["s-sn"] || e.nodeType === 1 && e.getAttribute("slot") || ""
/**
 * Recursively searches a series of child nodes for a slot with the provided name.
 * @param childNodes the nodes to search for a slot with a specific name.
 * @param slotName the name of the slot to match on.
 * @returns a reference to the slot node that matches the provided name, `null` otherwise
 */;

const getHostSlotNode = (e, t) => {
  let n = 0;
  let s;
  for (;n < e.length; n++) {
    s = e[n];
    if (s["s-sr"] && s["s-sn"] === t) {
      return s;
    }
    s = getHostSlotNode(s.childNodes, t);
    if (s) {
      return s;
    }
  }
  return null;
};

const getHostSlotChildNodes = (e, t) => {
  const n = [ e ];
  while ((e = e.nextSibling) && e["s-sn"] === t) {
    n.push(e);
  }
  return n;
};

const bootstrapLazy = (e, t = {}) => {
  var n;
  const s = createTime();
  const o = [];
  const l = t.exclude || [];
  const i = L.customElements;
  const c = j.head;
  const r =  c.querySelector("meta[charset]");
  const f =  j.createElement("style");
  const u = [];
  let p;
  let v = true;
  Object.assign(O, t);
  O._$$resourcesUrl$$_ = new URL(t.resourcesUrl || "./", j.baseURI).href;
  let m = false;
  e.map((e => {
    e[1].map((t => {
      var n;
      const s = {
        _$$flags$$_: t[0],
        _$$tagName$$_: t[1],
        _$$members$$_: t[2],
        _$$listeners$$_: t[3]
      };
      // Check if we are using slots outside the shadow DOM in this component.
      // We'll use this information later to add styles for `slot-fb` elements
            if (s._$$flags$$_ & 4 /* CMP_FLAGS.hasSlotRelocation */) {
        m = true;
      }
      {
        s._$$members$$_ = t[2];
      }
      {
        s._$$listeners$$_ = t[3];
      }
      {
        s._$$attrsToReflect$$_ = [];
      }
      {
        s._$$watchers$$_ = (n = t[4]) !== null && n !== void 0 ? n : {};
      }
      const c = s._$$tagName$$_;
      const r = class extends HTMLElement {
        // StencilLazyHost
        constructor(e) {
          // @ts-ignore
          super(e);
          e = this;
          registerHost(e, s);
          if (s._$$flags$$_ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
            // this component is using shadow dom
            // and this browser supports shadow dom
            // add the read-only property "shadowRoot" to the host element
            // adding the shadow root build conditionals to minimize runtime
            {
              {
                e.attachShadow({
                  mode: "open"
                });
              }
            }
          }
        }
        connectedCallback() {
          if (p) {
            clearTimeout(p);
            p = null;
          }
          if (v) {
            // connectedCallback will be processed once all components have been registered
            u.push(this);
          } else {
            O.jmp((() => connectedCallback(this)));
          }
        }
        disconnectedCallback() {
          O.jmp((() => disconnectedCallback(this)));
        }
        componentOnReady() {
          return getHostRef(this)._$$onReadyPromise$$_;
        }
      };
      // TODO(STENCIL-914): this check and `else` block can go away and be replaced by just the `scoped` check
            {
        {
          patchCloneNode(r.prototype);
        }
        {
          patchSlotAppendChild(r.prototype);
        }
      }
      s._$$lazyBundleId$$_ = e[0];
      if (!l.includes(c) && !i.get(c)) {
        o.push(c);
        i.define(c, proxyComponent(r, s, 1 /* PROXY_FLAGS.isElementConstructor */));
      }
    }));
  }));
  // Only bother generating CSS if we have components
  // TODO(STENCIL-1118): Add test cases for CSS content based on conditionals
    if (o.length > 0) {
    // Add styles for `slot-fb` elements if any of our components are using slots outside the Shadow DOM
    if (m) {
      f.textContent += d;
    }
    // Add hydration styles
        {
      f.textContent += o + a;
    }
    // If we have styles, add them to the DOM
        if (f.innerHTML.length) {
      f.setAttribute("data-styles", "");
      // Apply CSP nonce to the style tag if it exists
            const e = (n = O._$$nonce$$_) !== null && n !== void 0 ? n : queryNonceMetaTagContent(j);
      if (e != null) {
        f.setAttribute("nonce", e);
      }
      // Insert the styles into the document head
      // NOTE: this _needs_ to happen last so we can ensure the nonce (and other attributes) are applied
            c.insertBefore(f, r ? r.nextSibling : c.firstChild);
    }
  }
  // Process deferred connectedCallbacks now all components have been registered
    v = false;
  if (u.length) {
    u.map((e => e.connectedCallback()));
  } else {
    {
      O.jmp((() => p = setTimeout(appDidLoad, 30)));
    }
  }
  // Fallback appLoad event
    s();
};

const addHostEventListeners = (e, t, n, s) => {
  if (n) {
    n.map((([n, s, o]) => {
      const l = getHostListenerTarget(e, n);
      const i = hostListenerProxy(t, o);
      const c = hostListenerOpts(n);
      O.ael(l, s, i, c);
      (t._$$rmListeners$$_ = t._$$rmListeners$$_ || []).push((() => O.rel(l, s, i, c)));
    }));
  }
};

const hostListenerProxy = (e, t) => n => {
  try {
    {
      if (e._$$flags$$_ & 256 /* HOST_FLAGS.isListenReady */) {
        // instance is ready, let's call it's member method for this event
        e._$$lazyInstance$$_[t](n);
      } else {
        (e._$$queuedListeners$$_ = e._$$queuedListeners$$_ || []).push([ t, n ]);
      }
    }
  } catch (e) {
    consoleError(e);
  }
};

const getHostListenerTarget = (e, t) => {
  if (t & 4 /* LISTENER_FLAGS.TargetDocument */) return j;
  if (t & 8 /* LISTENER_FLAGS.TargetWindow */) return L;
  return e;
};

// prettier-ignore
const hostListenerOpts = e => U ? {
  passive: (e & 1 /* LISTENER_FLAGS.Passive */) !== 0,
  capture: (e & 2 /* LISTENER_FLAGS.Capture */) !== 0
} : (e & 2 /* LISTENER_FLAGS.Capture */) !== 0
/**
 * Assigns the given value to the nonce property on the runtime platform object.
 * During runtime, this value is used to set the nonce attribute on all dynamically created script and style tags.
 * @param nonce The value to be assigned to the platform nonce property.
 * @returns void
 */;

const setNonce = e => O._$$nonce$$_ = e
/**
 * A WeakMap mapping runtime component references to their corresponding host reference
 * instances.
 *
 * **Note**: If we're in an HMR context we need to store a reference to this
 * value on `window` in order to maintain the mapping of {@link d.RuntimeRef}
 * to {@link d.HostRef} across HMR updates.
 *
 * This is necessary because when HMR updates for a component are processed by
 * the browser-side dev server client the JS bundle for that component is
 * re-fetched. Since the module containing {@link hostRefs} is included in
 * that bundle, if we do not store a reference to it the new iteration of the
 * component will not have access to the previous hostRef map, leading to a
 * bug where the new version of the component cannot properly initialize.
 */;

const R = new WeakMap;

/**
 * Given a {@link d.RuntimeRef} retrieve the corresponding {@link d.HostRef}
 *
 * @param ref the runtime ref of interest
 * @returns the Host reference (if found) or undefined
 */ const getHostRef = e => R.get(e)
/**
 * Register a lazy instance with the {@link hostRefs} object so it's
 * corresponding {@link d.HostRef} can be retrieved later.
 *
 * @param lazyInstance the lazy instance of interest
 * @param hostRef that instances `HostRef` object
 * @returns a reference to the host ref WeakMap
 */;

const registerInstance = (e, t) => R.set(t._$$lazyInstance$$_ = e, t)
/**
 * Register a host element for a Stencil component, setting up various metadata
 * and callbacks based on {@link BUILD} flags as well as the component's runtime
 * metadata.
 *
 * @param hostElement the host element to register
 * @param cmpMeta runtime metadata for that component
 * @returns a reference to the host ref WeakMap
 */;

const registerHost = (e, t) => {
  const n = {
    _$$flags$$_: 0,
    $hostElement$: e,
    _$$cmpMeta$$_: t,
    _$$instanceValues$$_: new Map
  };
  {
    n._$$onInstancePromise$$_ = new Promise((e => n._$$onInstanceResolve$$_ = e));
  }
  {
    n._$$onReadyPromise$$_ = new Promise((e => n._$$onReadyResolve$$_ = e));
    e["s-p"] = [];
    e["s-rc"] = [];
  }
  addHostEventListeners(e, n, t._$$listeners$$_);
  return R.set(e, n);
};

const isMemberInElement = (e, t) => t in e;

const consoleError = (e, t) => (0, console.error)(e, t);

const T =  new Map;

const loadModule = (e, t, n) => {
  // loadModuleImport
  const s = e._$$tagName$$_.replace(/-/g, "_");
  const o = e._$$lazyBundleId$$_;
  const l = T.get(o);
  if (l) {
    return l[s];
  }
  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/  return import(
  /* @vite-ignore */
  /* webpackInclude: /\.entry\.js$/ */
  /* webpackExclude: /\.system\.entry\.js$/ */
  /* webpackMode: "lazy" */
  `./${o}.entry.js${""}`).then((e => {
    {
      T.set(o, e);
    }
    return e[s];
  }), consoleError);
};

const x =  new Map;

const L = typeof window !== "undefined" ? window : {};

const j = L.document || {
  head: {}
};

const D = L.HTMLElement || class {};

const O = {
  _$$flags$$_: 0,
  _$$resourcesUrl$$_: "",
  jmp: e => e(),
  raf: e => requestAnimationFrame(e),
  ael: (e, t, n, s) => e.addEventListener(t, n, s),
  rel: (e, t, n, s) => e.removeEventListener(t, n, s),
  ce: (e, t) => new CustomEvent(e, t)
};

const M = 
// TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
true;

const U =  (() => {
  let e = false;
  try {
    j.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        e = true;
      }
    }));
  } catch (e) {}
  return e;
})();

const promiseResolve = e => Promise.resolve(e);

const N =  (() => {
  try {
    new CSSStyleSheet;
    return typeof (new CSSStyleSheet).replaceSync === "function";
  } catch (e) {}
  return false;
})();

const W = [];

const F = [];

const queueTask = (e, t) => n => {
  e.push(n);
  if (!u) {
    u = true;
    if (t && O._$$flags$$_ & 4 /* PLATFORM_FLAGS.queueSync */) {
      nextTick(flush);
    } else {
      O.raf(flush);
    }
  }
};

const consume = e => {
  for (let t = 0; t < e.length; t++) {
    try {
      e[t](performance.now());
    } catch (e) {
      consoleError(e);
    }
  }
  e.length = 0;
};

const flush = () => {
  // always force a bunch of medium callbacks to run, but still have
  // a throttle on how many can run in a certain time
  // DOM READS!!!
  consume(W);
  // DOM WRITES!!!
    {
    consume(F);
    if (u = W.length > 0) {
      // still more to do yet, but we've run out of time
      // let's let this thing cool off and try again in the next tick
      O.raf(flush);
    }
  }
};

const nextTick = e => promiseResolve().then(e);

const A =  queueTask(F, true);

export { D as H, getAssetPath as a, bootstrapLazy as b, createEvent as c, getRenderingRef as d, b as e, forceUpdate as f, getElement as g, h, promiseResolve as p, registerInstance as r, setNonce as s };
//# sourceMappingURL=index-0efb1dc1.js.map</script>
</body>
</html>
