<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>232c8114289c91172737.html</title>
</head>
<body>

<script>
"use strict";(self.__LOADABLE_LOADED_CHUNKS__=self.__LOADABLE_LOADED_CHUNKS__||[]).push([[9936],{69936:(e,r,t)=>{t.d(r,{c:()=>c});var n=t(11504),a=t(73664),i=t(50104);const s=n.use||(e=>{if("pending"===e.status)throw e;if("fulfilled"===e.status)return e.value;throw"rejected"===e.status?e.reason:(e.status="pending",e.then((r=>{e.status="fulfilled",e.value=r}),(r=>{e.status="rejected",e.reason=r})),e)}),u={dedupe:!0};i.kP.defineProperty(i.SK,"defaultValue",{value:i.Ag});const o=(0,i._O)(((e,r,t)=>{const{cache:o,compare:c,suspense:d,fallbackData:l,revalidateOnMount:f,revalidateIfStale:g,refreshInterval:E,refreshWhenHidden:R,refreshWhenOffline:_,keepPreviousData:Y}=t,[O,V,p,h]=i.Ce.get(o),[v,L]=(0,i.ii)(e),T=(0,n.useRef)(!1),A=(0,n.useRef)(!1),D=(0,n.useRef)(v),S=(0,n.useRef)(r),b=(0,n.useRef)(t),C=()=>b.current,m=()=>C().isVisible()&&C().isOnline(),[k,y,M,w]=(0,i.Md)(o,v),N=(0,n.useRef)({}).current,I=(0,i.Y3)(l)?t.fallback[v]:l,P=(e,r)=>{for(const t in N){const n=t;if("data"===n){if(!c(e[n],r[n])){if(!(0,i.Y3)(e[n]))return!1;if(!c(x,r[n]))return!1}}else if(r[n]!==e[n])return!1}return!0},F=(0,n.useMemo)((()=>{const e=!!v&&!!r&&((0,i.Y3)(f)?!C().isPaused()&&!d&&(!!(0,i.Y3)(g)||g):f),t=r=>{const t=(0,i.yQ)(r);return delete t._k,e?{isValidating:!0,isLoading:!0,...t}:t},n=k(),a=w(),s=t(n),u=n===a?s:t(a);let o=s;return[()=>{const e=t(k());return P(e,o)?(o.data=e.data,o.isLoading=e.isLoading,o.isValidating=e.isValidating,o.error=e.error,o):(o=e,e)},()=>u]}),[o,v]),U=(0,a.useSyncExternalStore)((0,n.useCallback)((e=>M(v,((r,t)=>{P(t,r)||e()}))),[o,v]),F[0],F[1]),j=!T.current,H=O[v]&&O[v].length>0,K=U.data,B=(0,i.Y3)(K)?I:K,W=U.error,q=(0,n.useRef)(B),x=Y?(0,i.Y3)(K)?q.current:K:B,Q=!(H&&!(0,i.Y3)(W))&&(j&&!(0,i.Y3)(f)?f:!C().isPaused()&&(d?!(0,i.Y3)(B)&&g:(0,i.Y3)(B)||g)),z=!!(v&&r&&j&&Q),G=(0,i.Y3)(U.isValidating)?z:U.isValidating,J=(0,i.Y3)(U.isLoading)?z:U.isLoading,X=(0,n.useCallback)((async e=>{const r=S.current;if(!v||!r||A.current||C().isPaused())return!1;let n,a,s=!0;const u=e||{},o=!p[v]||!u.dedupe,d=()=>i.gp?!A.current&&v===D.current&&T.current:v===D.current,l={isValidating:!1,isLoading:!1},f=()=>{y(l)},g=()=>{const e=p[v];e&&e[1]===a&&delete p[v]},E={isValidating:!0};(0,i.Y3)(k().data)&&(E.isLoading=!0);try{if(o&&(y(E),t.loadingTimeout&&(0,i.Y3)(k().data)&&setTimeout((()=>{s&&d()&&C().onLoadingSlow(v,t)}),t.loadingTimeout),p[v]=[r(L),(0,i.Mr)()]),[n,a]=p[v],n=await n,o&&setTimeout(g,t.dedupingInterval),!p[v]||p[v][1]!==a)return o&&d()&&C().onDiscarded(v),!1;l.error=i.Sc;const e=V[v];if(!(0,i.Y3)(e)&&(a<=e[0]||a<=e[1]||0===e[1]))return f(),o&&d()&&C().onDiscarded(v),!1;const u=k().data;l.data=c(u,n)?u:n,o&&d()&&C().onSuccess(n,v,t)}catch(e){g();const r=C(),{shouldRetryOnError:t}=r;r.isPaused()||(l.error=e,o&&d()&&(r.onError(e,v,r),(!0===t||(0,i.mg)(t)&&t(e))&&(C().revalidateOnFocus&&C().revalidateOnReconnect&&!m()||r.onErrorRetry(e,v,r,(e=>{const r=O[v];r&&r[0]&&r[0](i.Ep.ERROR_REVALIDATE_EVENT,e)}),{retryCount:(u.retryCount||0)+1,dedupe:!0}))))}return s=!1,f(),!0}),[v,o]),Z=(0,n.useCallback)(((...e)=>(0,i.CI)(o,D.current,...e)),[]);if((0,i.Mb)((()=>{S.current=r,b.current=t,(0,i.Y3)(K)||(q.current=K)})),(0,i.Mb)((()=>{if(!v)return;const e=X.bind(i.Sc,u);let r=0;const t=(0,i.Aj)(v,O,((t,n={})=>{if(t==i.Ep.FOCUS_EVENT){const t=Date.now();C().revalidateOnFocus&&t>r&&m()&&(r=t+C().focusThrottleInterval,e())}else if(t==i.Ep.RECONNECT_EVENT)C().revalidateOnReconnect&&m()&&e();else{if(t==i.Ep.MUTATE_EVENT)return X();if(t==i.Ep.ERROR_REVALIDATE_EVENT)return X(n)}}));return A.current=!1,D.current=v,T.current=!0,y({_k:L}),Q&&((0,i.Y3)(B)||i.MA?e():(0,i.yA)(e)),()=>{A.current=!0,t()}}),[v]),(0,i.Mb)((()=>{let e;function r(){const r=(0,i.mg)(E)?E(k().data):E;r&&-1!==e&&(e=setTimeout(t,r))}function t(){k().error||!R&&!C().isVisible()||!_&&!C().isOnline()?r():X(u).then(r)}return r(),()=>{e&&(clearTimeout(e),e=-1)}}),[E,R,_,v]),(0,n.useDebugValue)(x),d&&(0,i.Y3)(B)&&v){if(!i.gp&&i.MA)throw new Error("Fallback data is required when using suspense in SSR.");S.current=r,b.current=t,A.current=!1;const e=h[v];if(!(0,i.Y3)(e)){const r=Z(e);s(r)}if(!(0,i.Y3)(W))throw W;{const e=X(u);(0,i.Y3)(x)||(e.status="fulfilled",e.value=!0),s(e)}}return{mutate:Z,get data(){return N.data=!0,x},get error(){return N.error=!0,W},get isValidating(){return N.isValidating=!0,G},get isLoading(){return N.isLoading=!0,J}}})),c=(0,i.s1)(o,(e=>(r,t,n)=>(n.revalidateOnFocus=!1,n.revalidateIfStale=!1,n.revalidateOnReconnect=!1,e(r,t,n))))}}]);
</script>

</body>
</html>
